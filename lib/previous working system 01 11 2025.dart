// main.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io' show File, Directory;
import 'dart:math';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/services.dart';
import 'package:window_manager/window_manager.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:http/http.dart' as http;
import 'package:url_launcher/url_launcher.dart';
import 'package:archive/archive.dart';
import 'package:path/path.dart' as path;
import 'package:screen_retriever/screen_retriever.dart';
import 'package:desktop_drop/desktop_drop.dart';
import 'audio_checker.dart';
import 'package:file_icon/file_icon.dart';
import 'package:file_picker/file_picker.dart';
import 'package:system_theme/system_theme.dart';
import 'native_blur.dart'; // Путь к вашему файлу
import 'package:flutter/foundation.dart';
import 'clipboard_monitor.dart';
import 'package:clipboard/clipboard.dart';
import 'file_drag_drop_service.dart';
import 'package:flutter/painting.dart';
import 'dart:isolate';
import 'dart:collection'; // Добавляем этот импорт
import 'package:html/parser.dart' as html_parser;
import 'package:charset_converter/charset_converter.dart';
import 'package:flutter/rendering.dart';

import 'package:cross_file/cross_file.dart';

// Add this import for DateFormat
import 'package:intl/intl.dart';
import 'package:image/image.dart' as img;

import 'package:flutter_colorpicker/flutter_colorpicker.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:speech_to_text/speech_to_text.dart' as stt;
import 'hotkey_service.dart';
// Стоп-слова
// Стоп-слова

import 'package:cached_network_image/cached_network_image.dart';


import 'dart:convert';

import 'native_smtc.dart';

import 'native_mouse_service.dart';



import 'package:universal_io/io.dart';

import 'package:path/path.dart' as p;










  // ==================== ENUMS ====================

  enum KeyContentType { image, text, url, windowsShortcut, macros, clipboard }
  enum KeyAction { copyToClipboard, pasteToForeground, open, openInExplorer, run }
  enum MacroActionType { hotkey, click, delay, runPath }

  // ==================== MACRO ACTION ====================

  class MacroAction {
    final MacroActionType type;
    final String value;
    final int? x, y, x1, y1, delay;

    MacroAction({
      required this.type,
      required this.value,
      this.x, this.y, this.x1, this.y1, this.delay,
    });

    Map<String, dynamic> toJson() => {
      'type': type.index, 'value': value,
      'x': x, 'y': y, 'x1': x1, 'y1': y1, 'delay': delay,
    };

    factory MacroAction.fromJson(Map<String, dynamic> json) => MacroAction(
      type: MacroActionType.values[json['type'] ?? 0],
      value: json['value'] ?? '',
      x: json['x'], y: json['y'], x1: json['x1'], y1: json['y1'], delay: json['delay'],
    );

    String toScript() {
      switch (type) {
        case MacroActionType.hotkey: return 'HOTKEY: $value';
        case MacroActionType.click: return 'CLICK: ($x,$y) → ($x1,$y1)';
        case MacroActionType.delay: return 'DELAY: ${delay}ms';
        case MacroActionType.runPath: return 'RUN: $value';
      }
    }

    IconData get icon {
      switch (type) {
        case MacroActionType.hotkey: return Icons.keyboard;
        case MacroActionType.click: return Icons.mouse;
        case MacroActionType.delay: return Icons.timer;
        case MacroActionType.runPath: return Icons.play_arrow;
      }
    }

    String get displayName {
      switch (type) {
        case MacroActionType.hotkey: return value;
        case MacroActionType.click: return 'Click';
        case MacroActionType.delay: return '${delay}ms';
        case MacroActionType.runPath: return p.basename(value);
      }
    }
  }

  // ==================== MACRO ====================

  class Macro {
    List<MacroAction> actions;
    int loopAmount;
    
    Macro({required this.actions, this.loopAmount = 1});

    Map<String, dynamic> toJson() => {
      'actions': actions.map((a) => a.toJson()).toList(),
      'loopAmount': loopAmount,
    };
    
    factory Macro.fromJson(Map<String, dynamic> json) => Macro(
      actions: (json['actions'] as List? ?? []).map((a) => MacroAction.fromJson(a)).toList(),
      loopAmount: json['loopAmount'] ?? 1,
    );
    
    String toScript() => 'LOOP: $loopAmount\n${actions.map((a) => a.toScript()).join('\n')}';
  }

  // ==================== KEY BIND ====================

  class KeyBind {
    final String key;
    String name, hint, description, combination;
    KeyContentType type;
    String? imagePath, filePath, textContent, url;
    Macro? macro;
    List<KeyAction> actions;
    IconData? icon;
    Uint8List? fileIcon;

    KeyBind({
      required this.key, required this.name, required this.hint,
      required this.description, required this.type, required this.combination,
      required this.actions, this.imagePath, this.filePath, this.textContent,
      this.url, this.macro, this.icon, this.fileIcon,
    });

    Map<String, dynamic> toJson() => {
      'key': key, 'name': name, 'hint': hint, 'description': description,
      'type': type.index, 'imagePath': imagePath, 'filePath': filePath,
      'textContent': textContent, 'url': url, 'macro': macro?.toJson(),
      'combination': combination, 'actions': actions.map((a) => a.index).toList(),
      'icon': icon?.codePoint,
    };

    factory KeyBind.fromJson(Map<String, dynamic> json) => KeyBind(
      key: json['key'] ?? '', name: json['name'] ?? '', hint: json['hint'] ?? '',
      description: json['description'] ?? '', type: KeyContentType.values[json['type'] ?? 0],
      imagePath: json['imagePath'], filePath: json['filePath'],
      textContent: json['textContent'], url: json['url'],
      macro: json['macro'] != null ? Macro.fromJson(json['macro']) : null,
      combination: json['combination'] ?? '',
      actions: (json['actions'] as List? ?? [0]).map((a) => KeyAction.values[a]).toList(),
      icon: json['icon'] != null ? IconData(json['icon'], fontFamily: 'MaterialIcons') : null,
    );
  }

  // ==================== СЕРВИС ШИФРОВАНИЯ ====================

  class EncryptionService {
    static final EncryptionService _instance = EncryptionService._internal();
    factory EncryptionService() => _instance;
    EncryptionService._internal();

    bool _initialized = false;
    late Uint8List _key;

    Future<void> initialize() async {
      if (_initialized) return;
      final prefs = await SharedPreferences.getInstance();
      String? keyString = prefs.getString('encryption_key');
      if (keyString == null) {
        final random = Random.secure();
        _key = Uint8List.fromList(List<int>.generate(32, (i) => random.nextInt(256)));
        await prefs.setString('encryption_key', base64.encode(_key));
      } else {
        _key = base64.decode(keyString);
      }
      _initialized = true;
    }

    String encrypt(String plainText) {
      if (!_initialized) throw Exception('EncryptionService not initialized');
      final plainBytes = utf8.encode(plainText);
      final encryptedBytes = Uint8List(plainBytes.length);
      for (int i = 0; i < plainBytes.length; i++) {
        encryptedBytes[i] = plainBytes[i] ^ _key[i % _key.length];
      }
      return base64.encode(encryptedBytes);
    }

    String decrypt(String encryptedText) {
      if (!_initialized) throw Exception('EncryptionService not initialized');
      final encryptedBytes = base64.decode(encryptedText);
      final decryptedBytes = Uint8List(encryptedBytes.length);
      for (int i = 0; i < encryptedBytes.length; i++) {
        decryptedBytes[i] = encryptedBytes[i] ^ _key[i % _key.length];
      }
      return utf8.decode(decryptedBytes);
    }
  }

  // ==================== ХРАНИЛИЩЕ ====================

  class KeyBindStorage {
    static final KeyBindStorage _instance = KeyBindStorage._internal();
    factory KeyBindStorage() => _instance;
    KeyBindStorage._internal();
    String?  _filePath, _textContent;
    final Map<String, KeyBind> _keyBinds = {};
    bool _loaded = false;
    late TextEditingController _nameCtrl, _hintCtrl, _descCtrl;
    Future<void> loadKeyBinds() async {
      if (_loaded) return;
      try {
        await EncryptionService().initialize();
        final prefs = await SharedPreferences.getInstance();
        final encryptedData = prefs.getString('key_binds_encrypted');
        if (encryptedData != null) {
          final jsonData = EncryptionService().decrypt(encryptedData);
          final Map<String, dynamic> data = json.decode(jsonData);
          _keyBinds.clear();
          data.forEach((key, value) {
            try {
              _keyBinds[key] = KeyBind.fromJson(value);
            } catch (e) {
              print('Error loading keybind $key: $e');
            }
          });
        }
        _loaded = true;
      } catch (e) {
        print('Error loading key binds: $e');
        _keyBinds.clear();
        _loaded = true;
      }
    }

    Future<void> saveKeyBinds() async {
      try {
        final data = <String, dynamic>{};
        _keyBinds.forEach((key, value) => data[key] = value.toJson());
        final jsonData = json.encode(data);
        final encryptedData = EncryptionService().encrypt(jsonData);
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString('key_binds_encrypted', encryptedData);
      } catch (e) {
        print('Error saving key binds: $e');
      }
    }

    KeyBind? getKeyBind(String key) => _keyBinds[key];
    void setKeyBind(String key, KeyBind keyBind) {
      _keyBinds[key] = keyBind;
      saveKeyBinds();
    }
    void removeKeyBind(String key) {
      _keyBinds.remove(key);
      saveKeyBinds();
    }
    bool hasKeyBind(String key) => _keyBinds.containsKey(key);
    List<String> getAllKeys() => _keyBinds.keys.toList();
  }





  // ==================== СЕРВИС ВЫПОЛНЕНИЯ ДЕЙСТВИЙ ====================

  class ActionService {
    static final ActionService _instance = ActionService._internal();
    factory ActionService() => _instance;
    ActionService._internal();
  final NativeMouseService _mouseService = NativeMouseService();
    Future<void> executeKeyBind(KeyBind keyBind) async {
      try {
        for (final action in keyBind.actions) {
          await _executeAction(keyBind, action);
        }
      } catch (e) {
        print('Error executing keybind: $e');
      }
    }

    Future<void> _executeAction(KeyBind keyBind, KeyAction action) async {
  switch (action) {
    case KeyAction.copyToClipboard:
      await _copyToClipboard(keyBind);
      break;
    case KeyAction.pasteToForeground:
      await _pasteToForeground(keyBind);
      break;
    case KeyAction.open:
      await _open(keyBind);
      break;
    case KeyAction.openInExplorer:
      await _openInExplorer(keyBind);
      break;
    case KeyAction.run:
      await _run(keyBind);
      break;
  }
}

Future<void> _pasteClipboardData(KeyBind keyBind) async {
  if (keyBind.filePath != null && File(keyBind.filePath!).existsSync()) {
    try {
      final file = File(keyBind.filePath!);
      final data = await file.readAsBytes();
      
      const MethodChannel clipboardChannel = MethodChannel('screenshot_channel');
      
      final Map<String, dynamic> arguments = {
        'data': data,
        'format': keyBind.textContent ?? 'unknown',
      };
      
      // Если у нас есть ID формата, передаем его тоже
      if (keyBind.textContent?.startsWith('custom/') == true) {
        final formatId = int.tryParse(keyBind.textContent!.replaceFirst('custom/', ''));
        if (formatId != null) {
          arguments['formatId'] = formatId;
        }
      }
      
      final success = await clipboardChannel.invokeMethod('setClipboardData', arguments);
      
      if (success == true) {
        print('Clipboard data pasted successfully');
        // Можно добавить уведомление если нужно
      } else {
        print('Failed to paste clipboard data');
      }
    } catch (e) {
      print('Error pasting clipboard data: $e');
    }
  } else if (keyBind.textContent != null) {
    // Fallback для текста
    await Clipboard.setData(ClipboardData(text: keyBind.textContent!));
  }
}

Future<void> _copyToClipboard(KeyBind keyBind) async {
  switch (keyBind.type) {
    case KeyContentType.text:
      if (keyBind.textContent != null) {
        await Clipboard.setData(ClipboardData(text: keyBind.textContent!));
      }
      break;
    case KeyContentType.image:
      if (keyBind.imagePath != null) {
        final file = File(keyBind.imagePath!);
        if (file.existsSync()) {
          final imageBytes = await file.readAsBytes();
          try {
            const MethodChannel clipboardChannel = MethodChannel('screenshot_channel');
            await clipboardChannel.invokeMethod('copyImageToClipboard', {
              'imageData': imageBytes,
            });
          } catch (e) {
            print('Error copying image to clipboard: $e');
            await Clipboard.setData(ClipboardData(text: keyBind.imagePath!));
          }
        }
      }
      break;
    case KeyContentType.url:
      if (keyBind.url != null) {
        await Clipboard.setData(ClipboardData(text: keyBind.url!));
      }
      break;
    case KeyContentType.windowsShortcut:
      if (keyBind.filePath != null) {
        final file = File(keyBind.filePath!);
        if (file.existsSync()) {
          try {
            final content = await file.readAsBytes();
            const MethodChannel clipboardChannel = MethodChannel('screenshot_channel');
            await clipboardChannel.invokeMethod('copyFileToClipboard', {
              'filePath': keyBind.filePath,
              'fileBytes': content,
            });
          } catch (e) {
            print('Error copying file to clipboard: $e');
            await Clipboard.setData(ClipboardData(text: keyBind.filePath!));
          }
        } else {
          await Clipboard.setData(ClipboardData(text: keyBind.filePath!));
        }
      }
      break;
   case KeyContentType.clipboard:
      await _pasteClipboardData(keyBind);
      break;
    case KeyContentType.macros:
      print('Cannot copy macro to clipboard');
      break;
  }
}

    Future<void> _pasteToForeground(KeyBind keyBind) async {
      await _copyToClipboard(keyBind);
      print('Pasting to foreground: ${keyBind.name}');
    }

    Future<void> _open(KeyBind keyBind) async {
      switch (keyBind.type) {
        case KeyContentType.url:
          if (keyBind.url != null) {
            await Process.run('start', [keyBind.url!], runInShell: true);
          }
          break;
        case KeyContentType.windowsShortcut:
          if (keyBind.filePath != null) {
            await Process.run('cmd', ['/c', 'start', '', keyBind.filePath!], runInShell: true);
          }
          break;
        default:
          print('Cannot open this content type');
      }
    }

    Future<void> _openInExplorer(KeyBind keyBind) async {
      if (keyBind.filePath != null) {
        final directory = p.dirname(keyBind.filePath!);
        await Process.run('explorer', [directory]);
      }
    }

    Future<void> _run(KeyBind keyBind) async {
      if (keyBind.type == KeyContentType.macros && keyBind.macro != null) {
        await _executeMacro(keyBind.macro!);
      } else if (keyBind.filePath != null) {
        await Process.run(keyBind.filePath!, [], runInShell: true);
      }
    }

    Future<void> _executeMacro(Macro macro) async {
    for (int i = 0; i < macro.loopAmount; i++) {
      for (final action in macro.actions) {
        await _executeMacroAction(action);
        // Убрал дублирующую задержку здесь, так как она теперь в _executeMacroAction
      }
    }
  }
  Future<void> _executeMacroAction(MacroAction action) async {
    switch (action.type) {
      case MacroActionType.hotkey:
        await _simulateHotkey(action.value);
        break;
      case MacroActionType.click:
        await _simulateClick(action.x!, action.y!);
        break;
      case MacroActionType.delay:
        await Future.delayed(Duration(milliseconds: action.delay ?? 1000));
        print('Delayed for ${action.delay}ms');
        break;
      case MacroActionType.runPath:
        if (action.value.isNotEmpty) {
          await Process.run(action.value, [], runInShell: true);
        }
        break;
    }
  }

  Future<void> _simulateHotkey(String hotkey) async {
    try {
      _mouseService.simulateKeyPress(hotkey);
    } catch (e) {
      print('Error simulating hotkey: $e');
    }
  }



  String _convertHotkeyToSendKeys(String hotkey) {
    // Конвертируем наш формат хоткеев в формат SendKeys
    return hotkey
        .replaceAll('Ctrl+', '^')
        .replaceAll('Alt+', '%')
        .replaceAll('Shift+', '+')
        .replaceAll('Win+', '#');
  }

  Future<void> _simulateClick(int x, int y) async {
    try {
      _mouseService.simulateMouseClick(x, y);
    } catch (e) {
      print('Error simulating click: $e');
    }
  }
  }

  // ==================== ГЛАВНОЕ ПРИЛОЖЕНИЕ ====================

  class VirtualKeyboardApp extends StatelessWidget {
    const VirtualKeyboardApp({Key? key}) : super(key: key);

    @override
    Widget build(BuildContext context) {
      return MaterialApp(
        title: 'Virtual Keyboard',
        debugShowCheckedModeBanner: false,
        theme: ThemeData.dark().copyWith(
          scaffoldBackgroundColor: Colors.transparent,
          colorScheme: ColorScheme.dark(
            primary: Colors.blue,
            secondary: Colors.blueAccent,
          ),
        ),
        home: const VirtualKeyboardScreen(),
      );
    }
  }

  // ==================== ГЛАВНЫЙ ЭКРАН ====================

  class VirtualKeyboardScreen extends StatefulWidget {
    const VirtualKeyboardScreen({Key? key}) : super(key: key);

    @override
    State<VirtualKeyboardScreen> createState() => _VirtualKeyboardScreenState();
  }

  class _VirtualKeyboardScreenState extends State<VirtualKeyboardScreen> with WindowListener {
    final KeyBindStorage _storage = KeyBindStorage();
    final ActionService _actionService = ActionService();
    bool _isLoading = true;
    bool _isEditing = false;
    bool _isMinimized = false;
    final FocusNode _focusNode = FocusNode();
    bool _isDragging = false;
    Offset _dragOffset = Offset.zero;

  final List<List<String>> _keyboardLayout = [
    ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
    ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
    ['Z', 'X', 'C', 'V', 'B', 'N', 'M', 'ADD'],
  ];

    @override
    void initState() {
      super.initState();
      windowManager.addListener(this);
      _initialize();
    }

    @override
    void dispose() {
      windowManager.removeListener(this);
      _focusNode.dispose();
      super.dispose();
    }

    Future<void> _initialize() async {
      await windowManager.ensureInitialized();
        final primaryDisplay = await screenRetriever.getPrimaryDisplay();
      final screenSize = primaryDisplay.size;
      final windowHeight = screenSize.height * 0.35;
      final windowWidth = screenSize.width * 0.55;
      WindowOptions windowOptions = WindowOptions(
        size:  Size(windowWidth, windowHeight),
        minimumSize:  Size(windowWidth, windowHeight),
        center: false,
        backgroundColor: Colors.transparent,
        skipTaskbar: false,
        titleBarStyle: TitleBarStyle.hidden,
        title: 'Virtual Keyboard',
      );

      await windowManager.waitUntilReadyToShow(windowOptions, () async {
        try {
        await windowManager.setAsFrameless();
      } catch (e) {
        print('Error setting frameless: $e');
      }

      try {
        await windowManager.setHasShadow(false);
      } catch (e) {
        print('Error disabling shadow: $e');
      }
      
      await windowManager.show();
        await _setWindowPosition();
        await windowManager.focus();
      });

      await _storage.loadKeyBinds();
      if (mounted) setState(() => _isLoading = false);
      
      _focusNode.requestFocus();
    }

    Future<void> _setWindowPosition() async {
      final primaryDisplay = await screenRetriever.getPrimaryDisplay();
      final screenSize = primaryDisplay.size;
      
      if (_isMinimized) {
        await windowManager.setPosition(const Offset(0, 25));
      } else {
        final windowHeight = screenSize.height * 0.32;
        final windowWidth = screenSize.width * 0.55;
        final yPosition = screenSize.height - windowHeight - 50;
        await windowManager.setPosition(Offset( (screenSize.width - windowWidth )/2, yPosition));
      }
    }

    Future<void> _toggleMinimize() async {
      setState(() => _isMinimized = !_isMinimized);
      final primaryDisplay = await screenRetriever.getPrimaryDisplay();
      final screenSize = primaryDisplay.size;
      if (_isMinimized) {
        await windowManager.setSize( Size(550, 300));
        await windowManager.setPosition( Offset(50, 150));
      } else {
            final windowHeight = screenSize.height * 0.32;
        final windowWidth = screenSize.width * 0.55;
        await windowManager.setSize( Size(windowWidth, windowHeight));
        await _setWindowPosition();
      }
    }

    void _onKeyPressed(String key) {
      if (_isEditing) return;
      
      if (key == 'ADD') {
        _showAddDialog();
        return;
      }

      final keyBind = _storage.getKeyBind(key);
      if (keyBind != null) {
        _actionService.executeKeyBind(keyBind);
      }
    }

    void _onKeySecondaryTap(String key) {
      _showKeyEditor(key);
    }

    void _onKeyLongPressed(String key) {
      _showKeyEditor(key);
    }

 
  void _handleKeyEvent(RawKeyEvent event) {
  if (event is RawKeyDownEvent && !_isEditing) {
    final logicalKey = event.logicalKey;
    
    if (logicalKey == LogicalKeyboardKey.escape || logicalKey == LogicalKeyboardKey.capsLock) {
      _animateWindowFadeOutToBottomToClose();
      return;
    }
    
    // Получаем физическую позицию клавиши вместо символа
    final physicalKey = event.physicalKey;
    
    for (final key in _storage.getAllKeys()) {
      final keyBind = _storage.getKeyBind(key);
      if (keyBind != null) {
        final parts = keyBind.combination.split('+');
        if (parts.length == 2) {
          // Сравниваем по физическим клавишам вместо символов
          final modifier = parts[0];
          final keyChar = parts[1];
          
          // Проверяем модификатор
          bool modifierPressed = false;
          if (modifier == 'CTRL' && (RawKeyboard.instance.keysPressed.contains(LogicalKeyboardKey.controlLeft) || 
              RawKeyboard.instance.keysPressed.contains(LogicalKeyboardKey.controlRight))) {
            modifierPressed = true;
          } else if (modifier == 'SHIFT' && (RawKeyboard.instance.keysPressed.contains(LogicalKeyboardKey.shiftLeft) || 
              RawKeyboard.instance.keysPressed.contains(LogicalKeyboardKey.shiftRight))) {
            modifierPressed = true;
          } else if (modifier == 'ALT' && (RawKeyboard.instance.keysPressed.contains(LogicalKeyboardKey.altLeft) || 
              RawKeyboard.instance.keysPressed.contains(LogicalKeyboardKey.altRight))) {
            modifierPressed = true;
          }
          
          // Проверяем основную клавишу по физической позиции
          bool keyMatches = _physicalKeyMatchesCharacter(physicalKey, keyChar);
          
          if (modifierPressed && keyMatches) {
            _actionService.executeKeyBind(keyBind);
            break;
          }
        }
      }
    }
  }
}

bool _physicalKeyMatchesCharacter(PhysicalKeyboardKey physicalKey, String character) {
  // Маппинг физических клавиш к символам в английской раскладке
  const keyMap = {
    'Q': PhysicalKeyboardKey.keyQ,
    'W': PhysicalKeyboardKey.keyW,
    'E': PhysicalKeyboardKey.keyE,
    'R': PhysicalKeyboardKey.keyR,
    'T': PhysicalKeyboardKey.keyT,
    'Y': PhysicalKeyboardKey.keyY,
    'U': PhysicalKeyboardKey.keyU,
    'I': PhysicalKeyboardKey.keyI,
    'O': PhysicalKeyboardKey.keyO,
    'P': PhysicalKeyboardKey.keyP,
    'A': PhysicalKeyboardKey.keyA,
    'S': PhysicalKeyboardKey.keyS,
    'D': PhysicalKeyboardKey.keyD,
    'F': PhysicalKeyboardKey.keyF,
    'G': PhysicalKeyboardKey.keyG,
    'H': PhysicalKeyboardKey.keyH,
    'J': PhysicalKeyboardKey.keyJ,
    'K': PhysicalKeyboardKey.keyK,
    'L': PhysicalKeyboardKey.keyL,
    'Z': PhysicalKeyboardKey.keyZ,
    'X': PhysicalKeyboardKey.keyX,
    'C': PhysicalKeyboardKey.keyC,
    'V': PhysicalKeyboardKey.keyV,
    'B': PhysicalKeyboardKey.keyB,
    'N': PhysicalKeyboardKey.keyN,
    'M': PhysicalKeyboardKey.keyM,
  };
  
  return keyMap[character] == physicalKey;
}

  Future<void> _animateWindowFadeOutToBottomToClose() async {

    final primaryDisplay = await screenRetriever.getPrimaryDisplay();
      final screenSize = primaryDisplay.size;
      final windowHeight = screenSize.height * 0.32;
      final windowWidth = screenSize.width * 0.55;
      // Устанавливаем точный размер
      await windowManager.setSize(Size(windowWidth, windowHeight));

      // Начальная позиция (за пределами экрана справа)
      final endPosition = Offset(
        (screenSize.width - windowWidth)/2, // Полностью за правым краем
        (screenSize.height ) ,
      );

      // Конечная позиция
      final startPosition = Offset(
    (screenSize.width - windowWidth )/2, // Правый край
        (screenSize.height - windowHeight) - 50,
      );

      // Устанавливаем начальную позицию (невидимо за экраном)
      await windowManager.setPosition(startPosition);

    const duration = Duration(milliseconds: 390);
    const steps = 60;
    final stepDuration = duration ~/ steps;

    for (int i = 0; i <= steps; i++) {
      final progress = i / steps;
      
      // Используем кривую для более естественной анимации
      final curvedProgress = Curves.easeOutCubic.transform(progress);
      
      final currentY = startPosition.dy + (endPosition.dy - startPosition.dy) * curvedProgress;
      final currentPosition = Offset(startPosition.dx,currentY);
      
      // Можно использовать разные кривые для прозрачности и движения
      final fadeProgress = Curves.easeOutCubic.transform(progress);
      final currentOpacity = fadeProgress;

      await windowManager.setPosition(currentPosition);
      await windowManager.setOpacity(1.0-currentOpacity);

      await Future.delayed(stepDuration);
    }

    // Финальные значения
    await windowManager.setPosition(endPosition);
    await windowManager.setOpacity(0.0);
    await windowManager.close();
  }

    void _showKeyEditorWithBind(String key, KeyBind bind) {
      setState(() => _isEditing = true);
      
      showDialog(
        context: context,
        barrierColor: Colors.black54,
        builder: (context) => KeyBindEditor(
          keyId: key,
          existingBind: bind,
          onSave: (newBind) {
            _storage.setKeyBind(key, newBind);
            setState(() {});
            Navigator.of(context).pop();
            setState(() => _isEditing = false);
          },
          onDelete: _storage.hasKeyBind(key) ? () {
            _storage.removeKeyBind(key);
            setState(() {});
            Navigator.of(context).pop();
            setState(() => _isEditing = false);
          } : null,
        ),
      ).then((_) => setState(() => _isEditing = false));
    }
  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Scaffold(
        backgroundColor: Colors.transparent,
        body: Center(
          child: CircularProgressIndicator(color: Colors.blue),
        ),
      );
    }

    return RepaintBoundary(
      child: RawKeyboardListener(
        focusNode: _focusNode,
        autofocus: true,
        onKey: _handleKeyEvent,
        child: Material(
          color: Colors.transparent,
          child: Stack(
            children: [
              // Фон, который всегда пропускает клики
              Positioned.fill(
                child: IgnorePointer(
                  ignoring: !_isEditing, // Всегда игнорируем клики на фоне
                  child: Container(color: Colors.transparent),
                ),
              ),
               // Область перетаскивания - НЕ пропускает клики
              _buildDragArea(),
              // Клавиатура - НЕ пропускает клики
              _buildKeyboard(),
              // Кнопка сворачивания - НЕ пропускает клики
              Positioned(
                top: 10,
                right: 10,
                child: IgnorePointer(
                  ignoring: false, // Не игнорируем клики на кнопке
                  child: Container(
                    width: 30,
                    height: 30,
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.7),
                      borderRadius: BorderRadius.circular(15),
                    ),
                    child: IconButton(
                      icon: Icon(_isMinimized ? Icons.open_in_full : Icons.minimize, 
                        color: Colors.white70, size: 16),
                      onPressed: _toggleMinimize,
                      padding: EdgeInsets.zero,
                    ),
                  ),
                ),
              ),
             
            ],
          ),
        ),
      ),
    );
  }
    Widget _buildDragArea() {
  return Positioned.fill(
    child: IgnorePointer(
      ignoring: _isEditing, // Игнорируем в режиме редактирования
      child: GestureDetector(
        onPanStart: (details) {
          windowManager.startDragging();
        },
        child: Container(
          color: Colors.transparent,
        ),
      ),
    ),
  );
}
  Future<void> _handleFileDrop(String key, List<File> files) async {
    if (files.isEmpty) return;
    
    final file = files.first;
    final path = file.path;
    if (path.isEmpty) return;

    if (_isMinimized) {
      await _toggleMinimize();
    }

    KeyBind newBind;
    
    // Получаем расширение файла из пути
    final extension = p.extension(path).toLowerCase();
    final fileName = p.basename(path);
    final fileNameWithoutExt = p.basenameWithoutExtension(path);
    
    if (extension == '.png' || extension == '.jpg' || extension == '.jpeg') {
      newBind = KeyBind(
        key: key,
        name: fileNameWithoutExt,
        hint: 'Image: $fileName',
        description: 'Dropped image file',
        type: KeyContentType.image,
        combination: 'CTRL+$key',
        actions: [KeyAction.copyToClipboard, KeyAction.open],
        imagePath: path,
      );
    } else if (extension == '.lnk' || extension == '.exe') {
      newBind = KeyBind(
        key: key,
        name: fileNameWithoutExt,
        hint: 'File: $fileName',
        description: 'Dropped file',
        type: KeyContentType.windowsShortcut,
        combination: 'CTRL+$key',
        actions: [KeyAction.open, KeyAction.openInExplorer],
        filePath: path,
      );
    } else if (extension == '.txt') {
      try {
        final content = await file.readAsString();
        newBind = KeyBind(
          key: key,
          name: fileNameWithoutExt,
          hint: 'Text: $fileName',
          description: 'Dropped text file',
          type: KeyContentType.text,
          combination: 'CTRL+$key',
          actions: [KeyAction.copyToClipboard],
          textContent: content,
        );
      } catch (e) {
        // Если не удалось прочитать файл как текст, создаем обычный файловый бинд
        newBind = KeyBind(
          key: key,
          name: fileNameWithoutExt,
          hint: 'File: $fileName',
          description: 'Dropped file',
          type: KeyContentType.windowsShortcut,
          combination: 'CTRL+$key',
          actions: [KeyAction.open, KeyAction.openInExplorer],
          filePath: path,
        );
      }
    } else {
      newBind = KeyBind(
        key: key,
        name: fileNameWithoutExt,
        hint: 'File: $fileName',
        description: 'Dropped file',
        type: KeyContentType.windowsShortcut,
        combination: 'CTRL+$key',
        actions: [KeyAction.open, KeyAction.openInExplorer],
        filePath: path,
      );
    }

    _showKeyEditorWithBind(key, newBind);
  }
    Widget _buildKeyboard() {
  return Container(
    padding: _isMinimized ? const EdgeInsets.all(1) : const EdgeInsets.all(12),
    child: Column(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: _keyboardLayout.map((row) {
        return Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: row.map((key) {
            return Padding(
              padding: _isMinimized ? const EdgeInsets.all(1) : const EdgeInsets.all(3),
              child: _buildKey(key),
            );
          }).toList(),
        );
      }).toList(),
    ),
  );
}
  Widget _buildKey(String key) {
  final hasBind = _storage.hasKeyBind(key);
  final keyBind = _storage.getKeyBind(key);
  final isAddButton = key == 'ADD';
  
  // Определяем цвет в зависимости от типа контента
  Color? backgroundColor;
  if (hasBind && keyBind != null) {
    Color baseColor = _getColorForType(keyBind.type);
    Color darkGray = const Color.fromRGBO(35, 35, 35, 1.0);
    backgroundColor = Color.lerp(baseColor, darkGray, 0.9)!;
  }
  
  return Tooltip(
    message: isAddButton ? 'Add new bind' : (hasBind ? (keyBind?.hint ?? '') : 'Right-click to add bind'),
    waitDuration: const Duration(milliseconds: 500),
    child: DropTarget(
      onDragDone: (detail) async {
        final files = <File>[];
        try {
          final processedPaths = <String>{};
          for (final item in detail.files) {
            final path = item.path;
            if (path != null && path.isNotEmpty && !processedPaths.contains(path)) {
              processedPaths.add(path);
              final file = File(path);
              if (await file.exists()) {
                files.add(file);
                break;
              }
            }
          }
        } catch (e) {
          print('Error in key drop: $e');
        }
        
        if (files.isNotEmpty) {
          _handleFileDrop(key, files);
          if (mounted) {
            setState(() {});
          }
          files.clear();
        }
      },
      child: GestureDetector(
        onTap: () => _onKeyPressed(key),
        onLongPress: isAddButton ? null : () => _onKeyLongPressed(key),
        onSecondaryTap: isAddButton ? null : () => _onKeySecondaryTap(key),
        child: Container(
          width: _isMinimized ? 35 : 70,
          height: _isMinimized ? 35 : 70,
          decoration: BoxDecoration(
            color: isAddButton 
                ? Colors.green.withOpacity(0.3)
                : hasBind 
                    ? backgroundColor ?? const Color(0xFF404040)
                    : const Color.fromRGBO(35, 35, 35, 0.4),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: isAddButton 
                  ? Colors.green
                  : hasBind 
                      ? _getBorderColorForType(keyBind?.type) ?? Colors.blue.withOpacity(0.5)
                      : Colors.black.withOpacity(0.2),
              width: 1,
            ),
          ),
          child: Stack(
            children: [
              if (isAddButton)
                Center(
                  child: Icon(Icons.add, color: Colors.green, size: _isMinimized ? 16 : 28),
                )
              else ...[
                Positioned(
                  top: 4,
                  left: 6,
                  child: Text(
                    key,
                    style: TextStyle(
                      color: hasBind ? Colors.white : Colors.white.withOpacity(0.5),
                      fontSize: _isMinimized ? 8 : 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                // Отображаем выбранную иконку или иконку по умолчанию
                if (hasBind && keyBind != null)
                  Positioned(
                    top: 4,
                    right: 6,
                    child: Icon(
                      keyBind.icon ?? _getTypeIcon(keyBind.type),
                      size: _isMinimized ? 10 : 14,
                      color: Colors.white70,
                    ),
                  ),
                // Для не-изображений показываем иконку в центре
                if (hasBind && keyBind != null && keyBind.type != KeyContentType.image)
                  Center(
                    child: Icon(
                      keyBind.icon ?? _getTypeIcon(keyBind.type),
                      size: _isMinimized ? 16 : 24,
                      color: Colors.white.withOpacity(0.8),
                    ),
                  ),
                // Для изображений показываем превью
                if (hasBind && keyBind != null && keyBind.type == KeyContentType.image)
                  Center(child: _buildContentPreview(keyBind, _isMinimized ? 20 : 35)),
                if (hasBind && keyBind != null && keyBind.name.isNotEmpty)
                  Positioned(
                    bottom: 4,
                    left: 4,
                    right: 4,
                    child: Text(
                      keyBind.name.length > (_isMinimized ? 4 : 8) 
                          ? '${keyBind.name.substring(0, _isMinimized ? 4 : 8)}..' 
                          : keyBind.name,
                      style: TextStyle(
                        color: Colors.white70, 
                        fontSize: _isMinimized ? 7 : 10
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
              ],
            ],
          ),
        ),
      ),
    ),
  );
}

  // Метод для получения цвета фона по типу контента
 Color _getColorForType(KeyContentType type) {
  switch (type) {
    case KeyContentType.image:
      return Colors.purple;
    case KeyContentType.text:
      return Colors.green;
    case KeyContentType.url:
      return Colors.blue;
    case KeyContentType.windowsShortcut:
      return Colors.orange;
    case KeyContentType.macros:
      return Colors.red;
    case KeyContentType.clipboard:
      return Colors.teal;
  }
}
 Color _getBorderColorForType(KeyContentType? type) {
  if (type == null) return Colors.black.withOpacity(0.5);
  
  switch (type) {
    case KeyContentType.image:
      return Colors.purpleAccent.withOpacity(0.7);
    case KeyContentType.text:
      return Colors.greenAccent.withOpacity(0.7);
    case KeyContentType.url:
      return Colors.blueAccent.withOpacity(0.7);
    case KeyContentType.windowsShortcut:
      return Colors.orangeAccent.withOpacity(0.7);
    case KeyContentType.macros:
      return Colors.redAccent.withOpacity(0.7);
    case KeyContentType.clipboard:
      return Colors.tealAccent.withOpacity(0.7);
  }
}

   IconData _getTypeIcon(KeyContentType type) {
  switch (type) {
    case KeyContentType.image: return Icons.image;
    case KeyContentType.text: return Icons.text_fields;
    case KeyContentType.url: return Icons.link;
    case KeyContentType.windowsShortcut: return Icons.insert_drive_file;
    case KeyContentType.macros: return Icons.play_arrow;
    case KeyContentType.clipboard: return Icons.content_paste;
  }
}
    Widget _buildContentPreview(KeyBind keyBind, double size) {
      if (keyBind.type == KeyContentType.image && keyBind.imagePath != null) {
        final file = File(keyBind.imagePath!);
        if (file.existsSync()) {
          return ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: Image.file(
              file,
              width: size,
              height: size,
              fit: BoxFit.cover,
              errorBuilder: (_, __, ___) => Icon(
                Icons.broken_image,
                size: size * 0.5,
                color: Colors.white30,
              ),
            ),
          );
        }
      }
      return const SizedBox.shrink();
    }

    void _showKeyEditor(String key) async {
      if (_isMinimized) {
        await _toggleMinimize();
      }

      setState(() => _isEditing = true);
      
      showDialog(
        context: context,
        barrierColor: Colors.black54,
        builder: (context) => KeyBindEditor(
          keyId: key,
          existingBind: _storage.getKeyBind(key),
          onSave: (bind) {
            _storage.setKeyBind(key, bind);
            setState(() {});
            Navigator.of(context).pop();
            setState(() => _isEditing = false);
          },
          onDelete: _storage.hasKeyBind(key) ? () {
            _storage.removeKeyBind(key);
            setState(() {});
            Navigator.of(context).pop();
            setState(() => _isEditing = false);
          } : null,
        ),
      ).then((_) => setState(() => _isEditing = false));
    }

   void _showAddDialog() {
  setState(() => _isEditing = true);
  
  String? selectedKey;
  final focusNode = FocusNode();
  
  showDialog(
    context: context,
    barrierColor: Colors.black54,
    builder: (context) => RawKeyboardListener(
      focusNode: focusNode,
      autofocus: true,
      onKey: (event) {
        if (event is RawKeyDownEvent) {
          final keyLabel = event.logicalKey.keyLabel;
          // Игнорируем модификаторы и специальные клавиши
          if (keyLabel.length == 1 && keyLabel.toUpperCase() != keyLabel.toLowerCase()) {
            final key = keyLabel.toUpperCase();
            if (_keyboardLayout.any((row) => row.contains(key))) {
              Navigator.pop(context);
              _showKeyEditor(key);
            }
          }
        }
      },
      child: StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          backgroundColor: Colors.black.withOpacity(0.8),
          title: const Text('Выберите клавишу', style: TextStyle(color: Colors.white)),
          content: SizedBox(
            width: 400,
            height: 200,
            child: GridView.count(
              crossAxisCount: 10,
              crossAxisSpacing: 4,
              mainAxisSpacing: 4,
              children: _keyboardLayout.expand((row) => row)
                  .where((k) => k != 'ADD')
                  .map((key) {
                return GestureDetector(
                  onTap: () => setState(() => selectedKey = key),
                  child: Container(
                    decoration: BoxDecoration(
                      color: selectedKey == key ? Colors.blue : Colors.grey.withOpacity(0.3),
                      borderRadius: BorderRadius.circular(4),
                      border: Border.all(
                        color: selectedKey == key ? Colors.blue : Colors.white.withOpacity(0.2),
                      ),
                    ),
                    child: Center(
                      child: Text(
                        key,
                        style: const TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.pop(context);
                setState(() => _isEditing = false);
              },
              child: const Text('Отмена'),
            ),
            ElevatedButton(
              onPressed: selectedKey == null ? null : () {
                Navigator.pop(context);
                _showKeyEditor(selectedKey!);
              },
              child: const Text('Далее'),
            ),
          ],
        ),
      ),
    ),
  ).then((_) {
    setState(() => _isEditing = false);
    focusNode.dispose();
  });
}}

  // ==================== РЕДАКТОР БИНДОВ ====================

  class KeyBindEditor extends StatefulWidget {
    final String keyId;
    final KeyBind? existingBind;
    final Function(KeyBind) onSave;
    final VoidCallback? onDelete;

    const KeyBindEditor({
      Key? key,
      required this.keyId,
      this.existingBind,
      required this.onSave,
      this.onDelete,
    }) : super(key: key);

    @override
    State<KeyBindEditor> createState() => _KeyBindEditorState();
  }

  class _KeyBindEditorState extends State<KeyBindEditor> {
    late TextEditingController _nameCtrl, _hintCtrl, _descCtrl;
    String _modifier = 'CTRL';
    KeyContentType _type = KeyContentType.text;
    List<KeyAction> _actions = [KeyAction.copyToClipboard];
    String? _imagePath, _filePath, _textContent, _url;
    Macro? _macro;
    IconData? _selectedIcon;
    bool _showIconGrid = false;

    final List<IconData> _icons = [
      Icons.home, Icons.settings, Icons.favorite, Icons.star, Icons.person,
      Icons.email, Icons.phone, Icons.chat, Icons.notifications, Icons.search,
      Icons.menu, Icons.close, Icons.arrow_back, Icons.arrow_forward, Icons.refresh,
      Icons.add, Icons.remove, Icons.create, Icons.delete, Icons.share,
      Icons.download, Icons.upload, Icons.cloud, Icons.wifi, Icons.bluetooth,
      Icons.gps_fixed, Icons.location_on, Icons.map, Icons.navigation, Icons.directions,
      Icons.camera, Icons.image, Icons.music_note, Icons.videocam, Icons.movie,
      Icons.games, Icons.sports_esports, Icons.fitness_center, Icons.beach_access, Icons.work,
      Icons.school, Icons.book, Icons.library_books, Icons.calculate, Icons.code,
      Icons.computer, Icons.phone_android, Icons.tablet, Icons.headset, Icons.keyboard,
      Icons.mouse, Icons.touch_app, Icons.memory, Icons.storage, Icons.usb,
      Icons.battery_std, Icons.power, Icons.lightbulb, Icons.flash_on, Icons.wb_sunny,
      Icons.ac_unit, Icons.whatshot, Icons.local_drink, Icons.restaurant, Icons.local_cafe,
      Icons.shopping_cart, Icons.credit_card, Icons.attach_money, Icons.account_balance,
      Icons.security, Icons.lock, Icons.visibility, Icons.visibility_off, Icons.vpn_key,
      Icons.fingerprint, Icons.face, Icons.verified_user, Icons.admin_panel_settings,
      Icons.warning, Icons.error, Icons.info, Icons.help, Icons.check_circle,
      Icons.cancel, Icons.remove_circle, Icons.add_circle, Icons.play_arrow, Icons.pause,
      Icons.stop, Icons.skip_next, Icons.skip_previous, Icons.fast_forward, Icons.fast_rewind,
      Icons.volume_up, Icons.volume_off, Icons.mic, Icons.mic_off, Icons.headphones,
      Icons.brightness_high, Icons.brightness_low, Icons.palette, Icons.format_paint, Icons.brush,
    ];

    @override
    void initState() {
      super.initState();
      final bind = widget.existingBind;
      _nameCtrl = TextEditingController(text: bind?.name ?? '');
      _hintCtrl = TextEditingController(text: bind?.hint ?? '');
      _descCtrl = TextEditingController(text: bind?.description ?? '');
      _selectedIcon = bind?.icon;
      
      if (bind != null) {
        _type = bind.type;
        _actions = List.from(bind.actions);
        _imagePath = bind.imagePath;
        _filePath = bind.filePath;
        _textContent = bind.textContent;
        _url = bind.url;
        _macro = bind.macro;
        final parts = bind.combination.split('+');
        if (parts.isNotEmpty) _modifier = parts[0];
      }
    }

    @override
    Widget build(BuildContext context) {
      final screenWidth = MediaQuery.of(context).size.width;

      return Dialog(
        backgroundColor: Colors.transparent,
        insetPadding: EdgeInsets.zero,
        child: Container(
          width: screenWidth,
          height: 450,
          padding: const EdgeInsets.all(20),
          child: Row(
            children: [
              Expanded(flex: 1, child: _buildLeftSection()),
              const SizedBox(width: 12),
              Expanded(flex: 1, child: _buildMiddleSection()),
              const SizedBox(width: 12),
              Expanded(flex: 1, child: _buildRightSection()),
            ],
          ),
        ),
      );
    }

    Widget _buildLeftSection() {
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.7),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          children: [
            Row(
              children: [
                Expanded(
                  flex: 2,
                  child: DropdownButtonFormField<String>(
                    value: _modifier,
                    items: ['CTRL', 'SHIFT', 'ALT', 'TAB']
                        .map((m) => DropdownMenuItem(value: m, child: Text(m, style: const TextStyle(color: Colors.white))))
                        .toList(),
                    onChanged: (v) => setState(() => _modifier = v!),
                    decoration: const InputDecoration(
                      labelText: 'Модификатор',
                      labelStyle: TextStyle(color: Colors.white70),
                      filled: true,
                      fillColor: Color(0xFF1E1E1E),
                    ),
                    dropdownColor: const Color(0xFF1E1E1E),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: GestureDetector(
                    onTap: _showKeySelector,
                    child: AbsorbPointer(
                      child: TextField(
                        enabled: false,
                        decoration: InputDecoration(
                          labelText: 'Клавиша',
                          hintText: widget.keyId,
                          hintStyle: const TextStyle(color: Colors.white),
                          labelStyle: const TextStyle(color: Colors.white70),
                          filled: true,
                          fillColor: const Color(0xFF1E1E1E),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            _buildIconSelector(),
            const SizedBox(height: 12),
            TextField(
              controller: _nameCtrl,
              style: const TextStyle(color: Colors.white),
              decoration: const InputDecoration(
                labelText: 'Название',
                labelStyle: TextStyle(color: Colors.white70),
                filled: true,
                fillColor: Color(0xFF1E1E1E),
              ),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _hintCtrl,
              style: const TextStyle(color: Colors.white),
              decoration: const InputDecoration(
                labelText: 'Подсказка',
                labelStyle: TextStyle(color: Colors.white70),
                filled: true,
                fillColor: Color(0xFF1E1E1E),
              ),
            ),
          ],
        ),
      );
    }

    Widget _buildIconSelector() {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Иконка', style: TextStyle(color: Colors.white70, fontSize: 14)),
          const SizedBox(height: 8),
          GestureDetector(
            onTap: () => setState(() => _showIconGrid = !_showIconGrid),
            child: Container(
              width: double.infinity,
              height: 40,
              decoration: BoxDecoration(
                color: const Color(0xFF1E1E1E),
                borderRadius: BorderRadius.circular(4),
                border: Border.all(color: Colors.white24),
              ),
              child: Row(
                children: [
                  const SizedBox(width: 8),
                  Icon(_selectedIcon ?? Icons.help_outline, color: Colors.white70),
                  const SizedBox(width: 8),
                  Text(
                    _selectedIcon != null ? 'Иконка выбрана' : 'Выберите иконку',
                    style: const TextStyle(color: Colors.white70),
                  ),
                  const Spacer(),
                  Icon(_showIconGrid ? Icons.expand_less : Icons.expand_more, color: Colors.white70),
                  const SizedBox(width: 8),
                ],
              ),
            ),
          ),
          if (_showIconGrid) ...[
            const SizedBox(height: 8),
            Container(
              height: 120,
              decoration: BoxDecoration(
                color: const Color(0xFF1E1E1E),
                borderRadius: BorderRadius.circular(4),
                border: Border.all(color: Colors.white24),
              ),
              child: Scrollbar(
                child: GridView.builder(
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 5,
                    crossAxisSpacing: 4,
                    mainAxisSpacing: 4,
                  ),
                  itemCount: _icons.length,
                  itemBuilder: (context, index) {
                    final icon = _icons[index];
                    final isSelected = _selectedIcon == icon;
                    return GestureDetector(
                      onTap: () => setState(() {
                        _selectedIcon = icon;
                        _showIconGrid = false;
                      }),
                      child: Container(
                        decoration: BoxDecoration(
                          color: isSelected ? Colors.blue : Colors.grey.withOpacity(0.3),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Icon(icon, color: Colors.white, size: 20),
                      ),
                    );
                  },
                ),
              ),
            ),
          ],
        ],
      );
    }

    void _showKeySelector() {
      String? selectedKey;
      showDialog(
        context: context,
        barrierColor: Colors.black54,
        builder: (context) => StatefulBuilder(
          builder: (context, setState) => AlertDialog(
            backgroundColor: Colors.black.withOpacity(0.8),
            title: const Text('Выберите клавишу', style: TextStyle(color: Colors.white)),
            content: SizedBox(
              width: 400,
              height: 200,
              child: GridView.count(
                crossAxisCount: 10,
                crossAxisSpacing: 8,
                mainAxisSpacing: 8,
                children: ['Q','W','E','R','T','Y','U','I','O','P','A','S','D','F','G','H','J','K','L','Z','X','C','V','B','N','M']
                    .map((key) {
                  return GestureDetector(
                    onTap: () => setState(() => selectedKey = key),
                    child: Container(
                      decoration: BoxDecoration(
                        color: selectedKey == key ? Colors.blue : Colors.grey.withOpacity(0.3),
                        borderRadius: BorderRadius.circular(4),
                        border: Border.all(
                          color: selectedKey == key ? Colors.blue : Colors.white.withOpacity(0.2),
                        ),
                      ),
                      child: Center(
                        child: Text(
                          key,
                          style: TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                  );
                }).toList(),
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Отмена'),
              ),
              ElevatedButton(
                onPressed: selectedKey == null ? null : () {
                  Navigator.pop(context);
                },
                child: const Text('Выбрать'),
              ),
            ],
          ),
        ),
      );
    }

    Widget _buildMiddleSection() {
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.7),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Комментарий',
                  style: TextStyle(color: Colors.white, fontSize: 16, fontWeight: FontWeight.bold),
                ),
                Tooltip(
                  message: 'Копировать в буфер обмена',
                  child: IconButton(
                    icon: const Icon(Icons.content_copy, size: 18),
                    color: Colors.white70,
                    onPressed: () {
                      if (_descCtrl.text.isNotEmpty) {
                        Clipboard.setData(ClipboardData(text: _descCtrl.text));
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Комментарий скопирован в буфер обмена')),
                        );
                      }
                    },
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Expanded(
              child: TextField(
                controller: _descCtrl,
                maxLines: null,
                expands: true,
                textAlignVertical: TextAlignVertical.top,
                style: const TextStyle(color: Colors.white),
                decoration: const InputDecoration(
                  hintText: 'Введите описание бинда...',
                  hintStyle: TextStyle(color: Colors.white30),
                  filled: true,
                  fillColor: Color(0xFF1E1E1E),
                  border: OutlineInputBorder(),
                ),
              ),
            ),
          ],
        ),
      );
    }

    Widget _buildRightSection() {
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.7),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          children: [
            _buildTypeSelector(),
            const SizedBox(height: 12),
            Expanded(child: _buildContentEditor()),
            const SizedBox(height: 12),
            //_buildActionSelector(),
            const SizedBox(height: 8),
            _buildButtons(),
          ],
        ),
      );
    }

    Widget _buildTypeSelector() {
      return DropdownButtonFormField<KeyContentType>(
        value: _type,
        items: KeyContentType.values.map((t) {
          return DropdownMenuItem(value: t, child: Text(_getTypeName(t), style: const TextStyle(color: Colors.white)));
        }).toList(),
        onChanged: (v) => setState(() {
          _type = v!;
          _actions = _getDefaultActions(v);
        }),
        decoration: const InputDecoration(
          labelText: 'Тип контента',
          labelStyle: TextStyle(color: Colors.white70),
          filled: true,
          fillColor: Color(0xFF1E1E1E),
        ),
        dropdownColor: const Color(0xFF1E1E1E),
      );
    }

  String _getTypeName(KeyContentType type) {
  switch (type) {
    case KeyContentType.image: return 'Изображение';
    case KeyContentType.text: return 'Текст';
    case KeyContentType.url: return 'URL';
    case KeyContentType.windowsShortcut: return 'Ярлык/Файл';
    case KeyContentType.macros: return 'Макрос';
    case KeyContentType.clipboard: return 'Буфер обмена';
  }
}

   List<KeyAction> _getDefaultActions(KeyContentType type) {
  switch (type) {
    case KeyContentType.image:
    case KeyContentType.text:
    case KeyContentType.url:
    case KeyContentType.clipboard:
      return [KeyAction.copyToClipboard];
    case KeyContentType.windowsShortcut:
      return [KeyAction.open];
    case KeyContentType.macros:
      return [KeyAction.run];
  }
}
Widget _buildClipboardEditor() {
  return Column(
    children: [
      Container(
        width: 100,
        height: 100,
        decoration: BoxDecoration(
          color: const Color(0xFF1E1E1E),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: Colors.white24),
        ),
        child: _filePath != null || _textContent != null
            ? const Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.check_circle, size: 40, color: Colors.green),
                  SizedBox(height: 8),
                  Text('Данные\nсохранены', 
                    textAlign: TextAlign.center,
                    style: TextStyle(color: Colors.green, fontSize: 12),
                  ),
                ],
              )
            : const Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.content_paste, size: 40, color: Colors.white30),
                  SizedBox(height: 8),
                  Text('Буфер\nобмена', 
                    textAlign: TextAlign.center,
                    style: TextStyle(color: Colors.white30, fontSize: 12),
                  ),
                ],
              ),
      ),
      const SizedBox(height: 12),
      Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
          ElevatedButton.icon(
            onPressed: _captureClipboard,
            icon: const Icon(Icons.content_paste),
            label: const Text('Захватить'),
          ),
          ElevatedButton.icon(
            onPressed: _filePath != null || _textContent != null ? _pasteClipboardData : null,
            icon: const Icon(Icons.content_copy),
            label: const Text('Вставить'),
          ),
        ],
      ),
      if (_filePath != null || _textContent != null) ...[
        const SizedBox(height: 8),
        Text(
          _filePath != null 
            ? 'Данные сохранены (${_textContent})'
            : 'Текст: ${_textContent != null && _textContent!.length > 20 ? '${_textContent!.substring(0, 20)}...' : _textContent}',
          style: const TextStyle(color: Colors.green, fontSize: 12),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        OutlinedButton(
          onPressed: () {
            setState(() {
              _filePath = null;
              _textContent = null;
            });
          },
          child: const Text('Очистить'),
        ),
      ],
    ],
  );
}
Future<void> _captureClipboard() async {
  try {
    const MethodChannel clipboardChannel = MethodChannel('screenshot_channel');
    final result = await clipboardChannel.invokeMethod('getClipboardData');
    
    if (result != null) {
      final data = result['data'] as Uint8List?;
      final format = result['format'] as String? ?? 'unknown';
      final formatId = result['formatId'] as int?;
      final filePath = result['filePath'] as String?;
      final availableFormats = result['availableFormats'] as List<dynamic>?;
      
      print('Available formats: $availableFormats');
      print('Detected format: $format (ID: $formatId)');
      
      if (data != null && data.isNotEmpty) {
        // Сохраняем данные в файл
        final directory = await getApplicationDocumentsDirectory();
        final fileName = 'clipboard_${DateTime.now().millisecondsSinceEpoch}.bin';
        final file = File('${directory.path}/$fileName');
        await file.writeAsBytes(data);
        
        setState(() {
          _filePath = file.path;
          _textContent = format;
          if (_nameCtrl.text.isEmpty) {
            _nameCtrl.text = 'Clipboard Data';
          }
        });
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Данные буфера сохранены (формат: $format)')),
        );
      } else if (filePath != null) {
        // Если получили путь к файлу
        setState(() {
          _filePath = filePath;
          _textContent = 'file/reference';
          if (_nameCtrl.text.isEmpty) {
            _nameCtrl.text = 'File Reference';
          }
        });
        
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Ссылка на файл сохранена')),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Буфер обмена пуст')),
        );
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Буфер обмена пуст или содержит неподдерживаемый формат')),
      );
    }
  } catch (e) {
    print('Error capturing clipboard: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Ошибка захвата буфера: $e')),
    );
  }
}

Future<void> _pasteClipboardData() async {
  if (_filePath != null && File(_filePath!).existsSync()) {
    try {
      final file = File(_filePath!);
      final data = await file.readAsBytes();
      
      const MethodChannel clipboardChannel = MethodChannel('screenshot_channel');
      
      final Map<String, dynamic> arguments = {
        'data': data,
        'format': _textContent ?? 'unknown',
      };
      
      // Если у нас есть ID формата, передаем его тоже
      if (_textContent?.startsWith('custom/') == true) {
        final formatId = int.tryParse(_textContent!.replaceFirst('custom/', ''));
        if (formatId != null) {
          arguments['formatId'] = formatId;
        }
      }
      
      final success = await clipboardChannel.invokeMethod('setClipboardData', arguments);
      
      if (success == true) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Данные скопированы в буфер')),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Не удалось скопировать данные в буфер')),
        );
      }
    } catch (e) {
      print('Error pasting clipboard data: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Ошибка вставки: $e')),
      );
    }
  } else if (_textContent != null) {
    // Fallback для текста
    await Clipboard.setData(ClipboardData(text: _textContent!));
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Текст скопирован в буфер')),
    );
  }
}


Widget _buildContentEditor() {
  switch (_type) {
    case KeyContentType.image: return _buildImageEditor();
    case KeyContentType.text: return _buildTextEditor();
    case KeyContentType.url: return _buildUrlEditor();
    case KeyContentType.windowsShortcut: return _buildFileEditor();
    case KeyContentType.macros: return _buildMacroEditor();
    case KeyContentType.clipboard: return _buildClipboardEditor();
  }
}

  Widget _buildImageEditor() {
  return Column(
    children: [
      DropTarget(
        onDragDone: (detail) async {
          final files = <File>[];
          try {
            final processedPaths = <String>{};
            for (final item in detail.files) {
              final path = item.path;
              if (path != null && path.isNotEmpty && !processedPaths.contains(path)) {
                processedPaths.add(path);
                final file = File(path);
                if (await file.exists()) {
                  files.add(file);
                  break;
                }
              }
            }
          } catch (e) {
            print('Error in image drop: $e');
          }
          
          if (files.isNotEmpty) {
            setState(() {
              _imagePath = files.first.path;
              if (_nameCtrl.text.isEmpty) {
                _nameCtrl.text = p.basenameWithoutExtension(files.first.path);
              }
            });
            files.clear();
          }
        },
        child: Container(
          width: 100,
          height: 100,
          decoration: BoxDecoration(
            color: const Color(0xFF1E1E1E),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: Colors.white24,
              width: 1,
            ),
          ),
          child: _imagePath != null && File(_imagePath!).existsSync()
              ? ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: Image.file(File(_imagePath!), fit: BoxFit.cover),
                )
              : const Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.add_photo_alternate, size: 40, color: Colors.white30),
                    SizedBox(height: 8),
                    Text('Перетащите\nизображение', 
                      textAlign: TextAlign.center,
                      style: TextStyle(color: Colors.white30, fontSize: 12),
                    ),
                  ],
                ),
        ),
      ),
      const SizedBox(height: 12),
      ElevatedButton.icon(
        onPressed: _pickImage,
        icon: const Icon(Icons.folder_open),
        label: const Text('Выбрать изображение'),
      ),
    ],
  );
}
    Widget _buildTextEditor() {
      return TextField(
        onChanged: (v) => _textContent = v,
        controller: TextEditingController(text: _textContent),
        maxLines: 5,
        style: const TextStyle(color: Colors.white),
        decoration: const InputDecoration(
          labelText: 'Текстовое содержимое',
          labelStyle: TextStyle(color: Colors.white70),
          filled: true,
          fillColor: Color(0xFF1E1E1E),
          border: OutlineInputBorder(),
        ),
      );
    }

    Widget _buildUrlEditor() {
      return Column(
        children: [
          TextField(
            onChanged: (v) => _url = v,
            controller: TextEditingController(text: _url),
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: 'URL адрес',
              labelStyle: TextStyle(color: Colors.white70),
              filled: true,
              fillColor: Color(0xFF1E1E1E),
              border: OutlineInputBorder(),
            ),
          ),
        ],
      );
    }

    Widget _buildFileEditor() {
      return Column(
        children: [
          TextField(
            onChanged: (v) => _filePath = v,
            controller: TextEditingController(text: _filePath),
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: 'Путь к файлу',
              labelStyle: TextStyle(color: Colors.white70),
              filled: true,
              fillColor: Color(0xFF1E1E1E),
              border: OutlineInputBorder(),
            ),
          ),
          const SizedBox(height: 8),
          ElevatedButton.icon(
            onPressed: _pickFile,
            icon: const Icon(Icons.folder_open),
            label: const Text('Выбрать файл'),
          ),
        ],
      );
    }

    Widget _buildMacroEditor() {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: const Color(0xFF1E1E1E),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.white24),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    const Text(
                      'Действия макроса:',
                      style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold),
                    ),
                    const Spacer(),
                    if (_macro != null)
                      SizedBox(
                        width: 80,
                        child: TextField(
                          keyboardType: TextInputType.number,
                          decoration: const InputDecoration(
                            labelText: 'Loop',
                            labelStyle: TextStyle(color: Colors.white70, fontSize: 12),
                            filled: true,
                            fillColor: Color(0xFF2A2A2A),
                            contentPadding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          ),
                          style: const TextStyle(color: Colors.white, fontSize: 12),
                          onChanged: (value) {
                            final amount = int.tryParse(value) ?? 1;
                            setState(() => _macro!.loopAmount = amount.clamp(1, 100));
                          },
                          controller: TextEditingController(text: _macro?.loopAmount.toString() ?? '1'),
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 8),
                SizedBox(
                  height: 100,
                  child: GridView.builder(
                    gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 5,
                      crossAxisSpacing: 4,
                      mainAxisSpacing: 4,
                      childAspectRatio: 1.0,
                    ),
                    itemCount: (_macro?.actions.length ?? 0) + 1,
                    itemBuilder: (context, index) {
                      if (index == (_macro?.actions.length ?? 0)) {
                        return Tooltip(
                          message: 'Добавить действие',
                          child: GestureDetector(
                            onTap: _addMacroAction,
                            child: Container(
                              decoration: BoxDecoration(
                                color: Colors.green.withOpacity(0.3),
                                borderRadius: BorderRadius.circular(4),
                                border: Border.all(color: Colors.green),
                              ),
                              child: const Icon(Icons.add, color: Colors.green, size: 20),
                            ),
                          ),
                        );
                      }
                      final action = _macro!.actions[index];
                      return Tooltip(
                        message: action.toScript(),
                        child: GestureDetector(
                          onTap: () => _editMacroAction(index),
                          child: Container(
                            width: 45,
                            height: 45,
                            decoration: BoxDecoration(
                              color: Colors.blue.withOpacity(0.3),
                              borderRadius: BorderRadius.circular(4),
                              border: Border.all(color: Colors.blue),
                            ),
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                Icon(action.icon, size: 20, color: Colors.white),
                                const SizedBox(height: 2),
                                Text(
                                  action.displayName.length > 4 
                                      ? '${action.displayName.substring(0, 4)}..' 
                                      : action.displayName,
                                  style: const TextStyle(color: Colors.white, fontSize: 8),
                                  textAlign: TextAlign.center,
                                  maxLines: 2,
                                ),
                              ],
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        ],
      );
    }

    void _editMacroAction(int index) {
      showDialog(
        context: context,
        barrierColor: Colors.black54,
        builder: (context) => MacroActionDialog(
          existingAction: _macro!.actions[index],
          onAdd: (action) {
            setState(() => _macro!.actions[index] = action);
            Navigator.pop(context);
          },
        ),
      );
    }

    Widget _buildActionSelector() {
      final availableActions = _getAvailableActions();
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Действия:', style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold)),
          const SizedBox(height: 8),
          Wrap(
            spacing: 4,
            runSpacing: 4,
            children: availableActions.map((action) {
              final selected = _actions.contains(action);
              return Tooltip(
                message: _getActionName(action),
                child: FilterChip(
                  label: Icon(_getActionIcon(action), size: 20),
                  selected: selected,
                  onSelected: (v) => setState(() {
                    if (v) _actions.add(action); else _actions.remove(action);
                  }),
                  backgroundColor: const Color(0xFF1E1E1E),
                  selectedColor: Colors.blue,
                  checkmarkColor: Colors.white,
                ),
              );
            }).toList(),
          ),
        ],
      );
    }

    String _getActionName(KeyAction action) {
      switch (action) {
        case KeyAction.copyToClipboard: return 'Копировать в буфер';
        case KeyAction.pasteToForeground: return 'Вставить в приложение';
        case KeyAction.open: return 'Открыть';
        case KeyAction.openInExplorer: return 'Открыть в проводнике';
        case KeyAction.run: return 'Запустить';
      }
    }

    IconData _getActionIcon(KeyAction action) {
      switch (action) {
        case KeyAction.copyToClipboard: return Icons.content_copy;
        case KeyAction.pasteToForeground: return Icons.content_paste;
        case KeyAction.open: return Icons.open_in_new;
        case KeyAction.openInExplorer: return Icons.folder_open;
        case KeyAction.run: return Icons.play_arrow;
      }
    }

   List<KeyAction> _getAvailableActions() {
  switch (_type) {
    case KeyContentType.image: return [KeyAction.copyToClipboard, KeyAction.pasteToForeground, KeyAction.open];
    case KeyContentType.text: return [KeyAction.copyToClipboard, KeyAction.pasteToForeground];
    case KeyContentType.url: return [KeyAction.copyToClipboard, KeyAction.pasteToForeground, KeyAction.open];
    case KeyContentType.windowsShortcut: return [KeyAction.open, KeyAction.openInExplorer, KeyAction.run];
    case KeyContentType.macros: return [KeyAction.run];
    case KeyContentType.clipboard: return [KeyAction.copyToClipboard, KeyAction.pasteToForeground];
  }
}
Widget _buildButtons() {
  return Align(
    alignment: Alignment.bottomCenter,
    child: Container(
      padding: const EdgeInsets.only(top: 16),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Кнопки действий - выровнены по левому краю
          Wrap(
            spacing: 4,
            runSpacing: 4,
            children: _getAvailableActions().map((action) {
              final selected = _actions.contains(action);
              return Tooltip(
                message: _getActionName(action),
                child: FilterChip(
                  label: Icon(_getActionIcon(action), size: 14),
                  selected: selected,
                  onSelected: (v) => setState(() {
                    if (v) _actions.add(action); else _actions.remove(action);
                  }),
                  backgroundColor: const Color(0xFF1E1E1E),
                  selectedColor: Colors.blue,
                  checkmarkColor: Colors.white,
                  labelStyle: const TextStyle(fontSize: 10),
                  padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 0),
                  visualDensity: VisualDensity.compact,
                ),
              );
            }).toList(),
          ),

          // Кнопки управления - выровнены по правому краю
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (widget.onDelete != null)
                Tooltip(
                  message: 'Удалить',
                  child: Container(
                    width: 28,
                    height: 28,
                    decoration: BoxDecoration(
                      color: Colors.red,
                      borderRadius: BorderRadius.circular(14),
                    ),
                    child: IconButton(
                      onPressed: widget.onDelete,
                      icon: const Icon(Icons.delete, size: 14),
                      color: Colors.white,
                      padding: EdgeInsets.zero,
                    ),
                  ),
                ),
              const SizedBox(width: 6),
              Tooltip(
                message: 'Отмена',
                child: Container(
                  width: 28,
                  height: 28,
                  decoration: BoxDecoration(
                    color: Colors.grey.withOpacity(0.7),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: IconButton(
                    onPressed: () => Navigator.pop(context),
                    icon: const Icon(Icons.close, size: 14),
                    color: Colors.white,
                    padding: EdgeInsets.zero,
                  ),
                ),
              ),
              const SizedBox(width: 6),
              Tooltip(
                message: 'Сохранить',
                child: Container(
                  width: 28,
                  height: 28,
                  decoration: BoxDecoration(
                    color: Colors.green,
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: IconButton(
                    onPressed: _save,
                    icon: const Icon(Icons.save, size: 14),
                    color: Colors.white,
                    padding: EdgeInsets.zero,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    ),
  );
}

    Future<void> _pickImage() async {
      final result = await FilePicker.platform.pickFiles(type: FileType.image, allowMultiple: false);
      if (result != null && result.files.single.path != null) {
        setState(() {
          _imagePath = result.files.single.path!;
          if (_nameCtrl.text.isEmpty) _nameCtrl.text = p.basenameWithoutExtension(result.files.single.name);
        });
      }
    }

    Future<void> _pickFile() async {
      final result = await FilePicker.platform.pickFiles(allowMultiple: false);
      if (result != null && result.files.single.path != null) {
        setState(() {
          _filePath = result.files.single.path!;
          if (_nameCtrl.text.isEmpty) _nameCtrl.text = p.basename(result.files.single.name);
        });
      }
    }

    void _addMacroAction() {
  // Создаем макрос если его нет
  if (_macro == null) {
    setState(() {
      _macro = Macro(actions: [], loopAmount: 1);
    });
  }
  
  showDialog(
    context: context,
    barrierColor: Colors.black54,
    builder: (context) => MacroActionDialog(
      onAdd: (action) {
        if (mounted) {
          setState(() {
            _macro!.actions.add(action);
          });
        }
      },
    ),
  );
}

    void _save() {
      final bind = KeyBind(
        key: widget.keyId,
        name: _nameCtrl.text.isEmpty ? 'Key ${widget.keyId}' : _nameCtrl.text,
        hint: _hintCtrl.text,
        description: _descCtrl.text,
        type: _type,
        imagePath: _imagePath,
        filePath: _filePath,
        textContent: _textContent,
        url: _url,
        macro: _macro,
        combination: '$_modifier+${widget.keyId}',
        actions: _actions.isEmpty ? [KeyAction.copyToClipboard] : _actions,
        icon: _selectedIcon,
      );
      widget.onSave(bind);
    }

    @override
    void dispose() {
      _nameCtrl.dispose();
      _hintCtrl.dispose();
      _descCtrl.dispose();
      super.dispose();
    }
  }

  // ==================== ДИАЛОГ РЕДАКТОРА МАКРОСОВ ====================
class MacroActionDialog extends StatefulWidget {
  final Function(MacroAction) onAdd;
  final MacroAction? existingAction;
  const MacroActionDialog({Key? key, required this.onAdd, this.existingAction}) : super(key: key);

  @override
  State<MacroActionDialog> createState() => _MacroActionDialogState();
}

class _MacroActionDialogState extends State<MacroActionDialog> {
  MacroActionType _type = MacroActionType.delay;
  final _valueCtrl = TextEditingController();
  int _delay = 1000;
  int _x = 100, _y = 100;
  
  // Переменные для записи хоткеев и кликов
  bool _isRecordingHotkey = false;
  bool _isRecordingClick = false;
  List<String> _currentHotkey = [];
  Timer? _hotkeyTimer;
  Timer? _mousePositionTimer;
  StreamSubscription<RawKeyEvent>? _keyboardSubscription;
  ({int x, int y}) _currentMousePosition = (x: 0, y: 0);

  @override
  void initState() {
    super.initState();
    if (widget.existingAction != null) {
      _type = widget.existingAction!.type;
      _valueCtrl.text = widget.existingAction!.value;
      _delay = widget.existingAction!.delay ?? 1000;
      _x = widget.existingAction!.x ?? 100;
      _y = widget.existingAction!.y ?? 100;
    }
  }

  @override
  void dispose() {
    _cleanupRecording();
    _valueCtrl.dispose();
    super.dispose();
  }



  Widget _buildTypeSpecificWidget() {
    switch (_type) {
      case MacroActionType.hotkey:
        return _buildHotkeyEditor();
      case MacroActionType.click:
        return _buildClickEditor();
      case MacroActionType.delay:
        return _buildDelayEditor();
      case MacroActionType.runPath:
        return _buildRunPathEditor();
    }
  }

  Widget _buildHotkeyEditor() {
    return Column(
      children: [
        TextField(
          controller: _valueCtrl,
          readOnly: true,
          style: const TextStyle(color: Colors.white),
          decoration: InputDecoration(
            labelText: _isRecordingHotkey ? 'Нажимайте клавиши...' : 'Сочетание клавиш',
            labelStyle: TextStyle(
              color: _isRecordingHotkey ? Colors.blue : Colors.white70,
            ),
            filled: true,
            fillColor: const Color(0xFF1E1E1E),
            border: const OutlineInputBorder(),
          ),
        ),
        const SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: ElevatedButton.icon(
                onPressed: _isRecordingHotkey ? _stopRecordingHotkey : _startRecordingHotkey,
                icon: Icon(_isRecordingHotkey ? Icons.stop : Icons.keyboard),
                label: Text(_isRecordingHotkey ? 'Остановить запись' : 'Начать запись'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: _isRecordingHotkey ? Colors.red : Colors.blue,
                ),
              ),
            ),
            const SizedBox(width: 8),
            IconButton(
              onPressed: _clearHotkey,
              icon: const Icon(Icons.clear),
              tooltip: 'Очистить',
            ),
          ],
        ),
        if (_currentHotkey.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              'Текущий хоткей: ${_currentHotkey.join(' + ')}',
              style: const TextStyle(color: Colors.green),
            ),
          ),
      ],
    );
  }

  Widget _buildClickEditor() {
    return Column(
      children: [
        Text(
          _isRecordingClick 
            ? 'Позиция курсора: (${_currentMousePosition.x}, ${_currentMousePosition.y})\nНажмите SPACE для записи'
            : 'Запись координат клика',
          style: TextStyle(
            color: _isRecordingClick ? Colors.blue : Colors.white70,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: ElevatedButton.icon(
                onPressed: _isRecordingClick ? _stopRecordingClick : _startRecordingClick,
                icon: Icon(_isRecordingClick ? Icons.stop : Icons.mouse),
                label: Text(_isRecordingClick ? 'Остановить запись' : 'Начать запись'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: _isRecordingClick ? Colors.red : Colors.blue,
                ),
              ),
            ),
            const SizedBox(width: 8),
            IconButton(
              onPressed: _clearClick,
              icon: const Icon(Icons.clear),
              tooltip: 'Очистить',
            ),
          ],
        ),
        if (_valueCtrl.text.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              _valueCtrl.text,
              style: const TextStyle(color: Colors.green),
            ),
          ),
      ],
    );
  }

  Widget _buildDelayEditor() {
    return Column(
      children: [
        Text('Задержка: ${_delay}ms', style: const TextStyle(color: Colors.white, fontSize: 16)),
        Slider(
          value: _delay.toDouble(),
          min: 0,
          max: 5000,
          divisions: 50,
          label: '${_delay}ms',
          onChanged: (v) => setState(() => _delay = v.round()),
          activeColor: Colors.blue,
        ),
      ],
    );
  }

  Widget _buildRunPathEditor() {
    return Column(
      children: [
        TextField(
          controller: _valueCtrl,
          style: const TextStyle(color: Colors.white),
          decoration: const InputDecoration(
            labelText: 'Путь к файлу или URL',
            labelStyle: TextStyle(color: Colors.white70),
            filled: true,
            fillColor: Color(0xFF1E1E1E),
            border: OutlineInputBorder(),
          ),
        ),
        const SizedBox(height: 8),
        ElevatedButton.icon(
          onPressed: _pickExecutable,
          icon: const Icon(Icons.folder_open),
          label: const Text('Выбрать файл'),
        ),
      ],
    );
  }
void _startRecordingHotkey() {
  _cleanupRecording();
  
  setState(() {
    _isRecordingHotkey = true;
    _currentHotkey.clear();
    _valueCtrl.clear();
  });

  // Вместо подписки используем RawKeyboard.addListener напрямую
  RawKeyboard.instance.addListener(_handleHotkeyRecording);
  _hotkeyTimer = Timer(const Duration(seconds: 10), _stopRecordingHotkey);
}

void _stopRecordingHotkey() {
  _hotkeyTimer?.cancel();
  RawKeyboard.instance.removeListener(_handleHotkeyRecording);

  if (_currentHotkey.isNotEmpty) {
    _valueCtrl.text = _currentHotkey.join('+');
  }

  setState(() {
    _isRecordingHotkey = false;
  });
}

void _handleHotkeyRecording(RawKeyEvent event) {
  if (!_isRecordingHotkey) return;
  
  if (event is RawKeyDownEvent) {
    final keyLabel = event.logicalKey.keyLabel;
    
    // Игнорируем системные клавиши
    if (_shouldIgnoreKey(keyLabel)) return;
    
    final keyName = _getKeyName(event.logicalKey);
    
    if (!_currentHotkey.contains(keyName)) {
      setState(() {
        _currentHotkey.add(keyName);
      });
    }
  }
}

void _cleanupRecording() {
  _hotkeyTimer?.cancel();
  _mousePositionTimer?.cancel();
  
  // Удаляем все слушатели
  RawKeyboard.instance.removeListener(_handleHotkeyRecording);
  RawKeyboard.instance.removeListener(_handleClickRecording);
}

  bool _shouldIgnoreKey(String keyLabel) {
    const ignoredKeys = ['Caps Lock', 'Num Lock', 'Scroll Lock'];
    return ignoredKeys.contains(keyLabel);
  }

  String _getKeyName(LogicalKeyboardKey key) {
    final keyLabel = key.keyLabel;
    
    if (key == LogicalKeyboardKey.controlLeft || key == LogicalKeyboardKey.controlRight) {
      return 'Ctrl';
    } else if (key == LogicalKeyboardKey.altLeft || key == LogicalKeyboardKey.altRight) {
      return 'Alt';
    } else if (key == LogicalKeyboardKey.shiftLeft || key == LogicalKeyboardKey.shiftRight) {
      return 'Shift';
    } else if (key == LogicalKeyboardKey.metaLeft || key == LogicalKeyboardKey.metaRight) {
      return 'Win';
    }
    
    if (keyLabel.length == 1 && keyLabel.toLowerCase() != keyLabel.toUpperCase()) {
      return keyLabel.toUpperCase();
    }
    
    return keyLabel;
  }

  void _clearHotkey() {
    setState(() {
      _currentHotkey.clear();
      _valueCtrl.clear();
    });
  }
void _startRecordingClick() {
  _cleanupRecording();
  
  setState(() {
    _isRecordingClick = true;
    _valueCtrl.clear();
  });

  final mouseService = NativeMouseService();
  mouseService.startMouseTracking();
  
  _mousePositionTimer = Timer.periodic(const Duration(milliseconds: 100), (timer) {
    final position = mouseService.getCursorPosition();
    if (mounted) {
      setState(() {
        _currentMousePosition = position;
      });
    }
  });

  // Используем addListener вместо подписки
  RawKeyboard.instance.addListener(_handleClickRecording);

  ScaffoldMessenger.of(context).showSnackBar(
    const SnackBar(
      content: Text('Наведите курсор и нажмите SPACE для записи позиции'),
      duration: Duration(seconds: 5),
    ),
  );
}

void _handleClickRecording(RawKeyEvent event) {
  if (!_isRecordingClick) return;
  
  if (event is RawKeyDownEvent && event.logicalKey == LogicalKeyboardKey.space) {
    _recordMousePosition();
  }
}

  void _recordMousePosition() {
    setState(() {
      _valueCtrl.text = '(${_currentMousePosition.x}, ${_currentMousePosition.y})';
      _x = _currentMousePosition.x;
      _y = _currentMousePosition.y;
    });
    
    _stopRecordingClick();
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Позиция записана: (${_currentMousePosition.x}, ${_currentMousePosition.y})'),
        duration: const Duration(seconds: 2),
      ),
    );
  }

  void _stopRecordingClick() {
    _mousePositionTimer?.cancel();
    _keyboardSubscription?.cancel();
    _keyboardSubscription = null;
    
    setState(() {
      _isRecordingClick = false;
    });
  }

  void _clearClick() {
    setState(() {
      _valueCtrl.clear();
    });
  }

  Future<void> _pickExecutable() async {
    final result = await FilePicker.platform.pickFiles(
      type: FileType.any,
      allowMultiple: false,
    );
    
    if (result != null && result.files.single.path != null) {
      setState(() {
        _valueCtrl.text = result.files.single.path!;
      });
    }
  }

  void _addAction() {
    MacroAction action;
    
    switch (_type) {
      case MacroActionType.hotkey:
        final hotkey = _currentHotkey.isNotEmpty ? _currentHotkey.join('+') : _valueCtrl.text;
        if (hotkey.isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Введите сочетание клавиш'))
          );
          return;
        }
        action = MacroAction(type: _type, value: hotkey);
        break;
        
      case MacroActionType.click:
        if (_valueCtrl.text.isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Запишите позицию клика'))
          );
          return;
        }
        action = MacroAction(
          type: _type, 
          value: 'click', 
          x: _x, 
          y: _y, 
          x1: _x, 
          y1: _y
        );
        break;
        
      case MacroActionType.delay:
        action = MacroAction(
          type: _type, 
          value: '${_delay}ms', 
          delay: _delay
        );
        break;
        
      case MacroActionType.runPath:
        if (_valueCtrl.text.isEmpty) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Введите путь или URL'))
          );
          return;
        }
        action = MacroAction(type: _type, value: _valueCtrl.text);
        break;
    }
    
    widget.onAdd(action);
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      backgroundColor: Colors.black.withOpacity(0.8),
      child: Container(
        width: 400,
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              widget.existingAction != null ? 'Редактировать действие' : 'Добавить действие макроса', 
              style: const TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold)
            ),
            const SizedBox(height: 20),
            DropdownButtonFormField<MacroActionType>(
              value: _type,
              items: MacroActionType.values.map((t) {
                return DropdownMenuItem(
                  value: t, 
                  child: Text(_getTypeName(t), style: const TextStyle(color: Colors.white))
                );
              }).toList(),
              onChanged: (v) {
                if (v != null) {
                  _cleanupRecording();
                  setState(() => _type = v);
                }
              },
              decoration: const InputDecoration(
                labelText: 'Тип действия',
                labelStyle: TextStyle(color: Colors.white70),
                filled: true,
                fillColor: Color(0xFF1E1E1E),
              ),
              dropdownColor: const Color(0xFF1E1E1E),
            ),
            const SizedBox(height: 16),
            _buildTypeSpecificWidget(),
            const SizedBox(height: 24),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Отмена'),
                    style: OutlinedButton.styleFrom(foregroundColor: Colors.white70),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _addAction,
                    child: Text(widget.existingAction != null ? 'Сохранить' : 'Добавить'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.green,
                      foregroundColor: Colors.white
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  String _getTypeName(MacroActionType type) {
    switch (type) {
      case MacroActionType.hotkey: return 'Горячая клавиша';
      case MacroActionType.click: return 'Клик мыши';
      case MacroActionType.delay: return 'Задержка';
      case MacroActionType.runPath: return 'Запуск программы/URL';
    }
  }
}







































class MusicBrainzService {
  static const String _baseUrl = 'https://musicbrainz.org/ws/2/';
  static const Map<String, String> _headers = {
    'User-Agent': 'MediaMetadataApp/1.0 ( your-email@example.com )',
    'Accept': 'application/json'
  };

  // Получение жанров трека по исполнителю и названию
  Future<List<String>> getTrackGenres(String artist, String title) async {
    try {
      print('MusicBrainz: Поиск жанров для "$artist" - "$title"');

      // 1. Сначала ищем запись (recording)
      final recordingId = await _findRecordingId(artist, title);
      if (recordingId == null) {
        print('MusicBrainz: Запись не найдена');
        return [];
      }

      // 2. Получаем теги/жанры для записи
      return await _getRecordingTags(recordingId);
    } catch (e) {
      print('MusicBrainz Ошибка: $e');
      return [];
    }
  }

  // Поиск ID записи по исполнителю и названию
  Future<String?> _findRecordingId(String artist, String title) async {
    final query = 'artist:"${_escapeQuery(artist)}" AND recording:"${_escapeQuery(title)}"';
    final url = '${_baseUrl}recording?query=${Uri.encodeQueryComponent(query)}&fmt=json&limit=5';

    try {
      final response = await http.get(Uri.parse(url), headers: _headers);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final recordings = data['recordings'] as List?;
        
        if (recordings != null && recordings.isNotEmpty) {
          // Берем первую наиболее релевантную запись
          final recording = recordings.first;
          return recording['id'] as String;
        }
      } else {
        print('MusicBrainz: HTTP ${response.statusCode}');
      }
    } catch (e) {
      print('MusicBrainz Ошибка поиска записи: $e');
    }
    
    return null;
  }

  // Получение тегов/жанров для записи
  Future<List<String>> _getRecordingTags(String recordingId) async {
    final url = '${_baseUrl}recording/$recordingId?fmt=json&inc=tags';

    try {
      final response = await http.get(Uri.parse(url), headers: _headers);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final tags = data['tags'] as List?;
        
        if (tags != null && tags.isNotEmpty) {
          final genreTags = tags.map<String>((tag) {
            return tag['name'] as String;
          }).toList();
          
          print('MusicBrainz: Найдены теги: $genreTags');
          return genreTags;
        }
      }
    } catch (e) {
      print('MusicBrainz Ошибка получения тегов: $e');
    }
    
    return [];
  }

  // Альтернативный метод: поиск жанров через исполнителя
  Future<List<String>> getArtistGenres(String artist) async {
    try {
      final query = 'artist:"${_escapeQuery(artist)}"';
      final url = '${_baseUrl}artist?query=${Uri.encodeQueryComponent(query)}&fmt=json&limit=1';

      final response = await http.get(Uri.parse(url), headers: _headers);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final artists = data['artists'] as List?;
        
        if (artists != null && artists.isNotEmpty) {
          final artistData = artists.first;
          final tags = artistData['tags'] as List?;
          
          if (tags != null && tags.isNotEmpty) {
            return tags.map<String>((tag) => tag['name'] as String).toList();
          }
        }
      }
    } catch (e) {
      print('MusicBrainz Ошибка поиска артиста: $e');
    }
    
    return [];
  }

  // Экранирование специальных символов в запросе
  String _escapeQuery(String text) {
    return text.replaceAll('"', '\\"').replaceAll("'", "\\'");
  }

  // Комбинированный метод: сначала трек, потом артист
  Future<String> getCombinedGenre(String artist, String title) async {
    // Пробуем найти жанры трека
    final trackGenres = await getTrackGenres(artist, title);
    if (trackGenres.isNotEmpty) {
      return trackGenres.first;
    }

    // Если не нашли, пробуем по артисту
    final artistGenres = await getArtistGenres(artist);
    if (artistGenres.isNotEmpty) {
      return artistGenres.first;
    }

    return 'unknown';
  }
}
































































Future<String> _getPageTitle(String url) async {
  try {
    // Простой способ - создаем HttpClient и игнорируем SSL ошибки
    HttpClient client = HttpClient();
    client.badCertificateCallback = (X509Certificate cert, String host, int port) => true;
    
    HttpClientRequest request = await client.getUrl(Uri.parse(url));
    HttpClientResponse response = await request.close();
    
    if (response.statusCode == HttpStatus.ok) {
      String html = await response.transform(utf8.decoder).join();
      
      debugPrint('Fetching title from: $url');
      debugPrint('HTML length: ${html.length}');
      
      // Упрощенное регулярное выражение для поиска title
      final titleRegex = RegExp(
        r'<title\s*>([\s\S]*?)</title>',
        caseSensitive: false,
      );
      
      final match = titleRegex.firstMatch(html);
      
      if (match != null) {
        String title = match.group(1)!;
        debugPrint('Raw title found: "$title"');
        
        // Очистка title
        title = title
            .replaceAll(RegExp(r'\s+'), ' ')
            .trim();
            
        AppLogger.writeLog('Cleaned title: "$title"');
        return title.isNotEmpty ? title : "none";
      } else {
        AppLogger.writeLog('Title tag not found');
        
        // Альтернативные варианты поиска title
        final alternativeRegexes = [
          RegExp(r'<meta\s+property="og:title"\s+content="([^"]*)"', caseSensitive: false),
          RegExp(r"<meta\s+property='og:title'\s+content='([^']*)'", caseSensitive: false),
          RegExp(r'<meta\s+name="twitter:title"\s+content="([^"]*)"', caseSensitive: false),
        ];
        
        for (final regex in alternativeRegexes) {
          final altMatch = regex.firstMatch(html);
          if (altMatch != null) {
            String altTitle = altMatch.group(1)!;
            AppLogger.writeLog('Found alternative title: "$altTitle"');

            return altTitle.trim();
          }
        }
      }
    } else {
      AppLogger.writeLog('HTTP error: ${response.statusCode}');
    }
    
    client.close();
  } catch (e) {
    AppLogger.writeLog('Error getting page title: $e');
  }
  return 'none';
}

void _writeToDebugLog1(String message) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final debugFile = File('${directory.path}/chat_debug1.log');
      await debugFile.writeAsString('${DateTime.now()}: $message\n', mode: FileMode.append);
      print('DEBUG: $message'); // Также выводим в консоль
    } catch (e) {
      print('Error writing to debug log: $e');
    }
  }
class AppLogger {
  static Future<void> writeLog(String message) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final logFile = File('${directory.path}/music_listener.log');
      final timestamp = DateTime.now().toString();
      final logMessage = '[$timestamp] $message\n';
      await logFile.writeAsString(logMessage, mode: FileMode.append);
      
      print('QUANTUM LOG: $message');
    } catch (e) {
      print('ERROR WRITING LOG: $e');
    }
  }
}
class ScreenAnalysis {
  static const MethodChannel _channel = MethodChannel('screenshot_channel');
  
  // Callback для получения результатов анализа
  static Function(String)? onAnalysisResult;
  
  static void initialize() {
    _channel.setMethodCallHandler(_handleMethodCall);
  }
  
  static Future<dynamic> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'onScreenAnalysisResult':
        final String result = call.arguments;
        if (onAnalysisResult != null) {
          onAnalysisResult!(result);
        }
        break;
      default:
        throw PlatformException(
          code: 'Unimplemented',
          message: 'Method ${call.method} not implemented',
        );
    }
  }
  
  static Future<bool> startAnalysis() async {
    try {
      final bool result = await _channel.invokeMethod('startScreenAnalysis');
      return result;
    } catch (e) {
      print('Failed to start analysis: $e');
      return false;
    }
  }
  
  static Future<bool> stopAnalysis() async {
    try {
      final bool result = await _channel.invokeMethod('stopScreenAnalysis');
      return result;
    } catch (e) {
      print('Failed to stop analysis: $e');
      return false;
    }
  }
}


class EssentialsApp extends StatelessWidget {
  const EssentialsApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        backgroundColor: Colors.transparent,
        body: EssentialsContent(),
      ),
    );
  }
}

class EssentialsContent extends StatefulWidget {
  const EssentialsContent({Key? key}) : super(key: key);

  @override
  _EssentialsContentState createState() => _EssentialsContentState();
}

class _EssentialsContentState extends State<EssentialsContent> {
   List<EssentialItem> _essentials = [];
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isLoading = true;
  final TextEditingController _searchController = TextEditingController();
  List<EssentialItem> _filteredEssentials = [];
  String? _backgroundImagePath;
  final Map<String, int> _hashtagFrequency = {};
  final Map<String, int> _emojiFrequency = {};
  final GlobalKey _essentialsListKey = GlobalKey();
final _searchFocusNode = FocusNode();
bool _isDragging = false;
int _draggedIndex = -1;
double _dragOffset = 0.0;
final ScrollController _scrollController = ScrollController();

final String _orderFileName = 'essentials_order.json';
double _lastDragPosition = 0.0;
double _dragStartY = 0.0;
double _dragStartLocalY = 0.0; // Позиция внутри виджета
Map<int, Rect> _widgetRects = {}; // Позиции и размеры виджетов
final Map<String, GlobalKey> _essentialKeys = {};

Future<void> _loadOrder() async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final orderFile = File('${directory.path}/essentials/$_orderFileName');
    
    if (orderFile.existsSync()) {
      final content = await orderFile.readAsString();
      final List<dynamic> orderList = json.decode(content);
      
      // Создаем карту для быстрого доступа к элементам по ID
      final Map<String, EssentialItem> itemsMap = {
        for (var item in _essentials) item.id: item
      };
      
      // Сортируем элементы согласно сохраненному порядку
      final List<EssentialItem> orderedItems = [];
      for (final id in orderList) {
        if (itemsMap.containsKey(id)) {
          orderedItems.add(itemsMap[id]!);
        }
      }
      
      // Добавляем элементы, которых нет в порядке (новые)
      for (final item in _essentials) {
        if (!orderList.contains(item.id)) {
          orderedItems.add(item);
        }
      }
      
      setState(() {
        _essentials = orderedItems;
      });
      _filterEssentials();
 
    }
  } catch (e) {
    print('Error loading order: $e');
  }
}
Future<void> _saveOrder() async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final essentialsDir = Directory('${directory.path}/essentials');
    
    if (!essentialsDir.existsSync()) {
      essentialsDir.createSync(recursive: true);
    }
    
    final orderFile = File('${essentialsDir.path}/$_orderFileName');
    final orderList = _essentials.map((item) => item.id).toList();
    
    print('Saving order: $orderList');
    
    await orderFile.writeAsString(json.encode(orderList));
  } catch (e) {
    print('Error saving order: $e');
  }
}

  @override
  void initState() {
    super.initState();
    _loadEssentials().then((_) {
    _loadOrder(); // Загружаем порядок после загрузки элементов
  });
    
    _startFileMonitoring();
    
    _searchController.addListener(_filterEssentials);
    _loadBackground();
  }

  void _filterEssentials() {
    final query = _searchController.text.trim().toLowerCase();
    
    if (query.isEmpty) {
      setState(() {
        _filteredEssentials = List.from(_essentials);
      });
      return;
    }

    final searchWords = query.split(' ').where((word) => word.isNotEmpty).toList();
    
    setState(() {
      _filteredEssentials = _essentials.where((item) {
        final searchText = '${item.icon ?? ''} ${item.name} ${item.comment ?? ''}'.toLowerCase();
        
        for (final word in searchWords) {
          if (!searchText.contains(word)) {
            return false;
          }
        }
        return true;
      }).toList();
    });
  }

  void _startFileMonitoring() {
    Timer.periodic(Duration(seconds: 12), (timer) async {
      if (!mounted) {
        timer.cancel();
        return;
      }
      
      await _checkForNewFiles();
    });
  }

  Future<void> _checkForNewFiles() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final essentialsDir = Directory('${directory.path}/essentials');
      
      if (!essentialsDir.existsSync()) return;
      
      final files = essentialsDir.listSync();
      final currentFilePaths = _essentials.map((e) => e.originalFilePath).whereType<String>().toSet();
      
      for (var file in files) {
        if (!currentFilePaths.contains(file.path) && !file.path.endsWith('.json')) {
          final newItem = EssentialItem.fromFile(file);
          setState(() {
            _essentials.add(newItem);
          });
          _filterEssentials();
        }
      }
    } catch (e) {
      print('Error monitoring files: $e');
    }
  }

  void _addNewEssential() {
    final newItem = EssentialItem(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: 'Новый элемент',
      icon: '📝',
      backgroundColor: Colors.blue.value,
      textColor: Colors.white.value,
    );
    
    _showEditDialog(newItem, isNewItem: true);
    
    setState(() {
      _essentials.add(newItem);
    });
    _saveEssential(newItem);
    _saveOrder();
  }

  Future<void> _loadEssentials() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final essentialsDir = Directory('${directory.path}/essentials');
      
      if (!essentialsDir.existsSync()) {
        essentialsDir.createSync(recursive: true);
      }
      
      final files = essentialsDir.listSync();
      final List<EssentialItem> loadedItems = [];
      
      for (var file in files) {
        if (file.path.endsWith('.json')) {
          try {
            final content = await File(file.path).readAsString();
            final jsonData = json.decode(content);
            loadedItems.add(EssentialItem.fromJson(jsonData));
          } catch (e) {
            print('Error loading essential: $e');
          }
        } else {
          loadedItems.add(EssentialItem.fromFile(file));
        }
      }
      
      if (mounted) {
        setState(() {
          _essentials.addAll(loadedItems);
          _isLoading = false;
          _updateHashtagFrequency();
          _updateEmojiFrequency();
        });
      }
    } catch (e) {
      print('Error loading essentials: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  void _updateHashtagFrequency() {
    _hashtagFrequency.clear();
    for (final item in _essentials) {
      if (item.comment != null) {
        final hashtags = RegExp(r'#\w+').allMatches(item.comment!);
        for (final match in hashtags) {
          final hashtag = match.group(0)!;
          _hashtagFrequency[hashtag] = (_hashtagFrequency[hashtag] ?? 0) + 1;
        }
      }
    }
  }

  void _updateEmojiFrequency() {
    _emojiFrequency.clear();
    for (final item in _essentials) {
      _emojiFrequency[item.icon] = (_emojiFrequency[item.icon] ?? 0) + 1;
    }
  }

Future<void> _saveEssential(EssentialItem item) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final essentialsDir = Directory('${directory.path}/essentials');
    
    if (!essentialsDir.existsSync()) {
      essentialsDir.createSync(recursive: true);
    }
    
    final file = File('${essentialsDir.path}/${item.id}.json');
    await file.writeAsString(json.encode(item.toJson()));
    
    // Обновляем состояние для мгновенного отображения изменений
    if (mounted) {
      setState(() {
        final index = _essentials.indexWhere((e) => e.id == item.id);
        if (index != -1) {
          _essentials[index] = item;
          _filterEssentials();
        }
      });
    }
    
    _updateHashtagFrequency();
    _updateEmojiFrequency();
  } catch (e) {
    print('Error saving essential: $e');
  }
}

  Future<void> _deleteEssential(EssentialItem item) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final essentialsDir = Directory('${directory.path}/essentials');
      
      final jsonFile = File('${essentialsDir.path}/${item.id}.json');
      if (jsonFile.existsSync()) {
        jsonFile.deleteSync();
      }
      
     
      
      setState(() {
        _essentials.remove(item);
      });
      
      _updateHashtagFrequency();
      _updateEmojiFrequency();
      _saveOrder();
    } catch (e) {
      print('Error deleting essential: $e');
    }
  }

  void _showEditDialog(EssentialItem item, {bool isNewItem = false}) {
    final sourceWidgetKey = GlobalKey();
    
    showDialog(
      context: context,
      builder: (context) => EssentialEditDialog(
        item: item,
        onSave: (updatedItem) {
          setState(() {
            final index = _essentials.indexOf(item);
            _essentials[index] = updatedItem;
          });
          _saveEssential(updatedItem);
        },
        onDelete: () => _showDeleteConfirmation(item),
        isNewItem: isNewItem,
        sourceWidgetKey: sourceWidgetKey,
      ),
    );
  }

  void _showDeleteConfirmation(EssentialItem item) {
    showDialog(
      context: context,
      builder: (context) => DeleteConfirmationDialog(
        item: item,
        onDelete: () => _deleteEssential(item),
      ),
    );
  }

  void _copyToClipboard(String text) {
    final textToCopy = text.contains(':') ? text.split(':').sublist(1).join(':').trim() : text;
    Clipboard.setData(ClipboardData(text: textToCopy));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Скопировано: $textToCopy'),
        backgroundColor: Colors.green,
      ),
    );
  }

  Future<void> _loadBackground() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final backgroundFile = File('${directory.path}/essentials_background.jpg');
      if (backgroundFile.existsSync()) {
        setState(() {
          _backgroundImagePath = backgroundFile.path;
        });
      }
    } catch (e) {
      print('Error loading background: $e');
    }
  }

  Future<void> _saveBackground(String imagePath) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final backgroundFile = File('${directory.path}/essentials_background.jpg');
      final originalFile = File(imagePath);
      await originalFile.copy(backgroundFile.path);
      setState(() {
        _backgroundImagePath = backgroundFile.path;
      });
    } catch (e) {
      print('Error saving background: $e');
    }
  }

  void _handleFileDrop(List<File> files) {
    if (files.isNotEmpty) {
      final file = files.first;
      final newItem = EssentialItem.fromFile(file);
      setState(() {
        _essentials.add(newItem);
      });
      _saveEssential(newItem);
    }
  }

  void _handleBackgroundDrop(List<File> files) {
    if (files.isNotEmpty) {
      _saveBackground(files.first.path);
    }
  }
void _updateMainListOrder() {
  // Создаем карту для быстрого доступа к элементам по ID
  final Map<String, EssentialItem> itemsMap = {
    for (var item in _essentials) item.id: item
  };

  // Создаем новый упорядоченный список на основе отфильтрованного
  final List<EssentialItem> newOrderedEssentials = [];

  for (final filteredItem in _filteredEssentials) {
    if (itemsMap.containsKey(filteredItem.id)) {
      newOrderedEssentials.add(itemsMap[filteredItem.id]!);
    }
  }

  // Добавляем элементы, которых нет в отфильтрованном списке
  for (final item in _essentials) {
    if (!_filteredEssentials.any((filteredItem) => filteredItem.id == item.id)) {
      newOrderedEssentials.add(item);
    }
  }

  setState(() {
    _essentials = newOrderedEssentials;
  });
}
void _reorderItems(int oldIndex, int newIndex) {
  if (oldIndex == newIndex) return;

  print('REORDER: Moving from $oldIndex to $newIndex');

  setState(() {
    final item = _filteredEssentials.removeAt(oldIndex);
    
    // Корректируем newIndex если нужно
    final adjustedNewIndex = newIndex > oldIndex ? newIndex - 1 : newIndex;
    _filteredEssentials.insert(adjustedNewIndex, item);

    _updateMainListOrder();
  });

  _saveOrder();
}
void _addHashtagToSearch(String hashtag) {
  final currentText = _searchController.text;
  
  // Если хэштег уже есть в тексте - удаляем его
  if (currentText.contains(hashtag)) {
    // Удаляем хэштег из текста
    final newText = currentText
        .replaceAll('$hashtag ', '') // Удаляем с пробелом после
        .replaceAll(' $hashtag', '') // Удаляем с пробелом перед
        .replaceAll(hashtag, '')     // Удаляем без пробелов
        .trim();                     // Убираем лишние пробелы
    
    _searchController.text = newText;
    _searchFocusNode.requestFocus();
    return; // Закрываем функцию
  }
  
  // Если хэштега нет - добавляем его
  final newText = currentText.isEmpty ? hashtag : '$currentText $hashtag';
  _searchController.text = newText;
}

  void _addEmojiToSearch(String emoji) {
    final currentText = _searchController.text;
    if (currentText.contains(emoji)) {
    // Удаляем хэштег из текста
    final newText = currentText
        .replaceAll('$emoji ', '') // Удаляем с пробелом после
        .replaceAll(' $emoji', '') // Удаляем с пробелом перед
        .replaceAll(emoji, '')     // Удаляем без пробелов
        .trim();                     // Убираем лишние пробелы
    
    _searchController.text = newText;
    return; // Закрываем функцию
  }
  
    final newText = currentText.isEmpty ? emoji : '$currentText $emoji';
    _searchController.text = newText;
    _searchFocusNode.requestFocus();
  }

 @override
Widget build(BuildContext context) {
  return Material(
    color: Colors.transparent,
    child: Stack(
      children: [
        // Background with pattern
        if (_backgroundImagePath != null)
          _buildBackgroundPattern(),
        
        // Main content
        Container(
          width: 400,
          height: MediaQuery.of(context).size.height,
          margin: EdgeInsets.only(right: 0),
          decoration: BoxDecoration(
            color: Color(0xFF2B2B2B).withOpacity(0.95),
            borderRadius: BorderRadius.only(
              topLeft: Radius.circular(12),
              bottomLeft: Radius.circular(12),
            ),
          ),
          child: Column(
            children: [
              // Header with DropTarget
              DropTarget(
                onDragDone: (detail) async {
                  final files = <File>[];
                  
                  try {
                    final processedPaths = <String>{};
                    
                    for (final item in detail.files) {
                      final path = item.path;
                      
                      if (path != null && path.isNotEmpty && !processedPaths.contains(path)) {
                        processedPaths.add(path);
                        
                        final file = File(path);
                        if (await file.exists()) {
                          files.add(file);
                          break; // Берем только первый файл
                        }
                      }
                    }
                  } catch (e) {
                    print('Error in header drop: $e');
                  }
                  
                  if (files.isNotEmpty) {
                    _handleBackgroundDrop(files);
                    if (mounted) {
                      setState(() {});
                    }
                    files.clear();
                  }
                },
                child: Container(
                  height: 40,
                  padding: EdgeInsets.symmetric(horizontal: 16),
                  decoration: BoxDecoration(
                    color: Color(0xFF1A1A1A).withOpacity(0.9),
                    borderRadius: BorderRadius.only(
                      topLeft: Radius.circular(12),
                    ),
                  ),
                  child: Row(
                    children: [
                      Text(
                        'Essentials',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Spacer(),
                      MouseRegion(
                        cursor: SystemMouseCursors.click,
                        child: GestureDetector(
                          onTap: () => windowManager.close(),
                          child: Icon(Icons.close, size: 20, color: Colors.white),
                        ),
                      ),
                    ],
                  ),
                ),
              ),

              // Search row
              Container(
                padding: EdgeInsets.all(12),
                color: Color(0xFF1A1A1A).withOpacity(0.7),
                child: Column(
                  children: [
                    TextField(
                      controller: _searchController,
                      focusNode: _searchFocusNode, 
                      style: TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        hintText: 'Поиск...',
                        hintStyle: TextStyle(color: Colors.white54),
                        prefixIcon: Icon(Icons.search, color: Colors.white54),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(20),
                          borderSide: BorderSide.none,
                        ),
                        filled: true,
                        fillColor: Color(0xFF2B2B2B).withOpacity(0.8),
                        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                      ),
                    ),
                    
                    // Hashtags suggestions
                    if ( _searchFocusNode.hasFocus && _hashtagFrequency.isNotEmpty)
                      _buildHashtagSuggestions(),
                    
                    // Emoji suggestions
                    if ( _searchFocusNode.hasFocus && _emojiFrequency.isNotEmpty)
                      _buildEmojiSuggestions(),
                  ],
                ),
              ),

              // Essentials list with DropTarget
              Expanded(
                child: DropTarget(
                  onDragDone: (detail) async {
                    final files = <File>[];
                    
                    try {
                      final processedPaths = <String>{};
                      
                      for (final item in detail.files) {
                        final path = item.path;
                        
                        if (path != null && path.isNotEmpty && !processedPaths.contains(path)) {
                          processedPaths.add(path);
                          
                          final file = File(path);
                          if (await file.exists()) {
                            files.add(file);
                            break; // Берем только первый файл
                          }
                        }
                      }
                    } catch (e) {
                      print('Error in essentials drop: $e');
                    }
                    
                    if (files.isNotEmpty) {
                      _handleFileDrop(files);
                      if (mounted) {
                        setState(() {});
                      }
                      files.clear();
                    }
                  },
                  child: _isLoading
                      ? Center(child: CircularProgressIndicator(color: Colors.white))
                      : _filteredEssentials.isEmpty
                          ? Center(
                              child: Container(
                                padding: EdgeInsets.all(16),
                                decoration: BoxDecoration(
                                  color: Color(0xFF2B2B2B).withOpacity(0.8),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: Text(
                                  _searchController.text.isEmpty ? 'Нет элементов' : 'Ничего не найдено',
                                  style: TextStyle(color: Colors.white54),
                                ),
                              ),
                            )
                          : _buildReorderableList(),
                ),
              ),

              // Add new Essential button
              Container(
                margin: EdgeInsets.all(16),
                child: MouseRegion(
                  cursor: SystemMouseCursors.click,
                  child: GestureDetector(
                    onTap: _addNewEssential,
                    child: Container(
                      padding: EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.blue.withOpacity(0.8),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.add, color: Colors.white, size: 16),
                          SizedBox(width: 8),
                          Text(
                            'Добавить Essential',
                            style: TextStyle(color: Colors.white),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),

        // Drag and drop areas for background
        Positioned.fill(
          child: IgnorePointer(
            ignoring: true,
            child: Row(
              children: [
                // Left drop zone
                Expanded(
                  flex: 1,
                  child: Container(
                    color: Colors.transparent,
                  ),
                ),
                
                // Center content area (protected)
                Container(
                  width: 400,
                  color: Colors.transparent,
                ),
                
                // Right drop zone
                Expanded(
                  flex: 1,
                  child: Container(
                    color: Colors.transparent,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    ),
  );
}

  Widget _buildBackgroundPattern() {
    return Positioned.fill(
      child: Image.file(
        File(_backgroundImagePath!),
        fit: BoxFit.cover,
        alignment: Alignment.center,
        repeat: ImageRepeat.repeat,
      ),
    );
  }

  Widget _buildHashtagSuggestions() {
  final sortedHashtags = _hashtagFrequency.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value))
    ..take(10);

  return Container(
    margin: EdgeInsets.only(top: 8),
    padding: EdgeInsets.all(8),
    decoration: BoxDecoration(
      color: Color(0xFF1A1A1A).withOpacity(0.9),
      borderRadius: BorderRadius.circular(12),
    ),
    child: Wrap(
      spacing: 8, // горизонтальный отступ между элементами
      runSpacing: 8, // вертикальный отступ между строками
      children: sortedHashtags.map((entry) {
        return Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(8),
            onTap: () => _addHashtagToSearch(entry.key),
            child: Container(
              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 12),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.white30),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                entry.key,
                style: TextStyle(
                  color: Colors.white70,
                  fontSize: 14,
                ),
              ),
            ),
          ),
        );
      }).toList(),
    ),
  );
}

Widget _buildEmojiSuggestions() {
  final sortedEmojis = _emojiFrequency.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value))
    ..take(15);

  return Container(
    height: 50,
    margin: EdgeInsets.only(top: 8),
    decoration: BoxDecoration(
      color: Color(0xFF1A1A1A).withOpacity(0.9),
      borderRadius: BorderRadius.circular(12),
    ),
    child: ListView.builder(
      scrollDirection: Axis.horizontal,
      itemCount: sortedEmojis.length,
      itemBuilder: (context, index) {
        final entry = sortedEmojis[index];
        return Container(
          width: 45,
          height: 45,
          margin: EdgeInsets.all(2.5),
          child: GestureDetector(
            onTap: () => _addEmojiToSearch(entry.key),
            child: Text(
              entry.key,
              style: TextStyle(fontSize: 20),
              textAlign: TextAlign.center,
            ),
          ),
        );
      },
    ),
  );
}
void _collectWidgetRects() {
  _widgetRects.clear();
  
  final listRenderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
  if (listRenderBox == null) return;

  final listPosition = listRenderBox.localToGlobal(Offset.zero);
  
  for (int i = 0; i < _filteredEssentials.length; i++) {
    try {
      // Находим элемент виджета по индексу
      final widgetElement = _findWidgetByIndex(i);
      if (widgetElement == null) continue;
      
      final widgetRenderBox = widgetElement.findRenderObject() as RenderBox?;
      if (widgetRenderBox != null) {
        final widgetPosition = widgetRenderBox.localToGlobal(Offset.zero);
        final relativeY = widgetPosition.dy - listPosition.dy + _scrollController.offset;
        
        _widgetRects[i] = Rect.fromLTWH(
          0, 
          relativeY, 
          widgetRenderBox.size.width, 
          widgetRenderBox.size.height
        );
        
        print('Widget $i: Y=$relativeY, height=${widgetRenderBox.size.height}');
      }
    } catch (e) {
      print('Error collecting rect for widget $i: $e');
    }
  }
}
void _handleDragUpdate(DragUpdateDetails details, int draggedIndex) {
  if (!_isDragging) return;

  final renderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
  if (renderBox == null) return;

  final listPosition = renderBox.localToGlobal(Offset.zero);
  final mouseY = details.globalPosition.dy;

  // Вычисляем относительную позицию внутри списка
  final relativeY = mouseY - listPosition.dy;
  _lastDragPosition = relativeY;

  // Собираем позиции всех видимых виджетов
  // _collectWidgetRects();

  // Автопрокрутка при приближении к границам
  const scrollThreshold = 50.0;
  const scrollSpeed = 10.0;

  if (relativeY < scrollThreshold && _scrollController.offset > 0) {
    _scrollController.jumpTo(_scrollController.offset - scrollSpeed);
  } else if (relativeY > renderBox.size.height - scrollThreshold && 
             _scrollController.offset < _scrollController.position.maxScrollExtent) {
    _scrollController.jumpTo(_scrollController.offset + scrollSpeed);
  }
}


  void _handleDragStart(int index) {
    setState(() {
      _isDragging = true;
      _dragOffset = 0.0;
    });
  }



// Обновить функцию построения списка
Widget _buildReorderableList() {
  return Container(
    key: _essentialsListKey,
    child: ListView.builder(
      controller: _scrollController,
      padding: EdgeInsets.all(5), // Уменьшили padding
      itemCount: _filteredEssentials.length,
      itemBuilder: (context, index) {
        final item = _filteredEssentials[index];
        return _buildDraggableEssentialItem(
          item: item,
          index: index,
        );
      },
    ),
  );
}
void _handleDragUpdateWithCustomLogic(DragUpdateDetails details, int draggedIndex) {
  final renderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
  if (renderBox == null) return;

  final listPosition = renderBox.localToGlobal(Offset.zero);
  final mouseY = details.globalPosition.dy - listPosition.dy;

  // Автопрокрутка при приближении к границам
  const scrollThreshold = 150.0;
  const scrollSpeed = 20.0;

  if (mouseY < scrollThreshold && _scrollController.offset > 0) {
    _scrollController.jumpTo(_scrollController.offset - scrollSpeed);
  } else if (mouseY > renderBox.size.height - scrollThreshold && 
             _scrollController.offset < _scrollController.position.maxScrollExtent) {
    _scrollController.jumpTo(_scrollController.offset + scrollSpeed);
  }

  // Определяем новый индекс на основе позиции Y
  final itemHeight = 92.0; // Примерная высота элемента
  final newIndex = (mouseY / itemHeight).clamp(0, _essentials.length - 1).floor();

  if (newIndex != draggedIndex && newIndex >= 0 && newIndex < _essentials.length) {
    _reorderItems(draggedIndex, newIndex);
  }
}
void _handleDragEnd(int draggedIndex) {
  if (_lastDragPosition < 0) return;

  // Получаем реальную высоту перетаскиваемого виджета
  final double widgetHeight = _getWidgetHeight(draggedIndex);
  final double minDragDistance = widgetHeight * 0.3; // Уменьшили минимальное расстояние

  final double dragDistance = (_lastDragPosition - _dragStartLocalY).abs();
  
  print('Real widget height: $widgetHeight, drag distance: $dragDistance');

  if (dragDistance < minDragDistance) {
    print('Drag distance too small, returning to original position');
    setState(() {
      _isDragging = false;
      _draggedIndex = -1;
      _lastDragPosition = 0.0;
    });
    return;
  }

  // Собираем реальные позиции и размеры всех виджетов
  final Map<int, double> widgetHeights = {};
  final Map<int, double> widgetPositions = {};
  
  double currentY = 0;
  for (int i = 0; i < _filteredEssentials.length; i++) {
    final double height = _getWidgetHeight(i);
    widgetHeights[i] = height;
    widgetPositions[i] = currentY;
    currentY += height + 8; // + margin
  }

  // Вычисляем позицию с учетом прокрутки
  final double dropPosition = _lastDragPosition + _scrollController.offset;

  // Ищем между какими виджетами находится точка отпускания
  int newIndex = draggedIndex;
  
  for (int i = 0; i < _filteredEssentials.length; i++) {
    final double widgetTop = widgetPositions[i]!;
    final double widgetBottom = widgetTop + widgetHeights[i]!;
    final double widgetCenter = widgetTop + (widgetHeights[i]! / 2);

    if (i == draggedIndex) continue;

    // Проверяем попадает ли точка в зону виджета
    if (dropPosition >= widgetTop && dropPosition <= widgetBottom) {
      // Сравниваем с центром виджета
      if (dropPosition < widgetCenter) {
        newIndex = i; // Ставим ПЕРЕД этим виджетом
      } else {
        newIndex = i + 1; // Ставим ПОСЛЕ этого виджета
      }
      break;
    }
  }

  // Ограничиваем индекс
  newIndex = newIndex.clamp(0, _filteredEssentials.length - 1);

  print('Moving from $draggedIndex to $newIndex based on real positions');

  // Предотвращаем перемещение на то же место
  if (newIndex != draggedIndex) {
    _reorderItems(draggedIndex, newIndex);
  }

  setState(() {
    _isDragging = false;
    _draggedIndex = -1;
    _lastDragPosition = 0.0;
  });
}

Map<int, Rect> _getVisibleWidgetRects() {
  final Map<int, Rect> rects = {};
  
  final listRenderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
  if (listRenderBox == null) return rects;

  final listPosition = listRenderBox.localToGlobal(Offset.zero);
  final listTop = listPosition.dy;
  final listBottom = listTop + listRenderBox.size.height;

  for (int i = 0; i < _filteredEssentials.length; i++) {
    try {
      // Создаем GlobalKey для каждого виджета чтобы получить его позицию
      final key = GlobalKey();
      
      // Получаем контекст виджета (упрощенный способ)
      final widgetContext = _essentialsListKey.currentContext;
      if (widgetContext == null) continue;

      // Ищем все RenderBox в списке
      final widgetFinder = _findWidgetByIndex(i);
      if (widgetFinder != null) {
        final widgetRenderBox = widgetFinder.findRenderObject() as RenderBox?;
        if (widgetRenderBox != null) {
          final widgetPosition = widgetRenderBox.localToGlobal(Offset.zero);
          final widgetTop = widgetPosition.dy;
          final widgetBottom = widgetTop + widgetRenderBox.size.height;

          // Проверяем, виден ли виджет в области списка
          if (widgetBottom >= listTop && widgetTop <= listBottom) {
            final relativeTop = widgetTop - listTop + _scrollController.offset;
            rects[i] = Rect.fromLTWH(
              0, 
              relativeTop, 
              widgetRenderBox.size.width, 
              widgetRenderBox.size.height
            );
            
            print('Widget $i: top=$relativeTop, height=${widgetRenderBox.size.height}');
          }
        }
      }
    } catch (e) {
      print('Error getting rect for widget $i: $e');
    }
  }

  return rects;
}
Element? _findWidgetByIndex(int index) {
  try {
    final listContext = _essentialsListKey.currentContext;
    if (listContext == null) return null;

    Element? targetElement;
    int foundIndex = 0;
    
    void traverse(Element element) {
      if (targetElement != null) return;

      // Проверяем, является ли это Container с EssentialWidget
      final widget = element.widget;
      if (widget is Container) {
        if (widget.child is EssentialWidget) {
          if (foundIndex == index) {
            targetElement = element;
            return;
          }
          foundIndex++;
        }
      }

      element.visitChildren(traverse);
    }

    // Приводим BuildContext к Element и обходим
    (listContext as Element).visitChildren(traverse);
    return targetElement;
  } catch (e) {
    print('Error finding widget by index: $e');
    return null;
  }
}

double _getWidgetHeight(int index) {
  try {
    final item = _filteredEssentials[index];
    final widgetKey = _essentialKeys[item.id];
    if (widgetKey != null && widgetKey.currentContext != null) {
      final renderBox = widgetKey.currentContext!.findRenderObject() as RenderBox?;
      if (renderBox != null) {
        return renderBox.size.height;
      }
    }
  } catch (e) {
    print('Error getting widget height for index $index: $e');
  }
  
  // Fallback если не удалось получить реальный размер
  return 80.0; // Примерная высота по умолчанию
}
int _findPositionBetweenWidgets(double draggedCenter, Map<int, Rect> widgetRects, int draggedIndex) {
  if (widgetRects.isEmpty) return draggedIndex;

  // Сортируем виджеты по позиции
  final sortedEntries = widgetRects.entries.toList()
    ..sort((a, b) => a.value.top.compareTo(b.value.top));

  // Проверяем позицию перед первым виджетом
  final firstWidget = sortedEntries.first;
  if (draggedCenter < firstWidget.value.top) {
    return 0;
  }

  // Проверяем позицию после последнего виджета
  final lastWidget = sortedEntries.last;
  if (draggedCenter > lastWidget.value.bottom) {
    return _filteredEssentials.length - 1;
  }

  // Ищем между какими виджетами находится центр
  for (int i = 0; i < sortedEntries.length - 1; i++) {
    final currentWidget = sortedEntries[i];
    final nextWidget = sortedEntries[i + 1];

    // Проверяем, находится ли центр между текущим и следующим виджетом
    if (draggedCenter > currentWidget.value.bottom && 
        draggedCenter < nextWidget.value.top) {
      
      // Возвращаем индекс следующего виджета (ставим перед ним)
      return nextWidget.key;
    }
  }

  return draggedIndex; // Оставляем на месте если не нашли подходящую позицию
}

Widget _buildDraggableEssentialItem({
  required EssentialItem item,
  required int index,
}) {
  return LongPressDraggable<int>(
    data: index,
    feedback: Material(
      elevation: 8,
      borderRadius: BorderRadius.circular(16),
      child: Opacity(
        opacity: 0.8,
        child: Container(
          width: 360,
          child: _buildEssentialContent(item),
        ),
      ),
    ),
    childWhenDragging: Container(
      height: 76,
      margin: EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: Colors.grey.withOpacity(0.3),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white30, width: 2),
      ),
    ),
    onDragStarted: () {
  // Используем PostFrameCallback чтобы гарантировать что виджеты отрендерены
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final renderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
        if (renderBox != null) {
          final listPosition = renderBox.localToGlobal(Offset.zero);
          
          // Получаем позицию конкретного виджета
          final widgetElement = _findWidgetByIndex(index);
          if (widgetElement != null) {
            final widgetRenderBox = widgetElement.findRenderObject() as RenderBox?;
            if (widgetRenderBox != null) {
              final widgetPosition = widgetRenderBox.localToGlobal(Offset.zero);
              _dragStartY = widgetPosition.dy;
              _dragStartLocalY = widgetPosition.dy - listPosition.dy;
              
              print('Drag started at index $index, localY: $_dragStartLocalY');
            }
          }
        }
      });

      setState(() {
        _isDragging = true;
        _draggedIndex = index;
      });
    },
    onDragUpdate: (details) {
      _handleDragUpdate(details, index);
    },
    onDragEnd: (details) {
      _handleDragEnd(index);
    },
    child: _buildEssentialWidget(item, index),
  );
}



  Widget _buildEssentialContent(EssentialItem item) {
    return Container(
      width: 360, // Ширина контейнера
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Color(item.backgroundColor).withOpacity(0.9),
        borderRadius: BorderRadius.circular(16),
        image: item.backgroundImagePath != null
            ? DecorationImage(
                image: FileImage(File(item.backgroundImagePath!)),
                fit: BoxFit.cover,
                alignment: Alignment.center,
              )
            : null,
      ),
      child: _buildEssentialInfo(item),
    );
  }

  Widget _buildEssentialInfo(EssentialItem item) {
    final filePathDisplay = _getFilePathDisplay(item);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              item.icon,
              style: TextStyle(fontSize: 20),
            ),
            SizedBox(width: 8),
            Expanded(
              child: Text(
                item.name,
                style: TextStyle(
                  color: Color(item.textColor),
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
        
        if (filePathDisplay != null)
          Padding(
            padding: EdgeInsets.only(top: 4),
            child: Text(
              filePathDisplay,
              style: TextStyle(
                color: Color(item.textColor).withOpacity(0.6),
                fontSize: 10,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        
        if (item.comment != null && item.comment!.isNotEmpty)
          Padding(
            padding: EdgeInsets.only(top: 8),
            child: Text(
              item.comment!,
              style: TextStyle(
                color: Color(item.textColor).withOpacity(0.8),
                fontSize: 12,
              ),
              maxLines: 3,
              overflow: TextOverflow.ellipsis,
            ),
          ),
      ],
    );
  }
Widget _buildEssentialWidget(EssentialItem item, int index) {
  if (!_essentialKeys.containsKey(item.id)) {
    _essentialKeys[item.id] = GlobalKey();
  }
  
  return Container(
    key: _essentialKeys[item.id], // ← вот это важно
    margin: EdgeInsets.only(bottom: 8),
    child: EssentialWidget(
      key: Key(item.id),
      item: item,
      onTap: () => _copyToClipboard(item.name),
      
      onEdit: () => _showEditDialog(item),
      onDelete: () => _showDeleteConfirmation(item),
    ),
  );
}

  String? _getFilePathDisplay(EssentialItem item) {
    if (item.shortcutTarget != null) {
      return 'Ярлык: ${item.shortcutTarget}';
    } else if (item.filePath != null) {
      return 'Файл: ${item.filePath}';
    }
    return null;
  }


  @override
void dispose() {
  _searchFocusNode.dispose();
   _scrollController.dispose();
  super.dispose();
}
}
class EssentialWidget extends StatefulWidget {
  final EssentialItem item;
  final VoidCallback onTap;

  final VoidCallback onEdit;
  final VoidCallback onDelete;

  const EssentialWidget({
    Key? key,
    required this.item,
    required this.onTap,

    required this.onEdit,
    required this.onDelete,
  }) : super(key: key);

  @override
  _EssentialWidgetState createState() => _EssentialWidgetState();
}

class _EssentialWidgetState extends State<EssentialWidget> {
  bool _isHovered = false;
  Uint8List? _imagePreview;
  Uint8List? _appIcon;
  Uint8List? _favicon;
  Timer? _doubleTapTimer;
  bool _isWaitingDoubleTap = false;

  @override
  void initState() {
    super.initState();
    _loadImagePreview();
    _loadAppIcon();
    _loadFavicon();
  }

  @override
  void dispose() {
    _doubleTapTimer?.cancel();
    super.dispose();
  }

  void _handleTap() {
    if (_isWaitingDoubleTap) {
      // Это двойной клик
      _doubleTapTimer?.cancel();
      _isWaitingDoubleTap = false;
      _handleDoubleTap();
    } else {
      // Это одинарный клик - ждем возможный второй клик
      _isWaitingDoubleTap = true;
      _doubleTapTimer = Timer(Duration(milliseconds: 300), () {
        if (_isWaitingDoubleTap) {
          _isWaitingDoubleTap = false;
          _handleSingleTap();
        }
      });
    }
  }

  void _handleSingleTap() {
    final url = _extractUrlFromText(widget.item.name);
    if (url != null) {
      _launchUrl(url);
    } else if (widget.item.originalFilePath != null) {
      _openFile();
    } else {
      widget.onTap();
    }
  }

  void _handleDoubleTap() {
    final url = _extractUrlFromText(widget.item.name);
    if (url != null) {
      // Для URL открываем в Google
      _launchUrlInGoogle(url);
    } else if (widget.item.originalFilePath != null) {
      // Для файлов открываем расположение
      _openFileLocation();
    } else {
      // Для обычных элементов - копируем в буфер
      widget.onTap();
    }
  }

  Future<void> _openFileLocation() async {
    try {
      if (widget.item.originalFilePath != null) {
        final file = File(widget.item.originalFilePath!);
        final directory = file.parent;
        
        if (await directory.exists()) {
          final uri = Uri.file(directory.path);
          if (await canLaunchUrl(uri)) {
            await launchUrl(uri);
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Не удалось открыть расположение файла'),
                backgroundColor: Colors.orange,
              ),
            );
          }
        }
      }
    } catch (e) {
      print('Error opening file location: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Ошибка при открытии расположения файла'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  Future<void> _launchUrlInGoogle(String url) async {
    try {
      // Преобразуем URL для открытия в Google
      final googleUrl = 'https://www.google.com/search?q=${Uri.encodeComponent(url)}';
      final uri = Uri.parse(googleUrl);
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri);
      } else {
        // Если не получилось открыть в Google, открываем обычным способом
        await _launchUrl(url);
      }
    } catch (e) {
      print('Error launching URL in Google: $e');
      await _launchUrl(url);
    }
  }

  
  Widget _buildIcon() {
    final url = _extractUrlFromText(widget.item.name);
    
    if (_imagePreview != null) {
      return Container(
        width: 32,
        height: 32,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(4),
          image: DecorationImage(
            image: MemoryImage(_imagePreview!),
            fit: BoxFit.cover,
          ),
        ),
      );
    } else if (_appIcon != null) {
      return Image.memory(_appIcon!, width: 32, height: 32);
    } else if (_favicon != null) {
      return Image.memory(_favicon!, width: 32, height: 32);
    } else if (url != null) {
      return Icon(Icons.public, color: Color(widget.item.textColor), size: 20);
    } else {
      return Text(
        widget.item.icon,
        style: TextStyle(fontSize: 20),
      );
    }
  }

  String? _getFilePathDisplay() {
  if (widget.item.shortcutTarget != null) {
    return 'Ярлык: ${widget.item.shortcutTarget}';
  } else if (widget.item.filePath != null) {
    return 'Файл: ${widget.item.filePath}';
  } else if (widget.item.originalFilePath != null) {
    return 'Расположение: ${widget.item.originalFilePath}';
  }
  return null;
}
  Future<void> _openFile() async {
    try {
      final file = File(widget.item.originalFilePath!);
      if (await file.exists()) {
        final uri = Uri.file(widget.item.originalFilePath!);
        if (Platform.isWindows) {
        await Process.run('start', ['""', widget.item.originalFilePath!], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', [widget.item.originalFilePath!]);
      } else {
        await Process.run('xdg-open', [widget.item.originalFilePath!]);
      }
      }
    } catch (e) {
      print('Error opening file: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Ошибка при открытии файла'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }


    String? _extractUrlFromText(String text) {
    try {
      final uri = Uri.parse(text);
      if (uri.scheme == 'http' || uri.scheme == 'https') {
        return text;
      }
      
      if (text.toLowerCase().contains('http') && text.contains('://')) {
        final start = text.indexOf('http');
        final end = text.indexOf(' ', start);
        if (end == -1) return text.substring(start);
        return text.substring(start, end);
      }
      
      return null;
    } catch (_) {
      return null;
    }
  }

  bool _isImageFile(String path) {
    final ext = path.toLowerCase().split('.').last;
    return ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].contains(ext);
  }

  bool _isWebUrl(String text) {
    try {
      final uri = Uri.parse(text);
      return uri.scheme == 'http' || uri.scheme == 'https';
    } catch (_) {
      return false;
    }
  }
    Future<void> _loadImagePreview() async {
    if (widget.item.originalFilePath != null && 
        _isImageFile(widget.item.originalFilePath!)) {
      try {
        final file = File(widget.item.originalFilePath!);
        final bytes = await file.readAsBytes();
        if (mounted) {
          setState(() {
            _imagePreview = bytes;
          });
        }
      } catch (e) {
        print('Error loading image preview: $e');
      }
    }
  }

  Future<void> _loadAppIcon() async {
    if (widget.item.originalFilePath != null && 
        widget.item.originalFilePath!.toLowerCase().endsWith('.exe')) {
      try {
        // В реальном приложении используйте MethodChannel для извлечения иконки EXE
        // Это упрощенная заглушка
        final iconBytes = await _extractExeIcon(widget.item.originalFilePath!);
        if (mounted && iconBytes != null) {
          setState(() {
            _appIcon = iconBytes;
          });
        }
      } catch (e) {
        print('Error loading app icon: $e');
      }
    }
  }

  Future<void> _loadFavicon() async {
    final url = _extractUrlFromText(widget.item.name);
    if (url != null) {
      try {
        final faviconBytes = await _downloadFavicon(url);
        if (mounted && faviconBytes != null) {
          setState(() {
            _favicon = faviconBytes;
          });
        }
      } catch (e) {
        print('Error loading favicon: $e');
      }
    }
  }

  Future<Uint8List?> _extractExeIcon(String exePath) async {
    // Заглушка для извлечения иконки EXE
    // В реальном приложении используйте platform channels для вызова WinAPI
    try {
      // Возвращаем заглушку - зеленый квадрат
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder);
      final paint = Paint()..color = Colors.green;
      canvas.drawRect(Rect.fromLTWH(0, 0, 32, 32), paint);
      final picture = recorder.endRecording();
      final image = await picture.toImage(32, 32);
      final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      return byteData?.buffer.asUint8List();
    } catch (e) {
      print('Error extracting EXE icon: $e');
      return null;
    }
  }

  Future<Uint8List?> _downloadFavicon(String url) async {
    try {
      final uri = Uri.parse(url);
      final faviconUrl = '${uri.scheme}://${uri.host}/favicon.ico';
      final response = await http.get(Uri.parse(faviconUrl));
      if (response.statusCode == 200) {
        return response.bodyBytes;
      }
      
      // Пробуем альтернативные пути
      final alternativeUrls = [
        '${uri.scheme}://${uri.host}/apple-touch-icon.png',
        '${uri.scheme}://${uri.host}/favicon.png',
      ];
      
      for (final altUrl in alternativeUrls) {
        try {
          final altResponse = await http.get(Uri.parse(altUrl));
          if (altResponse.statusCode == 200) {
            return altResponse.bodyBytes;
          }
        } catch (e) {
          continue;
        }
      }
    } catch (e) {
      print('Error downloading favicon: $e');
    }
    return null;
  }


  // Остальные методы класса остаются без изменений...
  // _loadImagePreview, _loadAppIcon, _loadFavicon, _launchUrl, _openFile и т.д.

  Future<void> _launchUrl(String url) async {
    try {
      final uri = Uri.parse(url);
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri);
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Не удалось открыть ссылку: $url'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e) {
      print('Error launching URL: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Ошибка при открытии ссылки'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final filePathDisplay = _getFilePathDisplay();

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTap: _handleTap,
        
        child: Container(
          margin: EdgeInsets.only(bottom: 12),
          padding: EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Color(widget.item.backgroundColor).withOpacity(0.9),
            borderRadius: BorderRadius.circular(16),
            image: widget.item.backgroundImagePath != null
                ? DecorationImage(
                    image: FileImage(File(widget.item.backgroundImagePath!)),
                    fit: BoxFit.cover,
                    alignment: Alignment.center,
                  )
                : null,
          ),
          child: Stack(
            children: [
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      _buildIcon(),
                      SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          widget.item.name,
                          style: TextStyle(
                            color: Color(widget.item.textColor),
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ],
                  ),
                  
                  // Отображение пути файла/ярлыка с возможностью клика
                  if (filePathDisplay != null)
                    GestureDetector(
                      onTap: _openFileLocation,
                      child: MouseRegion(
                        cursor: SystemMouseCursors.click,
                        child: Padding(
                          padding: EdgeInsets.only(top: 4),
                          child: Text(
                            filePathDisplay,
                            style: TextStyle(
                              color: Color(widget.item.textColor).withOpacity(0.8),
                              fontSize: 10,
                              decoration: TextDecoration.underline,
                            ),
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ),
                    ),
                  
                  // Остальной контент без изменений...
                  if (widget.item.comment != null && widget.item.comment!.isNotEmpty)
                    Padding(
                      padding: EdgeInsets.only(top: 8),
                      child: Text(
                        widget.item.comment!,
                        style: TextStyle(
                          color: Color(widget.item.textColor).withOpacity(0.8),
                          fontSize: 12,
                        ),
                        maxLines: 3,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  if (widget.item.reminderTime != null)
                    Padding(
                      padding: EdgeInsets.only(top: 4),
                      child: Text(
                        'Напоминание: ${DateFormat('dd.MM.yyyy HH:mm').format(widget.item.reminderTime!)}',
                        style: TextStyle(
                          color: Color(widget.item.textColor).withOpacity(0.6),
                          fontSize: 10,
                        ),
                      ),
                    ),
                ],
              ),

              if (_isHovered)
                Positioned(
                  top: 4,
                  right: 4,
                  child: Row(
                    children: [
                      MouseRegion(
                        cursor: SystemMouseCursors.click,
                        child: GestureDetector(
                          onTap: widget.onEdit,
                          child: Container(
                            padding: EdgeInsets.all(4),
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.settings, size: 12, color: Colors.white),
                          ),
                        ),
                      ),
                      SizedBox(width: 4),
                      MouseRegion(
                        cursor: SystemMouseCursors.click,
                        child: GestureDetector(
                          onTap: widget.onDelete,
                          child: Container(
                            padding: EdgeInsets.all(4),
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.close, size: 12, color: Colors.white),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class EssentialEditDialog extends StatefulWidget {
  final EssentialItem item;
  final Function(EssentialItem) onSave;
  final VoidCallback onDelete;
  final bool isNewItem;
  final GlobalKey? sourceWidgetKey;

  const EssentialEditDialog({
    Key? key,
    required this.item,
    required this.onSave,
    required this.onDelete,
    this.isNewItem = false,
    this.sourceWidgetKey,
  }) : super(key: key);

  @override
  _EssentialEditDialogState createState() => _EssentialEditDialogState();
}

class _EssentialEditDialogState extends State<EssentialEditDialog> {
  late EssentialItem _editedItem;
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _iconController = TextEditingController();
  final TextEditingController _commentController = TextEditingController();
  final TextEditingController _musicController = TextEditingController();
  DateTime? _selectedDate;
  TimeOfDay? _selectedTime;
  final FocusNode _nameFocusNode = FocusNode();
  final FocusNode _iconFocusNode = FocusNode();
  bool _showReminderSettings = false;
  bool _showEmojiGrid = false;
  Color _currentColor = Colors.blue;

  final List<String> _quickEmojis = ['🔑', '⭐', '📄', 'ℹ️', '⚠️', '🌐', '📝', '🟢', '❓'];

  @override
  void initState() {
    super.initState();
    _editedItem = widget.item;
    _nameController.text = _editedItem.name;
    _iconController.text = _editedItem.icon;
    _commentController.text = _editedItem.comment ?? '';
    _musicController.text = _editedItem.musicFile ?? 'alarm.mp3';
    _selectedDate = _editedItem.reminderTime;
    _selectedTime = _editedItem.reminderTime != null
        ? TimeOfDay.fromDateTime(_editedItem.reminderTime!)
        : null;
    _showReminderSettings = _editedItem.reminderTime != null;
    _currentColor = Color(_editedItem.backgroundColor);

    if (widget.isNewItem) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _nameFocusNode.requestFocus();
      });
    }

    _iconFocusNode.addListener(() {
      setState(() {
        _showEmojiGrid = _iconFocusNode.hasFocus;
      });
    });
  }

  Future<void> _pickImage() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
      );

      if (result != null && result.files.single.path != null) {
        final directory = await getApplicationDocumentsDirectory();
        final backgroundsDir = Directory('${directory.path}/Essentials_backgrounds');
        if (!backgroundsDir.existsSync()) {
          backgroundsDir.createSync(recursive: true);
        }

        final originalFile = File(result.files.single.path!);
        final newPath = '${backgroundsDir.path}/${DateTime.now().millisecondsSinceEpoch}.${result.files.single.extension}';
        await originalFile.copy(newPath);

        setState(() {
          _editedItem = _editedItem.copyWith(backgroundImagePath: newPath);
        });
      }
    } catch (e) {
      print('Error picking image: $e');
    }
  }

  void _removeImage() {
    setState(() {
      _editedItem = _editedItem.copyWith(backgroundImagePath: null);
    });
  }

  Future<void> _pickMusic() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.audio,
        allowedExtensions: ['mp3', 'wav'],
      );

      if (result != null && result.files.single.path != null) {
        final path = result.files.single.path!;
        final extension = result.files.single.extension?.toLowerCase();
        
        if (extension == 'mp3' || extension == 'wav') {
          setState(() {
            _editedItem = _editedItem.copyWith(musicFile: path);
            _musicController.text = path;
          });
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Поддерживаются только MP3 и WAV файлы'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      print('Error picking music: $e');
    }
  }

  Future<void> _pickDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime(2100),
    );
    if (picked != null) {
      setState(() {
        _selectedDate = picked;
      });
    }
  }

  Future<void> _pickTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: _selectedTime ?? TimeOfDay.now(),
    );
    if (picked != null) {
      setState(() {
        _selectedTime = picked;
      });
    }
  }

  void _saveChanges() {
    final updatedItem = _editedItem.copyWith(
      name: _nameController.text.trim(),
      icon: _iconController.text.trim(),
      comment: _commentController.text.trim().isEmpty ? null : _commentController.text.trim(),
      musicFile: _musicController.text.trim(),
      reminderTime: _showReminderSettings && _selectedDate != null && _selectedTime != null
          ? DateTime(
              _selectedDate!.year,
              _selectedDate!.month,
              _selectedDate!.day,
              _selectedTime!.hour,
              _selectedTime!.minute,
            )
          : null,
    );

    widget.onSave(updatedItem);
    Navigator.of(context).pop();
  }

  void _selectEmoji(String emoji) {
    setState(() {
      _iconController.text = emoji;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (widget.isNewItem || widget.sourceWidgetKey == null) {
      return _buildDialog(context);
    } else {
      return Stack(
        children: [
          Positioned.fill(
            child: Container(color: Colors.transparent),
          ),
          Positioned(
            top: _getDialogPosition(context).dy,
            left: _getDialogPosition(context).dx,
            child: _buildDialog(context),
          ),
        ],
      );
    }
  }

  Offset _getDialogPosition(BuildContext context) {
    try {
      final renderBox = widget.sourceWidgetKey?.currentContext?.findRenderObject() as RenderBox?;
      if (renderBox != null) {
        final offset = renderBox.localToGlobal(Offset.zero);
        return offset;
      }
    } catch (e) {
      print('Error getting widget position: $e');
    }
    return Offset.zero;
  }

  Widget _buildDialog(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: Container(
        width: MediaQuery.of(context).size.width ,
        height: MediaQuery.of(context).size.height * 0.7,
        decoration: BoxDecoration(
          color: Color(_editedItem.backgroundColor).withOpacity(0.95),
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.5),
              blurRadius: 10,
              spreadRadius: 2,
            ),
          ],
        ),
        child: Column(
          children: [
            Container(
              padding: EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Color(0xFF1A1A1A).withOpacity(0.9),
                borderRadius: BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
              ),
              child: Row(
                children: [
                  Text(
                    'Редактирование Essential',
                    style: TextStyle(color: Colors.white, fontSize: 16),
                  ),
                  Spacer(),
                  MouseRegion(
                    cursor: SystemMouseCursors.click,
                    child: GestureDetector(
                      onTap: () => Navigator.of(context).pop(),
                      child: Icon(Icons.close, size: 20, color: Colors.white),
                    ),
                  ),
                ],
              ),
            ),

            Expanded(
              child: Padding(
                padding: EdgeInsets.all(16),
                child: Column(
                  children: [
                    Row(
                      children: [
                        // Icon field with emoji grid
                        Container(
                          width: 60,
                          child: Column(
                            children: [
                              TextField(
                                controller: _iconController,
                                focusNode: _iconFocusNode,
                                style: TextStyle(color: Colors.white, fontSize: 20),
                                textAlign: TextAlign.center,
                                decoration: InputDecoration(
                                  hintText: '🔖',
                                  hintStyle: TextStyle(fontSize: 20),
                                  border: OutlineInputBorder(),
                                  contentPadding: EdgeInsets.symmetric(vertical: 8),
                                ),
                              ),
                              
                            // Emoji grid
if (_showEmojiGrid)
  Container(
    margin: EdgeInsets.only(top: 4),
    padding: EdgeInsets.all(4),
    decoration: BoxDecoration(
      color: Colors.black.withOpacity(0.8),
      borderRadius: BorderRadius.circular(8),
    ),
    child: GridView.builder(
      shrinkWrap: true,
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        crossAxisSpacing: 4,
        mainAxisSpacing: 4,
      ),
      itemCount: _quickEmojis.length,
      itemBuilder: (context, index) {
        return GestureDetector(
          onTap: () => _selectEmoji(_quickEmojis[index]),
          child: Container(
            decoration: BoxDecoration(
              color: Colors.grey[800],
              borderRadius: BorderRadius.circular(4),
            ),
            child: Center(
              child: Text(
                _quickEmojis[index],
                style: TextStyle(fontSize: 16),
              ),
            ),
          ),
        );
      },
    ),
  ),
],
),
),
SizedBox(width: 12),
Expanded(
  child: TextField(
    controller: _nameController,
    focusNode: _nameFocusNode,
    style: TextStyle(color: Colors.white),
    decoration: InputDecoration(
      labelText: 'Название',
      labelStyle: TextStyle(color: Colors.white70),
      border: OutlineInputBorder(),
    ),
  ),
),
],
),

// ПРАВИЛЬНОЕ МЕСТО ДЛЯ ОТОБРАЖЕНИЯ ПУТИ ФАЙЛА - после строки с названием
if (_editedItem.filePath != null || _editedItem.shortcutTarget != null)
  Container(
    width: double.infinity,
    padding: EdgeInsets.symmetric(vertical: 8, horizontal: 12),
    margin: EdgeInsets.only(top: 8, bottom: 8),
    decoration: BoxDecoration(
      color: Colors.black.withOpacity(0.3),
      borderRadius: BorderRadius.circular(8),
    ),
    child: Text(
      _editedItem.shortcutTarget != null 
          ? 'Ярлык: ${_editedItem.shortcutTarget}'
          : 'Файл: ${_editedItem.filePath}',
      style: TextStyle(
        color: Colors.white70,
        fontSize: 10,
      ),
      maxLines: 2,
      overflow: TextOverflow.ellipsis,
    ),
  ),

SizedBox(height: 16),
                    // Color pickers
                    Row(
                      children: [
                        Text('Цвет виджета:', style: TextStyle(color: Colors.white)),
                        SizedBox(width: 8),
                        Expanded(
                          child: Container(
                            height: 40,
                            child: _buildColorPicker(
                              initialColor: Color(_editedItem.backgroundColor),
                              onColorChanged: (color) {
                                setState(() {
                                  _editedItem = _editedItem.copyWith(backgroundColor: color.value);
                                  _currentColor = color;
                                });
                              },
                            ),
                          ),
                        ),
                        SizedBox(width: 16),
                        Text('Цвет текста:', style: TextStyle(color: Colors.white)),
                        SizedBox(width: 16),
                        Expanded(
                          child: Container(
                            height: 40,
                            child: _buildColorPicker(
                              initialColor: Color(_editedItem.textColor),
                              onColorChanged: (color) {
                                setState(() {
                                  _editedItem = _editedItem.copyWith(textColor: color.value);
                                });
                              },
                            ),
                          ),
                        ),
                      ],
                    ),

                    SizedBox(height: 16),

                    Expanded(
                      child: SingleChildScrollView(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            TextField(
                              controller: _commentController,
                              style: TextStyle(color: Colors.white),
                              maxLines: 4,
                              decoration: InputDecoration(
                                labelText: 'Комментарий',
                                labelStyle: TextStyle(color: Colors.white70),
                                border: OutlineInputBorder(),
                                alignLabelWithHint: true,
                              ),
                            ),

                            SizedBox(height: 16),

                            // Image management
                            Row(
                              children: [
                                Expanded(
                                  child: Text(
                                    _editedItem.backgroundImagePath != null
                                        ? 'Изображение установлено'
                                        : 'Нет изображения',
                                    style: TextStyle(color: Colors.white),
                                  ),
                                ),
                                MouseRegion(
                                  cursor: SystemMouseCursors.click,
                                  child: GestureDetector(
                                    onTap: _pickImage,
                                    child: Container(
                                      padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                      decoration: BoxDecoration(
                                        color: Colors.blue.withOpacity(0.8),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        'Выбрать изображение',
                                        style: TextStyle(color: Colors.white, fontSize: 12),
                                      ),
                                    ),
                                  ),
                                ),
                                if (_editedItem.backgroundImagePath != null) ...[
                                  SizedBox(width: 8),
                                  MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: _removeImage,
                                      child: Container(
                                        padding: EdgeInsets.all(8),
                                        decoration: BoxDecoration(
                                          color: Colors.red.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Icon(Icons.delete, size: 16, color: Colors.white),
                                      ),
                                    ),
                                  ),
                                ],
                              ],
                            ),

                            SizedBox(height: 16),

                            // Reminder toggle
                            Row(
                              children: [
                                Checkbox(
                                  value: _showReminderSettings,
                                  onChanged: (value) {
                                    setState(() {
                                      _showReminderSettings = value ?? false;
                                      if (!_showReminderSettings) {
                                        _selectedDate = null;
                                        _selectedTime = null;
                                      }
                                    });
                                  },
                                ),
                                Text(
                                  'Создать напоминалку',
                                  style: TextStyle(color: Colors.white),
                                ),
                              ],
                            ),

                            // Reminder settings (only visible when toggle is on)
                            if (_showReminderSettings) ...[
                              SizedBox(height: 8),
                              Text(
                                'Напоминание',
                                style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                              ),
                              SizedBox(height: 8),
                              Row(
                                children: [
                                  Expanded(
                                    child: Text(
                                      _selectedDate != null
                                          ? '${_selectedDate!.day}-${_selectedDate!.month}-${_selectedDate!.year}'
                                          : 'Дата не выбрана',
                                      style: TextStyle(color: Colors.white70),
                                    ),
                                  ),
                                  MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: _pickDate,
                                      child: Container(
                                        padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                        decoration: BoxDecoration(
                                          color: Colors.green.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Text(
                                          'Выбрать дату',
                                          style: TextStyle(color: Colors.white, fontSize: 12),
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              SizedBox(height: 8),
                              Row(
                                children: [
                                  Expanded(
                                    child: Text(
                                      _selectedTime != null
                                          ? '${_selectedTime!.hour}:${_selectedTime!.minute.toString().padLeft(2, '0')}'
                                          : 'Время не выбрано',
                                      style: TextStyle(color: Colors.white70),
                                    ),
                                  ),
                                  MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: _pickTime,
                                      child: Container(
                                        padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                        decoration: BoxDecoration(
                                          color: Colors.green.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Text(
                                          'Выбрать время',
                                          style: TextStyle(color: Colors.white, fontSize: 12),
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              
                            // Music
                            Row(
                              children: [
                                Expanded(
                                  child: TextField(
                                    controller: _musicController,
                                    style: TextStyle(color: Colors.white),
                                    decoration: InputDecoration(
                                      labelText: 'Музыкальный файл',
                                      labelStyle: TextStyle(color: Colors.white70),
                                      border: OutlineInputBorder(),
                                    ),
                                  ),
                                ),
                                SizedBox(width: 8),
                                MouseRegion(
                                  cursor: SystemMouseCursors.click,
                                  child: GestureDetector(
                                    onTap: _pickMusic,
                                    child: Container(
                                      padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                      decoration: BoxDecoration(
                                        color: Colors.orange.withOpacity(0.8),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        'Выбрать файл',
                                        style: TextStyle(color: Colors.white, fontSize: 12),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                              SizedBox(height: 16),
                            ],


                            SizedBox(height: 16),

                            // Action buttons
                            Row(
                              children: [
                                Expanded(
                                  child: MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: _saveChanges,
                                      child: Container(
                                        padding: EdgeInsets.all(12),
                                        decoration: BoxDecoration(
                                          color: Colors.blue.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Text(
                                          'Сохранить',
                                          style: TextStyle(color: Colors.white),
                                          textAlign: TextAlign.center,
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                                SizedBox(width: 12),
                                Expanded(
                                  child: MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: widget.onDelete,
                                      child: Container(
                                        padding: EdgeInsets.all(12),
                                        decoration: BoxDecoration(
                                          color: Colors.red.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Text(
                                          'Удалить',
                                          style: TextStyle(color: Colors.white),
                                          textAlign: TextAlign.center,
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

Widget _buildColorPicker({required Color initialColor, required ValueChanged<Color> onColorChanged}) {
  return GestureDetector(
    onTap: () {
      Color selectedColor = initialColor; // Запоминаем начальный цвет
      
      showDialog(
        context: context,
        builder: (context) => StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              backgroundColor: selectedColor,
              title: Text('Выберите цвет', style: TextStyle(
                color: selectedColor.computeLuminance() > 0.5 ? Colors.black : Colors.white
              )),
              content: Container(
                width: 300,
                height: 300,
                child: ColorPicker(
                  color: selectedColor,
                  onColorChanged: (color) {
                    setDialogState(() {
                      selectedColor = color; // Обновляем выбранный цвет
                    });
                  },
                  showLabel: false,
                  pickerAreaHeightPercent: 0.8,
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: Text('Отмена', style: TextStyle(
                    color: selectedColor.computeLuminance() > 0.5 ? Colors.black : Colors.white
                  )),
                ),
                TextButton(
                  onPressed: () {
                    onColorChanged(selectedColor); // Сохраняем выбранный цвет
                    Navigator.of(context).pop();
                  },
                  child: Text('OK', style: TextStyle(
                    color: selectedColor.computeLuminance() > 0.5 ? Colors.black : Colors.white
                  )),
                ),
              ],
            );
          },
        ),
      );
    },
    child: Container(
      decoration: BoxDecoration(
        color: initialColor,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.white, width: 2),
      ),
    ),
  );
}
}

class ColorPicker extends StatefulWidget {
  final Color color;
  final ValueChanged<Color> onColorChanged;
  final bool showLabel;
  final double pickerAreaHeightPercent;

  const ColorPicker({
    Key? key,
    required this.color,
    required this.onColorChanged,
    this.showLabel = true,
    this.pickerAreaHeightPercent = 0.8,
  }) : super(key: key);

  @override
  _ColorPickerState createState() => _ColorPickerState();
}

class _ColorPickerState extends State<ColorPicker> {
  late Color _currentColor;

  @override
  void initState() {
    super.initState();
    _currentColor = widget.color;
  }

  List<Color> _generateColors() {
    final colors = <Color>[];
    
    // Basic colors
    colors.addAll([
      Colors.black, Colors.white, Colors.grey,
      Colors.red, Colors.pink, Colors.purple,
      Colors.deepPurple, Colors.indigo, Colors.blue,
      Colors.lightBlue, Colors.cyan, Colors.teal,
      Colors.green, Colors.lightGreen, Colors.lime,
      Colors.yellow, Colors.amber, Colors.orange,
      Colors.deepOrange, Colors.brown,
    ]);

    // Generate more shades
    for (var baseColor in [Colors.red, Colors.blue, Colors.green, Colors.yellow, Colors.purple]) {
      for (int i = 1; i <= 9; i++) {
        colors.add(baseColor[i * 100]!);
      }
    }

    return colors;
  }

  @override
  Widget build(BuildContext context) {
    final colors = _generateColors();
    
    return Column(
      children: [
        Expanded(
          child: GridView.builder(
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 10,
              crossAxisSpacing: 2,
              mainAxisSpacing: 2,
            ),
            itemCount: colors.length,
            itemBuilder: (context, index) {
              final color = colors[index];
              return GestureDetector(
                onTap: () {
                  setState(() {
                    _currentColor = color;
                  });
                  widget.onColorChanged(color);
                },
                child: Container(
                  decoration: BoxDecoration(
                    color: color,
                    border: Border.all(
                      color: _currentColor.value == color.value ? Colors.white : Colors.transparent,
                      width: 2,
                    ),
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
              );
            },
          ),
        ),
        
        SizedBox(height: 16),
        
        // Gradient picker
        Container(
          height: 40,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            gradient: LinearGradient(
              colors: [
                Colors.red, Colors.orange, Colors.yellow, 
                Colors.green, Colors.blue, Colors.indigo, 
                Colors.purple
              ],
            ),
          ),
          child: GestureDetector(
            onTapDown: (details) {
              final relativeX = details.localPosition.dx;
              final containerWidth = context.size?.width ?? 1;
              final ratio = relativeX / containerWidth;
              
              final hue = ratio * 360;
              final color = HSVColor.fromAHSV(1.0, hue, 1.0, 1.0).toColor();
              
              setState(() {
                _currentColor = color;
              });
              widget.onColorChanged(color);
            },
          ),
        ),
        
        SizedBox(height: 8),
        
        // Current color display
        Container(
          padding: EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: _currentColor,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: Colors.white),
          ),
          child: Text(
            'RGB: ${_currentColor.red}, ${_currentColor.green}, ${_currentColor.blue}',
            style: TextStyle(
              color: _currentColor.computeLuminance() > 0.5 ? Colors.black : Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ],
    );
  }
}

class DeleteConfirmationDialog extends StatelessWidget {
  final EssentialItem item;
  final VoidCallback onDelete;

  const DeleteConfirmationDialog({
    Key? key,
    required this.item,
    required this.onDelete,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: Color(0xFF2B2B2B),
      title: Text(
        'Удаление элемента',
        style: TextStyle(color: Colors.white),
      ),
      content: Text(
        'Вы уверены, что хотите удалить "${item.name}"?',
        style: TextStyle(color: Colors.white70),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text('Отмена', style: TextStyle(color: Colors.white)),
        ),
        TextButton(
          onPressed: () {
            onDelete();
            Navigator.of(context).pop();
          },
          child: Text('Удалить', style: TextStyle(color: Colors.red)),
        ),
      ],
    );
  }
}
class EssentialItem {
  final String id;
  final String name;
  final String icon;
  final int backgroundColor;
  final int textColor;
  final String? comment;
  final String? backgroundImagePath;
  final String? musicFile;
  final DateTime? reminderTime;
  final String? originalFilePath;
  final String? filePath; // Новое поле для пути файла/ярлыка
  final String? shortcutTarget; // Новое поле для цели ярлыка

  EssentialItem({
    required this.id,
    required this.name,
    required this.icon,
    required this.backgroundColor,
    required this.textColor,
    this.comment,
    this.backgroundImagePath,
    this.musicFile,
    this.reminderTime,
    this.originalFilePath,
    this.filePath,
    this.shortcutTarget,
  });

  factory EssentialItem.fromFile(FileSystemEntity file) {
    final fileName = file.path.split('/').last;
    final extension = fileName.split('.').last.toLowerCase();
    
    String icon = '📄';
    String? shortcutTarget;
    
    // Проверяем, является ли файл ярлыком
    if (extension == 'lnk' || extension == 'url') {
      icon = '🔗';
      shortcutTarget = _readShortcutTarget(file.path);
    } else if (['jpg', 'jpeg', 'png', 'gif', 'bmp'].contains(extension)) {
      icon = '🖼️';
    } else if (['mp3', 'wav', 'ogg'].contains(extension)) {
      icon = '🎵';
    } else if (['exe'].contains(extension)) {
      icon = '⚙️';
    }
    
    return EssentialItem(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: fileName,
      icon: icon,
      backgroundColor: Colors.blue.value,
      textColor: Colors.white.value,
      originalFilePath: file.path,
      filePath: file.path,
      shortcutTarget: shortcutTarget,
    );
  }

  // Функция для чтения цели ярлыка (упрощенная версия)
  static String? _readShortcutTarget(String shortcutPath) {
    try {
      if (shortcutPath.toLowerCase().endsWith('.url')) {
        final file = File(shortcutPath);
        final lines = file.readAsLinesSync();
        for (final line in lines) {
          if (line.toLowerCase().startsWith('url=')) {
            return line.substring(4).trim();
          }
        }
      }
      // Для .lnk файлов в реальном приложении нужно использовать native channel
      return shortcutPath;
    } catch (e) {
      return shortcutPath;
    }
  }

  factory EssentialItem.fromJson(Map<String, dynamic> json) {
    return EssentialItem(
      id: json['id'],
      name: json['name'],
      icon: json['icon'],
      backgroundColor: json['backgroundColor'],
      textColor: json['textColor'],
      comment: json['comment'],
      backgroundImagePath: json['backgroundImagePath'],
      musicFile: json['musicFile'],
      reminderTime: json['reminderTime'] != null ? DateTime.parse(json['reminderTime']) : null,
      originalFilePath: json['originalFilePath'],
      filePath: json['filePath'],
      shortcutTarget: json['shortcutTarget'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'icon': icon,
      'backgroundColor': backgroundColor,
      'textColor': textColor,
      'comment': comment,
      'backgroundImagePath': backgroundImagePath,
      'musicFile': musicFile,
      'reminderTime': reminderTime?.toIso8601String(),
      'originalFilePath': originalFilePath,
      'filePath': filePath,
      'shortcutTarget': shortcutTarget,
    };
  }

  EssentialItem copyWith({
    String? id,
    String? name,
    String? icon,
    int? backgroundColor,
    int? textColor,
    String? comment,
    String? backgroundImagePath,
    String? musicFile,
    DateTime? reminderTime,
    String? originalFilePath,
    String? filePath,
    String? shortcutTarget,
  }) {
    return EssentialItem(
      id: id ?? this.id,
      name: name ?? this.name,
      icon: icon ?? this.icon,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      textColor: textColor ?? this.textColor,
      comment: comment ?? this.comment,
      backgroundImagePath: backgroundImagePath ?? this.backgroundImagePath,
      musicFile: musicFile ?? this.musicFile,
      reminderTime: reminderTime ?? this.reminderTime,
      originalFilePath: originalFilePath ?? this.originalFilePath,
      filePath: filePath ?? this.filePath,
      shortcutTarget: shortcutTarget ?? this.shortcutTarget,
    );
  }
}
class ClipboardHistoryWindow extends StatefulWidget {
  const ClipboardHistoryWindow({super.key});

  @override
  State<ClipboardHistoryWindow> createState() => _ClipboardHistoryWindowState();
}

class _ClipboardHistoryWindowState extends State<ClipboardHistoryWindow> {
  final TextEditingController _searchController = TextEditingController();
  List<Map<String, dynamic>> _clipboardHistory = [];
  List<Map<String, dynamic>> _filteredHistory = [];
  bool _isLoading = true;
  late Timer _keyboardInputTimer;
  String _currentTypedText = '';
  DateTime _lastTypedTime = DateTime.now();
  late Directory _copypasteDir;
  late StreamSubscription<FileSystemEvent> _fileWatcher;
  int _currentTab = 0; // 0 - все, 1 - избранное
  File? _backgroundImage;
  Map<String, dynamic>? _expandedItem;
  List<String> _selectedItems = []; // Для compose функционала
  bool _showExportOptions = false;
  String _exportMode = 'auto'; // auto, image, text, html, archive, separate

  // CSS для HTML экспорта
  final String _htmlCss = '''
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        max-width: 70%;
        margin: 0 auto;
        padding: 40px 20px;
        background-color: #1a1a1a;
        color: #ffffff;
        line-height: 1.6;
      }
      .text-block {
        background: #2b2b2b;
        padding: 25px;
        margin: 20px 0;
        border-radius: 8px;
        border-left: 4px solid #4CAF50;
      }
      .code-block {
        background: #1e1e1e;
        padding: 25px;
        margin: 20px 0;
        border-radius: 8px;
        border-left: 4px solid #2196F3;
        font-family: 'Consolas', 'Monaco', monospace;
        white-space: pre-wrap;
        overflow-x: auto;
      }
      .image-block {
        text-align: center;
        margin: 30px 0;
        padding: 15px;
        background: #2b2b2b;
        border-radius: 8px;
        border-left: 4px solid #FF9800;
      }
      .image-block img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
      }
      .image-caption {
        margin-top: 10px;
        font-style: italic;
        color: #cccccc;
      }
      .header {
        text-align: center;
        margin-bottom: 40px;
        padding-bottom: 20px;
        border-bottom: 2px solid #333;
      }
      .timestamp {
        color: #888;
        font-size: 0.9em;
        margin-top: 10px;
      }
    </style>
  ''';

  @override
  void initState() {
    super.initState();
    _initializeApp();
    _setupKeyboardListeners();
  }

  void _setupKeyboardListeners() {
    // Слушатель для клавиш Esc и Ctrl+Z
    RawKeyboard.instance.addListener(_handleKeyEvent);
  }

  void _handleKeyEvent(RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      // Esc - очистить выделение
      if (event.logicalKey == LogicalKeyboardKey.escape) {
        if (_selectedItems.isNotEmpty) {
          setState(() {
            _selectedItems.clear();
            _showExportOptions = false;
          });
        }
      }
      // Ctrl+Z - отменить последнее выделение
      else if (event.logicalKey == LogicalKeyboardKey.keyZ && 
               event.isControlPressed) {
        if (_selectedItems.isNotEmpty) {
          setState(() {
            _selectedItems.removeLast();
            _showExportOptions = _selectedItems.isNotEmpty;
          });
        }
      }
    }
  }

  void _handleBackgroundImageDrop(List<File> files) async {
    if (files.isNotEmpty && (files.first.path.endsWith('.png') || files.first.path.endsWith('.jpg'))) {
      try {
        final directory = await getApplicationDocumentsDirectory();
        final bgDir = Directory('${directory.path}/imeyou_pet/widget_backgrounds');
        if (!bgDir.existsSync()) {
          bgDir.createSync(recursive: true);
        }
        
        // Сохраняем изображение
        final newFile = File('${bgDir.path}/cnp_bg${path.extension(files.first.path)}');
        await newFile.writeAsBytes(await files.first.readAsBytes());
        
        // Сохраняем путь в JSON
        final configFile = File('${bgDir.path}/current_cnp_bg.json');
        final configData = {
          'current_bg': newFile.path
        };
        await configFile.writeAsString(json.encode(configData));
        
        setState(() {
          _backgroundImage = newFile;
        });
        
        print('Background saved: ${newFile.path}');
        
      } catch (e) {
        print('Error setting background: $e');
      }
    }
  }

  void _loadBackgroundImage() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final bgDir = Directory('${directory.path}/imeyou_pet/widget_backgrounds');
      
      if (bgDir.existsSync()) {
        // Сначала пытаемся загрузить из JSON
        final configFile = File('${bgDir.path}/current_cnp_bg.json');
        if (configFile.existsSync()) {
          final jsonString = await configFile.readAsString();
          final configData = json.decode(jsonString);
          final bgPath = configData['current_bg'];
          
          if (bgPath != null && File(bgPath).existsSync()) {
            setState(() {
              _backgroundImage = File(bgPath);
            });
            print('Background loaded from config: $bgPath');
            return; // Выходим, если нашли в конфиге
          }
        }
        
        // Если JSON нет или путь невалидный, ищем любой подходящий файл
        final files = bgDir.listSync();
        for (var file in files) {
          if (file.path.endsWith('cnp_bg.png') || file.path.endsWith('cnp_bg.jpg')) {
            setState(() {
              _backgroundImage = File(file.path);
            });
            print('Background loaded from fallback: ${file.path}');
            break;
          }
        }
      }
    } catch (e) {
      print('Error loading background: $e');
    }
  }

  void _initializeApp() async {
    try {
      // Инициализация окна
      await windowManager.ensureInitialized();
      await windowManager.setAsFrameless();
      await windowManager.setSize(const Size(400, 700));
      await windowManager.setAlwaysOnTop(true);
      
      // Инициализация директории
      final directory = await getApplicationDocumentsDirectory();
      _copypasteDir = Directory('${directory.path}/copypasted');
      if (!_copypasteDir.existsSync()) {
        _copypasteDir.createSync(recursive: true);
      }

      // Загрузка истории и запуск слушателей
      await _loadClipboardHistory();
      _searchController.addListener(_filterHistory);
      _startFileWatcher();
      _startKeyboardListener();
      _loadBackgroundImage();
      
    } catch (e) {
      print('Error initializing app: $e');
      setState(() {
        _isLoading = false;
      });
    }
  }

  void _startFileWatcher() {
    _fileWatcher = _copypasteDir.watch(events: FileSystemEvent.all).listen((event) {
      if (event.type == FileSystemEvent.create || event.type == FileSystemEvent.modify) {
        // Задержка для гарантии что файл полностью записан
        Future.delayed(const Duration(milliseconds: 100), () {
          _loadClipboardHistory();
        });
      }
    });
  }

  void _startKeyboardListener() {
    return;
    _keyboardInputTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      _checkKeyboardInput();
    });
  }

  void _checkKeyboardInput() {
    final now = DateTime.now();
    final timeDiff = now.difference(_lastTypedTime).inSeconds;
    
    // Если прошло больше 45 секунд с последнего ввода и есть набранный текст
    if (timeDiff > 45 && _currentTypedText.trim().isNotEmpty) {
      _saveKeyboardInput(_currentTypedText);
      _currentTypedText = '';
    }
  }

  bool _isValidContent(String content) {
    if (content.isEmpty) return false;
    
    // Фильтрация слишком коротких текстов (меньше 3 символов)
    if (content.length < 3) return false;
    
    // Фильтрация только пробелов/переносов строк
    if (content.trim().isEmpty) return false;
    
    // Фильтрация повторяющихся символов (например, "aaaaaaa")
    final regex = RegExp(r'^(.)\1+$');
    if (regex.hasMatch(content)) return false;
    
    // Фильтрация только цифр без букв
    final onlyDigits = RegExp(r'^\d+$');
    if (onlyDigits.hasMatch(content) && content.length < 10) return false;
    
    return true;
  }

  Future<void> _saveKeyboardInput(String text) async {
    if (!_isValidContent(text)) return;
    
    try {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'keyboard_$timestamp.cnp';
      final file = File('${_copypasteDir.path}/$fileName');
      
      final entry = {
        'content': text,
        'timestamp': timestamp,
        'source': 'keyboard',
        'starred': false,
      };
      
      await file.writeAsString(jsonEncode(entry), encoding: utf8);
      print('Keyboard input saved: ${text.length} characters');
    } catch (e) {
      print('Error saving keyboard input: $e');
    }
  }

  Future<void> _saveToClipboardHistory(String text) async {
    if (!_isValidContent(text)) return;
    
    try {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'clipboard_$timestamp.cnp';
      final file = File('${_copypasteDir.path}/$fileName');
      
      final entry = {
        'content': text,
        'timestamp': timestamp,
        'source': 'clipboard',
        'starred': false,
      };
      
      await file.writeAsString(jsonEncode(entry), encoding: utf8);
      print('Clipboard content saved: ${text.length} characters');
    } catch (e) {
      print('Error saving clipboard content: $e');
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    _keyboardInputTimer.cancel();
    _fileWatcher.cancel();
    RawKeyboard.instance.removeListener(_handleKeyEvent);
    super.dispose();
  }
Future<void> _loadClipboardHistory() async {
  try {
    List<Map<String, dynamic>> history = [];
    
    if (_copypasteDir.existsSync()) {
      final files = _copypasteDir.listSync()
        .where((file) => file is File && file.path.endsWith('.cnp'))
        .toList();

      // Сортировка по времени изменения
      files.sort((a, b) {
        final aStat = a.statSync();
        final bStat = b.statSync();
        return bStat.modified.compareTo(aStat.modified);
      });

      for (final file in files.take(100)) {
        try {
          final content = await File(file.path).readAsString(encoding: utf8);
          final entry = jsonDecode(content);
          
          if (entry is Map<String, dynamic>) {
            final textContent = entry['content']?.toString() ?? '';
            String itemType = entry['type'] as String? ?? 'text';
            
            // Автоматически определяем тип для файлов изображений
            if (itemType == 'file') {
              final fileExtension = path.extension(textContent).toLowerCase();
              if (fileExtension == '.png' || fileExtension == '.jpg' || fileExtension == '.jpeg') {
                itemType = 'image';
              }
            }
            
            history.add({
              'content': textContent,
              'timestamp': entry['timestamp'] as int? ?? DateTime.now().millisecondsSinceEpoch,
              'length': textContent.length,
              'filePath': file.path,
              'starred': entry['starred'] as bool? ?? false,
              'source': entry['source'] as String? ?? 'clipboard',
              'type': itemType, // Используем обновленный тип
              'file_info': entry['file_info'],
            });
          }
        } catch (e) {
          print('Error reading file ${file.path}: $e');
        }
      }
    }

    setState(() {
      _clipboardHistory = history;
      _filterHistory();
      _isLoading = false;
    });
    
  } catch (e) {
    print('Error loading history: $e');
    setState(() {
      _isLoading = false;
      _clipboardHistory = [];
      _filteredHistory = [];
    });
  }
}

 void _filterHistory() {
  final query = _searchController.text.toLowerCase().trim();
  setState(() {
    if (query.isEmpty) {
      _filteredHistory = _currentTab == 0 
          ? _clipboardHistory 
          : _clipboardHistory.where((item) => item['starred'] == true).toList();
    } else {
      final baseList = _currentTab == 0 
          ? _clipboardHistory 
          : _clipboardHistory.where((item) => item['starred'] == true).toList();
      
      // Разбиваем запрос на отдельные слова
      final queryWords = query.split(RegExp(r'\s+')).where((word) => word.length > 1).toList();
      
      // Если запрос состоит из одного слова, используем простой поиск
      if (queryWords.length <= 1) {
        _filteredHistory = baseList.where((item) {
          final content = item['content']?.toString().toLowerCase() ?? '';
          final type = _getTypeDisplayName(item['type'] as String? ?? 'text').toLowerCase();
          final date = _formatDate(item['timestamp'] as int? ?? 0).toLowerCase();
          final time = _formatTime(item['timestamp'] as int? ?? 0).toLowerCase();
          
          return content.contains(query) || 
                 type.contains(query) || 
                 date.contains(query) || 
                 time.contains(query);
        }).toList();
      } else {
        // Для многокомпонентного запроса используем сложную логику ранжирования
        final List<Map<String, dynamic>> resultsWithScore = [];
        
        for (final item in baseList) {
          final content = item['content']?.toString().toLowerCase() ?? '';
          final type = _getTypeDisplayName(item['type'] as String? ?? 'text').toLowerCase();
          final date = _formatDate(item['timestamp'] as int? ?? 0).toLowerCase();
          final time = _formatTime(item['timestamp'] as int? ?? 0).toLowerCase();
          
          double score = 0.0;
          int foundWords = 0;
          
          // Проверяем каждое слово запроса
          for (final word in queryWords) {
            bool wordFound = false;
            
            // Поиск точного совпадения слова
            final wordVariations = _getWordVariations(word);
            for (final variation in wordVariations) {
              if (content.contains(variation)) {
                score += variation == word ? 3.0 : 2.5; // Чуть меньше баллов за вариации
                wordFound = true;
                break;
              }
            }
            
            // Поиск частичного совпадения (для версий слов)
            if (!wordFound) {
              // Ищем слова, которые начинаются с этого корня
              final wordPattern = RegExp(r'\b' + word);
              if (wordPattern.hasMatch(content)) {
                score += 2.0; // Средний балл за частичное совпадение
                wordFound = true;
              }
            }
            
            // Поиск в других полях
            if (!wordFound) {
              if (type.contains(word) || date.contains(word) || time.contains(word)) {
                score += 1.0; // Низкий балл за совпадение в метаданных
                wordFound = true;
              }
            }
            
            if (wordFound) foundWords++;
          }
          
          // Дополнительные бонусы
          if (foundWords == queryWords.length) {
            score += 5.0; // Бонус за все слова
          }
          
          // Бонус за избранное
          if (item['starred'] == true) {
            score += 2.0;
          }
          
          // Штраф за длинный текст (предпочтение более коротким релевантным результатам)
          final lengthPenalty = content.length > 200 ? content.length / 1000.0 : 0.0;
          score -= lengthPenalty;
          
          // Бонус за точное совпадение всей фразы
          if (content.contains(query)) {
            score += 4.0;
          }
          
          // Бонус за совпадение в начале текста
          if (content.startsWith(query)) {
            score += 3.0;
          }
          
          if (foundWords > 0) {
            resultsWithScore.add({
              'item': item,
              'score': score,
              'foundWords': foundWords,
              'contentLength': content.length,
            });
          }
        }
        
        // Сортируем по релевантности
        resultsWithScore.sort((a, b) {
          final double scoreA = a['score'] as double;
          final double scoreB = b['score'] as double;
          
          // Сначала по баллам (по убыванию)
          if (scoreB > scoreA) return 1;
          if (scoreB < scoreA) return -1;
          
          // Затем по количеству найденных слов (по убыванию)
          final int wordsA = a['foundWords'] as int;
          final int wordsB = b['foundWords'] as int;
          if (wordsB > wordsA) return 1;
          if (wordsB < wordsA) return -1;
          
          // Затем по длине контента (по возрастанию - короткие первыми)
          final int lengthA = a['contentLength'] as int;
          final int lengthB = b['contentLength'] as int;
          return lengthA.compareTo(lengthB);
        });
        
        _filteredHistory = resultsWithScore.map((e) => e['item'] as Map<String, dynamic>).toList();
      }

      // Дополнительная сортировка для избранного (если поиск не многокомпонентный)
      if (queryWords.length <= 1) {
        _filteredHistory.sort((a, b) {
          final aStarred = a['starred'] as bool? ?? false;
          final bStarred = b['starred'] as bool? ?? false;
          
          if (aStarred && !bStarred) return -1;
          if (!aStarred && bStarred) return 1;
          return 0;
        });
      }
    }
  });
}

// Добавьте этот метод в класс
List<String> _getWordVariations(String word) {
  final variations = <String>[];
  
  // Базовое слово
  variations.add(word);
  
  // Простые окончания для русского языка
  if (word.length > 3) {
    if (word.endsWith('а')) {
      variations.add(word.substring(0, word.length - 1)); // маша -> маш
    }
    if (word.endsWith('я')) {
      variations.add(word.substring(0, word.length - 1)); // танцую -> танцу
    }
    if (word.endsWith('о')) {
      variations.add(word.substring(0, word.length - 1)); // яблоко -> яблок
    }
    if (word.endsWith('ы')) {
      variations.add(word.substring(0, word.length - 1)); // яблоки -> яблок
    }
    if (word.endsWith('и')) {
      variations.add(word.substring(0, word.length - 1)); // груши -> груш
    }
  }
  
  return variations;
}
String _getTypeDisplayName(String type) {
  switch (type) {
    case 'file': return 'Файл';
    case 'image_url': return 'Изображение';
    case 'url': return 'Ссылка';
    case 'document_url': return 'Документ';
    case 'email': return 'Email';
    case 'code': return 'Код';
    case 'html': return 'HTML';
    case 'keyboard': return 'Клавиатура';
    case 'image': return 'Изображение';
    default: return 'Текст';
  }
}

  Color _getTypeBorderColor(String type) {
    switch (type) {
      case 'file': return Colors.orange;
      case 'image_url': return Colors.pink;
      case 'image': return Colors.pink;
      case 'url': return Colors.blue;
      case 'document_url': return Colors.purple;
      case 'email': return Colors.green;
      case 'code': return Colors.cyan;
      case 'html': return Colors.yellow;
      case 'keyboard': return Colors.grey;
      default: return Colors.white;
    }
  }

  Future<void> _copyToClipboard(Map<String, dynamic> item) async {
    try {
      final content = item['content']?.toString() ?? '';
      final type = item['type'] as String? ?? 'text';
      
      if (type == 'file') {
        final file = File(content);
        if (await file.exists()) {
          if (Platform.isWindows) {
            await _copyFileToClipboardWindows(content);
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text('Файл скопирован в буфер обмена'),
                backgroundColor: Colors.green,
                duration: const Duration(seconds: 2),
              ),
            );
          } else {
            await Clipboard.setData(ClipboardData(text: content));
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text('Путь к файлу скопирован в буфер обмена'),
                backgroundColor: Colors.green,
                duration: const Duration(seconds: 2),
              ),
            );
          }
        } else {
          await Clipboard.setData(ClipboardData(text: content));
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Файл не найден, скопирован путь'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 2),
            ),
          );
        }
      } else {
        await Clipboard.setData(ClipboardData(text: content));
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Скопировано в буфер обмена'),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      print('Error copying to clipboard: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Ошибка копирования: $e'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  Future<void> _openItem(Map<String, dynamic> item) async {
    try {
      final content = item['content']?.toString() ?? '';
      final type = item['type'] as String? ?? 'text';
      
      if (type == 'url' || type == 'image_url' || type == 'document_url') {
        // Открываем ссылку в браузере
        if (await canLaunch(content)) {
          await launch(content);
        } else {
          throw Exception('Could not launch $content');
        }
      } else if (type == 'file') {
        // Открываем файл
        final file = File(content);
        if (await file.exists()) {
          if (Platform.isWindows) {
            await Process.run('start', ['""', content], runInShell: true);
          } else if (Platform.isMacOS) {
            await Process.run('open', [content]);
          } else if (Platform.isLinux) {
            await Process.run('xdg-open', [content]);
          }
        } else {
          throw Exception('File not found: $content');
        }
      }
    } catch (e) {
      print('Error opening item: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Ошибка открытия: $e'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  Future<void> _copyFileToClipboardWindows(String filePath) async {
    try {
      final powerShellScript = '''
        Add-Type -AssemblyName System.Windows.Forms
        \$file = Get-Item '$filePath'
        
        if (\$file.Attributes -band [System.IO.FileAttributes]::Directory) {
          [System.Windows.Forms.Clipboard]::SetText('$filePath')
        } else {
          \$collection = New-Object System.Collections.Specialized.StringCollection
          \$collection.Add('$filePath')
          [System.Windows.Forms.Clipboard]::SetFileDropList(\$collection)
        }
      ''';

      final result = await Process.run('powershell', [
        '-NoProfile',
        '-ExecutionPolicy', 
        'Bypass',
        '-Command',
        powerShellScript
      ]);

      if (result.stderr != null && result.stderr.toString().isNotEmpty) {
        print('PowerShell error: ${result.stderr}');
        await Clipboard.setData(ClipboardData(text: filePath));
      }
    } catch (e) {
      print('Error copying file to clipboard: $e');
      await Clipboard.setData(ClipboardData(text: filePath));
    }
  }

  Future<void> _toggleStar(Map<String, dynamic> item) async {
    try {
      final filePath = item['filePath']?.toString();
      if (filePath != null && File(filePath).existsSync()) {
        final currentStarred = item['starred'] as bool? ?? false;
        final newStarred = !currentStarred;
        
        final content = await File(filePath).readAsString(encoding: utf8);
        final entry = jsonDecode(content) as Map<String, dynamic>;
        
        entry['starred'] = newStarred;
        
        await File(filePath).writeAsString(jsonEncode(entry), encoding: utf8);
        
        _loadClipboardHistory();
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(newStarred ? 'Добавлено в избранное' : 'Удалено из избранного'),
            backgroundColor: Colors.blue,
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      print('Error toggling star: $e');
    }
  }

  Future<void> _deleteItem(Map<String, dynamic> item) async {
    try {
      final filePath = item['filePath']?.toString();
      if (filePath != null && File(filePath).existsSync()) {
        await File(filePath).delete();
      }
    } catch (e) {
      print('Error deleting file: $e');
    }
    
    setState(() {
      _clipboardHistory.remove(item);
      _filteredHistory.remove(item);
    });
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('Элемент удален'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 2),
      ),
    );
  }

  Future<void> _clearAllHistory() async {
    try {
      int deletedCount = 0;
      int skippedCount = 0;
      
      if (_copypasteDir.existsSync()) {
        final files = _copypasteDir.listSync()
          .where((file) => file is File && file.path.endsWith('.cnp'))
          .toList();

        for (final file in files) {
          try {
            final content = await File(file.path).readAsString(encoding: utf8);
            final entry = jsonDecode(content) as Map<String, dynamic>;
            
            final isStarred = entry['starred'] as bool? ?? false;
            
            if (isStarred) {
              skippedCount++;
              continue;
            }
            
            await file.delete();
            deletedCount++;
            
          } catch (e) {
            print('Error processing file ${file.path}: $e');
            skippedCount++;
          }
        }
      }

      _loadClipboardHistory();

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Удалено $deletedCount элементов, сохранено $skippedCount избранных'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 3),
        ),
      );
    } catch (e) {
      print('Error clearing history: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Ошибка очистки: $e'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  void _toggleSelection(Map<String, dynamic> item) {
    final filePath = item['filePath']?.toString() ?? '';
    setState(() {
      if (_selectedItems.contains(filePath)) {
        _selectedItems.remove(filePath);
      } else {
        _selectedItems.add(filePath);
      }
      _showExportOptions = _selectedItems.isNotEmpty;
    });
  }

  bool _isSelected(Map<String, dynamic> item) {
    return _selectedItems.contains(item['filePath']?.toString() ?? '');
  }
Future<void> _executeCompose() async {
  try {
    // Получаем выбранные элементы
    final selectedItems = _clipboardHistory.where(
      (item) => _selectedItems.contains(item['filePath']?.toString() ?? '')
    ).toList();

    if (selectedItems.isEmpty) return;

    // Определяем тип экспорта
    String exportType = _exportMode;
    if (_exportMode == 'auto') {
      exportType = _determineExportType(selectedItems);
    }

    // Выполняем экспорт
    String? resultPath;
    switch (exportType) {
      case 'text':
        resultPath = await _exportAsText(selectedItems);
        break;
      case 'image':
        resultPath = await _exportAsImage(selectedItems);
        break;
      case 'html':
        resultPath = await _exportAsHtml(selectedItems);
        break;
      case 'archive':
        resultPath = await _exportAsArchive(selectedItems);
        break;
      case 'separate':
        resultPath = await _exportAsSeparateFiles(selectedItems);
        break;
    }

    // Очищаем выделение после экспорта
    setState(() {
      _selectedItems.clear();
      _showExportOptions = false;
    });

    // Открываем результат если есть путь
    if (resultPath != null && await File(resultPath).exists()) {
      await _openResultFile(resultPath, exportType);
    }

  } catch (e) {
    print('Error during compose: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Ошибка экспорта: $e'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

String _determineExportType(List<Map<String, dynamic>> items) {
  final hasImages = items.any((item) => item['type'] == 'image' || item['type'] == 'image_url');
  final hasText = items.any((item) => item['type'] == 'text' || item['type'] == 'code' || item['type'] == 'html');
  final hasFiles = items.any((item) => item['type'] == 'file');
  
  if (hasFiles) return 'archive';
  if (hasImages || hasText) return 'html'; // HTML доступен при наличии и текста и изображений
  if (hasImages) return 'image';
  if (hasText) return 'text';
  return 'archive';
}
 Future<String?> _exportAsText(List<Map<String, dynamic>> items) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final buffer = StringBuffer();
    for (final item in items) {
      if (item['type'] == 'text' || item['type'] == 'code' || item['type'] == 'html') {
        buffer.writeln(item['content']?.toString() ?? '');
        buffer.writeln('---'); // Разделитель
      }
    }

    final content = buffer.toString();
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final file = File('${exportDir.path}/text_export_$timestamp.txt');
    await file.writeAsString(content, encoding: utf8);

    await Clipboard.setData(ClipboardData(text: content));

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Текст экспортирован: ${file.path}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );
    
    return file.path;
  } catch (e) {
    print('Error exporting text: $e');
    rethrow;
  }
}

Future<String?> _exportAsSeparateFiles(List<Map<String, dynamic>> items) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export/separate_${DateTime.now().millisecondsSinceEpoch}');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    for (final item in items) {
      try {
        final content = item['content']?.toString() ?? '';
        final type = item['type'] as String? ?? 'text';
        final timestamp = item['timestamp'] as int? ?? 0;
        final fileInfo = item['file_info'] as Map<String, dynamic>?;
        
        String extension = '.txt';
        String filename = 'item_${items.indexOf(item)}';
        
        switch (type) {
          case 'image':
            // Копируем файл изображения как есть
            final sourceFile = File(content);
            if (await sourceFile.exists()) {
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              final targetFile = File('${exportDir.path}/$originalName');
              await sourceFile.copy(targetFile.path);
              print('Copied image: ${sourceFile.path} -> ${targetFile.path} (${sourceFile.lengthSync()} bytes)');
            }
            break;
            
          case 'file':
            // Копируем файл как есть
            final sourceFile = File(content);
            if (await sourceFile.exists()) {
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              final targetFile = File('${exportDir.path}/$originalName');
              await sourceFile.copy(targetFile.path);
            }
            break;
            
          default:
            // Текстовые данные
            switch (type) {
              case 'code': extension = '.txt'; break;
              case 'html': extension = '.html'; break;
              case 'url': extension = '.url.txt'; break;
            }
            final file = File('${exportDir.path}/$filename$extension');
            await file.writeAsString(content, encoding: utf8);
            break;
        }
      } catch (e) {
        print('Error exporting separate file: $e');
      }
    }

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Файлы экспортированы: ${exportDir.path}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );
    
    return exportDir.path;
  } catch (e) {
    print('Error exporting separate files: $e');
    rethrow;
  }
}

Future<String?> _exportAsImage(List<Map<String, dynamic>> items) async {
  try {
    final imageItems = items.where((item) => 
      item['type'] == 'image' || item['type'] == 'image_url'
    ).toList();

    if (imageItems.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('Нет изображений для экспорта'),
          backgroundColor: Colors.orange,
          duration: const Duration(seconds: 3),
        ),
      );
      return null;
    }

    // Загружаем все изображения
    final List<img.Image> loadedImages = [];
    final List<String> imageSources = [];

    for (final item in imageItems) {
      try {
        final content = item['content']?.toString() ?? '';
        final type = item['type'] as String? ?? 'text';
        
        img.Image? image;
        
        if (type == 'image_url') {
          // Загрузка по URL
          final response = await http.get(Uri.parse(content));
          if (response.statusCode == 200) {
            image = img.decodeImage(response.bodyBytes);
          }
        } else if (type == 'image') {
          // Загрузка из файла
          final file = File(content);
          if (await file.exists()) {
            final bytes = await file.readAsBytes();
            image = img.decodeImage(bytes);
          }
        }
        
        if (image != null) {
          loadedImages.add(image);
          imageSources.add(content);
        }
      } catch (e) {
        print('Error loading image: $e');
      }
    }

    if (loadedImages.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('Не удалось загрузить изображения'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
      return null;
    }

    // Анализируем изображения и создаем коллаж
    final img.Image collage = await _createCollage(loadedImages);
    
    // Сохраняем коллаж
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final outputFile = File('${exportDir.path}/collage_$timestamp.png');
    
    // Сохраняем как PNG
    final pngBytes = img.encodePng(collage);
    await outputFile.writeAsBytes(pngBytes);

    // Копируем в буфер обмена
    await _copyImageToClipboard(pngBytes);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Коллаж создан: ${outputFile.path}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );

    return outputFile.path;

  } catch (e) {
    print('Error creating image collage: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Ошибка создания коллажа: $e'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
    return null;
  }
}

Future<img.Image> _createCollage(List<img.Image> images) async {
  if (images.length == 1) {
    // Если одно изображение - просто возвращаем его
    return images.first;
  }

  // Анализируем размеры и ориентации изображений
  final List<ImageInfo> imageInfos = [];
  int totalWidth = 0;
  int totalHeight = 0;
  bool allLandscape = true;
  bool allPortrait = true;
  bool allSameSize = true;
  int firstWidth = images.first.width;
  int firstHeight = images.first.height;

  for (final image in images) {
    final bool isLandscape = image.width >= image.height;
    final bool isPortrait = image.height > image.width;
    
    imageInfos.add(ImageInfo(
      image: image,
      width: image.width,
      height: image.height,
      isLandscape: isLandscape,
      isPortrait: isPortrait,
      aspectRatio: image.width / image.height
    ));

    allLandscape = allLandscape && isLandscape;
    allPortrait = allPortrait && isPortrait;
    allSameSize = allSameSize && 
                  image.width == firstWidth && 
                  image.height == firstHeight;
  }

  // Определяем стратегию компоновки
  CollageStrategy strategy;
  
  if (allLandscape && allSameSize) {
    // Все изображения альбомные и одинакового размера - горизонтальный ряд
    strategy = _createHorizontalRowStrategy(images, 1920, 1080);
  } else if (allPortrait && allSameSize) {
    // Все изображения портретные и одинакового размера - вертикальная колонка
    strategy = _createVerticalColumnStrategy(images, 1080, 1920);
  } else if (allLandscape) {
    // Все альбомные, но разных размеров - адаптивная сетка
    strategy = _createAdaptiveGridStrategy(images, 1920, 1080, true);
  } else if (allPortrait) {
    // Все портретные, но разных размеров - адаптивная сетка
    strategy = _createAdaptiveGridStrategy(images, 1080, 1920, false);
  } else {
    // Смешанные ориентации - интеллектуальная компоновка
    strategy = _createMixedOrientationStrategy(images, 1920, 1080);
  }

  // Создаем холст
  final canvas = img.Image(
    width: strategy.canvasWidth,
    height: strategy.canvasHeight,
  );

  // Рисуем изображения на холсте
  for (final placement in strategy.placements) {
    final resizedImage = img.copyResize(
      placement.image,
      width: placement.width,
      height: placement.height,
    );
    
    img.compositeImage(
      canvas,
      resizedImage,
      dstX: placement.x,
      dstY: placement.y,
    );
  }

  return canvas;
}

Future<void> _copyImageToClipboard(List<int> imageBytes) async {
  try {
    if (Platform.isWindows) {
      await _copyImageToClipboardWindows(imageBytes);
    } else {
      // Для других платформ пока просто сохраняем путь
      final tempDir = await getTemporaryDirectory();
      final tempFile = File('${tempDir.path}/clipboard_image.png');
      await tempFile.writeAsBytes(imageBytes);
      
      await Clipboard.setData(ClipboardData(text: tempFile.path));
    }
  } catch (e) {
    print('Error copying image to clipboard: $e');
    // Fallback - копируем как текст
    await Clipboard.setData(ClipboardData(text: 'Изображение создано, но не скопировано в буфер'));
  }
}

Future<void> _copyImageToClipboardWindows(List<int> imageBytes) async {
  try {
    final powerShellScript = '''
      Add-Type -AssemblyName System.Windows.Forms
      Add-Type -AssemblyName System.Drawing
      
      \$memoryStream = New-Object System.IO.MemoryStream
      \$memoryStream.Write([byte[]] @(${imageBytes.join(',')}), 0, ${imageBytes.length})
      \$memoryStream.Seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
      
      \$bitmap = [System.Drawing.Bitmap]::FromStream(\$memoryStream)
      [System.Windows.Forms.Clipboard]::SetImage(\$bitmap)
      
      \$bitmap.Dispose()
      \$memoryStream.Dispose()
    ''';

    final result = await Process.run('powershell', [
      '-NoProfile',
      '-ExecutionPolicy', 
      'Bypass',
      '-Command',
      powerShellScript
    ]);

    if (result.stderr != null && result.stderr.toString().isNotEmpty) {
      print('PowerShell error: ${result.stderr}');
      throw Exception('PowerShell execution failed');
    }
  } catch (e) {
    print('Error in Windows image copy: $e');
    rethrow;
  }
}
Future<String?> _exportAsHtml(List<Map<String, dynamic>> items) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export/html_${DateTime.now().millisecondsSinceEpoch}');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final htmlBuffer = StringBuffer();
    htmlBuffer.writeln('<!DOCTYPE html>');
    htmlBuffer.writeln('<html lang="ru">');
    htmlBuffer.writeln('<head>');
    htmlBuffer.writeln('<meta charset="UTF-8">');
    htmlBuffer.writeln('<meta name="viewport" content="width=device-width, initial-scale=1.0">');
    htmlBuffer.writeln('<title>QWA Clipboard Export</title>');
    htmlBuffer.writeln(_htmlCss);
    htmlBuffer.writeln('</head>');
    htmlBuffer.writeln('<body>');
    
    htmlBuffer.writeln('<div class="header">');
    htmlBuffer.writeln('<h1>Clipboard Export</h1>');
    htmlBuffer.writeln('<p>Создано: ${DateTime.now()}</p>');
    htmlBuffer.writeln('</div>');

    for (final item in items) {
      final type = item['type'] as String? ?? 'text';
      final content = item['content']?.toString() ?? '';
      final timestamp = item['timestamp'] as int? ?? 0;

      switch (type) {
        case 'text':
        case 'email':
        case 'url':
          htmlBuffer.writeln('<div class="text-block">');
          htmlBuffer.writeln(content);
          htmlBuffer.writeln('<div class="timestamp">${_formatDate(timestamp)} ${_formatTime(timestamp)}</div>');
          htmlBuffer.writeln('</div>');
          break;
        
        case 'code':
        case 'html':
          htmlBuffer.writeln('<div class="code-block">');
          htmlBuffer.writeln(content);
          htmlBuffer.writeln('<div class="timestamp">${_formatDate(timestamp)} ${_formatTime(timestamp)}</div>');
          htmlBuffer.writeln('</div>');
          break;
        
        case 'image':
        case 'image_url':
          htmlBuffer.writeln('<div class="image-block">');
          // Для реальных изображений нужно конвертировать в base64
          htmlBuffer.writeln('<img src="$content" alt="Image">');
          htmlBuffer.writeln('<div class="image-caption">${_formatDate(timestamp)} ${_formatTime(timestamp)}</div>');
          htmlBuffer.writeln('</div>');
          break;
      }
    }

    htmlBuffer.writeln('</body>');
    htmlBuffer.writeln('</html>');

    final htmlFile = File('${exportDir.path}/export.html');
    await htmlFile.writeAsString(htmlBuffer.toString(), encoding: utf8);

    // Копируем HTML в буфер обмена
    await Clipboard.setData(ClipboardData(text: htmlBuffer.toString()));

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('HTML экспортирован: ${htmlFile.path}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );
    
    return htmlFile.path;
  } catch (e) {
    print('Error exporting HTML: $e');
    rethrow;
  }
}
Future<String?> _exportAsArchive(List<Map<String, dynamic>> items) async {
  try {
    if (items.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('Нет элементов для архивации'),
          backgroundColor: Colors.orange,
          duration: const Duration(seconds: 3),
        ),
      );
      return null;
    }

    final archive = Archive();
    int addedFiles = 0;

    // Обрабатываем каждый элемент
    for (final item in items) {
      try {
        final content = item['content']?.toString() ?? '';
        final type = item['type'] as String? ?? 'text';
        final timestamp = item['timestamp'] as int? ?? DateTime.now().millisecondsSinceEpoch;
        final fileInfo = item['file_info'] as Map<String, dynamic>?;

        switch (type) {
          case 'text':
          case 'code':
          case 'html':
          case 'email':
          case 'url':
          case 'document_url':
          case 'image_url':
          case 'keyboard':
            // Текстовые данные
            final extension = _getFileExtension(type);
            final filename = 'text_${items.indexOf(item)}_$timestamp$extension';
            final data = utf8.encode(content);
            archive.addFile(ArchiveFile(filename, data.length, data));
            addedFiles++;
            break;

          case 'image':
            // Локальные изображения - читаем как бинарные данные
            final file = File(content);
            if (await file.exists()) {
              final bytes = await file.readAsBytes();
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              final filename = 'image_${items.indexOf(item)}_$originalName';
              archive.addFile(ArchiveFile(filename, bytes.length, bytes));
              addedFiles++;
              print('Added image to archive: $filename (${bytes.length} bytes)');
            }
            break;

          case 'file':
            // Файлы из файловой системы
            final file = File(content);
            if (await file.exists()) {
              final bytes = await file.readAsBytes();
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              final filename = 'file_${items.indexOf(item)}_$originalName';
              archive.addFile(ArchiveFile(filename, bytes.length, bytes));
              addedFiles++;
              print('Added file to archive: $filename (${bytes.length} bytes)');
            }
            break;

          default:
            // Неизвестный тип - сохраняем как текст
            final filename = 'unknown_${items.indexOf(item)}_$timestamp.txt';
            final data = utf8.encode('Type: $type\nContent: $content');
            archive.addFile(ArchiveFile(filename, data.length, data));
            addedFiles++;
            break;
        }
      } catch (e) {
        print('Error processing item for archive: $e');
      }
    }

    if (addedFiles == 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('Не удалось добавить файлы в архив'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
      return null;
    }

    // Сохраняем архив
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final zipFile = File('${exportDir.path}/archive_$timestamp.zip');
    
    // Кодируем архив в ZIP
    final zipData = ZipEncoder().encode(archive);
    if (zipData != null) {
      await zipFile.writeAsBytes(zipData);
      print('Archive created: ${zipFile.path} (${zipData.length} bytes)');

      // Копируем путь к архиву в буфер обмена
      await Clipboard.setData(ClipboardData(text: zipFile.path));

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Архив создан: $addedFiles файлов\n${zipFile.path}'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 4),
        ),
      );
      
      return zipFile.path;
    } else {
      throw Exception('Failed to encode ZIP archive');
    }

  } catch (e) {
    print('Error creating archive: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Ошибка создания архива: $e'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
    return null;
  }
}

String _getFileExtension(String type) {
  switch (type) {
    case 'code':
      return '.txt';
    case 'html':
      return '.html';
    case 'url':
    case 'document_url':
    case 'image_url':
      return '.url.txt';
    case 'email':
      return '.email.txt';
    case 'keyboard':
      return '.keyboard.txt';
    default:
      return '.txt';
  }
}
Future<void> _openResultFile(String filePath, String exportType) async {
  try {
    if (exportType == 'html') {
      // Открываем HTML в браузере
      if (await canLaunch(filePath)) {
        await launch(filePath);
      } else {
        // Если не получается открыть как файл, пробуем как file:// URL
        await launch('file://$filePath');
      }
    } else if (exportType == 'text') {
      // Открываем текстовой файл
      if (Platform.isWindows) {
        await Process.run('notepad', [filePath], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', ['-t', filePath]);
      } else if (Platform.isLinux) {
        await Process.run('xdg-open', [filePath]);
      }
    } else if (exportType == 'image') {
      // Открываем изображение в стандартном просмотрщике
      if (Platform.isWindows) {
        await Process.run('start', ['""', filePath], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', [filePath]);
      } else if (Platform.isLinux) {
        await Process.run('xdg-open', [filePath]);
      }
    } else if (exportType == 'archive' || exportType == 'separate') {
      // Открываем папку и выделяем файл/папку
      final directory = path.dirname(filePath);
      if (Platform.isWindows) {
        await Process.run('explorer', ['/select,', filePath], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', ['-R', filePath]);
      } else if (Platform.isLinux) {
        await Process.run('xdg-open', [directory]);
      }
    }
  } catch (e) {
    print('Error opening result file: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Файл создан, но не удалось открыть: $e'),
        backgroundColor: Colors.orange,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

void _ensureDirectoryInArchive(Archive archive, String directoryPath) {
  final parts = directoryPath.split('/');
  String currentPath = '';
  
  for (final part in parts) {
    if (part.isEmpty) continue;
    
    currentPath = currentPath.isEmpty ? part : '$currentPath/$part';
    
    // Проверяем, существует ли уже такая директория
    final exists = archive.files.any((file) => 
      file.name == '$currentPath/' || file.name.startsWith('$currentPath/')
    );
    
    if (!exists) {
      // Добавляем запись директории
      archive.addFile(ArchiveFile('$currentPath/', 0, []));
    }
  }
}

// Дополнительный метод для создания архива с метаданными
Future<void> _exportAsArchiveWithMetadata(List<Map<String, dynamic>> items) async {
  try {
    final archive = Archive();
    int addedFiles = 0;

    // Добавляем файл с метаданными
    final metadata = StringBuffer();
    metadata.writeln('QWA Clipboard Export Archive');
    metadata.writeln('Created: ${DateTime.now()}');
    metadata.writeln('Total items: ${items.length}');
    metadata.writeln('\n=== Items List ===');
    
    for (final item in items) {
      final index = items.indexOf(item);
      final type = item['type'] as String? ?? 'text';
      final timestamp = item['timestamp'] as int? ?? 0;
      final starred = item['starred'] as bool? ?? false;
      
      metadata.writeln('\nItem $index:');
      metadata.writeln('  Type: $type');
      metadata.writeln('  Date: ${_formatDate(timestamp)} ${_formatTime(timestamp)}');
      metadata.writeln('  Starred: $starred');
      metadata.writeln('  Source: ${item['source']}');
      
      if (type == 'file') {
        final fileInfo = item['file_info'] as Map<String, dynamic>?;
        metadata.writeln('  File: ${fileInfo?['name'] ?? item['content']}');
        if (fileInfo?['size'] != null) {
          metadata.writeln('  Size: ${_formatFileSize(fileInfo!['size'])}');
        }
      } else {
        final content = item['content']?.toString() ?? '';
        final preview = content.length > 100 ? 
            '${content.substring(0, 100)}...' : content;
        metadata.writeln('  Preview: $preview');
      }
    }

    final metadataBytes = utf8.encode(metadata.toString());
    archive.addFile(ArchiveFile('metadata.txt', metadataBytes.length, metadataBytes));
    addedFiles++;

    // Добавляем остальные файлы (как в основном методе)
    for (final item in items) {
      try {
        final content = item['content']?.toString() ?? '';
        final type = item['type'] as String? ?? 'text';
        final timestamp = item['timestamp'] as int? ?? DateTime.now().millisecondsSinceEpoch;
        final fileInfo = item['file_info'] as Map<String, dynamic>?;

        String filename;
        List<int> data;

        switch (type) {
          case 'text':
          case 'code':
          case 'html':
          case 'email':
          case 'url':
          case 'document_url':
          case 'image_url':
          case 'keyboard':
            final extension = _getFileExtension(type);
            filename = 'items/item_${items.indexOf(item)}$extension';
            data = utf8.encode(content);
            break;

          case 'image':
            final file = File(content);
            if (await file.exists()) {
              data = await file.readAsBytes();
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              filename = 'images/$originalName';
            } else {
              continue;
            }
            break;

          case 'file':
            final file = File(content);
            if (await file.exists()) {
              data = await file.readAsBytes();
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              filename = 'files/$originalName';
            } else {
              continue;
            }
            break;

          default:
            filename = 'unknown/item_${items.indexOf(item)}.txt';
            data = utf8.encode('Type: $type\nContent: $content');
            break;
        }

        // Создаем директории если нужно
        final dirPath = path.dirname(filename);
        if (dirPath.isNotEmpty && dirPath != '.') {
          _ensureDirectoryInArchive(archive, dirPath);
        }

        archive.addFile(ArchiveFile(filename, data.length, data));
        addedFiles++;

      } catch (e) {
        print('Error processing item for archive: $e');
      }
    }

    if (addedFiles == 0) {
      throw Exception('No files were added to archive');
    }

    // Сохраняем архив
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final zipFile = File('${exportDir.path}/archive_${timestamp}_with_metadata.zip');
    
    final zipData = ZipEncoder().encode(archive);
    if (zipData != null) {
      await zipFile.writeAsBytes(zipData);
      await Clipboard.setData(ClipboardData(text: zipFile.path));

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Архив с метаданными создан: $addedFiles файлов'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 4),
        ),
      );
    }

  } catch (e) {
    print('Error creating archive with metadata: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Ошибка создания архива: $e'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

String _formatFileSize(dynamic size) {
  try {
    final bytes = size is int ? size : int.tryParse(size.toString()) ?? 0;
    if (bytes == 0) return '0 B';
    
    const units = ['B', 'KB', 'MB', 'GB'];
    var unitIndex = 0;
    double value = bytes.toDouble();
    
    while (value >= 1024 && unitIndex < units.length - 1) {
      value /= 1024;
      unitIndex++;
    }
    
    return '${value.toStringAsFixed(1)} ${units[unitIndex]}';
  } catch (e) {
    return 'Unknown';
  }
}

Widget _buildHistoryItem(Map<String, dynamic> item) {
  return HistoryItemWidget(
    item: item,
    isSelected: _isSelected(item),
    onCopy: () => _copyToClipboard(item),
    onLongPress: () {
      final type = item['type'] as String? ?? 'text';
      if (type == 'text' || type == 'code') {
        setState(() {
          _expandedItem = item;
        });
      } else {
        _openItem(item);
      }
    },
    onToggleSelection: () => _toggleSelection(item),
    onToggleStar: () => _toggleStar(item),
    onDelete: () => _deleteItem(item),
    showExportOptions: _showExportOptions,
  );
}

// Вспомогательный метод для получения файла изображения
Future<File> _getImageFile(String content, Map<String, dynamic>? fileInfo) async {
  try {
    final file = File(content);
    if (await file.exists()) {
      return file;
    } else {
      // Если файл не найден, создаем временный файл из base64 или других данных
      throw Exception('File not found');
    }
  } catch (e) {
    throw Exception('Failed to load image: $e');
  }
}

  Widget _buildExpandedView() {
    if (_expandedItem == null) return const SizedBox.shrink();

    final content = _expandedItem!['content']?.toString() ?? '';
    final timestamp = _expandedItem!['timestamp'] as int? ?? 0;
    final type = _expandedItem!['type'] as String? ?? 'text';

    return Positioned.fill(
      child: Container(
        color: Colors.black.withOpacity(0.9),
        child: Column(
          children: [
            // Заголовок
            Container(
              height: 60,
              padding: const EdgeInsets.symmetric(horizontal: 16),
              decoration: BoxDecoration(
                color: const Color(0xFF1A1A1A).withOpacity(0.9),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12),
                ),
              ),
              child: Row(
                children: [
                  IconButton(
                    icon: const Icon(Icons.arrow_back, color: Colors.white),
                    onPressed: () {
                      setState(() {
                        _expandedItem = null;
                      });
                    },
                  ),
                  const SizedBox(width: 12),
                  Text(
                    type == 'code' ? 'Просмотр кода' : 'Полный текст',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  Text(
                    '${_formatDate(timestamp)} ${_formatTime(timestamp)}',
                    style: const TextStyle(color: Colors.white70),
                  ),
                ],
              ),
            ),
            // Контент
            Expanded(
              child: Container(
                padding: const EdgeInsets.all(16),
                child: SingleChildScrollView(
                  child: type == 'code' 
                      ? SelectableText(
                          content,
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                            fontFamily: 'Monospace',
                          ),
                        )
                      : SelectableText(
                          content,
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                          ),
                        ),
                ),
              ),
            ),
            // Кнопки
            Container(
              padding: const EdgeInsets.all(16),
              child: Row(
                children: [
                  Expanded(
                    child: ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.blue,
                        foregroundColor: Colors.white,
                      ),
                      onPressed: () => _copyToClipboard(_expandedItem!),
                      child: const Text('Копировать'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.grey,
                        foregroundColor: Colors.white,
                      ),
                      onPressed: () {
                        setState(() {
                          _expandedItem = null;
                        });
                      },
                      child: const Text('Закрыть'),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSearchField() {
    return Container(
      padding: const EdgeInsets.all(16),
      color: const Color(0xFF1A1A1A).withOpacity(0.7),
      child: TextField(
        controller: _searchController,
        style: const TextStyle(color: Colors.white, fontSize: 14),
        decoration: InputDecoration(
          hintText: 'Поиск в истории...',
          hintStyle: const TextStyle(color: Colors.white54, fontSize: 14),
          filled: true,
          fillColor: const Color(0xFF2B2B2B).withOpacity(0.8),
          prefixIcon: const Icon(Icons.search, color: Colors.white54),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(20),
            borderSide: BorderSide.none,
          ),
          contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      height: 60,
      decoration: BoxDecoration(
        color: const Color(0xFF1A1A1A).withOpacity(0.9),
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(12),
        ),
      ),
      child: Row(
        children: [
          // Кнопка Compose
          if (_selectedItems.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: MouseRegion(
                cursor: SystemMouseCursors.click,
                child: GestureDetector(
                  onTap: _executeCompose,
                  child: Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: Colors.blue.withOpacity(0.7),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.get_app_outlined, color: Colors.white, size: 20),
                  ),
                ),
              ),
            ),
          // Кнопка Clear Selection
          if (_selectedItems.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: MouseRegion(
                cursor: SystemMouseCursors.click,
                child: GestureDetector(
                  onTap: () {
                    setState(() {
                      _selectedItems.clear();
                      _showExportOptions = false;
                    });
                  },
                  child: Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: Colors.grey.withOpacity(0.7),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.clear, color: Colors.white, size: 20),
                  ),
                ),
              ),
            ),
          // Кнопка Clear All
          Padding(
            padding: const EdgeInsets.only(left: 8),
            child: MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: _clearAllHistory,
                child: Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    color: Colors.red.withOpacity(0.7),
                    shape: BoxShape.circle,
                  ),
                  child: const Icon(Icons.delete_forever, color: Colors.white, size: 20),
                ),
              ),
            ),
          ),
          const Spacer(),
          // Заголовок
          Text(
            _currentTab == 0 ? '📋 История буфера обмена' : '⭐ Избранное',
            style: const TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const Spacer(),
          // Кнопка закрытия
          Padding(
            padding: const EdgeInsets.only(right: 16),
            child: MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: () => windowManager.close(),
                child: Container(
                  width: 35,
                  height: 35,
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.7),
                    shape: BoxShape.circle,
                  ),
                  child: const Icon(Icons.close, color: Colors.white, size: 18),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTabBar() {
    return Container(
      color: const Color(0xFF1A1A1A).withOpacity(0.8),
      child: Row(
        children: [
          Expanded(
            child: TextButton(
              style: TextButton.styleFrom(
                backgroundColor: _currentTab == 0 ? const Color(0xFF2B2B2B).withOpacity(0.8) : Colors.transparent,
                shape: const RoundedRectangleBorder(),
                padding: const EdgeInsets.symmetric(vertical: 12),
              ),
              onPressed: () {
                setState(() {
                  _currentTab = 0;
                  _filterHistory();
                });
              },
              child: Text(
                'Все',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 14,
                ),
              ),
            ),
          ),
          Expanded(
            child: TextButton(
              style: TextButton.styleFrom(
                backgroundColor: _currentTab == 1 ? const Color(0xFF2B2B2B).withOpacity(0.8) : Colors.transparent,
                shape: const RoundedRectangleBorder(),
                padding: const EdgeInsets.symmetric(vertical: 12),
              ),
              onPressed: () {
                setState(() {
                  _currentTab = 1;
                  _filterHistory();
                });
              },
              child: Text(
                'Избранное',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 14,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
Widget _buildExportOptions() {
  if (!_showExportOptions) return const SizedBox.shrink();

  final selectedItems = _clipboardHistory.where(
    (item) => _selectedItems.contains(item['filePath']?.toString() ?? '')
  ).toList();

  final hasImages = selectedItems.any((item) => item['type'] == 'image' || item['type'] == 'image_url');
  final hasText = selectedItems.any((item) => item['type'] == 'text' || item['type'] == 'code' || item['type'] == 'html');
  final hasFiles = selectedItems.any((item) => item['type'] == 'file');

  return Container(
    height: 60, // Фиксированная высота
    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
    color: const Color(0xFF1A1A1A).withOpacity(0.9),
    child: Row(
      children: [
        Expanded(
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children: [
                _buildExportOption('simple', 'auto', true, Colors.grey),
                const SizedBox(width: 6),
                if (hasImages) _buildExportOption('IMG', 'image', hasImages, Colors.pink),
                if (hasImages) const SizedBox(width: 6),
                if (hasText) _buildExportOption('TXT', 'text', hasText, Colors.green),
                if (hasText) const SizedBox(width: 6),
                if (hasImages || hasText) _buildExportOption('WEB', 'html', hasImages || hasText, Colors.blue),
                if (hasImages || hasText) const SizedBox(width: 6),
                if (hasFiles) _buildExportOption('ZIP', 'archive', hasFiles, Colors.orange),
                if (hasFiles) const SizedBox(width: 6),
                _buildExportOption('Plain', 'separate', true, Colors.purple),
              ],
            ),
          ),
        ),
        const SizedBox(width: 12),
        // Кнопка Process
        MouseRegion(
          cursor: SystemMouseCursors.click,
          child: GestureDetector(
            onTap: _executeCompose,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: Colors.blue,
                borderRadius: BorderRadius.circular(20),
              ),
              child: Text(
                'Process',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 11,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ),
      ],
    ),
  );
}

Widget _buildExportOption(String label, String value, bool enabled, Color color) {
  final isSelected = _exportMode == value;
  return FilterChip(
    label: Text(
      label,
      style: TextStyle(
        color: isSelected ? Colors.white : Colors.white70,
        fontSize: 9, // Уменьшенный шрифт
      ),
    ),
    selected: isSelected,
    onSelected: enabled ? (selected) {
      setState(() {
        _exportMode = value;
      });
    } : null,
    backgroundColor:  Colors.grey[600],
    selectedColor: color,
    checkmarkColor: Colors.white,
    disabledColor: Colors.grey[600],
    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
  );
}

  Widget _buildContent() {
    if (_isLoading) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(color: Colors.white),
            SizedBox(height: 16),
            Text(
              'Загрузка истории...',
              style: TextStyle(color: Colors.white, fontSize: 16),
            ),
          ],
        ),
      );
    }

    if (_filteredHistory.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              _currentTab == 0 ? Icons.content_paste : Icons.star,
              size: 64, 
              color: Colors.white54
            ),
            const SizedBox(height: 16),
            Text(
              _clipboardHistory.isEmpty 
                  ? 'История буфера обмена пуста'
                  : _currentTab == 1 
                    ? 'Нет избранных элементов'
                    : 'Ничего не найдено',
              style: const TextStyle(color: Colors.white, fontSize: 16),
            ),
            const SizedBox(height: 8),
            Text(
              _clipboardHistory.isEmpty
                  ? 'Скопируйте текст в буфер обмена'
                  : 'Попробуйте изменить запрос поиска',
              style: const TextStyle(color: Colors.white54, fontSize: 14),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: 8),
      itemCount: _filteredHistory.length,
      itemBuilder: (context, index) {
        return _buildHistoryItem(_filteredHistory[index]);
      },
    );
  }

  String _formatTime(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.day.toString().padLeft(2, '0')}.${date.month.toString().padLeft(2, '0')}.${date.year}';
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      home: Scaffold(
        backgroundColor: Colors.transparent,
        body: Stack(
          children: [
            // Background
            if (_backgroundImage != null)
              Positioned.fill(
                child: Image.file(
                  _backgroundImage!,
                  fit: BoxFit.cover,
                ),
              ),
            
            // Main content
            Container(
              width: 400,
              height: MediaQuery.of(context).size.height,
              margin: const EdgeInsets.only(right: 0),
              decoration: BoxDecoration(
                color: const Color(0xFF2B2B2B).withOpacity(0.95),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12),
                  bottomLeft: Radius.circular(12),
                ),
              ),
              child: Column(
                children: [
                  _buildHeader(),
                  _buildTabBar(),
                  _buildSearchField(),
                  _buildExportOptions(),
                  Expanded(
                    child: _buildContent(),
                  ),
                ],
              ),
            ),

            // Expanded view
            if (_expandedItem != null)
              _buildExpandedView(),
          ],
        ),
      ),
    );
  }
}
class HistoryItemWidget extends StatefulWidget {
  final Map<String, dynamic> item;
  final bool isSelected;
  final VoidCallback onCopy;
  final VoidCallback onLongPress;
  final VoidCallback onToggleSelection;
  final VoidCallback onToggleStar;
  final VoidCallback onDelete;
  final bool showExportOptions;

  const HistoryItemWidget({
    Key? key,
    required this.item,
    required this.isSelected,
    required this.onCopy,
    required this.onLongPress,
    required this.onToggleSelection,
    required this.onToggleStar,
    required this.onDelete,
    required this.showExportOptions,
  }) : super(key: key);

  @override
  State<HistoryItemWidget> createState() => _HistoryItemWidgetState();
}

class _HistoryItemWidgetState extends State<HistoryItemWidget> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final item = widget.item;
    final content = item['content']?.toString() ?? '';
    final timestamp = item['timestamp'] as int? ?? 0;
    final isStarred = item['starred'] as bool? ?? false;
    final type = item['type'] as String? ?? 'text';
    final fileInfo = item['file_info'] as Map<String, dynamic>?;
    final isSelected = widget.isSelected;
    final borderColor = _getTypeBorderColor(type);
    
    String displayText;
    String typeText = _getTypeDisplayName(type);
    IconData leadingIcon;
    Color backgroundColor = const Color(0xFF2B2B2B).withOpacity(0.8);
    
    // Переменные для превью изображения
    Widget? imagePreview;
    bool showImagePreview = false;
    bool isImageFile = false;
    
    switch (type) {
      case 'file':
        final fileName = fileInfo?['name']?.toString() ?? path.basename(content);
        displayText = fileName;
        leadingIcon = fileInfo?['is_directory'] as bool? ?? false ? Icons.folder : Icons.insert_drive_file;
        
        // Проверяем, является ли файл изображением
        final fileExtension = path.extension(content).toLowerCase();
        if (fileExtension == '.png' || fileExtension == '.jpg' || fileExtension == '.jpeg') {
          isImageFile = true;
          showImagePreview = true;
          typeText = 'Image';
          leadingIcon = Icons.image;
          
          // Создаем превью для файла изображения
          imagePreview = Container(
            height: 150,
            width: double.infinity,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(4),
              color: Colors.grey[800],
            ),
            child: FutureBuilder<File>(
              future: Future.value(File(content)),
              builder: (context, snapshot) {
                if (snapshot.hasData && snapshot.data != null) {
                  return ClipRRect(
                    borderRadius: BorderRadius.circular(4),
                    child: Image.file(
                      snapshot.data!,
                      fit: BoxFit.cover,
                      errorBuilder: (context, error, stackTrace) {
                        return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                      },
                    ),
                  );
                } else if (snapshot.hasError) {
                  return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                } else {
                  return Center(child: CircularProgressIndicator(color: Colors.white54));
                }
              },
            ),
          );
        }
        break;
      case 'image_url':
      case 'image':
        displayText = type == 'image' ? 'Image: ${fileInfo?['name'] ?? 'From Clipboard'}' : 'Image URL: $content';
        leadingIcon = Icons.image;
        showImagePreview = true;
        
        // Создаем превью для изображения
        if (type == 'image_url') {
          // Для URL изображения
          imagePreview = Container(
            height: 150,
            width: double.infinity,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(4),
              color: Colors.grey[800],
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: Image.network(
                content,
                fit: BoxFit.cover,
                loadingBuilder: (context, child, loadingProgress) {
                  if (loadingProgress == null) return child;
                  return Center(
                    child: CircularProgressIndicator(
                      value: loadingProgress.expectedTotalBytes != null
                          ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes!
                          : null,
                    ),
                  );
                },
                errorBuilder: (context, error, stackTrace) {
                  return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                },
              ),
            ),
          );
        } else if (type == 'image') {
          // Для локального изображения
          imagePreview = Container(
            height: 150,
            width: double.infinity,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(4),
              color: Colors.grey[800],
            ),
            child: FutureBuilder<File>(
              future: _getImageFile(content, fileInfo),
              builder: (context, snapshot) {
                if (snapshot.hasData && snapshot.data != null) {
                  return ClipRRect(
                    borderRadius: BorderRadius.circular(4),
                    child: Image.file(
                      snapshot.data!,
                      fit: BoxFit.cover,
                      errorBuilder: (context, error, stackTrace) {
                        return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                      },
                    ),
                  );
                } else if (snapshot.hasError) {
                  return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                } else {
                  return Center(child: CircularProgressIndicator(color: Colors.white54));
                }
              },
            ),
          );
        }
        break;
      case 'url':
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.link;
        break;
      case 'document_url':
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.description;
        break;
      case 'email':
        displayText = content;
        leadingIcon = Icons.email;
        break;
      case 'code':
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.code;
        break;
      case 'html':
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.web;
        break;
      default:
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.text_fields;
        break;
    }

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 16),
        child: Stack(
          children: [
            GestureDetector(
              onTap: widget.onCopy,
              onLongPress: widget.onLongPress,
              child: Card(
                color: backgroundColor,
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                  side: BorderSide(
                    color: isSelected ? Colors.blue : borderColor,
                    width: isSelected ? 2 : 1,
                  ),
                ),
                child: Container(
                  padding: const EdgeInsets.all(12),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Иконка и тип
                      Column(
                        children: [
                          CircleAvatar(
                            backgroundColor: Colors.blueGrey[700],
                            radius: 20,
                            child: Icon(
                              leadingIcon,
                              size: 20,
                              color: Colors.white,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            typeText,
                            style: TextStyle(
                              color: Colors.white70,
                              fontSize: 10,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(width: 12),
                      // Контент
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            if (showImagePreview && imagePreview != null)
                              Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  imagePreview,
                                  const SizedBox(height: 8),
                                  Text(
                                    isImageFile ? 'Image File: ${path.basename(content)}' : displayText,
                                    style: const TextStyle(
                                      color: Colors.white,
                                      fontSize: 12,
                                    ),
                                    maxLines: 2,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ],
                              )
                            else
                              Text(
                                displayText,
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 12,
                                ),
                                maxLines: 3,
                                overflow: TextOverflow.ellipsis,
                              ),
                            const SizedBox(height: 4),
                            Text(
                              '${_formatDate(timestamp)} ${_formatTime(timestamp)} • ${content.length} символов',
                              style: TextStyle(
                                color: Colors.white54,
                                fontSize: 10,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
            // Кнопка выбора для compose (видна при hover или если выбрана)
            if (_isHovered || isSelected)
              Positioned(
                top: 8,
                left: 8,
                child: MouseRegion(
                  cursor: SystemMouseCursors.click,
                  child: GestureDetector(
                    onTap: widget.onToggleSelection,
                    child: Container(
                      width: 25,
                      height: 25,
                      decoration: BoxDecoration(
                        color: isSelected ? Colors.blue : Colors.black.withOpacity(0.8),
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 1),
                      ),
                      child: isSelected 
                          ? const Icon(Icons.check, size: 14, color: Colors.white)
                          : const Icon(Icons.add, size: 14, color: Colors.white),
                    ),
                  ),
                ),
              ),
            // Кнопки звездочки и удаления (видны только при hover)
            if (_isHovered)
              Positioned(
                top: 8,
                right: 8,
                child: MouseRegion(
                  cursor: SystemMouseCursors.click,
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Звездочка (видна всегда если избранное, и при hover)
                      GestureDetector(
                        onTap: widget.onToggleStar,
                        child: Container(
                          width: 25,
                          height: 25,
                          decoration: BoxDecoration(
                            color: Colors.black.withOpacity(0.8),
                            shape: BoxShape.circle,
                          ),
                          child: Icon(
                            isStarred ? Icons.star : Icons.star_border,
                            color: isStarred ? Colors.amber : Colors.white,
                            size: 14,
                          ),
                        ),
                      ),
                      const SizedBox(width: 4),
                      // Крестик (виден только при hover)
                      GestureDetector(
                        onTap: widget.onDelete,
                        child: Container(
                          width: 25,
                          height: 25,
                          decoration: BoxDecoration(
                            color: Colors.black.withOpacity(0.8),
                            shape: BoxShape.circle,
                          ),
                          child: const Icon(
                            Icons.close,
                            color: Colors.white,
                            size: 14,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  String _getTypeDisplayName(String type) {
    switch (type) {
      case 'file': return 'Файл';
      case 'image_url': return 'Изображение';
      case 'url': return 'Ссылка';
      case 'document_url': return 'Документ';
      case 'email': return 'Email';
      case 'code': return 'Код';
      case 'html': return 'HTML';
      case 'keyboard': return 'Клавиатура';
      case 'image': return 'Изображение';
      default: return 'Текст';
    }
  }

  Color _getTypeBorderColor(String type) {
    switch (type) {
      case 'file': return Colors.orange;
      case 'image_url': return Colors.pink;
      case 'image': return Colors.pink;
      case 'url': return Colors.blue;
      case 'document_url': return Colors.purple;
      case 'email': return Colors.green;
      case 'code': return Colors.cyan;
      case 'html': return Colors.yellow;
      case 'keyboard': return Colors.grey;
      default: return Colors.white;
    }
  }

  String _formatTime(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.day.toString().padLeft(2, '0')}.${date.month.toString().padLeft(2, '0')}.${date.year}';
  }

  Future<File> _getImageFile(String content, Map<String, dynamic>? fileInfo) async {
    try {
      final file = File(content);
      if (await file.exists()) {
        return file;
      } else {
        throw Exception('File not found');
      }
    } catch (e) {
      throw Exception('Failed to load image: $e');
    }
  }
}

class ArrowPainter extends CustomPainter {
  final List<Arrow> arrows;
  final Offset? arrowStart;
  final Offset? currentArrowEnd;
  
  ArrowPainter(this.arrows, {this.arrowStart, this.currentArrowEnd});
  
  @override
  void paint(Canvas canvas, Size size) {
    // Рисуем сохраненные стрелки
    for (final arrow in arrows) {
      _drawArrow(canvas, arrow.start, arrow.end);
    }
    
    // Рисуем предварительный просмотр текущей стрелки
    if (arrowStart != null && currentArrowEnd != null) {
      _drawArrow(canvas, arrowStart!, currentArrowEnd!, isPreview: true);
    }
  }
  
  void _drawArrow(Canvas canvas, Offset start, Offset end, {bool isPreview = false}) {
    final paint = Paint()
      ..color = isPreview ? Colors.red.withOpacity(0.7) : Colors.red
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;

    canvas.drawLine(start, end, paint);
    
    // Рисуем наконечник стрелки только для завершенных стрелок
    if (!isPreview) {
      final angle = (end - start).direction;
      const arrowSize = 8.0;
      
      final path = Path()
        ..moveTo(end.dx, end.dy)
        ..lineTo(
          end.dx - arrowSize * cos(angle - pi / 6),
          end.dy - arrowSize * sin(angle - pi / 6),
        )
        ..lineTo(
          end.dx - arrowSize * cos(angle + pi / 6),
          end.dy - arrowSize * sin(angle + pi / 6),
        )
        ..close();
      
      canvas.drawPath(path, paint..style = PaintingStyle.fill);
    }
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}
/// Декодер для CP1251
class Windows1251Decoder extends Converter<List<int>, String> {
  const Windows1251Decoder();
  static const _cp1251 = [
    'Ѓ','Ђ','Ѓ','ѓ','„','…','†','‡','€','‰','Љ','‹','Њ','Ќ','Ћ','Џ',
    'ђ','‘','’','“','”','•','–','—','','™','љ','›','њ','ќ','ћ','џ',
    ' ','Ў','ў','Ј','¤','Ґ','¦','§','Ё','©','Є','«','¬','­','®','Ї',
    '°','±','І','і','ґ','µ','¶','·','ё','№','є','»','ј','Ѕ','ѕ','ї',
    'А','Б','В','Г','Д','Е','Ж','З','И','Й','К','Л','М','Н','О','П',
    'Р','С','Т','У','Ф','Х','Ц','Ч','Ш','Щ','Ъ','Ы','Ь','Э','Ю','Я',
    'а','б','в','г','д','е','ж','з','и','й','к','л','м','н','о','п',
    'р','с','т','у','ф','х','ц','ч','ш','щ','ъ','ы','ь','э','ю','я'
  ];

  @override
  String convert(List<int> input) {
    final sb = StringBuffer();
    for (final b in input) {
      if (b >= 0xC0) {
        sb.write(_cp1251[b - 0xC0 + 64]);
      } else {
        sb.writeCharCode(b);
      }
    }
    return sb.toString();
  }
}

String _fixEncoding(String text) {
  try {
    // Если текст содержит символы неправильной кодировки, пробуем конвертировать
    if (text.contains('Р') && text.contains('С')) {
      // Пробуем конвертировать из CP1251/Windows-1251 в UTF-8
      final bytes = latin1.encode(text);
      return utf8.decode(bytes, allowMalformed: true);
    }
    return text;
  } catch (e) {
    return text;
  }
}

class Arrow {
  final Offset start;
  final Offset end;
  
  Arrow(this.start, this.end);
}

class ScreenshotApp extends StatelessWidget {
  const ScreenshotApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Скриншот модуль',
      theme: ThemeData.dark(),
      home: ScreenshotScreen(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class ScreenshotScreen extends StatefulWidget {
  const ScreenshotScreen({Key? key}) : super(key: key);

  @override
  _ScreenshotScreenState createState() => _ScreenshotScreenState();
}

class _ScreenshotScreenState extends State<ScreenshotScreen> with WindowListener {
  Uint8List? _screenshotData;
  Offset _startOffset = Offset.zero;
  Offset _currentOffset = Offset.zero;
  bool _isSelecting = false;
  final TextEditingController _textController = TextEditingController();
  bool _isProcessing = false;
  Rect? _selectedRegion;
  bool _showTextInput = false;
  final FocusNode _focusNode = FocusNode();
  final GlobalKey _screenshotKey = GlobalKey();
  final GlobalKey _globalKey = GlobalKey(); // Добавляем GlobalKey
  List<Arrow> _arrows = []; // Список стрелок
final List<List<Arrow>> _arrowHistory = []; // История для undo
Offset? _currentArrowEnd; 
// Добавьте эти поля в класс State
Offset _selectionStart = Offset.zero;
Offset _selectionEnd = Offset.zero;
String _recognizedTextFromScreenshot ="";
final _httpClient = http.Client();
String _defaultLanguage = 'ru'; // Русский по умолчанию

  @override
  void initState() {
    super.initState();
    windowManager.addListener(this);
    _initializeScreenshot();
    _setupKeyboardListener();
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    _textController.dispose();
    _focusNode.dispose();
    super.dispose();
  }

void _setupKeyboardListener() {
  RawKeyboard.instance.addListener((RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      final isControlPressed = event.isControlPressed;
      
      if (event.logicalKey == LogicalKeyboardKey.escape) {
        windowManager.close();
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyZ) {
        _undoArrow();
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyS) {
        _copyScreenshotToClipboard();
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyX) {
        _createMemeScreenshot();
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyC) {
        _copyTextAndClose(); // Обновлено
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyQ) {
        _translateTextToDefaultLanguage(); // Обновлено
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyW) {
        _translateTextToEnglishLanguage(); // Обновлено
      }
    }
  });
}
Future<void> _copyTextAndClose() async {
  final text = _textController.text.trim();
  if (text.isNotEmpty) {
    await Clipboard.setData(ClipboardData(text: text));
    _showMessage('Текст скопирован в буфер');
    Future.delayed(Duration(milliseconds: 500), () {
      windowManager.close();
    });
  } else {
    _showMessage('Нет текста для копирования');
  }
}


Future<void> _translateTextToDefaultLanguage() async {
  await _translateText(_defaultLanguage);
}

Future<void> _translateTextToEnglishLanguage() async {
  await _translateText('en');
}

Future<void> _translateText(String targetLanguage) async {
  final text = _textController.text.trim();
  if (text.isEmpty) {
    _showMessage('Нет текста для перевода');
    return;
  }

  try {
    setState(() {
      _isProcessing = true;
    });

    // Определяем исходный язык
    final sourceLanguage = await _detectLanguage(text);
    
    // Если исходный язык уже целевой - не переводим
    if (sourceLanguage == targetLanguage) {
      _showMessage('Текст уже на целевом языке');
      return;
    }

    // Пробуем разные API переводчиков
    String translatedText = await _translateWithLibreTranslate(text, sourceLanguage, targetLanguage);
    
    if (translatedText.isEmpty) {
      translatedText = await _translateWithMyMemory(text, sourceLanguage, targetLanguage);
    }

    if (translatedText.isNotEmpty) {
      setState(() {
        _textController.text = translatedText;
      });
      _showMessage('Текст переведен');
    } else {
      _showMessage('Не удалось выполнить перевод');
    }
    
  } catch (e) {
    _showMessage('Ошибка перевода: $e');
  } finally {
    setState(() {
      _isProcessing = false;
    });
  }
}

// Бесплатный API LibreTranslate
Future<String> _translateWithLibreTranslate(String text, String from, String to) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/translate'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'q': text,
        'source': from,
        'target': to,
        'format': 'text'
      }),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['translatedText'] ?? '';
    }
  } catch (e) {
    print('LibreTranslate error: $e');
  }
  return '';
}

// Резервный API MyMemory
Future<String> _translateWithMyMemory(String text, String from, String to) async {
  try {
    final response = await _httpClient.get(
      Uri.parse('https://api.mymemory.translated.net/get?'
          'q=${Uri.encodeComponent(text)}&'
          'langpair=$from|$to'),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['responseData']['translatedText'] ?? '';
    }
  } catch (e) {
    print('MyMemory error: $e');
  }
  return '';
}

Future<String> _detectLanguage(String text) async {
  try {
    // Простая эвристика для определения языка
    return _detectLanguageBasic(text);
    
    // Для более точного определения можно использовать API (раскомментировать при необходимости)
    // return await _detectLanguageWithAPI(text);
  } catch (e) {
    return _detectLanguageBasic(text);
  }
}

// API определение языка (раскомментировать при необходимости)
/*
Future<String> _detectLanguageWithAPI(String text) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/detect'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'q': text}),
    ).timeout(Duration(seconds: 5));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      if (data is List && data.isNotEmpty) {
        return data[0]['language'] ?? 'en';
      }
    }
  } catch (e) {
    print('Language detection API error: $e');
  }
  return _detectLanguageBasic(text);
}
*/

String _detectLanguageBasic(String text) {
  // Улучшенная эвристика для определения языка
  final russianRegex = RegExp(r'[а-яА-ЯёЁ]');
  final englishRegex = RegExp(r'[a-zA-Z]');
  final koreanRegex = RegExp(r'[ㄱ-ㅎㅏ-ㅣ가-힣]');
  final chineseRegex = RegExp(r'[\u4e00-\u9fff]');
  final japaneseRegex = RegExp(r'[\u3040-\u309F\u30A0-\u30FF]');
  
  // Подсчет символов разных языков
  int russianCount = russianRegex.allMatches(text).length;
  int englishCount = englishRegex.allMatches(text).length;
  int koreanCount = koreanRegex.allMatches(text).length;
  int chineseCount = chineseRegex.allMatches(text).length;
  int japaneseCount = japaneseRegex.allMatches(text).length;
  
  // Определяем язык по преобладающим символам
  if (russianCount > 0 && russianCount > englishCount) return 'ru';
  if (koreanCount > 0) return 'ko';
  if (chineseCount > 0) return 'zh';
  if (japaneseCount > 0) return 'ja';
  if (englishCount > 0) return 'en';
  
  return 'en'; // По умолчанию английский
}


  Future<void> _initializeScreenshot() async {
    try {
      // Сначала скрываем окно, делаем скриншот, потом показываем
      
      
      final screenshot = await _takeRealScreenshot();
      if (screenshot != null) {
        setState(() {
          _screenshotData = screenshot;
        });
        
        // Показываем поверх скриншота
        await windowManager.show();
        await windowManager.focus();
        await windowManager.setAlwaysOnTop(true);
        await windowManager.setFullScreen(true);
      }
    } catch (e) {
      print('Ошибка инициализации скриншота: $e');
      await windowManager.show();
      await windowManager.focus();
    }
  }

  Future<Uint8List?> _takeRealScreenshot() async {
    return takeScreen();
  }

  Future<Uint8List?> takeScreen() async {
    try {
      // Using platform channels to take screenshot
      const channel = MethodChannel('screenshot_channel');
      final result = await channel.invokeMethod('takeScreenshot');
      if (result != null && result is Uint8List) {
        return result;
      }
      return null;
    } catch (e) {
      print('Ошибка скриншота: $e');
      return _takeScreenshotFallback();
    }
  }

  Future<Uint8List?> _takeScreenshotFallback() async {
    try {
      // Alternative method using screenshot package
      // You'll need to implement this based on your platform
      return null;
    } catch (e) {
      print('Fallback screenshot failed: $e');
      return null;
    }
  }



Future<void> _writeTextLog(String message) async {
  try {
    final documentsDir = await getApplicationDocumentsDirectory();
    final logFile = File('${documentsDir.path}/log_decode_text.log');
    final timestamp = DateTime.now().toString();
    final logMessage = '[$timestamp] $message\n';
    await logFile.writeAsString(logMessage, mode: FileMode.append);
    if (kDebugMode) print(message);
  } catch (e) {
    if (kDebugMode) print('Ошибка записи лога: $e');
  }
}
Future<String> _recognizeTextFromBytes(Uint8List imageData) async {
  await _writeTextLog('=== НАЧАЛО РАСПОЗНАВАНИЯ ТЕКСТА ===');
  await _writeTextLog('Размер изображения: ${imageData.length} байт');
  
  // Проверяем установлен ли Tesseract в системе
  final isTesseractAvailable = await _isTesseractInstalled();
  
  if (!isTesseractAvailable) {
    await _writeTextLog('Tesseract не установлен в системе');
    return _getTesseractNotInstalledMessage(imageData);
  }
  
  // Если Tesseract установлен, используем его
  return await _useSystemTesseract(imageData);
}

Future<bool> _isTesseractInstalled() async {
  try {
    await _writeTextLog('Проверка установки Tesseract...');
    
    final result = await Process.run('tesseract', ['--version']);
    
    await _writeTextLog('Код выхода: ${result.exitCode}');
    await _writeTextLog('Stdout: ${result.stdout}');
    
    return result.exitCode == 0;
    
  } catch (e) {
    await _writeTextLog('Tesseract не найден: $e');
    return false;
  }
}


Future<String> _useSystemTesseract(Uint8List imageData) async {
  try {
    final tempDir = await getTemporaryDirectory();
    final filePath = '${tempDir.path}/ocr_input_${DateTime.now().millisecondsSinceEpoch}.png';
    final file = File(filePath);
    await file.writeAsBytes(imageData);

    await _writeTextLog('Запуск системного Tesseract...');

    final process = await Process.start(
      'tesseract',
      [
        filePath,
        'stdout',
        '-l', 'rus+eng',
        '--psm', '6',
        '--oem', '3',
      ],
      runInShell: true,
      environment: {
        'LANG': 'ru_RU.UTF-8',
        'LC_ALL': 'ru_RU.UTF-8',
      },
    );

    // читаем байты, не полагаясь на авто-декод
    final stdoutBytes = await process.stdout.fold<List<int>>([], (a, b) => a..addAll(b));
    final stderrBytes = await process.stderr.fold<List<int>>([], (a, b) => a..addAll(b));
    final exitCode = await process.exitCode;

    await file.delete();

    // Пробуем декодировать как UTF-8, если не получается — CP1251
    String decodeBytes(List<int> bytes) {
      try {
        return utf8.decode(bytes);
      } catch (_) {
        return const Windows1251Decoder().convert(bytes);
      }
    }

    final recognizedText = decodeBytes(stdoutBytes).trim();
    final stderrText = decodeBytes(stderrBytes);

    if (exitCode == 0) {
      await _writeTextLog('Tesseract распознал: ${recognizedText.length} символов');
      await _writeTextLog('Текст: "$recognizedText"');
      if (recognizedText.isNotEmpty) {
        setState(() {
         _recognizedTextFromScreenshot=_cleanRecognizedText(recognizedText);
      });
       
        return _cleanRecognizedText(_recognizedTextFromScreenshot);
      } else {
        return 'Текст не распознан. Попробуйте выделить область с более четким текстом.';
      }
    } else {
      await _writeTextLog('Ошибка Tesseract. Exit code: $exitCode');
      await _writeTextLog('Stderr: $stderrText');
      return 'Ошибка Tesseract: $stderrText';
    }
  } on TimeoutException catch (e) {
    await _writeTextLog('Таймаут Tesseract: $e');
    return 'Таймаут: Tesseract не ответил за 15 секунд';
  } catch (e) {
    await _writeTextLog('Ошибка вызова Tesseract: $e');
    return 'Ошибка вызова Tesseract: $e';
  }
}

String _cleanRecognizedText(String text) {
  // Очищаем текст от лишних пробелов и пустых строк
  text = text.trim();
  
  // Удаляем специальные символы которые могут быть мусором
  text = text.replaceAll(RegExp(r'[^\w\sа-яА-ЯёЁ.,!?;:()\\/_-]'), '');
  
  // Заменяем множественные пробелы на одинарные
  text = text.replaceAll(RegExp(r'\s+'), ' ');
  
  // Удаляем строки состоящие только из символов пунктуации
  final lines = text.split('\n');
  final cleanedLines = lines.where((line) {
    final trimmed = line.trim();
    if (trimmed.isEmpty) return false;
    return RegExp(r'[a-zA-Zа-яА-Я0-9]').hasMatch(trimmed);
  }).toList();
  
  return cleanedLines.join('\n').trim();
}

Future<String> _getTesseractNotInstalledMessage(Uint8List imageData) async {
  // Сохраняем изображение для ручного анализа
  final documentsDir = await getApplicationDocumentsDirectory();
  final debugFilePath = '${documentsDir.path}/screenshot_area_${DateTime.now().millisecondsSinceEpoch}.png';
  final debugFile = File(debugFilePath);
  await debugFile.writeAsBytes(imageData);
  
  // Получаем информацию об изображении
  String imageInfo = 'Не удалось получить информацию об изображении';
  try {
    final codec = await ui.instantiateImageCodec(imageData);
    final frame = await codec.getNextFrame();
    final image = frame.image;
    imageInfo = '${image.width}×${image.height} пикселей';
  } catch (e) {
    imageInfo = 'Ошибка анализа: $e';
  }

  return '''
🔍 **Tesseract OCR не установлен**

**Для автоматического распознавания текста необходимо:**

📥 **Установить Tesseract:**
1. Скачайте с: https://github.com/UB-Mannheim/tesseract/wiki
2. Установите с отметкой "Add Tesseract to the system PATH"
3. Перезапустите приложение

**Или используйте текущий режим:**
• ✍️ **Введите текст вручную** в поле ниже
• 📋 Скопируйте текст из выделенной области
• 🤖 Нажмите "Send to AI" для анализа

**Информация о выделенной области:**
• Размер: $imageInfo
• Файл сохранен: `$debugFilePath`

_После установки Tesseract перезапустите приложение_
''';
}
  Future<void> _processSelectedRegion(Rect region) async {
    if (_screenshotData == null) return;

    try {
      setState(() {
        _isProcessing = true;
      });

      print('Обработка области: $region');

      // Вырезаем область из скриншота
      final croppedImage = await _cropImageRegion(_screenshotData!, region);
      if (croppedImage == null) {
        _showMessage('Ошибка обрезки изображения');
        return;
      }

      // Пытаемся распознать QR-код
      final qrResult = await _scanQRCode(croppedImage);
      if (qrResult.isNotEmpty) {
        setState(() {
          _textController.text = qrResult;
        });
        _showMessage('QR-код распознан!');
        return;
      }

      // Если QR не найден, распознаем текст
      final textResult = await _recognizeTextFromBytes(croppedImage);
      setState(() {
        _textController.text = textResult;
      });
      _showMessage('Текст распознан!');

    } catch (e) {
      print('Ошибка обработки: $e');
      _showMessage('Ошибка: $e');
    } finally {
      setState(() {
        _isProcessing = false;
      });
    }
  }

Future<Uint8List?> _cropImageRegion(Uint8List imageData, Rect region) async {
  try {
    print('Обрезка из готового скриншота, регион: $region');
    
    // Декодируем оригинальное изображение
    final codec = await ui.instantiateImageCodec(imageData);
    final frame = await codec.getNextFrame();
    final originalImage = frame.image;
    
    // Получаем размеры экрана
    final screenSize = MediaQuery.of(context).size;
    
    // Рассчитываем масштаб между скриншотом и экраном
    final scaleX = originalImage.width / screenSize.width;
    final scaleY = originalImage.height / screenSize.height;
    
    print('Original image: ${originalImage.width}x${originalImage.height}');
    print('Screen size: $screenSize');
    print('Scale: $scaleX x $scaleY');
    
    // Рассчитываем координаты в масштабе изображения
    final cropX = (region.left * scaleX).round();
    final cropY = (region.top * scaleY).round();
    final cropWidth = (region.width * scaleX).round();
    final cropHeight = (region.height * scaleY).round();
    
    print('Crop coordinates: $cropX,$cropY ${cropWidth}x$cropHeight');
    
    // Проверяем границы
    if (cropX < 0 || cropY < 0 || 
        cropX + cropWidth > originalImage.width || 
        cropY + cropHeight > originalImage.height) {
      print('Выход за границы изображения');
      return null;
    }
    
    // Создаем обрезанное изображение
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    
    canvas.drawImageRect(
      originalImage,
      ui.Rect.fromLTWH(
        cropX.toDouble(),
        cropY.toDouble(),
        cropWidth.toDouble(),
        cropHeight.toDouble(),
      ),
      ui.Rect.fromLTWH(0, 0, cropWidth.toDouble(), cropHeight.toDouble()),
      Paint(),
    );
    
    final picture = recorder.endRecording();
    final croppedImage = await picture.toImage(cropWidth, cropHeight);
    final byteData = await croppedImage.toByteData(format: ui.ImageByteFormat.png);
    final resultBytes = byteData!.buffer.asUint8List();
    
    print('Успешно обрезано: ${resultBytes.length} байт');
    
    // Сохраняем для отладки
    final docDir = await getApplicationDocumentsDirectory();
    final debugFile = File('${docDir.path}/debug_crop.png');
    await debugFile.writeAsBytes(resultBytes);
    print('Сохранено для отладки: ${debugFile.path}');
    
    return resultBytes;
    
  } catch (e) {
    print('Ошибка обрезки: $e');
    return null;
  }
}


Future<String> _scanQRCode(Uint8List imageData) async {
     const channel = MethodChannel('screenshot_channel');
  final String result = await channel.invokeMethod('scanQRCode', {
    'imageData': imageData,
  });
  return result;
}
Future<void> _sendToAI(String recognizedText, String userText) async {
  // Выполняем вычисления в изоляте
  final combinedText = await compute(_prepareCombinedText, {
    'recognizedText': recognizedText,
    'recognizedTextFromScreenshot': _recognizedTextFromScreenshot,
  });
  
  print('=' * 50);
  print('ОТПРАВКА В AI:');
  print('=' * 50);
  print(combinedText);
  print('=' * 50);
  
  // Отправка в отдельном потоке
  await _sendToServer(combinedText).timeout(const Duration(seconds: 30));
  
  // Закрытие окна в основном потоке
  WidgetsBinding.instance.addPostFrameCallback((_) {
    windowManager.close();
  });
}

// Функция для изолята
static String _prepareCombinedText(Map<String, String> data) {
  final recognizedText = data['recognizedText']!;
  final recognizedTextFromScreenshot = data['recognizedTextFromScreenshot']!;
  
  bool isSame = recognizedText == recognizedTextFromScreenshot;
  
  if (isSame) {
    return '''
    $recognizedTextFromScreenshot
    \n
    ''';
  } else {
    return '''
    $recognizedTextFromScreenshot
    \n
    $recognizedText
    ''';
  }
}
//пикей


static Future<void> _sendToServer(String data) async {
  try {
    final socket = await Socket.connect('localhost', 8081);
    // Явно кодируем в UTF-8
    final encodedData = utf8.encode(data);
    socket.add(encodedData);
    await socket.flush();
    socket.destroy();
  } catch (e) {
    print('Error sending data: $e');
  }
}


  Rect _getSelectionRect() {
    final left = _startOffset.dx < _currentOffset.dx ? _startOffset.dx : _currentOffset.dx;
    final top = _startOffset.dy < _currentOffset.dy ? _startOffset.dy : _currentOffset.dy;
    final right = _startOffset.dx > _currentOffset.dx ? _startOffset.dx : _currentOffset.dx;
    final bottom = _startOffset.dy > _currentOffset.dy ? _startOffset.dy : _currentOffset.dy;

    return Rect.fromLTRB(left, top, right, bottom);
  }

void _onPanStart(DragStartDetails details) {
  setState(() {
    _startOffset = details.localPosition;
    _currentOffset = details.localPosition;
    _isSelecting = true;
    _showTextInput = false;
    _arrows.clear(); // Очищаем стрелки при новом выделении
  });
}

void _onPanUpdate(DragUpdateDetails details) {
  setState(() {
    _currentOffset = details.localPosition;
  });
}

void _onPanEnd(DragEndDetails details) {
  final selectionRect = _getSelectionRect();
  setState(() {
    _selectedRegion = selectionRect;
    _isSelecting = false;
    _showTextInput = true;
  });

  // Обрабатываем выделенную область только если она достаточно большая
  if (selectionRect.width >= 20 && selectionRect.height >= 20) {
    _processSelectedRegion(selectionRect);
  }
}
void _onSend() async {
  if (_isProcessing || _selectedRegion == null) return;

  try {
    setState(() {
      _isProcessing = true;
    });

    // Получаем текст из поля ввода
    final recognizedText = _textController.text.trim();
    
    if (recognizedText.isEmpty) {
      _showMessage('Введите текст для отправки в AI');
      return;
    }

    // Отправляем в AI
    await _sendToAI(recognizedText, "Пользовательский ввод");

    // Закрываем окно после успешной отправки
    Future.delayed(Duration(milliseconds: 500), () {
      if (mounted) {
        windowManager.close();
      }
    });

  } catch (e) {
    _showMessage('Ошибка отправки: $e');
  } finally {
    if (mounted) {
      setState(() {
        _isProcessing = false;
      });
    }
  }
}

  void _showMessage(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: message.contains('Ошибка') ? Colors.red : Colors.green,
        duration: Duration(seconds: 3),
      ),
    );
  }

  void _cancelScreenshot() {
    windowManager.close();
  }


  Offset? _arrowStart;
bool _isDrawingArrow = false;

void _undoArrow() {
  if (_arrowHistory.isNotEmpty) {
    setState(() {
      _arrowHistory.removeLast();
      _arrows = _arrowHistory.isNotEmpty ? List.from(_arrowHistory.last) : [];
    });
  }
}
Future<void> _copyScreenshotToClipboard() async {
  if (_screenshotData == null || _selectedRegion == null) return;

  try {
    // Добавляем проверку на null и оператор ! для явного указания non-null
    final croppedImageData = await _cropImageRegion(_screenshotData!, _selectedRegion!);
    if (croppedImageData != null) {
      // Для Windows используем канал для копирования изображения в буфер
      const channel = MethodChannel('screenshot_channel');
      await channel.invokeMethod('copyImageToClipboard', {
        'imageData': croppedImageData,
      });
      windowManager.close();
    }
  } catch (e) {
    _showMessage('Ошибка копирования: $e');
  }
}

Future<void> _createMemeScreenshot() async {
  if (_screenshotData == null || _selectedRegion == null) return;

  try {
    final memeImage = await _createMemeImage(_screenshotData!, _selectedRegion!, _textController.text);
    if (memeImage != null) {
      // Для Windows используем канал для копирования изображения в буфер
      const channel = MethodChannel('screenshot_channel');
      await channel.invokeMethod('copyImageToClipboard', {
        'imageData': memeImage,
      });
      windowManager.close();
    }
  } catch (e) {
    _showMessage('Ошибка создания демотиватора: $e');
  }
}

Future<Uint8List?> _addArrowsToImage(Uint8List imageData, Rect region) async {
  try {
    final codec = await ui.instantiateImageCodec(imageData);
    final frame = await codec.getNextFrame();
    final originalImage = frame.image;

    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    
    // Рисуем оригинальное изображение
    canvas.drawImage(originalImage, Offset.zero, Paint());
    
    // Рисуем стрелки
    for (final arrow in _arrows) {
      _drawArrow(canvas, arrow.start, arrow.end);
    }
    
    final picture = recorder.endRecording();
    final finalImage = await picture.toImage(originalImage.width, originalImage.height);
    final byteData = await finalImage.toByteData(format: ui.ImageByteFormat.png);
    
    return byteData?.buffer.asUint8List();
  } catch (e) {
    print('Ошибка добавления стрелок: $e');
    return null;
  }
}

void _drawArrow(Canvas canvas, Offset start, Offset end) {
  final paint = Paint()
    ..color = Colors.red
    ..strokeWidth = 2.0
    ..style = PaintingStyle.stroke;

  // Рисуем линию
  canvas.drawLine(start, end, paint);
  
  // Рисуем стрелку
  final angle = (end - start).direction;
  const arrowSize = 4.0;
  
  final path = Path()
    ..moveTo(end.dx, end.dy)
    ..lineTo(
      end.dx - arrowSize * cos(angle - pi / 6),
      end.dy - arrowSize * sin(angle - pi / 6),
    )
    ..lineTo(
      end.dx - arrowSize * cos(angle + pi / 6),
      end.dy - arrowSize * sin(angle + pi / 6),
    )
    ..close();
  
  canvas.drawPath(path, paint..style = PaintingStyle.fill);
}
Future<Uint8List?> _createMemeImage(Uint8List imageData, Rect region, String text) async {
  try {
    // Сначала обрезаем изображение по выделенной области
    final croppedImageData = await _cropImageRegion(imageData, region);
    if (croppedImageData == null) return null;

    final codec = await ui.instantiateImageCodec(croppedImageData);
    final frame = await codec.getNextFrame();
    var baseImage = frame.image;

    // Базовые размеры для демотиватора
    const padding = 80.0;
    const bottomPadding = 80.0;
    const watermarkHeight = 40.0;
    const qrCodeSize = 70.0;

    // Определяем ширину изображения с учетом ограничений
    double imageWidth = baseImage.width.toDouble();
    if (imageWidth > 1600) {
      // Ресайзим до 1440 ширины
      final scale = 1440 / imageWidth;
      final scaledWidth = 1440;
      final scaledHeight = (baseImage.height * scale).toDouble();
      
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder);
      canvas.drawImageRect(
        baseImage,
        Rect.fromLTWH(0, 0, baseImage.width.toDouble(), baseImage.height.toDouble()),
        Rect.fromLTWH(0, 0, scaledWidth.toDouble(), scaledHeight),
        Paint(),
      );
      final picture = recorder.endRecording();
      baseImage = await picture.toImage(scaledWidth, scaledHeight.toInt());
      imageWidth = scaledWidth.toDouble();
    }

    // Вычисляем общую ширину с отступами
    final totalWidth = imageWidth + 160; // +160px (80px с каждой стороны)
    
    // Высота изображения
    final imageHeight = baseImage.height.toDouble();

    // Определяем размер шрифта в зависимости от длины текста
    double fontSize = 25.0;
    if (text.length <= 30) {
      fontSize = 32.0;
    } else if (text.length <= 50) {
      fontSize = 28.0;
    }

    // Создаем Paragraph для текста, чтобы определить его высоту
    final textParagraphBuilder = ui.ParagraphBuilder(
      ui.ParagraphStyle(
        fontSize: fontSize,
        textAlign: ui.TextAlign.center,
        fontWeight: ui.FontWeight.bold,
      ),
    )..pushStyle(ui.TextStyle(
        color: Colors.white,
      ))
     ..addText(text);
    
    final textParagraph = textParagraphBuilder.build();
    textParagraph.layout(ui.ParagraphConstraints(
      width: totalWidth - 40, // Отступы по 20 с каждой стороны
    ));

    final textHeight = textParagraph.height;

    // Вычисляем общую высоту изображения
    final totalHeight = padding + imageHeight + padding + textHeight + bottomPadding;

    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    
    // Рисуем черный фон
    canvas.drawRect(
      Rect.fromLTWH(0, 0, totalWidth, totalHeight),
      Paint()..color = Colors.black,
    );
    
    // Рисуем основное изображение со смещением на 80px по X
    final imageRect = Rect.fromLTWH(
      padding, // 80px отступ слева
      padding, 
      imageWidth, 
      imageHeight
    );
    
    // Создаем изображение с белой рамкой
    canvas.drawRect(
      imageRect.inflate(2),
      Paint()..color = Colors.white,
    );
    
    // Рисуем основное изображение
    canvas.drawImageRect(
      baseImage,
      Rect.fromLTWH(0, 0, baseImage.width.toDouble(), baseImage.height.toDouble()),
      imageRect,
      Paint(),
    );

    // Рисуем текст
    final textY = padding + imageHeight + padding;
    canvas.drawParagraph(
      textParagraph,
      Offset(20, textY),
    );

    // Создаем виртуальный Row для водяного знака "Created with" и логотипа
    const logoWidth = 70.0;
    const logoHeight = 40.0;
    const textLogoSpacing = 5.0; // Отступ между текстом и логотипом
    
    // Создаем Paragraph для текста "Created with"
    final createdWithBuilder = ui.ParagraphBuilder(
      ui.ParagraphStyle(
        fontSize: 11,
      ),
    )..pushStyle(ui.TextStyle(
        color: Colors.white,
      ))
     ..addText("Created with");
    
    final createdWithParagraph = createdWithBuilder.build();
    createdWithParagraph.layout(ui.ParagraphConstraints(
      width: 100,
    ));

    final createdWithHeight = createdWithParagraph.height;
    
    // Вычисляем общую ширину водяного знака (текст + отступ + логотип)
    final watermarkTotalWidth = createdWithParagraph.width + textLogoSpacing + logoWidth;
    
    // Позиция водяного знака (правый нижний угол)
    final watermarkX = totalWidth - watermarkTotalWidth - 10;
    final watermarkY = totalHeight - logoHeight - 10;
    
    // Создаем виртуальный Rect для всего водяного знака
    final watermarkRect = Rect.fromLTWH(
      watermarkX,
      watermarkY,
      watermarkTotalWidth,
      logoHeight, // Высота равна высоте логотипа
    );

    // Вычисляем вертикальный центр для текста
    final textVerticalCenter = watermarkRect.top + (watermarkRect.height - createdWithHeight) / 2;

    // Рисуем текст "Created with" по центру по вертикали
    canvas.drawParagraph(
      createdWithParagraph,
      Offset(watermarkRect.left, textVerticalCenter),
    );

    // Добавляем логотип (если есть в assets)
    try {
      final logoData = await rootBundle.load('assets/images/logo.png');
      final logoCodec = await ui.instantiateImageCodec(logoData.buffer.asUint8List());
      final logoFrame = await logoCodec.getNextFrame();
      final logoImage = logoFrame.image;
      
      final logoRect = Rect.fromLTWH(
        watermarkRect.left + createdWithParagraph.width + textLogoSpacing,
        watermarkRect.top,
        logoWidth,
        logoHeight
      );
      
      canvas.drawImageRect(
        logoImage,
        Rect.fromLTWH(0, 0, logoImage.width.toDouble(), logoImage.height.toDouble()),
        logoRect,
        Paint(),
      );
    } catch (e) {
      print('Логотип не найден: $e');
    }

    // Добавляем QR-код
    try {
      final qrData = await rootBundle.load('assets/images/qr_code.png');
      final qrCodec = await ui.instantiateImageCodec(qrData.buffer.asUint8List());
      final qrFrame = await qrCodec.getNextFrame();
      final qrImage = qrFrame.image;
      
      canvas.drawImageRect(
        qrImage,
        Rect.fromLTWH(0, 0, qrImage.width.toDouble(), qrImage.height.toDouble()),
        Rect.fromLTWH(
          10.0, 
          totalHeight - qrCodeSize - 10, 
          qrCodeSize, 
          qrCodeSize
        ),
        Paint(),
      );
    } catch (e) {
      print('QR-код не найден: $e');
    }

    final picture = recorder.endRecording();
    final memeImage = await picture.toImage(totalWidth.toInt(), totalHeight.toInt());
    final byteData = await memeImage.toByteData(format: ui.ImageByteFormat.png);
    
    return byteData?.buffer.asUint8List();
  } catch (e) {
    print('Ошибка создания демотиватора: $e');
    return null;
  }
}

Widget _buildMainInteractionListener() {
  return Positioned.fill(
    child: Listener(
      behavior: HitTestBehavior.translucent,
      onPointerDown: (event) {
        if (event.buttons == kPrimaryButton) {
          setState(() {
            _isSelecting = true;
            _selectionStart = event.localPosition;
            _selectionEnd = event.localPosition;
            _selectedRegion = null;
            _showTextInput = false;
            _arrows.clear();
            _arrowHistory.clear();
          });
        }
      },
      onPointerMove: (event) {
        if (_isSelecting) {
          setState(() {
            _selectionEnd = event.localPosition;
          });
        }
      },
      onPointerUp: (event) {
        if (_isSelecting) {
          setState(() {
            _isSelecting = false;
            final selectionRect = _getSelectionRect();
            if (selectionRect.width > 10 && selectionRect.height > 10) {
              _selectedRegion = selectionRect;
              _showTextInput = true;
              _focusNode.requestFocus();
            } else {
              _selectedRegion = null;
              _showTextInput = false;
            }
          });
        }
      },
    ),
  );
}

Widget _buildArrowInteractionListener() {
  return Positioned.fill(
    child: MouseRegion(
      cursor: SystemMouseCursors.precise,
      child: Listener(
        behavior: HitTestBehavior.translucent,
        onPointerDown: (event) {
          if (event.buttons == kSecondaryButton) {
            final localPosition = event.localPosition;
            if (_selectedRegion!.contains(localPosition)) {
              setState(() {
                _arrowStart = localPosition;
                _isDrawingArrow = true;
                _currentArrowEnd = localPosition;
              });
            }
          }
        },
        onPointerMove: (event) {
          if (_isDrawingArrow && _arrowStart != null) {
            setState(() {
              _currentArrowEnd = event.localPosition;
            });
          }
        },
        onPointerUp: (event) {
          if (_isDrawingArrow && _arrowStart != null) {
            setState(() {
              _arrows.add(Arrow(_arrowStart!, event.localPosition));
              _arrowHistory.add(List.from(_arrows));
              _isDrawingArrow = false;
              _arrowStart = null;
              _currentArrowEnd = null;
            });
          }
        },
        onPointerCancel: (event) {
          if (_isDrawingArrow) {
            setState(() {
              _isDrawingArrow = false;
              _arrowStart = null;
              _currentArrowEnd = null;
            });
          }
        },
      ),
    ),
  );
}
@override
Widget build(BuildContext context) {
  return Scaffold(
    backgroundColor: Colors.transparent,
    body: RawKeyboardListener(
      focusNode: FocusNode(),
      autofocus: true,
      onKey: (RawKeyEvent event) {
        if (event is RawKeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
          _cancelScreenshot();
        }
      },
      child: Stack(
        children: [
          if (_screenshotData == null)
            Center(
              child: Container(
                padding: EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.8),
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    CircularProgressIndicator(),
                    SizedBox(height: 10),
                    Text(
                      'Захват экрана...',
                      style: TextStyle(color: Colors.white),
                    ),
                  ],
                ),
              ),
            )
          else
            Stack(
              children: [
                // Фоновое изображение (скриншот)
                Positioned.fill(
                  child: Image.memory(
                    _screenshotData!,
                    fit: BoxFit.cover,
                  ),
                ),

                // Затемнение
                Positioned.fill(
                  child: Container(
                    color: Colors.black.withOpacity(0.2),
                  ),
                ),

                // Область выделения (показывается как во время выделения, так и после)
                if (_isSelecting || _selectedRegion != null) _buildSelectionArea(),
                
                // Стрелки
                if (_selectedRegion != null)
                  Positioned.fill(
                    child: CustomPaint(
                      painter: ArrowPainter(
                        _arrows, 
                        arrowStart: _arrowStart,
                        currentArrowEnd: _currentArrowEnd,
                      ),
                    ),
                  ),

                // Контролы с полем ввода
                if (_showTextInput && _selectedRegion != null) _buildControls(),

                // Инструкция
                if (!_showTextInput)
                  Positioned(
                    top: 20,
                    left: 20,
                    child: _buildInstructions(),
                  ),

                // Кнопка отмены
                Positioned(
                  top: 20,
                  right: 20,
                  child: _buildCancelButton(),
                ),

                // Основной GestureDetector для взаимодействия
                if (!_isProcessing)
                  Positioned.fill(
                    child: IgnorePointer(
                      ignoring: _showTextInput,
                      child: MouseRegion(
                        cursor: SystemMouseCursors.precise,
                        child: GestureDetector(
                          behavior: HitTestBehavior.translucent,
                          onPanStart: (details) {
                            if (_selectedRegion == null) {
                              // Левая кнопка - выделение области
                              _isSelecting = true;
                              _onPanStart(details);
                            } else if (_selectedRegion!.contains(details.localPosition)) {
                              // Правая кнопка - рисование стрелки (только в пределах выделения)
                              setState(() {
                                _arrowStart = details.localPosition;
                                _isDrawingArrow = true;
                              });
                            }
                          },
                          onPanUpdate: (details) {
                            if (_isSelecting) {
                              _onPanUpdate(details);
                            } else if (_isDrawingArrow) {
                              // Обновляем предварительный просмотр стрелки
                              setState(() {
                                _currentArrowEnd = details.localPosition;
                              });
                            }
                          },
                          onPanEnd: (details) {
                            if (_isSelecting) {
                              _onPanEnd(details);
                              _isSelecting = false;
                            } else if (_isDrawingArrow && _arrowStart != null) {
                              // Завершаем рисование стрелки
                              setState(() {
                                _arrows.add(Arrow(_arrowStart!, _currentArrowEnd ?? _arrowStart!));
                                _arrowHistory.add(List.from(_arrows));
                                _isDrawingArrow = false;
                                _arrowStart = null;
                                _currentArrowEnd = null;
                              });
                            }
                          },
                          onPanCancel: () {
                            // Сбрасываем состояния при отмене жеста
                            _isSelecting = false;
                            if (_isDrawingArrow) {
                              setState(() {
                                _isDrawingArrow = false;
                                _arrowStart = null;
                                _currentArrowEnd = null;
                              });
                            }
                          },
                        ),
                      ),
                    ),
                  ),

                // Индикатор обработки
                if (_isProcessing)
                  Center(
                    child: Container(
                      padding: EdgeInsets.all(20),
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.8),
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          CircularProgressIndicator(),
                          SizedBox(height: 10),
                          Text(
                            'Обработка...',
                            style: TextStyle(color: Colors.white),
                          ),
                        ],
                      ),
                    ),
                  ),
              ],
            ),
        ],
      ),
    ),
  );
}

Widget _buildSelectionArea() {
  final selectionRect = _getSelectionRect();
  
  return Stack(
    children: [
      // Затемнение вокруг выделенной области (только во время выделения)
      if (_isSelecting)
        Positioned.fill(
          child: Container(
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.3),
            ),
          ),
        ),
      
      // Выделенная область (показывается всегда)
      Positioned(
        left: selectionRect.left,
        top: selectionRect.top,
        child: Container(
          width: selectionRect.width,
          height: selectionRect.height,
          decoration: BoxDecoration(
            color: Colors.blue.withOpacity(0.1),
            border: Border.all(
              color: Colors.blue,
              width: 2.0,
            ),
          ),
        ),
      ),

      // Размеры области (показывается всегда)
      if (selectionRect.width > 50 && selectionRect.height > 20)
        Positioned(
          left: selectionRect.left,
          top: selectionRect.top - 30,
          child: Container(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.7),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(
              '${selectionRect.width.round()} × ${selectionRect.height.round()}',
              style: TextStyle(
                color: Colors.white,
                fontSize: 12,
              ),
            ),
          ),
        ),
    ],
  );
}



Widget _buildControls() {
  final screenSize = MediaQuery.of(context).size;
  final region = _selectedRegion!;

  double left = region.left;
  double top = region.bottom + 10;
  double width = region.width.clamp(300.0, screenSize.width - left - 20);

  if (top + 180 > screenSize.height) {
    top = region.top - 180;
    top = top.clamp(20.0, screenSize.height - 180);
  }

  double maxHeight = 120.0;

  return Positioned(
    left: left,
    top: top,
    width: width,
    child: Material(
      color: Colors.transparent,
      child: Container(
        padding: EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.9),
          borderRadius: BorderRadius.circular(8),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.5),
              blurRadius: 10,
              offset: Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              children: [
                Icon(Icons.edit, color: Colors.white70, size: 14),
                SizedBox(width: 6),
                Text(
                  'Редактируемый текст:',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Spacer(),
                // Кнопка отмены
                IconButton(
                  icon: Icon(Icons.close, size: 16, color: Colors.white70),
                  onPressed: _cancelScreenshot,
                  tooltip: 'Отменить (Esc)',
                ),
              ],
            ),
            SizedBox(height: 8),

            // Поле ввода текста
            ConstrainedBox(
              constraints: BoxConstraints(
                minHeight: 40,
                maxHeight: maxHeight,
              ),
              child: TextField(
                focusNode: _focusNode,
                controller: _textController,
                autofocus: true,
                decoration: InputDecoration(
                  hintText: 'Введите или отредактируйте текст...',
                  hintStyle: TextStyle(color: Colors.white60, fontSize: 12),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(6),
                    borderSide: BorderSide(color: Colors.blue.withOpacity(0.5), width: 1),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(6),
                    borderSide: BorderSide(color: Colors.blue.withOpacity(0.5), width: 1),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(6),
                    borderSide: BorderSide(color: Colors.blue, width: 1.5),
                  ),
                  filled: true,
                  fillColor: Colors.grey[900],
                  contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                ),
                style: TextStyle(color: Colors.white, fontSize: 13),
                maxLines: null,
                keyboardType: TextInputType.multiline,
                textInputAction: TextInputAction.newline,
              ),
            ),

            SizedBox(height: 12),

            Row(
              children: [
                // Информация о стрелках
                if (_arrows.isNotEmpty)
                  Text(
                    'Стрелок: ${_arrows.length}',
                    style: TextStyle(color: Colors.white70, fontSize: 10),
                  ),
                SizedBox(width: 8),
                
                // Кнопка отмены стрелки
                if (_arrowHistory.isNotEmpty)
                  ElevatedButton.icon(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.grey[700],
                      foregroundColor: Colors.white,
                      padding: EdgeInsets.symmetric(horizontal: 10, vertical: 8),
                      minimumSize: Size(0, 30),
                    ),
                    icon: Icon(Icons.undo, size: 12),
                    label: Text('Ctrl+Z', style: TextStyle(fontSize: 10)),
                    onPressed: _undoArrow,
                  ),

                Spacer(),

                // Кнопка "Копировать"
                ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.grey[800],
                    foregroundColor: Colors.white,
                    padding: EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                    minimumSize: Size(0, 36),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(6),
                    ),
                  ),
                  icon: Icon(Icons.copy, size: 14),
                  label: Text('Ctrl+C', style: TextStyle(fontSize: 12)),
                  onPressed: _copyScreenshotToClipboard,
                ),
                SizedBox(width: 8),

                // Кнопка "Демотиватор"
                ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.orange[700],
                    foregroundColor: Colors.white,
                    padding: EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                    minimumSize: Size(0, 36),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(6),
                    ),
                  ),
                  icon: Icon(Icons.photo_size_select_large, size: 14),
                  label: Text('Ctrl+X', style: TextStyle(fontSize: 12)),
                  onPressed: _createMemeScreenshot,
                ),
                SizedBox(width: 8),

                // Кнопка "Send to AI"
                ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue[700],
                    foregroundColor: Colors.white,
                    padding: EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                    minimumSize: Size(0, 36),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(6),
                    ),
                  ),
                  icon: _isProcessing
                      ? SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          ),
                        )
                      : Icon(Icons.send, size: 14),
                  label: Text('Send to AI', style: TextStyle(fontSize: 12)),
                  onPressed: _isProcessing ? null : _onSend,
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

  Widget _buildCancelButton() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.7),
        shape: BoxShape.circle,
      ),
      child: IconButton(
        icon: Icon(Icons.close, color: Colors.white),
        onPressed: _cancelScreenshot,
        tooltip: 'Закрыть (Esc)',
      ),
    );
  }

  Widget _buildInstructions() {
    return Container(
      padding: EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.7),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'Инструкция:',
            style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 14),
          ),
          SizedBox(height: 6),
          Text(
            '1. Выделите область с текстом или QR-кодом\n'
            '2. Распознавание произойдет автоматически\n'
            '3. Нажмите "Отправить в AI"\n'
            '4. Esc - закрыть',
            style: TextStyle(color: Colors.white70, fontSize: 12),
          ),
        ],
      ),
    );
  }

  @override
  void onWindowClose() {
    super.onWindowClose();
  }
}
class KeyboardLogger {
  static final KeyboardLogger _instance = KeyboardLogger._internal();
  factory KeyboardLogger() => _instance;
  KeyboardLogger._internal();

  Timer? _inactivityTimer;
  String _currentBuffer = '';
  DateTime _lastKeyTime = DateTime.now();
  final Duration _inactivityThreshold = Duration(seconds: 35);
  bool _isEnabled = false;

  // Фильтр для исключения системных клавиш
  final Set<LogicalKeyboardKey> _ignoredKeys = {
    LogicalKeyboardKey.shift,
    LogicalKeyboardKey.shiftLeft,
    LogicalKeyboardKey.shiftRight,
    LogicalKeyboardKey.control,
    LogicalKeyboardKey.controlLeft,
    LogicalKeyboardKey.controlRight,
    LogicalKeyboardKey.alt,
    LogicalKeyboardKey.altLeft,
    LogicalKeyboardKey.altRight,
    LogicalKeyboardKey.meta,
    LogicalKeyboardKey.metaLeft,
    LogicalKeyboardKey.metaRight,
    LogicalKeyboardKey.capsLock,
    LogicalKeyboardKey.numLock,
    LogicalKeyboardKey.scrollLock,
    LogicalKeyboardKey.f1,
    LogicalKeyboardKey.f2,
    LogicalKeyboardKey.f3,
    LogicalKeyboardKey.f4,
    LogicalKeyboardKey.f5,
    LogicalKeyboardKey.f6,
    LogicalKeyboardKey.f7,
    LogicalKeyboardKey.f8,
    LogicalKeyboardKey.f9,
    LogicalKeyboardKey.f10,
    LogicalKeyboardKey.f11,
    LogicalKeyboardKey.f12,
    LogicalKeyboardKey.escape,
    LogicalKeyboardKey.printScreen,
    LogicalKeyboardKey.pause,
    LogicalKeyboardKey.insert,
    LogicalKeyboardKey.home,
    LogicalKeyboardKey.pageUp,
    LogicalKeyboardKey.delete,
    LogicalKeyboardKey.end,
    LogicalKeyboardKey.pageDown,
    LogicalKeyboardKey.arrowLeft,
    LogicalKeyboardKey.arrowRight,
    LogicalKeyboardKey.arrowUp,
    LogicalKeyboardKey.arrowDown,
  };

  Future<void> initialize() async {
    if (_isEnabled) return;
    
    _isEnabled = true;
    _currentBuffer = '';
    _lastKeyTime = DateTime.now();
    
    await _writeTextLog('Keyboard logger initialized');
    
    // Запускаем таймер проверки неактивности
    _startInactivityTimer();
  }

  void _startInactivityTimer() {
    return;
    _inactivityTimer = Timer.periodic(Duration(seconds: 1), (timer) {
      final now = DateTime.now();
      final timeDiff = now.difference(_lastKeyTime);
      
      if (timeDiff >= _inactivityThreshold && _currentBuffer.isNotEmpty) {
        _writeTextLog('Inactivity timeout reached, saving buffer');
        _saveKeyboardInput();
      }
    });
  }

  void handleKeyEvent(RawKeyEvent event) {
    if (!_isEnabled) return;
    
    final now = DateTime.now();
    _lastKeyTime = now;

    if (event is RawKeyDownEvent) {
      final logicalKey = event.logicalKey;
      
      // Пропускаем системные клавиши
      if (_ignoredKeys.contains(logicalKey)) return;

      // Обработка специальных клавиш
      if (logicalKey == LogicalKeyboardKey.backspace) {
        _handleBackspace();
      } else if (logicalKey == LogicalKeyboardKey.enter) {
        _handleEnter();
      } else if (logicalKey == LogicalKeyboardKey.space) {
        _handleSpace();
      } else if (logicalKey == LogicalKeyboardKey.tab) {
        _handleTab();
      } else {
        // Обычные символы
        _handleCharacter(logicalKey);
      }
    }
  }

  void _handleBackspace() {
    if (_currentBuffer.isNotEmpty) {
      _currentBuffer = _currentBuffer.substring(0, _currentBuffer.length - 1);
      _writeTextLog('Backspace pressed, buffer length: ${_currentBuffer.length}');
    }
  }

  void _handleEnter() {
    _writeTextLog('Enter pressed, saving buffer with ${_currentBuffer.length} characters');
    _currentBuffer += '\n';
    // Сохраняем при нажатии Enter
    _saveKeyboardInput();
  }

  void _handleSpace() {
    _currentBuffer += ' ';
    _writeTextLog('Space pressed, buffer: "${_getBufferPreview()}"');
  }

  void _handleTab() {
    _currentBuffer += '\t';
    _writeTextLog('Tab pressed, buffer: "${_getBufferPreview()}"');
  }

  void _handleCharacter(LogicalKeyboardKey key) {
    final keyLabel = key.keyLabel;
    
    // Фильтрация специальных символов которые не должны быть в тексте
    if (keyLabel.length == 1 && _isValidCharacter(keyLabel)) {
      _currentBuffer += keyLabel;
      _writeTextLog('Character pressed: "$keyLabel", buffer: "${_getBufferPreview()}"');
    } else {
      _writeTextLog('Invalid character filtered: "$keyLabel" (key: ${key.keyId})');
    }
  }

  String _getBufferPreview() {
    if (_currentBuffer.isEmpty) return 'empty';
    final preview = _currentBuffer.length > 30 
        ? '${_currentBuffer.substring(0, 30)}...' 
        : _currentBuffer;
    return preview.replaceAll('\n', '\\n').replaceAll('\t', '\\t');
  }

  bool _isValidCharacter(String char) {
    // Базовые проверки валидности символа
    if (char.isEmpty) return false;
    
    final codeUnit = char.codeUnitAt(0);
    
    // Разрешаем буквы, цифры, основные символы
    // Кириллица: 1040-1103 (А-Яа-я) + Ёё (1025, 1105)
    // Латинница: 65-90 (A-Z), 97-122 (a-z)
    // Цифры: 48-57 (0-9)
    // Основные символы: 32 (пробел), 33-47, 58-64, 91-96, 123-126
    return (codeUnit >= 1040 && codeUnit <= 1103) || // Кириллица
           (codeUnit == 1025 || codeUnit == 1105) || // Ёё
           (codeUnit >= 65 && codeUnit <= 90) ||     // A-Z
           (codeUnit >= 97 && codeUnit <= 122) ||    // a-z
           (codeUnit >= 48 && codeUnit <= 57) ||     // 0-9
           (codeUnit >= 32 && codeUnit <= 126);      // Основные символы
  }

  bool _isValidContent(String content) {
    if (content.isEmpty) return false;
    
    final trimmed = content.trim();
    
    // Слишком короткие сообщения
    if (trimmed.length < 3) {
      _writeTextLog('Content too short: $trimmed');
      return false;
    }
    
    // Только пробелы/переносы
    if (trimmed.isEmpty) {
      _writeTextLog('Content only whitespace');
      return false;
    }
    
    // Повторяющиеся символы (например, "aaaaaaa")
    final repeatingRegex = RegExp(r'^(.)\1{4,}$'); // 5+ одинаковых символов
    if (repeatingRegex.hasMatch(trimmed)) {
      _writeTextLog('Content repeating characters: $trimmed');
      return false;
    }
    
    // Только цифры (короткие числовые последовательности)
    final onlyDigits = RegExp(r'^\d+$');
    if (onlyDigits.hasMatch(trimmed) && trimmed.length < 5) {
      _writeTextLog('Content only digits: $trimmed');
      return false;
    }
    
    // Случайные нажатия (например, "asdfghjk")
    if (_isRandomTyping(trimmed)) {
      _writeTextLog('Content random typing: $trimmed');
      return false;
    }
    
    return true;
  }

  bool _isRandomTyping(String text) {
    if (text.length < 6) return false;
    
    // Проверяем на последовательности типа "asdfgh" или "qwerty"
    final commonRandomPatterns = [
      'asdfgh', 'qwerty', 'zxcvbn', 'йцукен', 'фывапр', 'ячсмит'
    ];
    
    final lowerText = text.toLowerCase();
    for (final pattern in commonRandomPatterns) {
      if (lowerText.contains(pattern)) {
        return true;
      }
    }
    
    return false;
  }

  Future<void> _saveKeyboardInput() async {
    if (_currentBuffer.isEmpty) {
      _writeTextLog('Save attempted but buffer is empty');
      return;
    }

    if (!_isValidContent(_currentBuffer)) {
      _writeTextLog('Invalid content, skipping save: "${_currentBuffer.substring(0, min(_currentBuffer.length, 20))}..."');
      _currentBuffer = '';
      return;
    }

    try {
      final directory = await getApplicationDocumentsDirectory();
      final copypasteDir = Directory('${directory.path}/copypasted');
      
      if (!copypasteDir.existsSync()) {
        copypasteDir.createSync(recursive: true);
        _writeTextLog('Created directory: ${copypasteDir.path}');
      }

      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'keyboard_$timestamp.cnp';
      final file = File('${copypasteDir.path}/$fileName');
      
      final entry = {
        'content': _currentBuffer,
        'timestamp': timestamp,
        'source': 'keyboard',
        'starred': false,
        'length': _currentBuffer.length,
      };

      // Сохраняем с правильной кодировкой UTF-8
      final jsonString = jsonEncode(entry);
      final bytes = utf8.encode(jsonString);
      await file.writeAsBytes(bytes);
      
      _writeTextLog('Keyboard input saved: ${_currentBuffer.length} characters to $fileName');
      
      // Очищаем буфер после успешного сохранения
      _currentBuffer = '';
      
    } catch (e) {
      await _writeTextLog('Error saving keyboard input: $e');
    }
  }

  Future<void> _writeTextLog(String message) async {
    try {
      final documentsDir = await getApplicationDocumentsDirectory();
      final logFile = File('${documentsDir.path}/log_keylogger_text.log');
      
      final timestamp = DateTime.now().toString();
      final logMessage = '[$timestamp] $message\n';
      
      // Добавляем в конец файла
      await logFile.writeAsString(logMessage, mode: FileMode.append);
      
      // Также выводим в консоль для отладки
      print(message);
    } catch (e) {
      print('Ошибка записи лога: $e');
    }
  }

  // Принудительно сохранить текущий буфер
  Future<void> forceSave() async {
    if (_currentBuffer.isNotEmpty) {
      await _writeTextLog('Force save triggered');
      await _saveKeyboardInput();
    } else {
      await _writeTextLog('Force save attempted but buffer is empty');
    }
  }

  // Очистить текущий буфер без сохранения
  void clearBuffer() {
    _writeTextLog('Buffer cleared manually, was ${_currentBuffer.length} characters');
    _currentBuffer = '';
    _lastKeyTime = DateTime.now();
  }

  // Получить текущее состояние (для отладки)
  Map<String, dynamic> getStatus() {
    return {
      'isEnabled': _isEnabled,
      'bufferLength': _currentBuffer.length,
      'lastActivity': _lastKeyTime,
      'timeSinceLastActivity': DateTime.now().difference(_lastKeyTime).inSeconds,
      'bufferPreview': _currentBuffer.length > 50 
          ? '${_currentBuffer.substring(0, 50)}...' 
          : _currentBuffer,
    };
  }

  void dispose() {
    _writeTextLog('Keyboard logger disposed');
    _isEnabled = false;
    _inactivityTimer?.cancel();
    _inactivityTimer = null;
    
    // Принудительно сохраняем оставшийся буфер при закрытии
    if (_currentBuffer.isNotEmpty) {
      _writeTextLog('Auto-saving remaining buffer on dispose');
      _saveKeyboardInput();
    }
  }

  int min(int a, int b) => a < b ? a : b;
}
class ProcessManager {
  static final ProcessManager _instance = ProcessManager._internal();
  final Map<String, Process> _processes = {};

  factory ProcessManager() => _instance;

  ProcessManager._internal();

  void registerProcess(String id, Process process) {
    _processes[id] = process;
  }

  void killProcess(String id) {
    if (_processes.containsKey(id)) {
      _processes[id]?.kill();
      _processes.remove(id);
    }
  }

  void killAllProcesses() {
    _processes.forEach((id, process) {
      process.kill();
    });
    _processes.clear();
  }

  bool hasProcess(String id) => _processes.containsKey(id);

  // ======================
  // Добавляем метод getProcess
  // ======================
  Process? getProcess(String id) {
    return _processes[id];
  }
}

  void _writeToDebugLog(String message) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final debugFile = File('${directory.path}/chat_debug.log');
      await debugFile.writeAsString('${DateTime.now()}: $message\n', mode: FileMode.append);
      print('DEBUG: $message'); // Также выводим в консоль
    } catch (e) {
      print('Error writing to debug log: $e');
    }
  }

Future<String> _getSharedFilePath() async {
  final directory = await getApplicationDocumentsDirectory();
  return '${directory.path}/shared_eaten_files.json';
}

void _handleFileFeed(String filePath) {
  // Обработка файла из контекстного меню
  print('Feeding file to AI: $filePath');
  // Здесь можно отправить файл в основное приложение
}

void _handleTextFeed(String text) {
  // Обработка текста из контекстного меню браузера
  print('Feeding text to AI: $text');
  // Здесь можно отправить текст в основное приложение
  
}


void main(List<String> args) async {
  _writeToDebugLog1("0");
  WidgetsFlutterBinding.ensureInitialized();
  _writeToDebugLog1("1");
  // Проверяем аргументы командной строки
  if (args.isNotEmpty) {
      if (args.contains('--feed-file')) {
    final fileIndex = args.indexOf('--feed-file') + 1;
    if (fileIndex < args.length) {
      final filePath = args[fileIndex];
      _handleFileFeed(filePath);
      return;
    }
  }
  
  if (args.contains('--feed-text')) {
    final textIndex = args.indexOf('--feed-text') + 1;
    if (textIndex < args.length) {
      final text = args[textIndex];
      _handleTextFeed(text);
      return;
    }
  }
    if (args[0]=='ai_open'){
      
      await _initAIWindow();
       runApp(MaterialApp(
        title: 'Advanced Neural Network System',
        theme: ThemeData.dark(),
        home: NeuralNetworkApp(),
      ));
        return;
    }else if (args[0]=='essentials'){
      
      await _initEssentialsWindow();
        runApp(EssentialsApp(
        ));
        return;
    }else if (args[0]=='macro_keyboard'){
      
      await _initMacroKeyboardWindow();
         runApp( VirtualKeyboardApp());
        return;
    }else

    if (args[0] == 'chat') {
        final debugFile = File('chat_debug.log');
        await debugFile.writeAsString('Chat window args: $args\n', mode: FileMode.append);
        
        // Парсим историю чата
        List<Map<String, String>> chatHistory = [];
        if (args.length > 1 && args[1].isNotEmpty && args[1] != '[]') {
          try {
            final parsed = json.decode(args[1]) as List;
            chatHistory = parsed.map((item) => Map<String, String>.from(item)).toList();
          } catch (e) {
            debugFile.writeAsString('Error parsing chat history: $e\n', mode: FileMode.append);
          }
        }
        
        await _initChatWindow(args);
        runApp(ChatWindowApp(initialChatHistory: chatHistory));
        return;
      }else if (args[0] == 'files') {
  await _initFilesWindow();
  runApp(EatenFilesWindowApp(
    
  ));
} else if(args[0] == 'screenshoter') {
    await _initScreenshotWindow();
    runApp(const ScreenshotApp());
  }else if(args[0] == 'clipboard-history') {
    await _initClipboardHistoryWindow();
    runApp(const ClipboardHistoryWindow());
  } else if (args[0] == 'settings') {
      await _initSettingsWindow();
         String apiKey = args.length > 1 ? args[1] : '';
    bool useDeepSeek = args.length > 2 ? args[2].toLowerCase() == 'true' : false;
    String petName = args.length > 3 ? args[3] : 'Питомец';
    bool useVision = args.length > 4 ? args[4].toLowerCase() == 'true' : false;

    runApp(SettingsWindowApp(
      apiKey: apiKey,
      petName: petName,
      useDeepSeek: useDeepSeek,
      useVision: useVision,
    ));

    } else  if (args.contains('--feed-file') && args.length > 1) {
    final fileIndex = args.indexOf('--feed-file') + 1;
    if (fileIndex < args.length) {
      final filePath = args[fileIndex];
      print('Feeding file: $filePath');
    }
  }
  else {
      // Запуск основного приложения
      await _initMainWindow();
      
    }   
  } else {
    // Запуск основного приложения
    await _initMainWindow();
    
  }
}


Future<void> _initClipboardHistoryWindow() async {
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = WindowOptions(
    size: Size(400, 800), // Временный размер, потом установим точный
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    alwaysOnTop: true,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }

    // Получаем размеры экрана через screen_retriever
    final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    final windowHeight = screenSize.height * 0.8;

    // Устанавливаем точный размер
    await windowManager.setSize(Size(400, windowHeight));

    // Начальная позиция (за пределами экрана справа)
    final startPosition = Offset(
      screenSize.width, // Полностью за правым краем
      (screenSize.height - windowHeight) / 2,
    );

    // Конечная позиция
    final endPosition = Offset(
      screenSize.width - 405, // Правый край
      (screenSize.height - windowHeight) / 2,
    );

    // Устанавливаем начальную позицию (невидимо за экраном)
    await windowManager.setPosition(startPosition);
    await windowManager.setOpacity(0.0); // Начальная прозрачность

    // Показываем окно (но пока прозрачное и за экраном)
    await windowManager.show();

    // Анимация появления
    await _animateWindowAppearance(startPosition, endPosition);

    await windowManager.focus();

    print('Clipboard window initialized with animation');
  });
}


Future<void> _initAIWindow() async {
  await windowManager.ensureInitialized();
  await windowManager.setSize(ui.Size(1820, 940));
  await windowManager.center();
  //await windowManager.setAlwaysOnTop(true);
  await windowManager.setTitle('Квантовый мозг');
  await windowManager.show();
}



Future<void> _initMacroKeyboardWindow() async {
  await windowManager.ensureInitialized();
  await windowManager.setOpacity(0.0);
  WindowOptions windowOptions = WindowOptions(
    size: Size(420, 800), // Временный размер, потом установим точный
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    alwaysOnTop: true,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }

    // Получаем размеры экрана через screen_retriever
    final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    final windowHeight = screenSize.height * 0.35;
    final windowWidth = screenSize.width * 0.55;
    // Устанавливаем точный размер
    await windowManager.setSize(Size(windowWidth, windowHeight));

    // Начальная позиция (за пределами экрана справа)
    final startPosition = Offset(
      (screenSize.width - windowWidth)/2, // Полностью за правым краем
      (screenSize.height ) ,
    );

    // Конечная позиция
    final endPosition = Offset(
  (screenSize.width - windowWidth )/2, // Правый край
      (screenSize.height - windowHeight) - 50,
    );

    // Устанавливаем начальную позицию (невидимо за экраном)
    await windowManager.setPosition(startPosition);
    await windowManager.setOpacity(0.0); // Начальная прозрачность

    // Показываем окно (но пока прозрачное и за экраном)
    await windowManager.show();

    // Анимация появления
    await _animateWindowAppearanceFromBottom(startPosition, endPosition);

    await windowManager.focus();

    print('Clipboard window initialized with animation');
  });
}
Future<void> _initEssentialsWindow() async {
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = WindowOptions(
    size: Size(420, 800), // Временный размер, потом установим точный
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    alwaysOnTop: true,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }

    // Получаем размеры экрана через screen_retriever
    final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    final windowHeight = screenSize.height * 0.8;

    // Устанавливаем точный размер
    await windowManager.setSize(Size(420, windowHeight));

    // Начальная позиция (за пределами экрана справа)
    final startPosition = Offset(
      screenSize.width, // Полностью за правым краем
      (screenSize.height - windowHeight) / 2,
    );

    // Конечная позиция
    final endPosition = Offset(
      screenSize.width - 405, // Правый край
      (screenSize.height - windowHeight) / 2,
    );

    // Устанавливаем начальную позицию (невидимо за экраном)
    await windowManager.setPosition(startPosition);
    await windowManager.setOpacity(0.0); // Начальная прозрачность

    // Показываем окно (но пока прозрачное и за экраном)
    await windowManager.show();

    // Анимация появления
    await _animateWindowAppearance(startPosition, endPosition);

    await windowManager.focus();

    print('Clipboard window initialized with animation');
  });
}





Future<void> _animateWindowAppearanceFromBottom(Offset startPos, Offset endPos) async {
  const duration = Duration(milliseconds: 390);
  const steps = 60;
  final stepDuration = duration ~/ steps;

  for (int i = 0; i <= steps; i++) {
    final progress = i / steps;
    
    // Используем кривую для более естественной анимации
    final curvedProgress = Curves.easeOutCubic.transform(progress);
    
    final currentY = startPos.dy + (endPos.dy - startPos.dy) * curvedProgress;
    final currentPosition = Offset(startPos.dx,currentY);
    
    // Можно использовать разные кривые для прозрачности и движения
    final fadeProgress = Curves.easeOutCubic.transform(progress);
    final currentOpacity = fadeProgress;

    await windowManager.setPosition(currentPosition);
    await windowManager.setOpacity(currentOpacity);

    await Future.delayed(stepDuration);
  }

  // Финальные значения
  await windowManager.setPosition(endPos);
  await windowManager.setOpacity(1.0);
}


Future<void> _animateWindowAppearance(Offset startPos, Offset endPos) async {
  const duration = Duration(milliseconds: 390);
  const steps = 60;
  final stepDuration = duration ~/ steps;

  for (int i = 0; i <= steps; i++) {
    final progress = i / steps;
    
    // Используем кривую для более естественной анимации
    final curvedProgress = Curves.easeOutCubic.transform(progress);
    
    final currentX = startPos.dx + (endPos.dx - startPos.dx) * curvedProgress;
    final currentPosition = Offset(currentX, startPos.dy);
    
    // Можно использовать разные кривые для прозрачности и движения
    final fadeProgress = Curves.easeOutCubic.transform(progress);
    final currentOpacity = fadeProgress;

    await windowManager.setPosition(currentPosition);
    await windowManager.setOpacity(currentOpacity);

    await Future.delayed(stepDuration);
  }

  // Финальные значения
  await windowManager.setPosition(endPos);
  await windowManager.setOpacity(1.0);
}

Future<void> _animateFadeIn() async {
  const duration = Duration(milliseconds: 390);
  const steps = 60;
  final stepDuration = duration ~/ steps;

  for (int i = 0; i <= steps; i++) {
    final progress = i / steps;
    
    // Используем кривую для более естественной анимации
    final curvedProgress = Curves.easeOutCubic.transform(progress);
    
    
    // Можно использовать разные кривые для прозрачности и движения
    final fadeProgress = Curves.easeOutCubic.transform(progress);
    final currentOpacity = fadeProgress;

    await windowManager.setOpacity(currentOpacity);

    await Future.delayed(stepDuration);
  }


  await windowManager.setOpacity(1.0);
}

Future<void> _initChatWindow(List<String> args) async {
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = WindowOptions(
    size: Size(360, 700),
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    alwaysOnTop: true,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }

    await windowManager.setSize(Size(360, 700));

    // Стартовая позиция, если передали args
    if (args.length >= 4) {
      try {
        final parentX = double.parse(args[2]);
        final parentY = double.parse(args[3]);
        final targetX = parentX - 180;
        final targetY = parentY - 650;

        final display = await screenRetriever.getPrimaryDisplay();
        final screenSize = display.size;

        final finalX = targetX.clamp(0.0, screenSize.width - 600);
        final finalY = max(targetY, 0.0);

        await windowManager.setPosition(Offset(finalX, finalY));
      } catch (e) {
        await windowManager.center();
      }
    } else {
      await windowManager.center();
    }

    await windowManager.show();
    await windowManager.focus();
  });
_animateFadeIn();
  // ======================
  // Слушатель stdin для обновления позиции
  // ======================
  
}
Future<void> _initFilesWindow() async {
  await windowManager.ensureInitialized();
  await windowManager.setSize(ui.Size(800, 600));
  await windowManager.center();
  await windowManager.setAlwaysOnTop(true);
  await windowManager.setTitle('📁 Съеденные файлы');
  await windowManager.show();
}

Future<void> _initScreenshotWindow() async {
  await windowManager.ensureInitialized();
  final display = await screenRetriever.getPrimaryDisplay();
        final screenSize = display.size;

  await windowManager.setSize(ui.Size(screenSize.width,screenSize.height));
  await windowManager.center();
  await windowManager.setAlwaysOnTop(true);
  await windowManager.setTitle('📁 Съеденные файлы');
  await windowManager.show();
}
Future<void> _initSettingsWindow() async {
  await windowManager.ensureInitialized();
  await windowManager.setSize(ui.Size(500, 400));
  await windowManager.center();
  await windowManager.setAlwaysOnTop(true);
  await windowManager.setTitle('Настройки');
}


Future<void> _initMainWindow() async {

  
  await windowManager.ensureInitialized();

  final prefs = await SharedPreferences.getInstance();
  final firstRun = prefs.getBool('first_run') ?? true;
  
  // Получаем размер экрана
  final display = await screenRetriever.getPrimaryDisplay();
  final screenSize = display.size;
  
  final windowWidth = firstRun ? 400.0 : 260.0;
  final windowHeight = firstRun ? 500.0 : 270.0;

  WindowOptions windowOptions = WindowOptions(
    size: ui.Size(windowWidth, windowHeight),
    backgroundColor: Colors.transparent,
    skipTaskbar: firstRun ? false : true, // Для первого запуска показываем в таскбаре
    titleBarStyle: firstRun ? TitleBarStyle.normal : TitleBarStyle.hidden,
    windowButtonVisibility: firstRun, // Кнопки только при первом запуске
    alwaysOnTop: !firstRun, // Всегда поверх других только не при первом запуске
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    if (firstRun) {
      // Для первого запуска - обычное окно по центру
      // Не frameless
      await windowManager.setAsFrameless();
      await windowManager.center(); // ✅ ПО ЦЕНТРУ ЭКРАНА
    
    } else {
      // Для последующих запусков - frameless окно в правом нижнем углу
      await windowManager.setAsFrameless();
      await windowManager.setAlwaysOnTop(true);
      await windowManager.setSkipTaskbar(true);
      await windowManager.setPosition(Offset(
        screenSize.width - windowWidth - 15, // right: 15
        screenSize.height - windowHeight - 150, // bottom: 150
      ));
    }
    if (Platform.isWindows) {
  // Настройка прозрачности и кликов
  windowManager.setIgnoreMouseEvents(false); // Разрешаем обработку мыши
  // Убедитесь, что фон окна прозрачный
}
    await windowManager.setTitle('ImeYou Tamagochi');
    await windowManager.setSize(ui.Size(windowWidth, windowHeight));
    await windowManager.show();
  });
  final clipboardMonitor = ClipboardMonitor();
  await clipboardMonitor.initialize();


  runApp(MaterialApp(
    home: firstRun ? NameInputScreen() : TamagochiOverlay(),
    debugShowCheckedModeBanner: false,
  ));
}


class ChatWindowApp extends StatelessWidget {
  final List<Map<String, String>> initialChatHistory;
  final String chatName;

  const ChatWindowApp({Key? key, required this.initialChatHistory, this.chatName = 'Small talk'}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        backgroundColor: Colors.transparent,
        body: ChatWindowContent(
          initialChatHistory: initialChatHistory,
          initialChatName: chatName,
        ),
      ),
    );
  }
}

class ChatWindowContent extends StatefulWidget {
  final List<Map<String, String>> initialChatHistory;
  final String initialChatName;

  const ChatWindowContent({Key? key, required this.initialChatHistory, required this.initialChatName}) : super(key: key);

  @override
  _ChatWindowContentState createState() => _ChatWindowContentState();
}

class _ChatWindowContentState extends State<ChatWindowContent> {
  final List<ChatMessage> _chatHistory = [];
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  String _apiKey = '';
  bool _useDeepSeek = true;
  FocusNode _textFieldFocusNode = FocusNode();
  bool _isSearchMode = false;
  String _searchQuery = '';
  List<ChatMessage> _filteredChatHistory = [];
  bool _showFavorites = false;
  String _currentChatName = 'Small talk';
  List<String> _availableChats = ['Small talk'];
  Map<String, List<ChatMessage>> _chatHistories = {};
  Map<String, String> _chatFiles = {};
  bool _isRecording = false;
  stt.SpeechToText _speechToText = stt.SpeechToText();
  String _recognizedText = '';
  bool _searchWeb = true;
  bool _searchImages = false;
  bool _searchWiki = false;
  String _replyingTo = '';
  File? _backgroundImage;
  final Map<String, List<String>> _searchResults = {};
  final Map<String, List<Map<String, String>>> _imageResults = {};
  final Map<String, String> _wikiResults = {};
  bool _chatLocked = false;
  Timer? _directoryCheckTimer;
  int _hoveredMessageIndex = -1;
  String _defaultLanguage='ru';
  final _httpClient = http.Client();

Future<void> _translateTextToDefaultLanguage() async {
  await _translateText(_defaultLanguage);
}

Future<void> _translateTextToEnglishLanguage() async {
  await _translateText('en');
}

Future<void> _translateText(String targetLanguage) async {
  final text = _messageController.text.trim();
  if (text.isEmpty) {
    //_showMessage('Нет текста для перевода');
    return;
  }

  try {
   

    // Определяем исходный язык
    final sourceLanguage = await _detectLanguage(text);
    
    // Если исходный язык уже целевой - не переводим
    if (sourceLanguage == targetLanguage) {
      //_showMessage('Текст уже на целевом языке');
      return;
    }

    // Пробуем разные API переводчиков
    String translatedText = await _translateWithLibreTranslate(text, sourceLanguage, targetLanguage);
    
    if (translatedText.isEmpty) {
      translatedText = await _translateWithMyMemory(text, sourceLanguage, targetLanguage);
    }

    if (translatedText.isNotEmpty) {
      setState(() {
        _messageController.text = translatedText;
      });
      //_showMessage('Текст переведен');
    } else {
      //_showMessage('Не удалось выполнить перевод');
    }
    
  } catch (e) {
    //_showMessage('Ошибка перевода: $e');
  } finally {
    setState(() {
      //_isProcessing = false;
    });
  }
}

void _setupKeyboardListener() {
  RawKeyboard.instance.addListener((RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      final isControlPressed = event.isControlPressed;
      
      if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyQ) {
        _translateTextToDefaultLanguage(); // Обновлено
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyW) {
        _translateTextToEnglishLanguage(); // Обновлено
      }
    }
  });
}
// Бесплатный API LibreTranslate
Future<String> _translateWithLibreTranslate(String text, String from, String to) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/translate'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'q': text,
        'source': from,
        'target': to,
        'format': 'text'
      }),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['translatedText'] ?? '';
    }
  } catch (e) {
    print('LibreTranslate error: $e');
  }
  return '';
}

// Резервный API MyMemory
Future<String> _translateWithMyMemory(String text, String from, String to) async {
  try {
    final response = await _httpClient.get(
      Uri.parse('https://api.mymemory.translated.net/get?'
          'q=${Uri.encodeComponent(text)}&'
          'langpair=$from|$to'),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['responseData']['translatedText'] ?? '';
    }
  } catch (e) {
    print('MyMemory error: $e');
  }
  return '';
}

Future<String> _detectLanguage(String text) async {
  try {
    // Простая эвристика для определения языка
    return _detectLanguageBasic(text);
    
    // Для более точного определения можно использовать API (раскомментировать при необходимости)
    // return await _detectLanguageWithAPI(text);
  } catch (e) {
    return _detectLanguageBasic(text);
  }
}

// API определение языка (раскомментировать при необходимости)
/*
Future<String> _detectLanguageWithAPI(String text) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/detect'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'q': text}),
    ).timeout(Duration(seconds: 5));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      if (data is List && data.isNotEmpty) {
        return data[0]['language'] ?? 'en';
      }
    }
  } catch (e) {
    print('Language detection API error: $e');
  }
  return _detectLanguageBasic(text);
}
*/

String _detectLanguageBasic(String text) {
  // Улучшенная эвристика для определения языка
  final russianRegex = RegExp(r'[а-яА-ЯёЁ]');
  final englishRegex = RegExp(r'[a-zA-Z]');
  final koreanRegex = RegExp(r'[ㄱ-ㅎㅏ-ㅣ가-힣]');
  final chineseRegex = RegExp(r'[\u4e00-\u9fff]');
  final japaneseRegex = RegExp(r'[\u3040-\u309F\u30A0-\u30FF]');
  
  // Подсчет символов разных языков
  int russianCount = russianRegex.allMatches(text).length;
  int englishCount = englishRegex.allMatches(text).length;
  int koreanCount = koreanRegex.allMatches(text).length;
  int chineseCount = chineseRegex.allMatches(text).length;
  int japaneseCount = japaneseRegex.allMatches(text).length;
  
  // Определяем язык по преобладающим символам
  if (russianCount > 0 && russianCount > englishCount) return 'ru';
  if (koreanCount > 0) return 'ko';
  if (chineseCount > 0) return 'zh';
  if (japaneseCount > 0) return 'ja';
  if (englishCount > 0) return 'en';
  
  return 'en'; // По умолчанию английский
}


  @override
  void initState() {
    super.initState();
    _loadAllChats().then((_) {
      setState(() {
        _currentChatName = widget.initialChatName;
        if (_chatHistories.containsKey(_currentChatName)) {
          _chatHistory.addAll(_chatHistories[_currentChatName]!);
        } else {
          _chatHistory.addAll(widget.initialChatHistory.map((msg) => ChatMessage.fromMap(msg)));
        }
        
        if (_chatHistory.isEmpty && _currentChatName == 'Small talk') {
          _chatHistory.add(ChatMessage(
            type: 'ai',
            message: 'Привет! Как дела? Чем могу помочь?',
            timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
            starred: false,
            chatName: 'Small talk'
          ));
        }
      });
      _scrollToBottom();
    });
    
    
    _loadSavedData();
    _initSpeechToText();
    _loadBackgroundImage();
    _startDirectoryWatcher();
    _initListenerStd();
    _startServer();
     _setupKeyboardListener();
  }
 Future<void> _imReady() async {
  try {
    // Добавляем задержку 1500 мс
    await Future.delayed(const Duration(milliseconds: 300));
    await windowManager.focus();
      if (!_textFieldFocusNode.hasFocus) {
    _textFieldFocusNode.requestFocus();
  }
    final socket = await Socket.connect('localhost', 8082);
    // Явно кодируем в UTF-8
    final encodedData = utf8.encode("chat is ready");
    socket.add(encodedData);
    await socket.flush();
    socket.destroy();
  } catch (e) {
    print('Error sending data: $e');
  }
}
  void _initListenerStd(){
  // Текущие координаты окна
  double currentX = 0;
  double currentY = 0;
  
  stdin.transform(utf8.decoder).transform(const LineSplitter()).listen((line) async {
    try {
      final parts = line.trim().split(',');
      if (parts.length == 2) {
        final targetX = double.tryParse(parts[0]) ?? 0;
        final targetY = double.tryParse(parts[1]) ?? 0;
        
        final dx = targetX - 45;
        final dy = targetY - 625;
        
        // Запускаем плавную анимацию
        await _smoothMove(currentX, currentY, dx, dy, 50);
        
        // Обновляем текущие координаты
        currentX = dx;
        currentY = dy;
      }
    } catch (e) {
      print('Error parsing position from stdin: $e');
    }
  });
}

Future<void> _smoothMove(double startX, double startY, double targetX, double targetY, int durationMs) async {
  const int frames = 8; // Количество кадров анимации
  const double frameDuration = 50 / 8; // ~6.25ms на кадр
  
  for (int i = 1; i <= frames; i++) {
    // Вычисляем прогресс анимации (0.0 - 1.0)
    double progress = i / frames;
    
    // Используем линейную интерполяцию
    double currentX = startX + (targetX - startX) * progress;
    double currentY = startY + (targetY - startY) * progress;
    
    // Устанавливаем новую позицию окна
    await windowManager.setBounds(Rect.fromLTWH(currentX, currentY, 360, 700));
    
    // Ждем перед следующим кадром
    await Future.delayed(Duration(milliseconds: frameDuration.round()));
  }
  
  // Финальная позиция для точности
  await windowManager.setBounds(Rect.fromLTWH(targetX, targetY, 360, 700));
}

Future<void> _startServer() async {
  final server = await ServerSocket.bind('localhost', 8080);
  print('Server listening on port 8080');

  server.listen((Socket socket) {
    final List<int> dataBuffer = [];
    
    socket.listen(
      (List<int> data) {
        dataBuffer.addAll(data);
      },
      onDone: () {
        // Декодируем все полученные данные как UTF-8
        final String receivedString = utf8.decode(dataBuffer);
        _putIntoInput(receivedString);
      },
      onError: (error) {
        print('Socket error: $error');
      }
    );
  });

  await _imReady();
}
void _putIntoInput(String clipboardtext) {

  
  // Убедимся, что текстовое поле получает фокус
  if (!_textFieldFocusNode.hasFocus) {
    _textFieldFocusNode.requestFocus();
  }
  
  final currentText = _messageController.text;
  
  String newText;
  int newPosition;
  
  // Если текстовое поле не в фокусе или нет активного выделения,
  // просто добавляем текст в конец
  if (!_textFieldFocusNode.hasFocus || _messageController.selection.baseOffset == -1) {
    newText = currentText + clipboardtext;
    newPosition = newText.length;
  } else {
    final selection = _messageController.selection;
    
    if (selection.start == selection.end) {
      // Курсор без выделения - вставляем в позицию курсора
      final before = currentText.substring(0, selection.start);
      final after = currentText.substring(selection.end);
      newText = '$before$clipboardtext$after';
      newPosition = selection.start + clipboardtext.length;
    } else {
      // Есть выделенный текст - заменяем его
      final before = currentText.substring(0, selection.start);
      final after = currentText.substring(selection.end);
      newText = '$before$clipboardtext$after';
      newPosition = selection.start + clipboardtext.length;
    }
  }
  
  // Используем setValue для полного обновления контроллера
  _messageController.value = TextEditingValue(
    text: newText,
    selection: TextSelection.collapsed(offset: newPosition),
  );
  
  // Убедимся, что фокус установлен
  _textFieldFocusNode.requestFocus();
  setState(() {}); // Обновляем высоту
}
  void _startDirectoryWatcher() {
    _directoryCheckTimer = Timer.periodic(Duration(seconds: 5), (timer) async {
      await _checkForNewFiles();
    });
  }

  Future<void> _checkForNewFiles() async {
    await _loadAllChats();
  }

  Future<void> _loadAllChats() async {
    final directory = await getApplicationDocumentsDirectory();
    final chatsDir = Directory('${directory.path}/imeyou_pet/chats');
    
    if (!chatsDir.existsSync()) {
      chatsDir.createSync(recursive: true);
      return;
    }

    var chatFolders = chatsDir.listSync();
    List<String> chats = ['Новый чат'];
    Map<String, List<ChatMessage>> allChats = {};

    for (var folder in chatFolders) {
      if (folder is Directory) {
        String chatName = path.basename(folder.path);
        if (chatName != 'Новый чат') {
          chats.add(chatName);
          allChats[chatName] = await _loadChatHistory(chatName);
        }
      }
    }

    setState(() {
      _availableChats = chats;
      _chatHistories = allChats;
    });
  }

  Future<List<ChatMessage>> _loadChatHistory(String chatName) async {
    final directory = await getApplicationDocumentsDirectory();
    final chatDir = Directory('${directory.path}/imeyou_pet/chats/$chatName');
    List<ChatMessage> history = [];

    if (chatDir.existsSync()) {
      var messageFiles = chatDir.listSync();
      
      // Сортируем файлы по timestamp
      messageFiles.sort((a, b) {
        String nameA = path.basename(a.path);
        String nameB = path.basename(b.path);
        return nameA.compareTo(nameB);
      });

      for (var file in messageFiles) {
        if (file is File && file.path.endsWith('.json')) {
          try {
            String content = await file.readAsString();
            Map<String, dynamic> messageData = json.decode(content);
            history.add(ChatMessage(
              type: messageData['source'] ?? messageData['type'] ?? 'user',
              message: messageData['text'] ?? messageData['message'] ?? '',
              timestamp: messageData['timestamp'] ?? DateTime.now().millisecondsSinceEpoch.toString(),
              starred: messageData['starred'] == true || messageData['starred'] == 'true',
              chatName: chatName,
              searchResults: List<String>.from(messageData['searchResults'] ?? []),
              imageResults: List<Map<String, String>>.from(messageData['imageResults'] ?? []),
              wikiResult: messageData['wikiResult'] ?? ''
            ));
          } catch (e) {
            print('Ошибка чтения файла ${file.path}: $e');
          }
        }
      }
    }
    return history;
  }

  Future<void> _saveMessageToChat(ChatMessage message) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final chatDir = Directory('${directory.path}/imeyou_pet/chats/${message.chatName}');
      
      if (!chatDir.existsSync()) {
        chatDir.createSync(recursive: true);
      }
      
      String timestamp = message.timestamp;
      String sourcePrefix = message.type.toLowerCase() == 'ai' ? 'ai' : 'user';
      String fileName = '${timestamp}_$sourcePrefix.json';
      
      final messageFile = File('${chatDir.path}/$fileName');
      await messageFile.writeAsString(json.encode(message.toMap()));
      
    } catch (e) {
      print('Error saving message: $e');
    }
  }

  void _initSpeechToText() async {
    bool available = await _speechToText.initialize();
    if (!available) {
      print("Speech to text not available");
    }
  }

  void _loadBackgroundImage() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final bgDir = Directory('${directory.path}/imeyou_pet/widget_backgrounds');
      
      if (bgDir.existsSync()) {
        final configFile = File('${bgDir.path}/current_chat_bg.json');
        if (configFile.existsSync()) {
          final jsonString = await configFile.readAsString();
          final configData = json.decode(jsonString);
          final bgPath = configData['current_bg'];
          
          if (bgPath != null && File(bgPath).existsSync()) {
            setState(() {
              _backgroundImage = File(bgPath);
            });
            return;
          }
        }
        
        final files = bgDir.listSync();
        for (var file in files) {
          if (file.path.endsWith('chat_skin.png') || file.path.endsWith('chat_skin.jpg')) {
            setState(() {
              _backgroundImage = File(file.path);
            });
            break;
          }
        }
      }
    } catch (e) {
      print('Error loading background: $e');
    }
  }

  void _loadSavedData() async {
    final prefs = await SharedPreferences.getInstance();
    if (mounted) {
      setState(() {
        _apiKey = prefs.getString('api_key') ?? '';
        _useDeepSeek = prefs.getBool('use_deepseek') ?? true;
      });
    }
  }

  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  void _sendMessage() async {
    if (_chatLocked) return;
    
    final message = _messageController.text.trim();
    if (message.isEmpty) return;

    final userMessage = ChatMessage(
      type: 'user',
      message: message,
      timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
      starred: false,
      chatName: _currentChatName
    );
    
    setState(() {
      _chatHistory.add(userMessage);
      _messageController.clear();
      _replyingTo = '';
    });
    
    await _saveMessageToChat(userMessage);
    _scrollToBottom();

    if (_apiKey.isNotEmpty) {
      await _callAIAPI(message);
    }

    if (_searchWeb || _searchImages || _searchWiki) {
      await _performSearches(message);
    }
  }

  Future<void> _callAIAPI(String prompt) async {
    try {
      List<Map<String, dynamic>> messages = [];
      int startIndex = max(0, _chatHistory.length - 100);
      
      for (int i = startIndex; i < _chatHistory.length; i++) {
        var msg = _chatHistory[i];
        messages.add({
          "role": msg.type == 'user' ? "user" : "assistant",
          "content": msg.message
        });
      }

      messages.add({"role": "user", "content": prompt});

      var response = await http.post(
        Uri.parse('https://api.deepseek.com/v1/chat/completions'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $_apiKey',
        },
        body: json.encode({
          'model': 'deepseek-chat',
          'messages': messages,
          'max_tokens': 1000,
        }),
      );

      if (response.statusCode == 200) {
        var data = json.decode(response.body);
        String aiResponse = data['choices'][0]['message']['content'];
        
        if (_currentChatName == 'Новый чат' && aiResponse.contains('<chatname>')) {
          RegExp exp = RegExp(r'<chatname>(.*?)</chatname>');
          Match? match = exp.firstMatch(aiResponse);
          if (match != null) {
            String newChatName = match.group(1)!;
            setState(() {
              _currentChatName = newChatName;
              _availableChats = [_availableChats[0], 'Small talk', newChatName];
            });
            aiResponse = aiResponse.replaceAll(exp, '').trim();
          }
        }

        if (aiResponse.toLowerCase().contains('закрытие чата') || 
            aiResponse.toLowerCase().contains('chat closed')) {
          setState(() {
            _chatLocked = true;
          });
        }

        final aiMessage = ChatMessage(
          type: 'ai',
          message: aiResponse,
          timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
          starred: false,
          chatName: _currentChatName
        );
        
        setState(() {
          _chatHistory.add(aiMessage);
        });
        
        await _saveMessageToChat(aiMessage);
        _scrollToBottom();
      }
    } catch (e) {
      print('Error calling AI API: $e');
      // Fallback сообщение
      final fallbackMessage = ChatMessage(
        type: 'ai',
        message: 'Извините, произошла ошибка при подключении к AI сервису. Пожалуйста, проверьте подключение к интернету и настройки API ключа.',
        timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
        starred: false,
        chatName: _currentChatName
      );
      
      setState(() {
        _chatHistory.add(fallbackMessage);
      });
      await _saveMessageToChat(fallbackMessage);
      _scrollToBottom();
    }
  }

  Future<void> _performSearches(String query) async {
    if (_searchWeb) {
      await _searchWebResults(query);
    }
    if (_searchImages) {
      await _searchImagesResults(query);
    }
    if (_searchWiki && query.split(' ').length < 10) {
      await _searchWikiResults(query);
    }
  }

  Future<void> _searchWebResults(String query) async {
    // Mock web search results
    final results = [
      'https://example.com/result1',
      'https://example.com/result2',
      'https://example.com/result3',
    ];
    
    if (_chatHistory.isNotEmpty) {
      final lastMessage = _chatHistory.last;
      lastMessage.searchResults = results;
      await _saveMessageToChat(lastMessage);
    }
  }

  Future<void> _searchImagesResults(String query) async {
    // Mock image results
    final results = [];
    for (int i = 0; i < 9; i++) {
      results.add({
        'url': 'https://example.com/image$i.jpg',
        'thumbnail': 'https://example.com/thumb$i.jpg',
        'title': 'Result ${i + 1}'
      });
    }
    
    if (_chatHistory.isNotEmpty) {
      final lastMessage = _chatHistory.last;
      lastMessage.imageResults = List<Map<String, String>>.from(results);
      await _saveMessageToChat(lastMessage);
    }
  }

  Future<void> _searchWikiResults(String query) async {
    // Mock wiki result
    final result = 'Wikipedia article about $query - This is a summary of the first 50 words from the Wikipedia article...';
    
    if (_chatHistory.isNotEmpty) {
      final lastMessage = _chatHistory.last;
      lastMessage.wikiResult = result;
      await _saveMessageToChat(lastMessage);
    }
  }

  void _removeMessage(int index) async {
    if (index >= 0 && index < _chatHistory.length) {
      final message = _chatHistory[index];
      setState(() {
        _chatHistory.removeAt(index);
      });
      // Удаляем файл сообщения
      final directory = await getApplicationDocumentsDirectory();
      final chatDir = Directory('${directory.path}/imeyou_pet/chats/${message.chatName}');
      if (chatDir.existsSync()) {
        final files = chatDir.listSync();
        for (var file in files) {
          if (file is File && file.path.endsWith('.json')) {
            try {
              String content = await file.readAsString();
              Map<String, dynamic> messageData = json.decode(content);
              if (messageData['timestamp'] == message.timestamp) {
                file.deleteSync();
                break;
              }
            } catch (e) {
              print('Error deleting message file: $e');
            }
          }
        }
      }
    }
  }

  void _toggleStar(int index) async {
    if (index >= 0 && index < _chatHistory.length) {
      setState(() {
        _chatHistory[index].starred = !_chatHistory[index].starred;
      });
      await _saveMessageToChat(_chatHistory[index]);
    }
  }

  void _copyToClipboard(String text) {
    Clipboard.setData(ClipboardData(text: text));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Скопировано в буфер обмена')),
    );
  }

  void _setReply(String message) {
    setState(() {
      _replyingTo = message;
    });
  }

  void _clearChat() {
    setState(() {
      _chatHistory.removeWhere((msg) => !msg.starred);
    });
  }

 void _startRecording() async {
  if (_isRecording) return;
  
  if (await _speechToText.initialize()) {
    setState(() {
      _isRecording = true;
      _recognizedText = '';
    });
    
    _speechToText.listen(
      onResult: (result) {
        setState(() {
          _recognizedText = result.recognizedWords;
          _messageController.text = _recognizedText;
        });
      },
    );
  }
}

void _stopRecording() {
  _speechToText.stop();
  setState(() {
    _isRecording = false;
  });
}

  void _handleFileDrop(List<File> files) {
    if (files.isNotEmpty) {
      _analyzeFile(files.first.path);
    }
  }

  void _handleBackgroundImageDrop(List<File> files) async {
    if (files.isNotEmpty && (files.first.path.endsWith('.png') || files.first.path.endsWith('.jpg'))) {
      try {
        final directory = await getApplicationDocumentsDirectory();
        final bgDir = Directory('${directory.path}/imeyou_pet/widget_backgrounds');
        if (!bgDir.existsSync()) {
          bgDir.createSync(recursive: true);
        }
        
        final newFile = File('${bgDir.path}/chat_skin${path.extension(files.first.path)}');
        await newFile.writeAsBytes(await files.first.readAsBytes());
        
        final configFile = File('${bgDir.path}/current_chat_bg.json');
        final configData = {
          'current_bg': newFile.path
        };
        await configFile.writeAsString(json.encode(configData));
        
        print('Background saved: ${newFile.path}');
        _loadBackgroundImage();
        
      } catch (e) {
        print('Error setting background: $e');
      }
    }
  }

  void _analyzeFile(String filePath) async {
    final fileName = path.basename(filePath);
    final fileExtension = path.extension(filePath).toLowerCase();
    final fileSize = File(filePath).lengthSync();

    String fileMetadata = await _extractFileMetadata(filePath);

    String analysisPrompt = '''
Проанализируй файл: $fileName
Путь: $filePath
Размер: ${fileSize ~/ 1024} KB
Расширение: $fileExtension
$fileMetadata

Если тебе знаком название или ты можешь предположить что это за файл - дай обратную связь (например, музыкальная композиция, книга, программа). Если файл незнаком так и напиши "файл неопознан". Будь краток и информативен.
''';

    setState(() {
      _chatHistory.add(ChatMessage(
        type: 'ai',
        message: '📁 Анализ файла: $fileName\nЭто файл типа $fileExtension. Предположительно: ${_guessFileType(fileExtension)}',
        timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
        starred: false,
        chatName: _currentChatName
      ));
    });
    _saveFileResponse(filePath, "Mock analysis response");
  }

  String _guessFileType(String extension) {
    switch (extension) {
      case '.txt': return 'Текстовый файл';
      case '.pdf': return 'PDF документ';
      case '.jpg': case '.png': return 'Изображение';
      case '.mp3': return 'Аудио файл';
      case '.mp4': return 'Видео файл';
      default: return 'Неизвестный тип файла';
    }
  }

  Future<String> _extractFileMetadata(String filePath) async {
    final file = File(filePath);
    final stat = await file.stat();
    return 'Создан: ${stat.modified}\nРазмер: ${stat.size} байт';
  }

  Future<void> _saveFileResponse(String filePath, String response) async {
    final directory = await getApplicationDocumentsDirectory();
    final responsesDir = Directory('${directory.path}/imeyou_pet/file_responses');
    if (!responsesDir.existsSync()) {
      responsesDir.createSync(recursive: true);
    }
    
    final responseFile = File('${responsesDir.path}/${path.basename(filePath)}.response.txt');
    await responseFile.writeAsString(response);
  }

  void _createNewChat() {
    setState(() {
      _currentChatName = 'Новый чат';
      _chatHistory.clear();
      _chatLocked = false;
    });
  }

  void _switchChat(String chatName) {
    if (chatName == 'Новый чат') {
      _createNewChat();
      return;
    }
    
    setState(() {
      _currentChatName = chatName;
      _chatHistory.clear();
      if (_chatHistories.containsKey(chatName)) {
        _chatHistory.addAll(_chatHistories[chatName]!);
      }
      _chatLocked = false;
    });
  }

  void _filterMessages() {
    if (_isSearchMode && _searchQuery.isNotEmpty) {
      _filteredChatHistory = _searchAcrossAllChats(_searchQuery);
    } else if (_showFavorites) {
      _filteredChatHistory = _getAllStarredMessages();
    } else {
      _filteredChatHistory = List.from(_chatHistory);
    }
  }

  List<ChatMessage> _getAllStarredMessages() {
    List<ChatMessage> allStarred = [];
    for (var chat in _chatHistories.values) {
      allStarred.addAll(chat.where((msg) => msg.starred));
    }
    // Сортируем по времени (новые сверху)
    allStarred.sort((a, b) => b.timestamp.compareTo(a.timestamp));
    return allStarred;
  }

  List<ChatMessage> _searchAcrossAllChats(String query) {
    List<ChatMessage> allMessages = [];
    for (var chat in _chatHistories.values) {
      allMessages.addAll(chat);
    }
    allMessages.addAll(_chatHistory); // Добавляем текущие сообщения

    return _filterSearchResults(allMessages, query);
  }

  List<ChatMessage> _filterSearchResults(List<ChatMessage> messages, String query) {
    final queryLower = query.toLowerCase().trim();
    
    if (queryLower.isEmpty) {
      return messages;
    }

    final queryWords = queryLower.split(RegExp(r'\s+')).where((word) => word.length > 1).toList();
    
    if (queryWords.length <= 1) {
      return messages.where((msg) {
        final content = msg.message.toLowerCase();
        return content.contains(queryLower);
      }).toList();
    } else {
      final List<Map<String, dynamic>> resultsWithScore = [];
      
      for (final message in messages) {
        final content = message.message.toLowerCase();
        
        double score = 0.0;
        int foundWords = 0;
        
        for (final word in queryWords) {
          bool wordFound = false;
          
          final wordVariations = _getWordVariations(word);
          for (final variation in wordVariations) {
            if (content.contains(variation)) {
              score += variation == word ? 3.0 : 2.5;
              wordFound = true;
              break;
            }
          }
          
          if (!wordFound) {
            final wordPattern = RegExp(r'\b' + word);
            if (wordPattern.hasMatch(content)) {
              score += 2.0;
              wordFound = true;
            }
          }
          
          if (wordFound) foundWords++;
        }
        
        if (foundWords == queryWords.length) {
          score += 5.0;
        }
        
        if (message.starred) {
          score += 2.0;
        }
        
        final lengthPenalty = content.length > 200 ? content.length / 1000.0 : 0.0;
        score -= lengthPenalty;
        
        if (content.contains(queryLower)) {
          score += 4.0;
        }
        
        if (content.startsWith(queryLower)) {
          score += 3.0;
        }
        
        // Бонус за новые сообщения
        final ageBonus = _calculateAgeBonus(message.timestamp);
        score += ageBonus;
        
        if (foundWords > 0) {
          resultsWithScore.add({
            'message': message,
            'score': score,
            'foundWords': foundWords,
            'contentLength': content.length,
          });
        }
      }
      
      resultsWithScore.sort((a, b) {
        final double scoreA = a['score'] as double;
        final double scoreB = b['score'] as double;
        
        if (scoreB > scoreA) return 1;
        if (scoreB < scoreA) return -1;
        
        final int wordsA = a['foundWords'] as int;
        final int wordsB = b['foundWords'] as int;
        if (wordsB > wordsA) return 1;
        if (wordsB < wordsA) return -1;
        
        final int lengthA = a['contentLength'] as int;
        final int lengthB = b['contentLength'] as int;
        return lengthA.compareTo(lengthB);
      });
      
      return resultsWithScore.map((e) => e['message'] as ChatMessage).toList();
    }
  }

  double _calculateAgeBonus(String timestamp) {
    try {
      final messageTime = DateTime.fromMillisecondsSinceEpoch(int.parse(timestamp));
      final now = DateTime.now();
      final difference = now.difference(messageTime);
      
      if (difference.inDays == 0) return 3.0; // Сегодня
      if (difference.inDays <= 7) return 2.0; // На этой неделе
      if (difference.inDays <= 30) return 1.0; // В этом месяце
      return 0.0;
    } catch (e) {
      return 0.0;
    }
  }

  List<String> _getWordVariations(String word) {
    final variations = <String>[];
    variations.add(word);
    
    if (word.length > 3) {
      if (word.endsWith('а')) {
        variations.add(word.substring(0, word.length - 1));
      }
      if (word.endsWith('я')) {
        variations.add(word.substring(0, word.length - 1));
      }
      if (word.endsWith('о')) {
        variations.add(word.substring(0, word.length - 1));
      }
      if (word.endsWith('ы')) {
        variations.add(word.substring(0, word.length - 1));
      }
      if (word.endsWith('и')) {
        variations.add(word.substring(0, word.length - 1));
      }
    }
    
    return variations;
  }

  Widget _buildMessageBubble(ChatMessage chat, int index) {
    final isAI = chat.type == 'ai';
    
    return MouseRegion(
      onEnter: (_) => setState(() => _hoveredMessageIndex = index),
      onExit: (_) => setState(() => _hoveredMessageIndex = -1),
      child: Container(
        margin: EdgeInsets.only(bottom: 12),
        child: Column(
          crossAxisAlignment: isAI ? CrossAxisAlignment.start : CrossAxisAlignment.end,
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: isAI ? MainAxisAlignment.start : MainAxisAlignment.end,
              children: [
                if (isAI) ...[
                  Container(
                    padding: EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: Color(0xFF2B2B2B).withOpacity(0.8),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(Icons.android, size: 16, color: Colors.white),
                  ),
                  SizedBox(width: 8),
                ],
                Flexible(
                  child: Container(
                    padding: EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: isAI 
                        ? Color(0xFF2B2B2B).withOpacity(0.8)
                        : Color(0xFF2B2B2B).withOpacity(0.7),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          chat.message,
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                          ),
                        ),
                        ..._buildConditionalWidgets(chat),
                      ],
                    ),
                  ),
                ),
                if (!isAI) ...[
                  SizedBox(width: 8),
                  Container(
                    padding: EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: Color(0xFF2B2B2B).withOpacity(0.8),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(Icons.person, size: 16, color: Colors.white),
                  ),
                ],
              ],
            ),
            
            // Кнопки появляются только при ховере
            if (_hoveredMessageIndex == index)
              Container(
                margin: EdgeInsets.only(top: 4),
                child: Row(
                  mainAxisAlignment: isAI ? MainAxisAlignment.start : MainAxisAlignment.end,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (isAI) SizedBox(width: 32),
                    Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        GestureDetector(
                          onTap: () => _toggleStar(index),
                          child: Container(
                            width: 25,
                            height: 25,
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(
                              chat.starred ? Icons.star : Icons.star_border,
                              size: 16,
                              color: chat.starred ? Colors.yellow : Colors.white,
                            ),
                          ),
                        ),
                        SizedBox(width: 4),
                        GestureDetector(
                          onTap: () => _copyToClipboard(chat.message),
                          child: Container(
                            width: 25,
                            height: 25,
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.content_copy, size: 16, color: Colors.white),
                          ),
                        ),
                        SizedBox(width: 4),
                        GestureDetector(
                          onTap: () => _setReply(chat.message),
                          child: Container(
                            width: 25,
                            height: 25,
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.reply, size: 16, color: Colors.white),
                          ),
                        ),
                        SizedBox(width: 4),
                        GestureDetector(
                          onTap: () => _removeMessage(index),
                          child: Container(
                            width: 25,
                            height: 25,
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.delete, size: 16, color: Colors.white),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildConditionalWidgets(ChatMessage chat) {
    final List<Widget> widgets = [];
    
    if (chat.type == 'ai' && chat.searchResults.isNotEmpty) {
      widgets.addAll([
        SizedBox(height: 8),
        _buildSearchResults(chat.searchResults),
      ]);
    }
    
    if (chat.type == 'ai' && chat.imageResults.isNotEmpty) {
      widgets.addAll([
        SizedBox(height: 8),
        _buildImageGrid(chat.imageResults),
      ]);
    }
    
    if (chat.type == 'ai' && chat.wikiResult.isNotEmpty) {
      widgets.addAll([
        SizedBox(height: 8),
        _buildWikiWidget(chat.wikiResult),
      ]);
    }
    
    return widgets;
  }

  Widget _buildSearchResults(List<String> results) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Результаты поиска:', style: TextStyle(color: Colors.white70, fontSize: 12)),
        ...results.map((url) => GestureDetector(
          onTap: () => launch(url),
          child: Row(
            children: [
              Container(
                width: 16,
                height: 16,
                margin: EdgeInsets.only(right: 4),
                decoration: BoxDecoration(
                  color: Colors.blue,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              Expanded(
                child: Text(
                  url,
                  style: TextStyle(color: Colors.blue, fontSize: 12),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        )).toList(),
      ],
    );
  }

  Widget _buildImageGrid(List<Map<String, String>> images) {
    return GridView.builder(
      shrinkWrap: true,
      physics: NeverScrollableScrollPhysics(),
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        crossAxisSpacing: 4,
        mainAxisSpacing: 4,
      ),
      itemCount: min(images.length, 9),
      itemBuilder: (context, index) {
        return Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            color: Colors.grey[800],
          ),
          child: Center(
            child: Text(
              'Image ${index + 1}',
              style: TextStyle(color: Colors.white, fontSize: 10),
            ),
          ),
        );
      },
    );
  }

  Widget _buildWikiWidget(String wikiText) {
    return Container(
      padding: EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.2),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.article, size: 16, color: Colors.white),
              SizedBox(width: 4),
              Text('Wikipedia', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
            ],
          ),
          SizedBox(height: 4),
          Text(
            wikiText,
            style: TextStyle(color: Colors.white, fontSize: 12),
            maxLines: 3,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

 @override
Widget build(BuildContext context) {
  _filterMessages();
  
  return Material(
    color: Colors.transparent,
    child: Stack(
      children: [
        if (_backgroundImage != null)
          Positioned.fill(
            child: Container(
              decoration: BoxDecoration(
                image: DecorationImage(
                  image: FileImage(_backgroundImage!),
                  fit: BoxFit.cover,
                  alignment: Alignment.center,
                ),
              ),
            ),
          ),
        
        Container(
          color: Colors.transparent,
          child: Column(
            children: [
              // Header (фиксированная высота)
              Container(
                height: 40,
                padding: EdgeInsets.symmetric(horizontal: 12),
                color: Colors.transparent,
                child: Row(
                  children: [
                    Expanded(
                      child: DropdownButton<String>(
                        value: _currentChatName,
                        dropdownColor: Color(0xFF2B2B2B),
                        style: TextStyle(color: Colors.white, fontSize: 14),
                        underline: Container(),
                        onChanged: (String? newValue) {
                          if (newValue != null) _switchChat(newValue);
                        },
                        items: _availableChats.map<DropdownMenuItem<String>>((String value) {
                          return DropdownMenuItem<String>(
                            value: value,
                            child: Container(
                              constraints: BoxConstraints(maxWidth: 600),
                              child: Text(
                                value,
                                style: TextStyle(color: Colors.white),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          );
                        }).toList(),
                      ),
                    ),
                    if (_chatLocked)
                      Padding(
                        padding: EdgeInsets.only(right: 8),
                        child: Text(
                          'Чат закрыт',
                          style: TextStyle(color: Colors.red, fontSize: 12),
                        ),
                      ),
                    MouseRegion(
                      cursor: SystemMouseCursors.click,
                      child: GestureDetector(
                        onTap: _clearChat,
                        child: Container(
                          padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: Colors.red.withOpacity(0.7),
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            'Очистить чат',
                            style: TextStyle(color: Colors.white, fontSize: 12),
                          ),
                        ),
                      ),
                    ),
                    SizedBox(width: 8),
                    MouseRegion(
                      cursor: SystemMouseCursors.click,
                      child: GestureDetector(
                        onTap: () => windowManager.close(),
                        child: Icon(Icons.close, size: 20, color: Colors.white),
                      ),
                    ),
                  ],
                ),
              ),

              // Tabs (фиксированная высота)
              Container(
                height: 30,
                child: Row(
                  children: [
                    Expanded(
                      child: GestureDetector(
                        onTap: () => setState(() {
                          _showFavorites = false;
                          _isSearchMode = false;
                        }),
                        child: Container(
                          decoration: BoxDecoration(
                            color: !_showFavorites && !_isSearchMode 
                              ? Colors.blue.withOpacity(0.3) 
                              : Colors.transparent,
                          ),
                          child: Center(
                            child: Text(
                              'Все сообщения',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                    Expanded(
                      child: GestureDetector(
                        onTap: () => setState(() {
                          _showFavorites = true;
                          _isSearchMode = false;
                        }),
                        child: Container(
                          decoration: BoxDecoration(
                            color: _showFavorites 
                              ? Colors.blue.withOpacity(0.3) 
                              : Colors.transparent,
                          ),
                          child: Center(
                            child: Text(
                              'Избранные',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),

              // Reply widget (фиксированная высота при наличии)
              if (_replyingTo.isNotEmpty)
                Container(
                  height: 40, // фиксированная высота
                  margin: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  padding: EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.green.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.reply, size: 16, color: Colors.white),
                      SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _replyingTo,
                          style: TextStyle(color: Colors.white, fontSize: 12),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      GestureDetector(
                        onTap: () => setState(() => _replyingTo = ''),
                        child: Icon(Icons.close, size: 16, color: Colors.white),
                      ),
                    ],
                  ),
                ),

              // Гибкая область для истории сообщений и поля ввода
              Expanded(
                child: LayoutBuilder(
                  builder: (context, constraints) {
                    // Вычисляем высоту поля ввода
                    final double inputHeight = _calculateInputHeight();
                    // Высота истории сообщений = общая высота - высота поля ввода
                    final double chatHistoryHeight = constraints.maxHeight - inputHeight;
                    
                    return Column(
                      children: [
                        // История сообщений (растет/уменьшается сверху)
                        Container(
                          height: chatHistoryHeight,
                          child: _filteredChatHistory.isEmpty
                              ? Center(
                                  child: Container(
                                    padding: EdgeInsets.all(16),
                                    decoration: BoxDecoration(
                                      color: Color(0xFF2B2B2B).withOpacity(0.8),
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    child: Text(
                                      'Нет сообщений',
                                      style: TextStyle(color: Colors.white54),
                                    ),
                                  ),
                                )
                              : ListView.builder(
                                  controller: _scrollController,
                                  padding: EdgeInsets.all(16),
                                  itemCount: _filteredChatHistory.length,
                                  itemBuilder: (context, index) {
                                    return _buildMessageBubble(_filteredChatHistory[index], index);
                                  },
                                ),
                        ),
                        
                        // Поле ввода (растет вверх)
                        Container(
                          height: inputHeight,
                          child: Column(
                            children: [
                              // Checkboxes (фиксированная высота)
                              Container(
                                height: 30,
                                padding: EdgeInsets.symmetric(horizontal: 16),
                                child: Row(
                                  children: [
                                    Row(
                                      children: [
                                        Checkbox(
                                          value: _searchWeb,
                                          onChanged: (value) => setState(() => _searchWeb = value ?? false),
                                          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                        ),
                                        Text('search web', style: TextStyle(color: Colors.white, fontSize: 11)),
                                      ],
                                    ),
                                    Row(
                                      children: [
                                        Checkbox(
                                          value: _searchImages,
                                          onChanged: (value) => setState(() => _searchImages = value ?? false),
                                          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                        ),
                                        Text('search images', style: TextStyle(color: Colors.white, fontSize: 11)),
                                      ],
                                    ),
                                    Row(
                                      children: [
                                        Checkbox(
                                          value: _searchWiki,
                                          onChanged: (value) => setState(() => _searchWiki = value ?? false),
                                          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                        ),
                                        Text('search wiki', style: TextStyle(color: Colors.white, fontSize: 11)),
                                      ],
                                    ),
                                  ],
                                ),
                              ),

                              // Поле ввода текста (растет вверх)
                              Expanded(
                                child: Container(
                                  margin: EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    color: Color(0xFF2B2B2B).withOpacity(0.9),
                                    borderRadius: BorderRadius.circular(20),
                                  ),
                                  child: Row(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      if (_isSearchMode)
                                        Padding(
                                          padding: EdgeInsets.only(left: 16, top: 12),
                                          child: Text('?:', style: TextStyle(color: Colors.yellow)),
                                        ),
                                      
                                      Expanded(
                                        child: TextField(
                                          controller: _messageController,
                                          focusNode: _textFieldFocusNode,
                                          style: TextStyle(color: Colors.white),
                                          maxLines: null,
                                          decoration: InputDecoration(
                                            contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                                            border: InputBorder.none,
                                            hintText: _isSearchMode ? 'Поиск в чате...' : 'Введите сообщение...',
                                            hintStyle: TextStyle(color: Colors.white70),
                                          ),
                                          onChanged: (value) {
                                            if (value.startsWith('?:')) {
                                              setState(() {
                                                _isSearchMode = true;
                                                _searchQuery = value.substring(2).trim();
                                              });
                                            } else if (_isSearchMode && !value.startsWith('?:')) {
                                              setState(() {
                                                _isSearchMode = false;
                                                _searchQuery = '';
                                              });
                                            }
                                            setState(() {}); // Пересчет высоты
                                          },
                                          onSubmitted: (value) {
                                            if (_isSearchMode) {
                                              setState(() {
                                                _isSearchMode = false;
                                                _searchQuery = '';
                                                _messageController.clear();
                                              });
                                            } else {
                                              _sendMessage();
                                            }
                                          },
                                          enabled: !_chatLocked,
                                        ),
                                      ),
                                      if (_isRecording)
                                        Padding(
                                          padding: EdgeInsets.only(right: 8, top: 12),
                                          child: Icon(Icons.mic, color: Colors.red),
                                        ),
                                      IconButton(
                                        icon: Icon(Icons.send, color: Colors.white),
                                        onPressed: _chatLocked ? null : _sendMessage,
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    );
                  },
                ),
              ),
            ],
          ),
        ),
      ],
    ),
  );
}

double _calculateInputHeight() {
  final text = _messageController.text;
  final double baseHeight = 110.0; // Базовая высота (чекбоксы + минимальная высота поля)
  
  if (text.isEmpty) {
    return baseHeight;
  }
  
  // Расчет высоты на основе количества строк
  final lineCount = '\n'.allMatches(text).length ;
  final double lineHeight = 50.0; // Высота одной строки
  final double minTextFieldHeight = 110.0; // Минимальная высота текстового поля
  final double maxInputHeight = 420.0; // Максимальная высота всего поля ввода
  
  // Высота текстового поля = минимум 40px + (количество строк - 1) * высота строки
  final double textFieldHeight = minTextFieldHeight + (lineCount - 1) * lineHeight;
  
  // Общая высота = чекбоксы (30px) + текстовое поле + отступы
  final double totalHeight = textFieldHeight ; // 32px = margin (16+16)
  
  return totalHeight.clamp(baseHeight, maxInputHeight);
}

  @override
  void dispose() {
    _directoryCheckTimer?.cancel();
    _speechToText.stop();
    super.dispose();
  }
}

class ChatMessage {
  final String type;
  final String message;
  final String timestamp;
  bool starred;
  final String chatName;
  List<String> searchResults;
  List<Map<String, String>> imageResults;
  String wikiResult;

  ChatMessage({
    required this.type,
    required this.message,
    required this.timestamp,
    required this.starred,
    required this.chatName,
    this.searchResults = const [],
    this.imageResults = const [],
    this.wikiResult = '',
  });

  factory ChatMessage.fromMap(Map<String, String> map) {
    return ChatMessage(
      type: map['type'] ?? map['source'] ?? 'user',
      message: map['message'] ?? map['text'] ?? '',
      timestamp: map['timestamp'] ?? DateTime.now().millisecondsSinceEpoch.toString(),
      starred: map['starred'] == 'true',
      chatName: map['chatName'] ?? 'Small talk',
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'type': type,
      'message': message,
      'timestamp': timestamp,
      'starred': starred,
      'chatName': chatName,
      'searchResults': searchResults,
      'imageResults': imageResults,
      'wikiResult': wikiResult,
    };
  }
}

class EatenFilesWindowApp extends StatefulWidget {
  const EatenFilesWindowApp({Key? key}) : super(key: key);

  @override
  State<EatenFilesWindowApp> createState() => _EatenFilesWindowAppState();
}

class _EatenFilesWindowAppState extends State<EatenFilesWindowApp> {
  final TextEditingController _addController = TextEditingController();
  final TextEditingController _searchController = TextEditingController();
  final TextEditingController _folderNameController = TextEditingController();
  final FocusNode _addFocusNode = FocusNode();
  final FocusNode _folderNameFocusNode = FocusNode();
  
  bool _isAdding = false;
  bool _isCreatingFolder = false;
  Set<String> _selectedFilters = {};
  Map<String, List<EatenFile>> _filteredFiles = {
    'recent': [],
    'this_month': [],
    'older': []
  };
  int _currentTab = 0;
  List<EatenFile> _files = [];
  List<EatenFile> _recentlyOpened = [];
  List<CustomFolder> _customFolders = [];
  
  final String _storageDir = path.join(Directory.current.path, 'imeyou_pet', 'eaten_files');
  final String _foldersDataPath = path.join(Directory.current.path, 'imeyou_pet', 'custom_folders.json');
  
  Offset? _contextMenuPosition;
  EatenFile? _contextMenuFile;
  int? _contextMenuIndex;
  StreamSubscription<FileSystemEvent>? _fileWatcher;
  bool _isInitialized = false;
  bool _isLoading = true;

  // Редактирование файла
  bool _isEditing = false;
  EatenFile? _editingFile;
  final TextEditingController _editNameController = TextEditingController();
  final TextEditingController _editCommentController = TextEditingController();
  
  // Дебаунс для поиска
  Timer? _searchDebounce;
  
  @override
  void initState() {
    super.initState();
    _initializeApp();
  }

  void _initializeApp() async {
    try {
      await windowManager.ensureInitialized();
      
      final storageDir = Directory(_storageDir);
      if (!await storageDir.exists()) {
        await storageDir.create(recursive: true);
      }
      
      // Загружаем данные без блокировки UI
      await _loadFilesFromStorage();
      await _loadCustomFolders();
      
      _startFileWatcher();
      _setupListeners();
      
      if (mounted) {
        setState(() {
          _isInitialized = true;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Error in initializeApp: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  void _setupListeners() {
    _searchController.addListener(() {
      // Дебаунс поиска - ждем 300ms после последнего ввода
      _searchDebounce?.cancel();
      _searchDebounce = Timer(const Duration(milliseconds: 300), () {
        if (_isInitialized && mounted) {
          _updateFilteredFiles();
        }
      });
    });
    
    _addFocusNode.addListener(() {
      if (!_addFocusNode.hasFocus && mounted && _isAdding && _addController.text.isEmpty) {
        Future.delayed(const Duration(milliseconds: 100), () {
          if (mounted && !_addFocusNode.hasFocus) {
            setState(() {
              _isAdding = false;
            });
          }
        });
      }
    });
  }

  void _startFileWatcher() {
    try {
      final dir = Directory(_storageDir);
      _fileWatcher = dir.watch(recursive: false).listen((event) {
        if (event.type == FileSystemEvent.create || event.type == FileSystemEvent.delete) {
          Future.delayed(const Duration(milliseconds: 500), () {
            if (mounted) {
              _loadFilesFromStorage();
            }
          });
        }
      });
    } catch (e) {
      debugPrint('Error starting file watcher: $e');
    }
  }
  
  Future<void> _loadFilesFromStorage() async {
    try {
      final dir = Directory(_storageDir);
      if (!await dir.exists()) {
        if (mounted) {
          setState(() {
            _files = [];
            _filteredFiles = _filterFilesSync();
          });
        }
        return;
      }
      
      final List<EatenFile> loadedFiles = [];
      final entities = await dir.list().toList();
      
      for (var entity in entities) {
        if (entity is File && entity.path.endsWith('.json')) {
          try {
            final content = await entity.readAsString();
            final jsonData = json.decode(content);
            final file = EatenFile.fromJson(jsonData);
            loadedFiles.add(file);
          } catch (e) {
            debugPrint('Error loading file ${entity.path}: $e');
          }
        }
      }
      
      if (mounted) {
        setState(() {
          _files = loadedFiles;
          _filteredFiles = _filterFilesSync();
        });
      }
    } catch (e) {
      debugPrint('Error loading files from storage: $e');
    }
  }

  Future<void> _loadCustomFolders() async {
    try {
      final file = File(_foldersDataPath);
      if (await file.exists()) {
        final content = await file.readAsString();
        final List<dynamic> jsonList = json.decode(content);
        if (mounted) {
          setState(() {
            _customFolders = jsonList.map((e) => CustomFolder.fromJson(e)).toList();
          });
        }
      }
    } catch (e) {
      debugPrint('Error loading custom folders: $e');
    }
  }

  void _saveCustomFolders() async {
    try {
      final file = File(_foldersDataPath);
      final dir = file.parent;
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }
      await file.writeAsString(json.encode(_customFolders.map((e) => e.toJson()).toList()));
    } catch (e) {
      debugPrint('Error saving custom folders: $e');
    }
  }

  Future<void> _saveFileWithDuplicateCheck(EatenFile newFile) async {
    final existingFileIndex = _files.indexWhere((file) => file.path == newFile.path);
    
    if (existingFileIndex != -1) {
      final existingFile = _files[existingFileIndex];
      newFile.isStarred = existingFile.isStarred;
      newFile.openCount = existingFile.openCount;
      newFile.lastOpened = existingFile.lastOpened;
      newFile.comment = existingFile.comment;
      if (newFile.iconBytes == null && existingFile.iconBytes != null) {
        newFile.iconBytes = existingFile.iconBytes;
      }
      _files.removeAt(existingFileIndex);
    }
    
    _files.insert(0, newFile);
    
    await _saveFile(newFile);
    if (mounted) {
      setState(() {
        _filteredFiles = _filterFilesSync();
      });
    }
  }

  Future<void> _saveFile(EatenFile file) async {
    try {
      final fileName = '${file.id}.json';
      final filePath = path.join(_storageDir, fileName);
      final outputFile = File(filePath);
      final dir = outputFile.parent;
      
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }
      
      await outputFile.writeAsString(json.encode(file.toJson()));
    } catch (e) {
      debugPrint('Error saving file: $e');
    }
  }

  Future<void> _deleteFile(EatenFile file) async {
    try {
      final fileName = '${file.id}.json';
      final filePath = path.join(_storageDir, fileName);
      final outputFile = File(filePath);
      if (await outputFile.exists()) {
        await outputFile.delete();
      }
      if (mounted) {
        setState(() {
          _files.remove(file);
          _filteredFiles = _filterFilesSync();
        });
      }
    } catch (e) {
      debugPrint('Error deleting file: $e');
    }
  }

  void _addItem(String itemPath) async {
    final trimmedPath = itemPath.trim();
    if (trimmedPath.isEmpty) return;

    final isWeb = _isWebUrl(trimmedPath);
    final isSystemPath = _isSystemPath(trimmedPath);
    
    if (!isWeb && !isSystemPath) {
      _showErrorSnackbar('Некорректный путь или URL');
      return;
    }

    try {
      Uint8List? iconBytes;
      String title = 'none';
      
      if (isWeb) {
        // Для веб-сайтов загружаем иконку и заголовок асинхронно
        iconBytes = await _getFavicon(trimmedPath);
        title = await _getPageTitle(trimmedPath);
        if (title == 'none') {
          title = _getDomainName(trimmedPath);
        }
      } else if (isSystemPath) {
        // Для файлов получаем иконку
        if (trimmedPath.toLowerCase().endsWith('.lnk')) {
          iconBytes = await _getLnkFileIcon(trimmedPath);
        } else {
          iconBytes = await _getFileIcon(trimmedPath);
        }
      }

      final newFile = EatenFile(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        path: trimmedPath,
        isWeb: isWeb,
        isStarred: false,
        openCount: 0,
        lastOpened: null,
        iconBytes: iconBytes,
        fileName: isWeb ? _getDomainName(trimmedPath) : path.basename(trimmedPath),
        pageTitle: title,
        comment: '',
      );

      await _saveFileWithDuplicateCheck(newFile);
      
      _addController.clear();
      if (mounted) {
        setState(() {
          _isAdding = false;
        });
      }
    } catch (e) {
      debugPrint('Error adding item: $e');
      _showErrorSnackbar('Ошибка при добавлении файла');
    }
  }

  void _showErrorSnackbar(String message) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(message),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 2),
        )
      );
    }
  }

  Future<void> _handlePasteFromClipboard() async {
    try {
      if (Platform.isWindows || Platform.isMacOS || Platform.isLinux) {
        final result = await FilePicker.platform.pickFiles(
          allowMultiple: true,
          type: FileType.any,
        );

        if (result != null && result.files.isNotEmpty) {
          for (var platformFile in result.files) {
            if (platformFile.path != null) {
              _addItem(platformFile.path!);
            }
          }
        }
      }
    } catch (e) {
      debugPrint('Error handling paste: $e');
    }
  }

  bool _isWebUrl(String text) {
    final trimmed = text.trim();
    return trimmed.startsWith('http://') || 
           trimmed.startsWith('https://') ||
           trimmed.startsWith('www.');
  }

  bool _isSystemPath(String text) {
    final trimmed = text.trim();
    if (Platform.isWindows) {
      return trimmed.contains(':\\') || trimmed.startsWith('\\\\');
    } else {
      return trimmed.startsWith('/');
    }
  }

  Future<Uint8List?> _getFavicon(String url) async {
    try {
      final domain = _getDomainName(url);
      final faviconUrl = 'https://www.google.com/s2/favicons?domain=$domain&sz=32';
      final response = await http.get(Uri.parse(faviconUrl));
      if (response.statusCode == 200) {
        return response.bodyBytes;
      }
    } catch (e) {
      debugPrint('Error getting favicon: $e');
    }
    return null;
  }

  Future<String> _getPageTitle(String url) async {
    try {
      final formattedUrl = url.startsWith('http') ? url : 'https://$url';
      final response = await http.get(Uri.parse(formattedUrl));
      if (response.statusCode == 200) {
        final titleMatch = RegExp(r'<title>(.*?)</title>', caseSensitive: false).firstMatch(response.body);
        if (titleMatch != null && titleMatch.group(1)!.isNotEmpty) {
          return titleMatch.group(1)!;
        }
      }
    } catch (e) {
      debugPrint('Error getting page title: $e');
    }
    return _getDomainName(url);
  }

  Future<Uint8List?> _getLnkFileIcon(String lnkPath) async {
    try {
      const MethodChannel _channel = MethodChannel('screenshot_channel');
      final result = await _channel.invokeMethod('getLnkFileIcon', lnkPath);
      if (result != null) {
        return result as Uint8List;
      }
    } catch (e) {
      debugPrint('Error getting lnk file icon: $e');
    }
    
    return await _getFileIcon(lnkPath);
  }

  Future<Uint8List?> _getFileIcon(String filePath) async {
    try {
      const MethodChannel _channel = MethodChannel('screenshot_channel');
      final result = await _channel.invokeMethod('getFileIcon', filePath);
      return result as Uint8List?;
    } catch (e) {
      debugPrint('Error getting file icon: $e');
      return null;
    }
  }

  void _toggleStar(EatenFile file) async {
    if (mounted) {
      setState(() {
        file.isStarred = !file.isStarred;
        _filteredFiles = _filterFilesSync();
      });
    }
    await _saveFile(file);
  }

  void _incrementOpenCount(EatenFile file) async {
    if (mounted) {
      setState(() {
        file.openCount++;
        file.lastOpened = DateTime.now();
        _filteredFiles = _filterFilesSync();
      });
    }
    await _saveFile(file);
  }

  void _updateFilteredFiles() {
    if (!_isInitialized || !mounted) return;
    
    setState(() {
      _filteredFiles = _filterFilesSync();
    });
  }

  Map<String, List<EatenFile>> _filterFilesSync() {
    List<EatenFile> currentList = _currentTab == 0 ? List.from(_files) : List.from(_recentlyOpened);

    // Применяем поиск
    final searchQuery = _searchController.text.toLowerCase().trim();
    if (searchQuery.isNotEmpty) {
      final searchTerms = searchQuery.split(' ');
      currentList = currentList.where((file) {
        final fileName = file.fileName.toLowerCase();
        final filePath = file.path.toLowerCase();
        final comment = file.comment?.toLowerCase() ?? '';
        
        return searchTerms.every((term) =>
          fileName.contains(term) ||
          filePath.contains(term) ||
          comment.contains(term)
        );
      }).toList();
    }

    // Применяем фильтры
    if (_selectedFilters.isNotEmpty) {
      currentList = currentList.where((file) {
        if (file.isWeb) {
          final domain = _getDomainName(file.path);
          return _selectedFilters.contains('url') || 
                 _selectedFilters.contains('domain:$domain');
        } else {
          final ext = path.extension(file.path).toLowerCase();
          if (ext.isNotEmpty) {
            return _selectedFilters.contains(ext);
          } else {
            return _selectedFilters.contains('no_ext');
          }
        }
      }).toList();
    }

    // Группируем по времени
    return _groupFilesByTimeOptimized(currentList, _currentTab);
  }

  String _getDomainName(String url) {
    try {
      final uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');
      return uri.host;
    } catch (e) {
      return url.length > 15 ? '${url.substring(0, 12)}...' : url;
    }
  }

  Map<String, List<EatenFile>> _groupFilesByTimeOptimized(List<EatenFile> files, int currentTab) {
    if (currentTab != 0) {
      return {'recent': files, 'this_month': [], 'older': []};
    }

    final recent = <EatenFile>[];
    final thisMonthList = <EatenFile>[];
    final older = <EatenFile>[];

    for (var file in files) {
      if (file.isWeb) {
        recent.add(file);
        continue;
      }

      try {
        final fileEntity = File(file.path);
        if (fileEntity.existsSync()) {
          recent.add(file); // Упрощенная логика для производительности
        } else {
          recent.add(file);
        }
      } catch (e) {
        recent.add(file);
      }
    }

    return {
      'recent': recent,
      'this_month': thisMonthList,
      'older': older,
    };
  }

  void _createFolder() {
    final folderName = _folderNameController.text.trim();
    if (folderName.isEmpty) return;

    final newFolder = CustomFolder(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: folderName,
      fileIds: [],
    );

    if (mounted) {
      setState(() {
        _customFolders.add(newFolder);
        _isCreatingFolder = false;
        _folderNameController.clear();
      });
    }
    _saveCustomFolders();
  }

  Widget _buildFileGridItem(EatenFile file, int index) {
    return FileGridItem1(
      file: file,
      index: index,
      onTap: () {
        _hideContextMenu();
        if (file.isWeb || _isWebUrl(file.path)) {
          _openWebUrl(file);
        } else {
          _openFile(file);
        }
        _incrementOpenCount(file);
      },
      onLongPress: () {
        _hideContextMenu();
        if (file.isWeb || _isWebUrl(file.path)) {
          _searchWebTitle(file.path);
        } else {
          _revealInExplorer(file.path);
        }
      },
      onSecondaryTap: (details) {
        _showContextMenu(details.globalPosition, file, index);
      },
      onStarToggled: () => _toggleStar(file),
    );
  }

  void _showContextMenu(Offset position, EatenFile file, int index) {
    if (mounted) {
      setState(() {
        _contextMenuPosition = position;
        _contextMenuFile = file;
        _contextMenuIndex = index;
      });
    }
  }

  void _hideContextMenu() {
    if (mounted) {
      setState(() {
        _contextMenuPosition = null;
        _contextMenuFile = null;
        _contextMenuIndex = null;
      });
    }
  }

  void _handleMenuAction(String action) {
    if (_contextMenuFile == null || _contextMenuIndex == null) return;

    final file = _contextMenuFile!;
    final fileExists = file.isWeb ? true : File(file.path).existsSync();

    switch (action) {
      case 'open':
        if (file.isWeb) {
          _openWebUrl(file);
        } else if (fileExists) {
          _openFile(file);
        }
        _incrementOpenCount(file);
        break;
      case 'reveal':
        if (!file.isWeb && fileExists) {
          _revealInExplorer(file.path);
        }
        break;
      case 'search':
        if (file.isWeb) {
          _searchWebTitle(file.path);
        }
        break;
      case 'delete':
        _deleteFile(file);
        break;
      case 'toggle_star':
        _toggleStar(file);
        break;
      case 'edit':
        _startEditing(file);
        break;
    }

    _hideContextMenu();
  }

  void _startEditing(EatenFile file) {
    if (mounted) {
      setState(() {
        _isEditing = true;
        _editingFile = file;
        _editNameController.text = file.fileName;
        _editCommentController.text = file.comment ?? '';
      });
    }
  }

  void _stopEditing() {
    if (mounted) {
      setState(() {
        _isEditing = false;
        _editingFile = null;
        _editNameController.clear();
        _editCommentController.clear();
      });
    }
  }

  void _saveEditing() async {
    if (_editingFile == null) return;

    if (mounted) {
      setState(() {
        _editingFile!.fileName = _editNameController.text;
        _editingFile!.comment = _editCommentController.text;
        _filteredFiles = _filterFilesSync();
      });
    }

    await _saveFile(_editingFile!);
    _stopEditing();
  }

  Widget _buildContextMenu() {
    if (_contextMenuPosition == null || _contextMenuFile == null) return const SizedBox.shrink();

    final file = _contextMenuFile!;
    final isWeb = file.isWeb;
    final fileExists = isWeb ? true : File(file.path).existsSync();

    return Positioned(
      left: _contextMenuPosition!.dx,
      top: _contextMenuPosition!.dy,
      child: Container(
        width: 200,
        decoration: BoxDecoration(
          color: const Color(0xFF2D2D2D),
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.4),
              blurRadius: 15,
              spreadRadius: 2,
            )
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildContextMenuItem(
              Icons.open_in_new,
              'Открыть',
              Colors.blue,
              () => _handleMenuAction('open'),
            ),
            if (!isWeb && fileExists)
              _buildContextMenuItem(
                Icons.folder_open,
                'Расположение',
                Colors.green,
                () => _handleMenuAction('reveal'),
              )
            else
              _buildContextMenuItem(
                Icons.search,
                'Найти',
                Colors.green,
                () => _handleMenuAction('search'),
              ),
            _buildContextMenuItem(
              file.isStarred ? Icons.star : Icons.star_border,
              file.isStarred ? 'Снять звезду' : 'В звезды',
              Colors.orange,
              () => _handleMenuAction('toggle_star'),
            ),
            _buildContextMenuItem(
              Icons.edit,
              'Редактировать',
              Colors.blue,
              () => _handleMenuAction('edit'),
            ),
            _buildContextMenuItem(
              Icons.delete,
              'Удалить',
              Colors.red,
              () => _handleMenuAction('delete'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContextMenuItem(IconData icon, String text, Color color, VoidCallback onTap) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Icon(icon, size: 20, color: color),
              const SizedBox(width: 12),
              Text(
                text,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 14,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildExtensionFilter() {
    final extensions = _getAllExtensions();
    final domains = _getAllDomains();

    return Container(
      width: 200,
      color: Colors.black.withOpacity(0.3),
      child: ListView(
        children: [
          const Padding(
            padding: EdgeInsets.all(8),
            child: Text(
              'Фильтры',
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Divider(color: Colors.white54),
          if (domains.isNotEmpty) ...[
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 8),
              child: Text('Домены:', style: TextStyle(color: Colors.white70)),
            ),
            ...domains.map((domain) => _buildFilterItem('🌐 $domain', 'domain:$domain')),
            Divider(color: Colors.white54),
          ],
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 8),
            child: Text('Расширения:', style: TextStyle(color: Colors.white70)),
          ),
          ...extensions.map((ext) => _buildFilterItem(
            ext == 'url' ? '🌐 URL' : 
            ext == 'no_ext' ? '📄 Без расширения' : 
            '📄 ${ext.toUpperCase()}',
            ext
          )),
          Divider(color: Colors.white54),
          ListTile(
            title: const Text(
              'Очистить фильтры',
              style: TextStyle(
                color: Colors.white70,
                fontSize: 12,
              ),
            ),
            trailing: const Icon(Icons.clear_all, size: 16, color: Colors.white70),
            onTap: () {
              if (mounted) {
                setState(() {
                  _selectedFilters.clear();
                  _filteredFiles = _filterFilesSync();
                });
              }
            },
          ),
        ],
      ),
    );
  }

  Widget _buildFilterItem(String label, String value) {
    final isSelected = _selectedFilters.contains(value);
    
    return ListTile(
      title: Text(
        label,
        style: TextStyle(
          color: isSelected ? Colors.blue : Colors.white,
          fontSize: 12,
        ),
      ),
      trailing: isSelected ? const Icon(Icons.check, size: 16, color: Colors.blue) : null,
      onTap: () {
        if (mounted) {
          setState(() {
            if (isSelected) {
              _selectedFilters.remove(value);
            } else {
              _selectedFilters.add(value);
            }
            _filteredFiles = _filterFilesSync();
          });
        }
      },
    );
  }

  Set<String> _getAllExtensions() {
    final extensions = <String>{};
    final currentList = _currentTab == 0 ? _files : _recentlyOpened;
    
    for (var file in currentList) {
      if (file.isWeb) {
        extensions.add('url');
      } else {
        final ext = path.extension(file.path).toLowerCase();
        if (ext.isNotEmpty) {
          extensions.add(ext);
        } else {
          extensions.add('no_ext');
        }
      }
    }
    
    return extensions;
  }

  Set<String> _getAllDomains() {
    final domains = <String>{};
    final currentList = _currentTab == 0 ? _files : _recentlyOpened;
    
    for (var file in currentList) {
      if (file.isWeb) {
        domains.add(_getDomainName(file.path));
      }
    }
    
    return domains;
  }

  void _pickFile() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        allowMultiple: false,
        type: FileType.any,
      );

      if (result != null && result.files.single.path != null) {
        _addController.text = result.files.single.path!;
      }
    } catch (e) {
      debugPrint('Error picking file: $e');
    }
  }

  void _searchWebTitle(String url) async {
    final searchUrl = 'https://www.google.com/search?q=${Uri.encodeComponent(url)}';
    if (await canLaunch(searchUrl)) {
      await launch(searchUrl);
    }
  }

  Widget _buildEditPanel() {
    if (!_isEditing || _editingFile == null) return const SizedBox.shrink();

    return Positioned(
      right: 0,
      top: 0,
      bottom: 0,
      width: 200,
      child: Container(
        color: const Color(0xFF2B2B2B).withOpacity(0.95),
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Редактирование',
              style: TextStyle(
                color: Colors.white,
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            
            Container(
              width: double.infinity,
              height: 120,
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.3),
                borderRadius: BorderRadius.circular(8),
              ),
              child: _editingFile!.iconBytes != null
                  ? Image.memory(
                      _editingFile!.iconBytes!,
                      fit: BoxFit.contain,
                    )
                  : Icon(
                      _editingFile!.isWeb ? Icons.language : Icons.insert_drive_file,
                      color: Colors.white,
                      size: 48,
                    ),
            ),
            const SizedBox(height: 16),
            
            const Text(
              'Название:',
              style: TextStyle(color: Colors.white70, fontSize: 12),
            ),
            const SizedBox(height: 4),
            TextField(
              controller: _editNameController,
              style: const TextStyle(color: Colors.white, fontSize: 12),
              decoration: InputDecoration(
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                  borderSide: BorderSide.none,
                ),
                filled: true,
                fillColor: Colors.black.withOpacity(0.3),
                contentPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
              ),
            ),
            const SizedBox(height: 16),
            
            if (!_editingFile!.isWeb) ...[
              const Text(
                'Расположение:',
                style: TextStyle(color: Colors.white70, fontSize: 12),
              ),
              const SizedBox(height: 4),
              Row(
                children: [
                  Expanded(
                    child: Text(
                      _editingFile!.path,
                      style: const TextStyle(color: Colors.white54, fontSize: 10),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(width: 8),
                  MouseRegion(
                    cursor: SystemMouseCursors.click,
                    child: GestureDetector(
                      onTap: () => _revealInExplorer(_editingFile!.path),
                      child: Container(
                        padding: const EdgeInsets.all(4),
                        decoration: BoxDecoration(
                          color: Colors.blue.withOpacity(0.3),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: const Icon(Icons.folder_open, size: 16, color: Colors.white),
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
            ],
            
            const Text(
              'Комментарий:',
              style: TextStyle(color: Colors.white70, fontSize: 12),
            ),
            const SizedBox(height: 4),
            Expanded(
              child: TextField(
                controller: _editCommentController,
                style: const TextStyle(color: Colors.white, fontSize: 12),
                maxLines: null,
                expands: true,
                textAlignVertical: TextAlignVertical.top,
                decoration: InputDecoration(
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide.none,
                  ),
                  filled: true,
                  fillColor: Colors.black.withOpacity(0.3),
                  contentPadding: const EdgeInsets.all(8),
                ),
              ),
            ),
            const SizedBox(height: 16),
            
            Row(
              children: [
                Expanded(
                  child: MouseRegion(
                    cursor: SystemMouseCursors.click,
                    child: GestureDetector(
                      onTap: _saveEditing,
                      child: Container(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        decoration: BoxDecoration(
                          color: Colors.blue.withOpacity(0.8),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Center(
                          child: Text(
                            'Сохранить',
                            style: TextStyle(color: Colors.white, fontSize: 12),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: MouseRegion(
                    cursor: SystemMouseCursors.click,
                    child: GestureDetector(
                      onTap: () {
                        _deleteFile(_editingFile!);
                        _stopEditing();
                      },
                      child: Container(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        decoration: BoxDecoration(
                          color: Colors.red.withOpacity(0.8),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Center(
                          child: Text(
                            'Удалить',
                            style: TextStyle(color: Colors.white, fontSize: 12),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: _stopEditing,
                child: Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(vertical: 8),
                  decoration: BoxDecoration(
                    color: Colors.grey.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Center(
                    child: Text(
                      'Отмена',
                      style: TextStyle(color: Colors.white, fontSize: 12),
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            Row(
              children: [
                _buildExtensionFilter(),
                Expanded(
                  child: Stack(
                    children: [
                      Container(
                        margin: EdgeInsets.only(right: _isEditing ? 200 : 0),
                        decoration: BoxDecoration(
                          color: const Color(0xFF2B2B2B).withOpacity(0.95),
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(12),
                            bottomLeft: Radius.circular(12),
                          ),
                        ),
                        child: Column(
                          children: [
                            // Header
                            Container(
                              height: 40,
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              decoration: BoxDecoration(
                                color: const Color(0xFF1A1A1A).withOpacity(0.9),
                                borderRadius: const BorderRadius.only(
                                  topLeft: Radius.circular(12),
                                ),
                              ),
                              child: Row(
                                children: [
                                  const Text(
                                    'Файлы',
                                    style: TextStyle(
                                      color: Colors.white,
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  const Spacer(),
                                  MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: () => windowManager.close(),
                                      child: const Icon(Icons.close, size: 20, color: Colors.white),
                                    ),
                                  ),
                                ],
                              ),
                            ),

                            // Вкладки и поиск
                            Container(
                              padding: const EdgeInsets.all(12),
                              color: const Color(0xFF1A1A1A).withOpacity(0.7),
                              child: Column(
                                children: [
                                  Row(
                                    children: [
                                      _buildTab('📁 Съеденные', 0),
                                      _buildTab('🕐 Недавние', 1),
                                      Expanded(
                                        child: Padding(
                                          padding: const EdgeInsets.symmetric(horizontal: 8),
                                          child: TextField(
                                            controller: _searchController,
                                            style: const TextStyle(color: Colors.white),
                                            decoration: InputDecoration(
                                              hintText: 'Поиск...',
                                              hintStyle: const TextStyle(color: Colors.white54),
                                              border: OutlineInputBorder(
                                                borderRadius: BorderRadius.circular(20),
                                                borderSide: BorderSide.none,
                                              ),
                                              filled: true,
                                              fillColor: const Color(0xFF2B2B2B).withOpacity(0.8),
                                              contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                            ),
                                          ),
                                        ),
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.paste, color: Colors.white),
                                        onPressed: _handlePasteFromClipboard,
                                        tooltip: 'Вставить из буфера обмена',
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),

                            // Строка добавления (только для съеденных)
                            if (_currentTab == 0) _buildAddRow(),

                            // Список файлов
                            Expanded(
                              child: _isLoading 
                                  ? const Center(child: CircularProgressIndicator())
                                  : _buildFileList(),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            
            // Контекстное меню
            _buildContextMenu(),

            // Панель редактирования
            _buildEditPanel(),
          ],
        ),
      ),
    );
  }

  Widget _buildAddRow() {
    return Container(
      padding: const EdgeInsets.all(12),
      color: const Color(0xFF1A1A1A).withOpacity(0.7),
      child: Row(
        children: [
          if (_isAdding) ...[
            Expanded(
              child: TextField(
                controller: _addController,
                focusNode: _addFocusNode,
                style: const TextStyle(color: Colors.white),
                decoration: InputDecoration(
                  hintText: 'Введите URL или путь к файлу...',
                  hintStyle: const TextStyle(color: Colors.white54),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide.none,
                  ),
                  filled: true,
                  fillColor: const Color(0xFF2B2B2B).withOpacity(0.8),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                onSubmitted: (_) => _addItem(_addController.text),
              ),
            ),
            const SizedBox(width: 8),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: _pickFile,
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: const Color(0xFF2B2B2B).withOpacity(0.8),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Icon(Icons.folder_open, color: Colors.white),
                ),
              ),
            ),
            const SizedBox(width: 4),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: () => _addItem(_addController.text),
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Icon(Icons.add, color: Colors.white),
                ),
              ),
            ),
            const SizedBox(width: 4),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: () {
                  if (mounted) {
                    setState(() {
                      _isAdding = false;
                      _addController.clear();
                    });
                  }
                },
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: const Color(0xFF2B2B2B).withOpacity(0.8),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Icon(Icons.close, color: Colors.white),
                ),
              ),
            ),
          ] else ...[
            Expanded(
              child: Text(
                '📁 Съеденные файлы (${_files.length})',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: () {
                  if (mounted) {
                    setState(() {
                      _isAdding = true;
                    });
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      _addFocusNode.requestFocus();
                    });
                  }
                },
                child: Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Row(
                    children: [
                      Icon(Icons.add, color: Colors.white, size: 16),
                      SizedBox(width: 8),
                      Text(
                        'Добавить файл',
                        style: TextStyle(color: Colors.white),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildFileList() {
    final isEmpty = _currentTab == 0 ? _files.isEmpty : _recentlyOpened.isEmpty;

    if (isEmpty) {
      return Center(
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: const Color(0xFF2B2B2B).withOpacity(0.8),
            borderRadius: BorderRadius.circular(12),
          ),
          child: const Text(
            'Нет файлов',
            style: TextStyle(color: Colors.white54),
          ),
        ),
      );
    }

    // Проверяем, есть ли вообще файлы для отображения
    final hasRecent = _filteredFiles['recent']?.isNotEmpty ?? false;
    final hasThisMonth = _filteredFiles['this_month']?.isNotEmpty ?? false;
    final hasOlder = _filteredFiles['older']?.isNotEmpty ?? false;

    if (!hasRecent && !hasThisMonth && !hasOlder) {
      return Center(
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: const Color(0xFF2B2B2B).withOpacity(0.8),
            borderRadius: BorderRadius.circular(12),
          ),
          child: const Text(
            'Нет файлов по выбранным фильтрам',
            style: TextStyle(color: Colors.white54),
          ),
        ),
      );
    }

    return Container(
      color: const Color(0xFF2B2B2B).withOpacity(0.8),
      child: ListView(
        padding: const EdgeInsets.all(12),
        children: [
          if (hasRecent) ...[
            _buildSectionHeader('Недавние'),
            _buildFileGrid(_filteredFiles['recent']!),
            const SizedBox(height: 16),
          ],
          if (hasThisMonth) ...[
            _buildSectionHeader('В этом месяце'),
            _buildFileGrid(_filteredFiles['this_month']!),
            const SizedBox(height: 16),
          ],
          if (hasOlder) ...[
            _buildSectionHeader('Ранее'),
            _buildFileGrid(_filteredFiles['older']!),
          ],
        ],
      ),
    );
  }

  Widget _buildFileGrid(List<EatenFile> files) {
    return GridView.builder(
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 8,
        mainAxisSpacing: 8,
        crossAxisSpacing: 8,
        childAspectRatio: 0.85,
      ),
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: files.length,
      itemBuilder: (context, index) {
        final file = files[index];
        return _buildFileGridItem(file, index);
      },
    );
  }

  void _openWebUrl(EatenFile file) async {
    String formattedUrl = file.path.trim();
    if (!formattedUrl.startsWith('http')) {
      formattedUrl = 'https://$formattedUrl';
    }
    
    if (await canLaunch(formattedUrl)) {
      await launch(formattedUrl);
      _incrementOpenCount(file);
      _addToRecentlyOpened(file);
    }
  }

  void _openFile(EatenFile file) async {
    try {
      if (Platform.isWindows) {
        await Process.run('start', ['""', file.path], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', [file.path]);
      } else if (Platform.isLinux) {
        await Process.run('xdg-open', [file.path]);
      }
      _addToRecentlyOpened(file);
    } catch (e) {
      debugPrint('Error opening file: $e');
    }
  }

  void _addToRecentlyOpened(EatenFile file) {
    if (mounted) {
      setState(() {
        _recentlyOpened.removeWhere((f) => f.id == file.id);
        _recentlyOpened.insert(0, file);
        if (_recentlyOpened.length > 100) {
          _recentlyOpened.removeRange(100, _recentlyOpened.length);
        }
      });
    }
  }

  Widget _buildTab(String title, int tabIndex) {
    final isSelected = _currentTab == tabIndex;
    return GestureDetector(
      onTap: () {
        if (mounted) {
          setState(() {
            _currentTab = tabIndex;
            _filteredFiles = _filterFilesSync();
          });
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isSelected ? Colors.blue.withOpacity(0.3) : Colors.transparent,
          border: Border(
            bottom: BorderSide(
              color: isSelected ? Colors.blue : Colors.transparent,
              width: 2,
            ),
          ),
        ),
        child: Text(
          title,
          style: TextStyle(
            color: isSelected ? Colors.white : Colors.white70,
            fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
          ),
        ),
      ),
    );
  }
  
  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Text(
        title,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 14,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  void _revealInExplorer(String filePath) async {
    try {
      if (Platform.isWindows) {
        await Process.run('explorer', ['/select,', filePath]);
      } else if (Platform.isMacOS) {
        await Process.run('open', ['-R', filePath]);
      } else if (Platform.isLinux) {
        final dir = path.dirname(filePath);
        await Process.run('xdg-open', [dir]);
      }
    } catch (e) {
      debugPrint('Error revealing file: $e');
    }
  }

  @override
  void dispose() {
    _searchDebounce?.cancel();
    _fileWatcher?.cancel();
    _addFocusNode.dispose();
    _addController.dispose();
    _searchController.dispose();
    _folderNameController.dispose();
    _folderNameFocusNode.dispose();
    _editNameController.dispose();
    _editCommentController.dispose();
    super.dispose();
  }
}

class EatenFile {
  final String id;
  final String path;
  final bool isWeb;
  bool isStarred;
  int openCount;
  DateTime? lastOpened;
  Uint8List? iconBytes;
  String fileName;
  final String pageTitle;
  String? comment;

  EatenFile({
    required this.id,
    required this.path,
    required this.isWeb,
    required this.isStarred,
    required this.openCount,
    this.lastOpened,
    this.iconBytes,
    required this.fileName,
    required this.pageTitle,
    this.comment,
  });

  factory EatenFile.fromJson(Map<String, dynamic> json) {
    return EatenFile(
      id: json['id'],
      path: json['path'],
      isWeb: json['isWeb'],
      isStarred: json['isStarred'],
      openCount: json['openCount'],
      lastOpened: json['lastOpened'] != null ? DateTime.parse(json['lastOpened']) : null,
      fileName: json['fileName'] ?? (json['isWeb'] ? _getDomainName(json['path']) : _getFileName(json['path'])),
      pageTitle: json['pageTitle'] != null ? json['pageTitle'] : 'none',
      comment: json['comment'],
    );
  }

  static String _getFileName(String filePath) {
    final parts = filePath.split(RegExp(r'[\\/]'));
    return parts.isNotEmpty ? parts.last : filePath;
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'path': path,
      'isWeb': isWeb,
      'isStarred': isStarred,
      'openCount': openCount,
      'lastOpened': lastOpened?.toIso8601String(),
      'fileName': fileName,
      'pageTitle': pageTitle,
      'comment': comment,
    };
  }

  static String _getDomainName(String url) {
    try {
      final uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');
      return uri.host;
    } catch (e) {
      return url.length > 15 ? '${url.substring(0, 12)}...' : url;
    }
  }
}

class CustomFolder {
  final String id;
  final String name;
  final List<String> fileIds;

  CustomFolder({
    required this.id,
    required this.name,
    required this.fileIds,
  });

  factory CustomFolder.fromJson(Map<String, dynamic> json) {
    return CustomFolder(
      id: json['id'],
      name: json['name'],
      fileIds: List<String>.from(json['fileIds'] ?? []),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'fileIds': fileIds,
    };
  }
}

class FileGridItem1 extends StatefulWidget {
  final EatenFile file;
  final int index;
  final VoidCallback onTap;
  final VoidCallback onLongPress;
  final void Function(TapDownDetails) onSecondaryTap;
  final VoidCallback onStarToggled;

  const FileGridItem1({
    Key? key,
    required this.file,
    required this.index,
    required this.onTap,
    required this.onLongPress,
    required this.onSecondaryTap,
    required this.onStarToggled,
  }) : super(key: key);

  @override
  State<FileGridItem1> createState() => _FileGridItemState1();
}

class _FileGridItemState1 extends State<FileGridItem1> {
  @override
  Widget build(BuildContext context) {
    String displayName = widget.file.fileName;
    
    if (widget.file.isWeb) {
      displayName = widget.file.pageTitle != 'none' ? widget.file.pageTitle : widget.file.fileName;
    }
    
    if (displayName.length > 12) {
      displayName = '${displayName.substring(0, 9)}...';
    }
    
    return GestureDetector(
      onTap: widget.onTap,
      onLongPress: widget.onLongPress,
      onSecondaryTapDown: widget.onSecondaryTap,
      child: Container(
        width: 85,
        height: 85,
        margin: const EdgeInsets.all(4),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.4),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Stack(
          children: [
            Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Container(
                  height: 40,
                  width: double.infinity,
                  child: _buildContentPreview(widget.file),
                ),
                const SizedBox(height: 4),
                Text(
                  displayName,
                  style: const TextStyle(
                    fontSize: 10,
                    color: Colors.white,
                  ),
                  textAlign: TextAlign.center,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
            Positioned(
              top: 4,
              right: 4,
              child: GestureDetector(
                onTap: widget.onStarToggled,
                child: Icon(
                  widget.file.isStarred ? Icons.star : Icons.star_border,
                  color: widget.file.isStarred ? Colors.yellow : Colors.white54,
                  size: 16,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContentPreview(EatenFile file) {
    final isUrl = file.isWeb || _isWebUrl(file.path);
    final isImageFile = _isImageFile(file);
    
    if (isUrl) {
      return _buildUrlIcon(file);
    } else if (isImageFile) {
      return _buildImagePreview(file);
    } else {
      return _buildFileIcon(file);
    }
  }

  bool _isImageFile(EatenFile file) {
    final imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];
    final ext = file.fileName.toLowerCase();
    return imageExtensions.any((imageExt) => ext.endsWith(imageExt));
  }

  bool _isWebUrl(String path) {
    return path.startsWith('http://') || 
           path.startsWith('https://') ||
           path.startsWith('www.');
  }

  Future<Uint8List?> _getFileIcon(String filePath) async {
    const MethodChannel _fileIconChannel = MethodChannel('screenshot_channel');
    try {
      final result = await _fileIconChannel.invokeMethod('getFileIcon', filePath);
      return result as Uint8List?;
    } catch (e) {
      debugPrint('Error getting file icon: $e');
      return null;
    }
  }

  String _getDomainName(String url) {
    try {
      final uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');
      return uri.host;
    } catch (e) {
      return url.length > 15 ? '${url.substring(0, 12)}...' : url;
    }
  }

  Future<Uint8List?> _getFavicon(String url) async {
    try {
      final domain = _getDomainName(url);
      final faviconUrl = 'https://www.google.com/s2/favicons?domain=$domain&sz=32';
      final response = await http.get(Uri.parse(faviconUrl));
      if (response.statusCode == 200) {
        return response.bodyBytes;
      }
    } catch (e) {
      debugPrint('Error getting favicon: $e');
    }
    return null;
  }   
  
  Widget _buildUrlIcon(EatenFile file) {
    if (file.iconBytes != null) {
      return Center(
        child: Image.memory(
          file.iconBytes!,
          width: 36,
          height: 36,
          fit: BoxFit.contain,
        ),
      );
    } else {
      return FutureBuilder<Uint8List?>(
        future: _getFavicon(file.path),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Container(
              width: 36,
              height: 36,
              child: const CircularProgressIndicator(strokeWidth: 2),
            );
          } else if (snapshot.hasData) {
            return Image.memory(
              snapshot.data!,
              width: 36,
              height: 36,
              fit: BoxFit.contain,
            );
          } else {
            return const Icon(
              Icons.language,
              color: Colors.blue,
              size: 36,
            );
          }
        },
      );
    }
  }

  Widget _buildImagePreview(EatenFile file) {
    return Center(
      child: Container(
        width: 36,
        height: 36,
        child: Image.file(
          File(file.path),
          width: 36,
          height: 36,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            return _buildFallbackIcon(file);
          },
        ),
      ),
    );
  }

  Widget _buildFileIcon(EatenFile file) {
    if (file.iconBytes != null) {
      return Center(
        child: Image.memory(
          file.iconBytes!,
          width: 36,
          height: 36,
          fit: BoxFit.contain,
        ),
      );
    } else {
      return FutureBuilder<Uint8List?>(
        future: _getFileIcon(file.path),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Container(
              width: 36,
              height: 36,
              child: const CircularProgressIndicator(strokeWidth: 2),
            );
          } else if (snapshot.hasData) {
            return Image.memory(
              snapshot.data!,
              width: 36,
              height: 36,
              fit: BoxFit.contain,
            );
          } else {
            return _buildFallbackIcon(file);
          }
        },
      );
    }
  }

  Widget _buildFallbackIcon(EatenFile file) {
    return Icon(
      file.isWeb ? Icons.language : Icons.insert_drive_file,
      color: file.isWeb ? Colors.blue : Colors.white,
      size: 36,
    );
  }
}
class SettingsWindowApp extends StatefulWidget {
  final String apiKey;
  final String petName;
  final bool useDeepSeek;
  final bool useVision;

  const SettingsWindowApp({
    Key? key,
    required this.apiKey,
    required this.petName,
    required this.useDeepSeek,
    required this.useVision,
  }) : super(key: key);

  @override
  State<SettingsWindowApp> createState() => _SettingsWindowAppState();
}
class _SettingsWindowAppState extends State<SettingsWindowApp> {
  late TextEditingController _apiKeyController;
  late TextEditingController _petNameController;
  late bool _useDeepSeek;
  late bool _useVision;

  @override
  void initState() {
    super.initState();
    _apiKeyController = TextEditingController(text: widget.apiKey);
    _petNameController = TextEditingController(text: widget.petName);
    _useDeepSeek = widget.useDeepSeek;
    _useVision = widget.useVision;
  }

  void _saveSettings() async {
    final prefs = await SharedPreferences.getInstance();
    
    // Сохраняем API ключ
    await prefs.setString('api_key', _apiKeyController.text);
    
    // Сохраняем имя питомца
    await prefs.setString('pet_name', _petNameController.text);
    
    // Сохраняем настройку DeepSeek
    await prefs.setBool('use_deepseek', _useDeepSeek);
    
    // Сохраняем настройку компьютерного зрения
    await prefs.setBool('vision', _useVision);

    windowManager.close();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text('⚙️ Настройки'),
          actions: [
            IconButton(
              icon: Icon(Icons.close),
              onPressed: () => windowManager.close(),
            ),
          ],
        ),
        body: Padding(
          padding: EdgeInsets.all(20),
          child: Column(
            children: [
              TextField(
                controller: _petNameController,
                decoration: InputDecoration(labelText: 'Имя питомца'),
              ),
              SizedBox(height: 16),
              TextField(
                controller: _apiKeyController,
                decoration: InputDecoration(labelText: 'API ключ'),
                obscureText: true,
              ),
              SizedBox(height: 16),
              Row(
                children: [
                  Checkbox(
                    value: _useDeepSeek,
                    onChanged: (value) => setState(() => _useDeepSeek = value!),
                  ),
                  Text('Использовать DeepSeek API'),
                ],
              ),
              SizedBox(height: 8),
              Row(
                children: [
                  Checkbox(
                    value: _useVision,
                    onChanged: (value) => setState(() => _useVision = value!),
                  ),
                  Text('Активировать компьютерное зрение'),
                ],
              ),
              Spacer(),
              ElevatedButton(
                onPressed: _saveSettings,
                child: Text('Сохранить'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
class NameInputScreen extends StatefulWidget {
  @override
  _NameInputScreenState createState() => _NameInputScreenState();
}

class _NameInputScreenState extends State<NameInputScreen> {
  final _nameController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('ImeYou Tamagochi - Настройка'),
        actions: [
          IconButton(
            icon: Icon(Icons.close),
            onPressed: () => windowManager.close(),
          ),
        ],
      ),
      body: Padding(
        padding: EdgeInsets.all(20),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              '🎉 Добро пожаловать!',
              style: TextStyle(fontSize: 11, fontWeight: FontWeight.bold, color: Colors.deepPurple),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 20),
            Text(
              'Дайте имя вашему тамагочи:',
              style: TextStyle(fontSize: 11),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 20),
            TextField(
              controller: _nameController,
              decoration: InputDecoration(
                hintText: 'Введите имя',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                filled: true,
                fillColor: Colors.grey[100],
              ),
            ),
            SizedBox(height: 30),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                ElevatedButton(
                  onPressed: () => windowManager.close(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.grey,
                    padding: EdgeInsets.symmetric(horizontal: 30, vertical: 15),
                  ),
                  child: Text('Закрыть', style: TextStyle(color: Colors.white)),
                ),
                ElevatedButton(
                  onPressed: () async {
                    if (_nameController.text.isNotEmpty) {
                      final prefs = await SharedPreferences.getInstance();
                      await prefs.setString('pet_name', _nameController.text);
                      await prefs.setBool('first_run', false);
                      
                      // Перезапускаем приложение в режиме тамагочи
                      await windowManager.destroy();
                      await _initMainWindow();
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurple,
                    padding: EdgeInsets.symmetric(horizontal: 30, vertical: 15),
                  ),
                  child: Text('Продолжить', style: TextStyle(color: Colors.white)),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



  // Структура для кадров анимации
  class AnimationFrame {
    final String imagePath;
    final int durationMs;

    AnimationFrame(this.imagePath, this.durationMs);
  }

class TamagochiOverlay extends StatefulWidget {
  @override
  _TamagochiOverlayState createState() => _TamagochiOverlayState();
}

class _TamagochiOverlayState extends State<TamagochiOverlay>
    with WindowListener, TickerProviderStateMixin {
  // Состояние питомца
  
  final NativeSMTC _smtc = NativeSMTC();
  String _title = 'Не воспроизводится';
  String _artist = 'Нет данных';
  String _album = 'Нет данных';
  String _playbackState = 'Нет данных';
  String _lastUpdate = '';
  final GlobalKey _screenshotKey = GlobalKey();
  bool _screenshotAnalyzeActive = false;
  String _analysisResult = '';
    double _happiness = 50.0;
  double _hunger = 50.0;
  int _level = 1;
  int _daysAlive = 0;
  bool _isAlive = true;
  bool _isSleeping = false;
  String _petName = 'Тамагочи';
  bool _mouseOverWidgetOrChat = false;
  Timer? _longPressTimer;
  bool _isLongPressing = false;
  double _scale = 1.0;
  double _opacity = 0.0;
  bool _showStatus = false;
  bool _showRecentFiles = false;
  bool _isHoveringRecentFiles = false;
  final GlobalKey _petKey = GlobalKey();
  // Файлы и чат
  late List<String> _eatenFiles = [];
  final List<Map<String, String>> _chatHistory = [];
  String _apiKey = '';
  bool _useDeepSeek = true;
  final TextEditingController _promptController = TextEditingController();
  Process? _chatProcess;
  bool _isChatOpen = false;
  // Таймеры
  Timer? _dayTimer;
  Timer? _stateTimer;
  Timer? _movementTimer;
  Timer? _hoverTimer;
  Timer? _idleTimer;
 final String _storageDir = path.join(Directory.current.path, 'imeyou_pet', 'eaten_files');
  // Движение и позиционирование
  bool _isFollowingCursor = false;
  bool _isDragging = false;
  bool _isMovingWindow = false;
  bool _isAnimatingDrop = false;
  bool _contextMenuOpen = false;
  double _screenWidth = 1920;
  double _screenHeight = 1080;
  double _windowWidth = 260;
  double _windowHeight = 270;
  Offset _dragStartOffset = Offset.zero;
  Offset _windowStartOffset = Offset.zero;
  double _idleOffset = 0;
  double _idleDirection = 1;
  DateTime _lastCursorMove = DateTime.now();
  Offset _userSetPosition = Offset.zero;
  bool _userHasSetPosition = false;

  // Физика движения
  Offset _velocity = Offset.zero;
  Offset _position = Offset.zero;
  bool _isThrown = false;
  double _gravity = 0.5;
  double _friction = 0.95;
  double _bounceFactor = 0.7;
  Timer? _physicsTimer;

  // Анимации
  Map<String, List<AnimationFrame>> _animations = {};
  String _currentAnimation = 'idle';
  int _currentFrameIndex = 0;
  Timer? _animationTimer;
  DateTime _lastFrameChange = DateTime.now();

  // Оверлеи
  OverlayEntry? _chatOverlay;
  OverlayEntry? _contextMenuOverlay;
  OverlayEntry? _submenuOverlay;
  OverlayEntry? _fileViewerOverlay;
  bool _chatOverlayVisible = false;
  bool _isMusicPlaying = false;
  Timer? _musicCheckTimer;
  bool _chatIsReadyToReceiveMessages=false;
late final KeyboardLogger _keyboardLogger = KeyboardLogger();
late final HotkeyService _hotkeyService = HotkeyService();
late final http.Client _httpClient = http.Client();
String _defaultLanguage = 'ru';

  // Фразы
  List<String> _randomPhrases = [
    "Привет! Как дела?",
    "Я голоден!",
    "Поиграй со мной!",
    "Отличный день!",
    "Мне скучно...",
    "Ура! Новый файл!",
    "Я тебя люблю!",
    "Время покушать!",
  ];

  String _currentPhrase = "";

  late List<EatenFile> _files;
  late List<EatenFile> _filteredFiles;
  List<String> _recentlyOpened = [];
  final String _sharedFilesPath = 'eaten_files.json';
  final String _recentFilesPath = 'recent_files.json';
   final Map<String, Uint8List> _iconCache = {};
Timer? _clipboardTimer;
  Set<String> _lastFiles = {};

  static Process? _powerShellProcess;
  static Timer? _checkTimer;
  static final _script = '''
Add-Type -AssemblyName System.Windows.Forms
if ([System.Windows.Forms.Clipboard]::ContainsFileDropList()) {
    \$files = [System.Windows.Forms.Clipboard]::GetFileDropList()
    return (\$files | ConvertTo-Json -Compress)
}
return "[]"
''';


void _tabKeyPressed(String key){
    int index=-1;
    if (key=="Q"){
      index=0;
    } else
    if (key=="W"){
      index=1;
    } else
    if (key=="E"){
      index=2;
    } else
    if (key=="A"){
      index=3;
    } else
    if (key=="S"){
      index=4;
    } else
    if (key=="D"){
      index=5;
    } else
    if (key=="Z"){
      index=6;
    } else
    if (key=="X"){
      index=7;
    } else
    if (key=="C"){
      index=8;
    }
      if (index==-1) return;
      
// Сортируем файлы: сначала помеченные звездочкой, затем по частоте открытий, затем по давности последнего открытия
    final sortedFiles = _files.toList()
      ..sort((a, b) {
        // 1. Сначала помеченные звездочкой
        if (a.isStarred && !b.isStarred) return -1;
        if (!a.isStarred && b.isStarred) return 1;
        
        // 2. Затем по частоте открытий (по убыванию)
        final openCountComparison = b.openCount.compareTo(a.openCount);
        if (openCountComparison != 0) return openCountComparison;
        
        // 3. Затем по давности последнего открытия (сначала недавно открытые)
        if (a.lastOpened != null && b.lastOpened != null) {
          return b.lastOpened!.compareTo(a.lastOpened!);
        }
        if (a.lastOpened != null) return -1;
        if (b.lastOpened != null) return 1;
        
        return 0;
      });
      
                  final file=sortedFiles[index];
                   final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
    


}
  Future<void> _registerHotkeys() async {

    /*
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'q',
      onPressed: () {_tabKeyPressed("Q");
     }
    );
    
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'w',
      onPressed: () {_tabKeyPressed("W");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'e',
      onPressed: () {_tabKeyPressed("E");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'a',
      onPressed: () {_tabKeyPressed("A");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 's',
      onPressed: () {_tabKeyPressed("S");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'd',
      onPressed: () {_tabKeyPressed("D");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'z',
      onPressed: () {_tabKeyPressed("Z");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'x',
      onPressed: () {_tabKeyPressed("X");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'c',
      onPressed: () {_tabKeyPressed("C");
     }
    );
    */
    
    // Alt+Z
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'z',
      onPressed: () => _openFullChatWindow(),
    );

    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'e',
      onPressed: () => _showMacroKeyboardWindow(),
    );

    // Alt+X
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'x',
      onPressed: () => _showEssentialsViewer(),
    );

    // Alt+C
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'c',
      onPressed: () => _showCNPWindow(),
    );

    // Alt+V
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'v',
      onPressed: () => _copyVisibleAndOpenChatCopyCliplboardAsEntry(),
    );

    // Alt+S
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 's',
      onPressed: () => _showScreenshotViewer(),
    );

   await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'q',
      onPressed: () => _translateCurrentSelectionToDefaultLanguage(),
    );

    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'w',
      onPressed: () => _translateCurrentSelectionToEnglish(),
    );

  }

// Функция для получения информации о фокусе в Windows
Future<WindowsFocusInfo?> _getWindowsFocusInfo() async {
  try {
    const MethodChannel channel = MethodChannel('screenshot_channel');
    final String result = await channel.invokeMethod('getFocusInfo');
    return WindowsFocusInfo.fromJson(result);
  } catch (e) {
    print('Error getting Windows focus info: $e');
    return null;
  }
}
 

  
Future<void> _translateCurrentSelectionToDefaultLanguage() async {
  await _translateAndReplaceSelection(_defaultLanguage);
}

Future<void> _translateCurrentSelectionToEnglish() async {
  await _translateAndReplaceSelection('en');
}

Future<void> _translateAndReplaceSelection(String targetLanguage) async {
  try {
    // Получаем информацию о фокусе и выделенном тексте
    final focusInfo = await _getWindowsFocusInfo();
    
    if (focusInfo == null ||focusInfo.selectedText==null || focusInfo.selectedText!.isEmpty) {
      //_showMessage('Нет выделенного текста для перевода');
      return;
    }

    final selectedText = focusInfo.selectedText!.trim();
    
    // Проверяем, что текст не является URL или email
    if (_isUrlOrEmail(selectedText)) {
      //_showMessage('Выделенный текст является URL или email, перевод пропущен');
      return;
    }

    // Определяем исходный язык
    final sourceLanguage = await _detectLanguage(selectedText);
    
    // Если исходный язык уже целевой - не переводим
    if (sourceLanguage == targetLanguage) {
      //_showMessage('Текст уже на целевом языке');
      return;
    }

    // Выполняем перевод
    String translatedText = await _translateWithLibreTranslate(selectedText, sourceLanguage, targetLanguage);
    
    if (translatedText.isEmpty) {
      translatedText = await _translateWithMyMemory(selectedText, sourceLanguage, targetLanguage);
    }

    if (translatedText.isNotEmpty) {
      // Копируем переведенный текст в буфер обмена
      await Clipboard.setData(ClipboardData(text: translatedText));
        AppLogger.writeLog('should be: $selectedText --> $translatedText');
      // Имитируем вставку (Ctrl+V) в текущее окно
      await _simulatePaste();
      
      //_showMessage('Текст переведен и вставлен');
    } else {
      //_showMessage('Не удалось выполнить перевод');
    }
    
  } catch (e) {
    //_showMessage('Ошибка перевода: $e');
  }
}

bool _isUrlOrEmail(String text) {
  final urlRegex = RegExp(
    r'^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$',
    caseSensitive: false,
  );
  
  final emailRegex = RegExp(
    r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
  );
  
  return urlRegex.hasMatch(text) || emailRegex.hasMatch(text);
}

Future<void> _simulatePaste() async {
  try {
    const MethodChannel channel = MethodChannel('screenshot_channel');
    await channel.invokeMethod('simulatePaste');
  } catch (e) {
    print('Error simulating paste: $e');
    // Fallback: показываем сообщение с инструкцией
    //_showMessage('Переведенный текст скопирован в буфер. Нажмите Ctrl+V для вставки');
  }
}


// Бесплатный API LibreTranslate
Future<String> _translateWithLibreTranslate(String text, String from, String to) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/translate'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'q': text,
        'source': from,
        'target': to,
        'format': 'text'
      }),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['translatedText'] ?? '';
    }
  } catch (e) {
    print('LibreTranslate error: $e');
  }
  return '';
}

// Резервный API MyMemory
Future<String> _translateWithMyMemory(String text, String from, String to) async {
  try {
    final response = await _httpClient.get(
      Uri.parse('https://api.mymemory.translated.net/get?'
          'q=${Uri.encodeComponent(text)}&'
          'langpair=$from|$to'),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['responseData']['translatedText'] ?? '';
    }
  } catch (e) {
    print('MyMemory error: $e');
  }
  return '';
}

Future<String> _detectLanguage(String text) async {
  try {
    // Простая эвристика для определения языка
    return _detectLanguageBasic(text);
    
    // Для более точного определения можно использовать API (раскомментировать при необходимости)
    // return await _detectLanguageWithAPI(text);
  } catch (e) {
    return _detectLanguageBasic(text);
  }
}

// API определение языка (раскомментировать при необходимости)
/*
Future<String> _detectLanguageWithAPI(String text) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/detect'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'q': text}),
    ).timeout(Duration(seconds: 5));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      if (data is List && data.isNotEmpty) {
        return data[0]['language'] ?? 'en';
      }
    }
  } catch (e) {
    print('Language detection API error: $e');
  }
  return _detectLanguageBasic(text);
}
*/

String _detectLanguageBasic(String text) {
  // Улучшенная эвристика для определения языка
  final russianRegex = RegExp(r'[а-яА-ЯёЁ]');
  final englishRegex = RegExp(r'[a-zA-Z]');
  final koreanRegex = RegExp(r'[ㄱ-ㅎㅏ-ㅣ가-힣]');
  final chineseRegex = RegExp(r'[\u4e00-\u9fff]');
  final japaneseRegex = RegExp(r'[\u3040-\u309F\u30A0-\u30FF]');
  
  // Подсчет символов разных языков
  int russianCount = russianRegex.allMatches(text).length;
  int englishCount = englishRegex.allMatches(text).length;
  int koreanCount = koreanRegex.allMatches(text).length;
  int chineseCount = chineseRegex.allMatches(text).length;
  int japaneseCount = japaneseRegex.allMatches(text).length;
  
  // Определяем язык по преобладающим символам
  if (russianCount > 0 && russianCount > englishCount) return 'ru';
  if (koreanCount > 0) return 'ko';
  if (chineseCount > 0) return 'zh';
  if (japaneseCount > 0) return 'ja';
  if (englishCount > 0) return 'en';
  
  return 'en'; // По умолчанию английский
}


  void startMonitoring({int intervalMs = 1000}) {
    stopMonitoring(); // Останавливаем предыдущий таймер
    
    _checkTimer = Timer.periodic(
      Duration(milliseconds: intervalMs),
      (Timer t) => _checkWindowsClipboard()
    );
  }

  void _handleNewFiles(List<String> files) {
    return;
    final newFiles = files.toSet().difference(_lastFiles);
    if (newFiles.isNotEmpty) {
      // Файлы появились в буфере обмена - возможно началось перетаскивание
      print('Potential file drag detected: $newFiles');
      // Вызываем вашу функцию
      _handleFileDrag();
    }
    _lastFiles = files.toSet();
  }
  Future<void> _ensurePowerShell() async {
    if (_powerShellProcess != null) return;

    _powerShellProcess = await Process.start('powershell', [
      '-NoProfile',
      '-Command',
      '-'
    ], runInShell: false);
  }
   Future<void> _checkWindowsClipboard() async {
    try {
      await _ensurePowerShell();
      
      // Отправляем команду в существующий процесс
      _powerShellProcess!.stdin.writeln(_script);
      
      // Читаем результат с таймаутом
      final output = await _powerShellProcess!.stdout
          .transform(utf8.decoder)
          .transform(LineSplitter())
          .first
          .timeout(const Duration(seconds: 5));

      final filesJson = output.trim();
      if (filesJson != "[]") {
        try {
          final files = List<String>.from(json.decode(filesJson));
          _handleNewFiles(files);
        } catch (e) {
          print('Error parsing files: $e');
        }
      }
    } catch (e) {
      print('Clipboard check error: $e');
      // Пересоздаем процесс при ошибке
      _powerShellProcess?.kill();
      _powerShellProcess = null;
    }
  }




 Future<Uint8List?> _getFavicon(String url) async {
    try {
      final domain = _getDomainName(url);
      final faviconUrl = 'https://www.google.com/s2/favicons?domain=$domain&sz=32';
      final response = await http.get(Uri.parse(faviconUrl));
      if (response.statusCode == 200) {
        return response.bodyBytes;
      }
    } catch (e) {
      debugPrint('Error getting favicon: $e');
    }
    return null;
  }   
void _incrementOpenCount(EatenFile file) async {
    setState(() {
      file.openCount++;
      file.lastOpened = DateTime.now();
    });
    await _saveFile(file);
    _updateFilteredFiles();
  }



  void _updateFilteredFiles() {
  List<EatenFile> currentList = [];
  final Map<String, Uint8List> _iconCache = {};
  
    // Сначала помеченные звездочкой, затем по частоте открытий
    final starredFiles = _files.where((file) => file.isStarred).toList();
    final otherFiles = _files.where((file) => !file.isStarred).toList()
      ..sort((a, b) => b.openCount.compareTo(a.openCount));
    
    currentList = [...starredFiles, ...otherFiles];
  



    // Группируем по времени
    setState(() {
      _filteredFiles = currentList;
    });
  }

  

Future<Uint8List?> _getCachedIcon(EatenFile file) async {
  final cacheKey = file.isWeb ? 'web_${_getDomainName(file.path)}' : 'file_${file.path}';
  
  if (_iconCache.containsKey(cacheKey)) {
    return _iconCache[cacheKey];
  }
  
  Uint8List? iconBytes;
  if (file.isWeb) {
    iconBytes = await _getFavicon(file.path);
  } else {

    iconBytes =  await _getFileIcon(file);
  }
  
  if (iconBytes != null) {
    _iconCache[cacheKey] = iconBytes;
  }
  
  return iconBytes;
}

  void _onAnalysisResult(String result) {
    setState(() {
      _analysisResult = result;
    });
    print('Received analysis result: $result');
  }
  
  void _startAnalysis() async {
    bool success = await ScreenAnalysis.startAnalysis();
    if (success) {
      print('Screen analysis started');
    }
  }
  
  void _stopAnalysis() async {
    bool success = await ScreenAnalysis.stopAnalysis();
    if (success) {
      print('Screen analysis stopped');
    }
  }
  

  void _closeChatWindow() {
    _chatProcess?.kill();
    _chatProcess = null;
    _isChatOpen = false;
    // Не нужно удалять listener, так как мы используем миксин
  }
void _toggleChatWindow() async {
  const chatProcessId = 'chat_window';

  if (ProcessManager().hasProcess(chatProcessId)) {
    ProcessManager().killProcess(chatProcessId);
    _isChatOpen = false;
    return;
  }


  try {
    final pos = await windowManager.getPosition();
    final fullChatHistory = await _loadFullChatHistory();

    // JSON истории чата
    String chatHistoryJson;
    try {
      chatHistoryJson = json.encode(fullChatHistory);
      
    } catch (e) {
      
      chatHistoryJson = '[]';
    }

    // Логируем аргументы
    

    // Запуск дочернего процесса чата
    final process = await Process.start(
      Platform.resolvedExecutable,
      [
        'chat',
        chatHistoryJson,
        pos.dx.toString(),
        pos.dy.toString(),
      ],
    );

    

    ProcessManager().registerProcess(chatProcessId, process);
    _isChatOpen = true;

    // Слушаем stderr процесса
    process.stderr.transform(utf8.decoder).listen((data) async {
      
    });

    // Таймер для передачи координат каждые 80 мс
    Timer.periodic(Duration(milliseconds: 155), (timer) async {
      if (!ProcessManager().hasProcess(chatProcessId)) {
        timer.cancel();
        return;
      }
      if (!mounted) { // ← Добавьте эту проверку
        timer.cancel();
        return;
      }
      final currentPos = await windowManager.getPosition();
      final proc = ProcessManager().getProcess(chatProcessId);
      proc?.stdin.writeln('${currentPos.dx},${currentPos.dy}');
    });

    process.exitCode.then((code) async {
      
      if (mounted) {
        setState(() {
          _isChatOpen = false;
        });
      }
      ProcessManager().killProcess(chatProcessId);
    });
  } catch (e) {
    
    print('Error opening chat window: $e');
    _isChatOpen = false;
  }
}


void _windowListener() async {
  if (_isChatOpen) {
    final pos = await windowManager.getPosition();
    final size = await windowManager.getSize();
    
    // TODO: Отправить новую позицию процессу чата через IPC
  }
}



Future<void> _loadSharedFiles() async {
  try {
    final dir = Directory(_storageDir);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
      return;
    }
    
    final List<EatenFile> loadedFiles = [];
    final entities = await dir.list().toList();
    
    for (var entity in entities) {
      if (entity is File && entity.path.endsWith('.json')) {
        try {
          final content = await entity.readAsString();
          if (content.trim().isNotEmpty) {
            final jsonData = json.decode(content);
            final file = EatenFile.fromJson(jsonData);
            loadedFiles.add(file);
          }
        } catch (e) {
          debugPrint('Error loading file ${entity.path}: $e');
        }
      }
    }
    
    // Сортируем: сначала помеченные звездочкой, затем по частоте открытий
    loadedFiles.sort((a, b) {
      if (a.isStarred && !b.isStarred) return -1;
      if (!a.isStarred && b.isStarred) return 1;
      return b.openCount.compareTo(a.openCount);
    });
    
    setState(() {
      _files = loadedFiles;
      _updateFilteredFiles();
    });
    
    // Загружаем иконки для файлов
    _loadIconsForFiles();
  } catch (e) {
    debugPrint('Error loading files from storage: $e');
  }
}

void _loadIconsForFiles() async {
  for (var file in _files) {
    if (file.iconBytes == null) {
      final iconBytes = await _getCachedIcon(file);
      if (iconBytes != null && mounted) {
        setState(() {
          file.iconBytes = iconBytes;
        });
      }
    }
  }
}

Future<void> _saveFile(EatenFile file) async {
  try {
    final fileName = '${file.id}.json';
    final filePath = path.join(_storageDir, fileName);
    final outputFile = File(filePath);
    final dir = outputFile.parent;
    
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    
    await outputFile.writeAsString(json.encode(file.toJson()));
  } catch (e) {
    debugPrint('Error saving file: $e');
  }
}

Future<void> _deleteFile(EatenFile file) async {
  try {
    // Удаляем файл данных
    final fileName = '${file.id}.json';
    final filePath = path.join(_storageDir, fileName);
    final outputFile = File(filePath);
    
    if (await outputFile.exists()) {
      await outputFile.delete();
    }
    
    // Удаляем из кэша иконок
    final cacheKey = file.isWeb ? 'web_${_getDomainName(file.path)}' : 'file_${file.path}';
    _iconCache.remove(cacheKey);
    
    // Обновляем UI
    setState(() {
      _files.remove(file);
      _updateFilteredFiles();
    });
  } catch (e) {
    debugPrint('Error deleting file: $e');
  }
}
Future<void> _saveSharedFiles() async {
  try {
    final dir = Directory(_storageDir);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    
    // Сохраняем каждый файл отдельно
    for (var file in _files) {
      await _saveFile(file);
    }
    
    debugPrint('Saved ${_files.length} files to storage');
  } catch (e) {
    debugPrint('Error saving files to storage: $e');
  }
}

// Или если нужно сохранить только один файл:
Future<void> _saveSingleFile(EatenFile file) async {
  try {
    await _saveFile(file);
  } catch (e) {
    debugPrint('Error saving single file: $e');
  }
}

// Метод для массового сохранения (если нужно)
Future<void> _saveAllFiles(List<EatenFile> files) async {
  try {
    final dir = Directory(_storageDir);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    
    for (var file in files) {
      await _saveFile(file);
    }
    
    debugPrint('Saved ${files.length} files to storage');
  } catch (e) {
    debugPrint('Error saving all files: $e');
  }
}

Future<void> _keyLoggerActivate() async {
    //await _keyboardLogger.initialize();
}
  static void stopMonitoring() {
    _checkTimer?.cancel();
    _checkTimer = null;
    _powerShellProcess?.kill();
    _powerShellProcess = null;
  }


void _setupKeyboardListener() {
  RawKeyboard.instance.addListener((RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      //peekay
    if (_showRecentFiles==false) return;
// Сортируем файлы: сначала помеченные звездочкой, затем по частоте открытий, затем по давности последнего открытия
    final sortedFiles = _files.toList()
      ..sort((a, b) {
        // 1. Сначала помеченные звездочкой
        if (a.isStarred && !b.isStarred) return -1;
        if (!a.isStarred && b.isStarred) return 1;
        
        // 2. Затем по частоте открытий (по убыванию)
        final openCountComparison = b.openCount.compareTo(a.openCount);
        if (openCountComparison != 0) return openCountComparison;
        
        // 3. Затем по давности последнего открытия (сначала недавно открытые)
        if (a.lastOpened != null && b.lastOpened != null) {
          return b.lastOpened!.compareTo(a.lastOpened!);
        }
        if (a.lastOpened != null) return -1;
        if (b.lastOpened != null) return 1;
        
        return 0;
      });
      if (event.logicalKey == LogicalKeyboardKey.escape) {
        setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
      } else if ( event.logicalKey == LogicalKeyboardKey.keyQ) {
                  final file=sortedFiles[0];
                   final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
                  

      } else if (event.logicalKey == LogicalKeyboardKey.keyW) {
        final file=sortedFiles[1];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      } else if (event.logicalKey == LogicalKeyboardKey.keyE) {
        final file=sortedFiles[2];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      } else if (event.logicalKey == LogicalKeyboardKey.keyA) {
        final file=sortedFiles[3];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      } else if (event.logicalKey == LogicalKeyboardKey.keyS) {
        final file=sortedFiles[4];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      } else if (event.logicalKey == LogicalKeyboardKey.keyD) {
       final file=sortedFiles[5];
        final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      }else if (event.logicalKey == LogicalKeyboardKey.keyZ) {
        final file=sortedFiles[6];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      }else if (event.logicalKey == LogicalKeyboardKey.keyX) {
        final file=sortedFiles[7];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      }else if (event.logicalKey == LogicalKeyboardKey.keyC) {
        final file=sortedFiles[8];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      }
    }
  });
}

  void _setupDragDropListener() {
    FileDragDropService.onDragStart = () {
      setState(() {
        _isDragging = true;
      });
      print('Drag started!');
      _handleFileDrag();
    };

    FileDragDropService.onDragEnd = () {
      setState(() {
        _isDragging = false;
      });
      _returnToUserPosition();
    };

    FileDragDropService.initialize();
  }


  bool _isYouTubeContent(String title, String artist) {
  final lowerTitle = title.toLowerCase();
  final lowerArtist = artist.toLowerCase();
  
  return lowerTitle.contains('youtube') ||
         lowerArtist.contains('chrome') ||
         lowerArtist.contains('edge') ||
         lowerArtist.contains('microsoft') ||
         lowerArtist.contains('google') ||
         lowerTitle.contains(' - youtube') ||
         lowerArtist == 'youtube';
}

bool _isMusicContent(String title, String artist) {
  // Если это не YouTube и есть артист/название - считаем музыкой
  return !_isYouTubeContent(title, artist) &&
         artist != 'Неизвестный исполнитель' &&
         title != 'Неизвестный трек' &&
         artist.isNotEmpty;
}

Future<void> _youtubeVideoIsPlaying(String title, String channel) async {
  print('Обнаружено YouTube видео: "$title" от "$channel"');
  
  // Очищаем название от YouTube-артефактов
  final cleanTitle = _cleanYouTubeTitle(title);
  final cleanChannel = _cleanYouTubeArtist(channel);
  
  // Пытаемся определить длительность (это будет эмуляция)
  final videoType = await _determineYouTubeVideoType(cleanTitle, cleanChannel);
  
  switch (videoType) {
    case 'live':
      _startAnimation("watching_stream");
      _showPhrase(cleanTitle, cleanChannel, isMusic: false);
      break;
    case 'movie':
      final genre = await _getMovieGenre(cleanTitle);
      _startAnimation("watching_movie");
      _showPhrase(cleanTitle, cleanChannel, isMusic: false, movieGenre: genre);
      break;
    default:
      _startAnimation("watching_video");
      _showPhrase(cleanTitle, cleanChannel, isMusic: false);
  }
}

String _cleanYouTubeTitle(String title) {
  return title
      .replaceAll('YouTube', '')
      .replaceAll(' - YouTube', '')
      .replaceAll('| YouTube', '')
      .trim();
}

String _cleanYouTubeArtist(String artist) {
  if (artist.toLowerCase().contains('chrome') || 
      artist.toLowerCase().contains('edge')) {
    return 'YouTube';
  }
  return artist;
}

Future<String> _determineYouTubeVideoType(String title, String channel) async {
  // Эвристический анализ названия для определения типа видео
  final lowerTitle = title.toLowerCase();
  
  // Проверка на трансляцию
  if (lowerTitle.contains('прямой эфир') ||
      lowerTitle.contains('стрим') ||
      lowerTitle.contains('live') ||
      lowerTitle.contains('трансляция')) {
    return 'live';
  }
  
  // Проверка на фильм (по ключевым словам)
  if (lowerTitle.contains('фильм') ||
      lowerTitle.contains('кино') ||
      lowerTitle.contains('movie') ||
      lowerTitle.contains('full movie') ||
      lowerTitle.contains('полнометражный')) {
    return 'movie';
  }
  
  // Для реального проекта здесь можно было бы использовать YouTube API
  // для получения реальной длительности видео
  
  return 'video'; // обычное видео
}

Future<void> _musicIsPlaying(String artist, String title, String album, String? cover) async {
  print('Обнаружена музыка: "$title" - "$artist"');
  
  // Получаем жанр трека
  final genre = await _getMusicGenre(artist, title);
  final basicGenre = _simplifyGenre(genre);
  
  _startAnimation("music_interact_$basicGenre");
  _showPhrase(title, artist, isMusic: true, musicGenre: basicGenre);
}
String  _previusGenreMusic="unknown";
     
Future<String> _getMusicGenre(String artist, String title) async {
  try {

   

    if (_previusArtist==artist && _previusTitle==title){
      return "";
    }
    final musicBrainzService = MusicBrainzService();
    
    // Пробуем MusicBrainz API
    final genre = await musicBrainzService.getCombinedGenre(artist, title);
    if (genre != 'unknown') {
      _previusGenreMusic=genre;
      return genre;
    }
    
    // Fallback: определяем по артисту (локальная база)
    return await _getArtistGenre(artist);
  } catch (e) {
    print('Ошибка получения жанра: $e');
    return 'unknown';
  }
}

Future<String> _getArtistGenre(String artist) async {
  // Упрощенная база жанров по артистам
  final genreMap = {
    'rock': ['nirvana', 'linkin park', 'queen', 'ac/dc', 'metallica'],
    'pop': ['taylor swift', 'justin bieber', 'ariana grande', 'katy perry'],
    'hiphop': ['eminem', 'kanye west', 'drake', 'snoop dogg'],
    'electronic': ['daft punk', 'deadmau5', 'skrillex', 'tiesto'],
    'classical': ['mozart', 'beethoven', 'bach', 'chopin'],
    'jazz': ['miles davis', 'louis armstrong', 'ella fitzgerald'],
  };
  
  final lowerArtist = artist.toLowerCase();
  for (final entry in genreMap.entries) {
    if (entry.value.any((artistName) => lowerArtist.contains(artistName))) {
      return entry.key;
    }
  }
  
  return 'unknown';
}

String _simplifyGenre(String genre) {
  final lowerGenre = genre.toLowerCase();
  
  if (lowerGenre.contains('rock')) return 'rock';
  if (lowerGenre.contains('pop')) return 'pop';
  if (lowerGenre.contains('hip') || lowerGenre.contains('rap')) return 'hiphop';
  if (lowerGenre.contains('electronic') || lowerGenre.contains('dance') || lowerGenre.contains('house')) return 'electronic';
  if (lowerGenre.contains('classical')) return 'classical';
  if (lowerGenre.contains('jazz')) return 'jazz';
  if (lowerGenre.contains('metal')) return 'metal';
  if (lowerGenre.contains('country')) return 'country';
  if (lowerGenre.contains('reggae')) return 'reggae';
  
  return 'unknown';
}


final List<String> randomPhrasesImpression = ["Ух ты", "О", "Воу", "Прикольно", "Вау", "Здорово"];
final List<String> randomPhrasesEnd = ["Интересно!", "Ща заценим", "Годнота", "Крутяк", "Обожаю это"];


Timer? _phraseTimer;


String _previusTitle="Неизвестный трек";
String _previusArtist="Неизвестный исполнитель";
DateTime _lastMessageAppeared=DateTime.now();
void _showPhrase(String title, String artist, {bool isMusic = true, String? movieGenre, String? musicGenre}) {
  final random = Random();

  final now = DateTime.now();
    final timeDiff = now.difference(_lastMessageAppeared).inSeconds;
  // Шанс 69% на возврат без выполнения
  if (random.nextDouble() < 0.69 || timeDiff<600 || (_previusTitle==title && _previusArtist==artist)) {
    return;
  }
  _previusTitle=title;
  _previusArtist=artist;
  _lastMessageAppeared = now;
  final impression = randomPhrasesImpression[random.nextInt(randomPhrasesImpression.length)];
  final end = randomPhrasesEnd[random.nextInt(randomPhrasesEnd.length)];
  
  String middle;
  if (isMusic) {
    middle = "$artist - $title";
  } else {
    middle = movieGenre != null ? "$title ($movieGenre)" : title;
  }
  
  setState(() {
    _currentPhrase = "$impression, $middle, $end";
  });
  
  // Очищаем фразу через 4 секунды
  _phraseTimer?.cancel();
  _phraseTimer = Timer(const Duration(seconds: 4), () {
    setState(() {
      _currentPhrase = "";
    });
  });
}

Future<String> _getMovieGenre(String title) async {
  // Эвристическое определение жанра фильма по названию
  final lowerTitle = title.toLowerCase();
  
  if (lowerTitle.contains('ужас') || lowerTitle.contains('хоррор') || lowerTitle.contains('страш')) return 'horror';
  if (lowerTitle.contains('комедия') || lowerTitle.contains('смеш')) return 'comedy';
  if (lowerTitle.contains('драма')) return 'drama';
  if (lowerTitle.contains('фантастика') || lowerTitle.contains('фэнтези')) return 'fantasy';
  if (lowerTitle.contains('боевик') || lowerTitle.contains('экшн')) return 'action';
  if (lowerTitle.contains('роман') || lowerTitle.contains('любов')) return 'romance';
  if (lowerTitle.contains('детектив') || lowerTitle.contains('мистик')) return 'mystery';
  
  return 'movie';
}

    
  // Функции управления
  Future<void> _play() async {
    final success = _smtc.play();
    print('Play команда: $success');
  }

  Future<void> _pause() async {
    final success = _smtc.pause();
    print('Pause команда: $success');
  }

  Future<void> _next() async {
    final success = _smtc.next();
    print('Next команда: $success');
  }

  Future<void> _previous() async {
    final success = _smtc.previous();
    print('Previous команда: $success');
  }

  Timer? _updateTimer;
  Future<void> _initializeMediaControls() async {

    return;
    _updateTimer = Timer.periodic(const Duration(seconds: 25), (timer) {
      try{
      _updateMediaInfo();
      }
      catch (e){
        AppLogger.writeLog("update media info broken, try again");
      }
    });
  }

  void _updateMediaInfo() {
    try {
      final mediaInfo = _smtc.getCurrentMediaInfo();
      final playbackState = _smtc.getPlaybackState();
      if (_playbackState=="Воспроизведение"){
      setState(() {
        _title = mediaInfo.title.isNotEmpty ? mediaInfo.title : 'Неизвестный трек';
        _artist = mediaInfo.artist.isNotEmpty ? mediaInfo.artist : 'Неизвестный исполнитель';
        _album = mediaInfo.album.isNotEmpty ? mediaInfo.album : 'Неизвестный альбом';
        _playbackState = _parsePlaybackState(playbackState);
        _lastUpdate = 'Обновлено: ${DateTime.now().toString().substring(11, 19)}';
      });
      
      print('Метаданные: "$_title" - "$_artist" ($_playbackState)');
      AppLogger.writeLog('Метаданные: "$_title" - "$_artist" ($_playbackState)');
      // Анализируем тип контента

    
      if (_isYouTubeContent(_title, _artist)) {
        _youtubeVideoIsPlaying(_title, _artist);
      } else if (_isMusicContent(_title, _artist)) {
        _musicIsPlaying(_artist, _title, _album, null);
      }}

    } catch (e) {
      print('Ошибка получения метаданных: $e');
    }
  }



  String _parsePlaybackState(PlaybackState state) {
    switch (state) {
      case PlaybackState.playing:
        return 'Воспроизведение';
      case PlaybackState.paused:
        return 'Пауза';
      case PlaybackState.stopped:
        return 'Остановлено';
      default:
        return 'Неизвестно';
    }
  }



 @override
void initState() {
  super.initState();

  
  WidgetsBinding.instance.addPostFrameCallback((_) async {
    try {

      startMonitoring(intervalMs: 1000);
      _setupDragDropListener();
      windowManager.addListener(this);
      _startServer();
      _startServer2();
      _initializeMediaControls();
      await _keyLoggerActivate();
      

      await _loadSavedData();
      _registerHotkeys();
      _setupKeyboardListener();
      

      await _initializeScreenSizeAndWindow();
      

      _startTimers();
      

      _startIdleDetection();

      await _ensureShortcutsFolderExists();
      

      await _loadChatHistory();
      

      _startMusicChecker();
      

      _setupWindowsContextMenu();
      

      await _loadAnimations();
      

      await windowManager.setAlwaysOnTop(true);
      

      _startPhysicsEngine();
      

      
    } catch (e, stack) {

      
      // Пытаемся показать окно даже при ошибке
      try {
        await windowManager.show();

      } catch (e2) {

      }
    }
  });
}

  // Загрузка анимаций
  Future<void> _loadAnimations() async {
    try {
      final animations = {
        'idle': await _loadAnimationFrames('idle'),
        'walk': await _loadAnimationFrames('walk'),
        'catch': await _loadAnimationFrames('catch'),
        'sleep': await _loadAnimationFrames('sleep'),
        'happy': await _loadAnimationFrames('happy'),
      };
      
      setState(() {
        _animations = animations;
      });
      
      _startAnimation('idle');
    } catch (e) {
      print('Error loading animations: $e');
    }
  }

  Future<List<AnimationFrame>> _loadAnimationFrames(String animationName) async {
    final List<AnimationFrame> frames = [];
    final petName="test";
    try {
      final directory = await getApplicationDocumentsDirectory();
      final animationDir = Directory('${directory.path}/$petName/animations/$animationName');
      
      if (animationDir.existsSync()) {
        final files = animationDir.listSync()
          .where((file) => file.path.endsWith('.png'))
          .toList();
        
        files.sort((a, b) {
          final aName = path.basenameWithoutExtension(a.path);
          final bName = path.basenameWithoutExtension(b.path);
          return int.parse(aName).compareTo(int.parse(bName));
        });
        
        for (final file in files) {
          final fileName = path.basenameWithoutExtension(file.path);
          final durationMs = int.parse(fileName);
          frames.add(AnimationFrame(file.path, durationMs));
        }
      }
    } catch (e) {
      print('Error loading animation $animationName: $e');
    }
    
    return frames;
  }

  void _startAnimation(String animationName) {
    if (_animations[animationName] == null || _animations[animationName]!.isEmpty) {
      return;
    }
    
    _animationTimer?.cancel();
    _currentAnimation = animationName;
    _currentFrameIndex = 0;
    _lastFrameChange = DateTime.now();
    
    _animationTimer = Timer.periodic(Duration(milliseconds: 16), (timer) {
          if (!mounted) { // ← Добавьте эту проверку
        timer.cancel();
        return;
      }
      final now = DateTime.now();
      final currentFrame = _animations[_currentAnimation]![_currentFrameIndex];
      final elapsed = now.difference(_lastFrameChange).inMilliseconds;
      
      if (elapsed >= currentFrame.durationMs) {
        setState(() {
          _currentFrameIndex = (_currentFrameIndex + 1) % _animations[_currentAnimation]!.length;
          _lastFrameChange = now;
        });
      }
    });
  }

  void _startPhysicsEngine() {
    _physicsTimer = Timer.periodic(Duration(milliseconds: 16), (timer) {
      if (!mounted) { // ← Добавьте эту проверку
        timer.cancel();
        return;
      }
      if (!_isThrown) return;
      
      _updatePhysics();
    });
  }

void _updatePhysics() {
  // Применяем гравитацию
  _velocity = Offset(_velocity.dx, _velocity.dy + _gravity);
  
  // Обновляем позицию
  _position = Offset(
    _position.dx + _velocity.dx,
    _position.dy + _velocity.dy
  );
  
  // Определяем высоту поверхности (150 пикселей от нижней границы экрана)
  final surfaceLevel = _screenHeight - 50;
  
  // Проверяем столкновения с краями экрана
  bool hitBoundary = false;
  
  if (_position.dx < -30) {
    _position = Offset(-30, _position.dy);
    _velocity = Offset(-_velocity.dx * _bounceFactor, _velocity.dy);
    hitBoundary = true;
  } else if (_position.dx > _screenWidth - _windowWidth+30) {
    _position = Offset(_screenWidth - _windowWidth, _position.dy);
    _velocity = Offset(-_velocity.dx * _bounceFactor, _velocity.dy);
    hitBoundary = true;
  }
  
  if (_position.dy < 0) {
    _position = Offset(_position.dx, 0);
    _velocity = Offset(_velocity.dx, -_velocity.dy * _bounceFactor);
    hitBoundary = true;
  } else if (_position.dy > surfaceLevel - _windowHeight) {
    // Останавливаем на поверхности (150px от нижней границы)
    _position = Offset(_position.dx, surfaceLevel - _windowHeight);
    _velocity = Offset(_velocity.dx, -_velocity.dy * _bounceFactor);
    hitBoundary = true;
    
    // Если скорость очень мала после отскока от поверхности, останавливаем
    if (_velocity.dy.abs() < 1.0) {
      _isThrown = false;
      _velocity = Offset.zero;
      _userSetPosition = _position;
      _userHasSetPosition = true;
      _saveData();
      _startAnimation('idle');
    }
  }
  
  // Применяем трение
  _velocity = Offset(_velocity.dx * _friction, _velocity.dy * _friction);
  
  // Если скорость очень мала, останавливаем
  if (_velocity.distance < 0.5 && !hitBoundary) {
    _isThrown = false;
    _velocity = Offset.zero;
    _userSetPosition = _position;
    
    _userHasSetPosition = true;
    _saveData();
    _startAnimation('idle');
  }
  
  // Обновляем позицию окна

  if (!_isDragging){
windowManager.setPosition(_position);
  }
  
}

  void _startMusicChecker() {
    _musicCheckTimer = Timer.periodic(Duration(seconds: 3), (timer) async {
      try {
        final isPlaying = await AudioChecker.isAudioPlaying();
        if (mounted && isPlaying != _isMusicPlaying) {
          setState(() {
            _isMusicPlaying = isPlaying;
          });
        }
      } catch (e) {
        print('Music check failed: $e');
      }
    });
  }

  void _setupWindowsContextMenu() async {
    if (Platform.isWindows) {
      try {
        final exePath = Platform.resolvedExecutable;
        final regCommand = '''
          \$keyPath = "Registry::HKEY_CLASSES_ROOT\\\\*\\\\shell\\\\FeedTo${_petName.replaceAll(' ', '')}"
          New-Item -Path \$keyPath -Force
          Set-ItemProperty -Path \$keyPath -Name "MUIVerb" -Value "Скормить файл $_petName"
          Set-ItemProperty -Path \$keyPath -Name "Icon" -Value "$exePath"
          
          \$commandPath = "\$keyPath\\\\command"
          New-Item -Path \$commandPath -Force
          Set-ItemProperty -Path \$commandPath -Name "(Default)" -Value "'$exePath' --feed-file '%1'"
        ''';

        await Process.run('powershell', ['-Command', regCommand]);
      } catch (e) {
        print('Error setting up Windows context menu: $e');
      }
    }
  }

  void _showRandomPhrase() {
    setState(() {
      _currentPhrase = _randomPhrases[Random().nextInt(_randomPhrases.length)];
    });
    
    Timer(Duration(seconds: 3), () {
      setState(() {
        _currentPhrase = "";
      });
    });
  }

Future<List<Map<String, String>>> _loadFullChatHistory() async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final chatDir = Directory('${directory.path}/ai_chat');
    final file = File('${chatDir.path}/chat_history.json');

    if (file.existsSync()) {
      final content = await file.readAsString();
      await File('chat_debug.log').writeAsString(
        '${DateTime.now()}: File content: $content\n',
        mode: FileMode.append,
      );

      if (content.trim().isEmpty) {
        return [];
      }

      final List<dynamic> data = json.decode(content);
      // Преобразуем каждый элемент в Map<String, String>
      return data.map((item) {
        final map = item as Map<String, dynamic>;
        return map.map((key, value) => MapEntry(key, value.toString()));
      }).toList();
    }
  } catch (e) {
    await File('chat_debug.log').writeAsString(
      '${DateTime.now()}: Error loading chat history: $e\n',
      mode: FileMode.append,
    );
    print('Error loading chat history: $e');
  }

  return [];
}



  void _openFullChatWindow() async {
    const chatProcessId = 'chat_window';

  if (ProcessManager().hasProcess(chatProcessId)) {
    ProcessManager().killProcess(chatProcessId);
    _isChatOpen = false;
    return;
  }

  final debugFile = File('chat_debug.log');
  await debugFile.writeAsString(
    '${DateTime.now()}: _toggleChatWindow started\n',
    mode: FileMode.append,
  );

  try {
    final pos = await windowManager.getPosition();
    final fullChatHistory = await _loadFullChatHistory();

    // JSON истории чата
    String chatHistoryJson;
    try {
      chatHistoryJson = json.encode(fullChatHistory);
      await debugFile.writeAsString(
        '${DateTime.now()}: JSON encoded successfully: ${chatHistoryJson.length} chars\n',
        mode: FileMode.append,
      );
    } catch (e) {
      await debugFile.writeAsString(
        '${DateTime.now()}: JSON encode error: $e\n',
        mode: FileMode.append,
      );
      chatHistoryJson = '[]';
    }

    // Логируем аргументы
    await debugFile.writeAsString(
      '${DateTime.now()}: Starting process with args: chat, $chatHistoryJson, ${pos.dx}, ${pos.dy}\n',
      mode: FileMode.append,
    );

    // Запуск дочернего процесса чата
    final process = await Process.start(
      Platform.resolvedExecutable,
      [
        'chat',
        chatHistoryJson,
        pos.dx.toString(),
        pos.dy.toString(),
      ],
    );

    await debugFile.writeAsString(
      '${DateTime.now()}: Process started with PID: ${process.pid}\n',
      mode: FileMode.append,
    );

    ProcessManager().registerProcess(chatProcessId, process);
    _isChatOpen = true;

    // Слушаем stderr процесса
    process.stderr.transform(utf8.decoder).listen((data) async {
      await debugFile.writeAsString(
        '${DateTime.now()}: Process stderr: $data\n',
        mode: FileMode.append,
      );
    });

    // Таймер для передачи координат каждые 80 мс
    Timer.periodic(Duration(milliseconds: 25), (timer) async {
      if (!ProcessManager().hasProcess(chatProcessId)) {
        timer.cancel();
        return;
      }
      if (!mounted) { // ← Добавьте эту проверку
        timer.cancel();
        return;
      }
      final currentPos = await windowManager.getPosition();
      final proc = ProcessManager().getProcess(chatProcessId);
      proc?.stdin.writeln('${currentPos.dx},${currentPos.dy}');
    });

    process.exitCode.then((code) async {
      await debugFile.writeAsString(
        '${DateTime.now()}: Process exited with code: $code\n',
        mode: FileMode.append,
      );
      if (mounted) {
        setState(() {
          _isChatOpen = false;
          _chatIsReadyToReceiveMessages=false;
        });
      }
      ProcessManager().killProcess(chatProcessId);
    });
  } catch (e) {
    await debugFile.writeAsString(
      '${DateTime.now()}: Error opening chat window: $e\n',
      mode: FileMode.append,
    );
    print('Error opening chat window: $e');
    _isChatOpen = false;
  }
}


void _showContextMenuAtPosition() async {
  if (_contextMenuOverlay != null) {
    _removeContextMenu();
    return;
  }

  // Получаем позицию и размер виджета тамагочи
  final RenderBox petRenderBox = _petKey.currentContext!.findRenderObject() as RenderBox;
  final Offset petPosition = petRenderBox.localToGlobal(Offset.zero);
  final ui.Size petSize = petRenderBox.size;

  final display = await screenRetriever.getPrimaryDisplay();
  final screenSize = display.size;

  final menuWidth = 200.0;
  final menuHeight = 200.0;

  // Позиционируем меню по центру виджета тамагочи
  double menuX = petPosition.dx + (petSize.width - menuWidth) / 2;
  double menuY = petPosition.dy + (petSize.height - menuHeight) / 2 + 15;

  // Корректируем позицию, если меню выходит за границы экрана
  if (menuX + menuWidth > screenSize.width) {
    menuX = screenSize.width - menuWidth - 10;
  }
  if (menuY + menuHeight > screenSize.height) {
    menuY = screenSize.height - menuHeight - 10;
  }
  if (menuX < 10) menuX = 10;
  if (menuY < 10) menuY = 10;

  _contextMenuOpen = true;

  _contextMenuOverlay = OverlayEntry(
    builder: (context) => Stack(
      children: [
        // Затемнение фона
        Positioned.fill(
          child: GestureDetector(
            onTap: _removeContextMenu,
            child: Container(color: Colors.transparent),
          ),
        ),
        // Контекстное меню с отслеживанием выхода курсора
        Positioned(
          left: menuX,
          top: menuY,
          child: MouseRegion(
            // Указываем область, при выходе за которую меню закроется
            onExit: (event) {
              _removeContextMenu();
            },
            child: Container(
              width: menuWidth,
              height: menuHeight,
              decoration: BoxDecoration(
                color: Color(0xFF2D2D2D),
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.4),
                    blurRadius: 15,
                    spreadRadius: 2,
                  )
                ],
              ),
              child: GridView.count(
                crossAxisCount: 3,
                padding: EdgeInsets.all(11),
                mainAxisSpacing: 4,
                crossAxisSpacing: 4,
                children: [
                  _buildGridMenuItem(
                    Icons.camera_alt,
                    'Скриншот',
                    Colors.blue,
                    () {
                      _removeContextMenu();
                      _showScreenshotViewer();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.star,
                    'Essentials',
                    Colors.orange,
                    () {
                      _removeContextMenu();
                      _showEssentialsViewer();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.folder,
                    'Файлы',
                    Colors.blue,
                    () {
                      _removeContextMenu();
                      _showFileViewer();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.chat,
                    'Чат',
                    Colors.green,
                    () {
                      _removeContextMenu();
                      _openFullChatWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.chat,
                    'Копипаста',
                    Colors.green,
                    () {
                      _removeContextMenu();
                      _showCNPWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.settings,
                    'Настройки',
                    Colors.orange,
                    () {
                      _removeContextMenu();
                      _showSettingsWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.settings,
                    'AI Test',
                    Colors.orange,
                    () {
                      _removeContextMenu();
                      _showAIWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.keyboard,
                    'Виртуальная клавиатура',
                    Colors.orange,
                    () {
                      _removeContextMenu();
                      _showMacroKeyboardWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.close,
                    'Закрыть',
                    Colors.red,
                    () {
                      _removeContextMenu();
                      ProcessManager().killAllProcesses();
                      windowManager.close();
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ],
    ),
  );

  Overlay.of(context)!.insert(_contextMenuOverlay!);
}
Widget _buildGridMenuItem(IconData icon, String text, Color color, VoidCallback onTap) {
  return Material(
    color: Colors.transparent,
    child: InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        width: 55, // максимум 55 пикселей
        height: 55,
        decoration: BoxDecoration(
          color: Color(0xFF3D3D3D),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: Colors.white.withOpacity(0.1), width: 1),
        ),
        padding: EdgeInsets.symmetric(horizontal: 4, vertical: 4),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, size: 20, color: color), // чуть больше иконка
            SizedBox(height: 2),
            Flexible(
              child: Text(
                text,
                style: TextStyle(
                  fontSize: 10, // читаемый размер шрифта
                  color: Colors.white,
                  fontWeight: FontWeight.w500,
                ),
                textAlign: TextAlign.center,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    ),
  );
}
bool _isHoveringPet=false;
void _removeContextMenu() {
  if (_contextMenuOverlay != null) {
    _contextMenuOverlay!.remove();
    _contextMenuOverlay = null;
    _contextMenuOpen = false;
  }
     if (Platform.isWindows && !_isHoveringPet && !_isHoveringRecentFiles && !_contextMenuOpen) {
        windowManager.setIgnoreMouseEvents(false);
      }
}
  void _showEatenFilesOnClick() async {
    final pos = await windowManager.getPosition();
    //_showEatenFilesSubmenu(Offset(pos.dx, pos.dy - 100));
  }

  void _startLongPressTimer(Offset position) {
    _longPressTimer?.cancel();
    _isLongPressing = true;
    _longPressTimer = Timer(Duration(milliseconds: 450), () {
      if (_isLongPressing && mounted) {
        //_showEatenFilesSubmenu(position);
      }
    });
  }

  void _cancelLongPressTimer() {
    _longPressTimer?.cancel();
    _isLongPressing = false;
  }

  Future<void> _loadChatHistory() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final chatDir = Directory('${directory.path}/ai_chat');
      final file = File('${chatDir.path}/chat_history.json');
      
      if (file.existsSync()) {
        final content = await file.readAsString();
        final List<dynamic> data = json.decode(content);
        setState(() {
          _chatHistory.clear();
          _chatHistory.addAll(data.cast<Map<String, String>>());
        });
      }
    } catch (e) {
      print('Error loading chat history: $e');
    }
  }

  Future<void> _ensureShortcutsFolderExists() async {
    try {
      final exeDir = _getExeDirectory();
      final shortcuts = Directory(path.join(exeDir, 'Shortcuts'));
      if (!shortcuts.existsSync()) shortcuts.createSync(recursive: true);
    } catch (_) {}
  }

  String _getExeDirectory() {
    try {
      final exe = Platform.resolvedExecutable;
      final exeDir = path.dirname(exe);
      return exeDir;
    } catch (e) {
      return Directory.current.path;
    }
  }

  Future<void> _initializeScreenSizeAndWindow() async {
    final display = await screenRetriever.getPrimaryDisplay();
    final screenSize = display.size;
    final pos = await windowManager.getPosition();

    final prefs = await SharedPreferences.getInstance();
    final firstRun = prefs.getBool('first_run') ?? true;

    setState(() {
      _screenWidth = screenSize.width;
      _screenHeight = screenSize.height;
      _position = pos;
    });

    if (!firstRun) {
      _userSetPosition = Offset(
        _screenWidth - _windowWidth - 15,
        _screenHeight - _windowHeight-150,
      );
      _userHasSetPosition = true;
      await windowManager.setPosition(_userSetPosition);
      _position = _userSetPosition;
    } else {
      _userSetPosition = Offset(
        _screenWidth - 500,
        _screenHeight - 600,
      );
      _userHasSetPosition = true;
      await windowManager.setPosition(_userSetPosition);
      _position = _userSetPosition;
    }
  }

  void _startIdleDetection() {
    _idleTimer = Timer.periodic(Duration(milliseconds: 100), (timer) async {
      if (_isDragging || _isAnimatingDrop || _contextMenuOpen || _chatOverlayVisible || _isThrown) return;

      final now = DateTime.now();
      final idleTime = now.difference(_lastCursorMove).inSeconds;

      if (idleTime >= 20 && _userHasSetPosition && !_isThrown) {
        _startAnimation('idle');
        
        setState(() {
          _idleOffset += 2 * _idleDirection;
          if (_idleOffset.abs() >= 20) {
            _idleDirection *= -1;
          }
        });

        final currentPos = await windowManager.getPosition();
        await windowManager.setPosition(Offset(
          _userSetPosition.dx + _idleOffset,
          _userSetPosition.dy
        ));
      }
    });
  }

  Future<void> _loadSavedData() async {
    final prefs = await SharedPreferences.getInstance();
    if (mounted) {
      setState(() {
        _happiness = prefs.getDouble('happiness') ?? 50.0;
        _hunger = prefs.getDouble('hunger') ?? 50.0;
        _level = prefs.getInt('level') ?? 1;
        _daysAlive = prefs.getInt('days_alive') ?? 0;
        _apiKey = prefs.getString('api_key') ?? '';
        _useDeepSeek = prefs.getBool('use_deepseek') ?? true;
        _petName = prefs.getString('pet_name') ?? 'Тамагочи';
        
        _screenshotAnalyzeActive=prefs.getBool('vision') ?? false;
        final savedX = prefs.getDouble('user_position_x');
        final savedY = prefs.getDouble('user_position_y');
        if (savedX != null && savedY != null) {
          _userSetPosition = Offset(savedX, savedY);
          _position = _userSetPosition;
          _userHasSetPosition = true;
          windowManager.setPosition(_userSetPosition);
        }
      });
      _loadSharedFiles();
    }

    if (_screenshotAnalyzeActive==true){
      _startAnalysis();

    }else{
      _stopAnalysis();
    }
  }


  void _startTimers() {
    _dayTimer = Timer.periodic(Duration(minutes: 1), (timer) {
      if (!_isAlive || !mounted) return;
      setState(() {
        _daysAlive++;
        if (_daysAlive % 1440 == 0) _level++;
        _saveData();
      });
    });

    _stateTimer = Timer.periodic(Duration(seconds: 1100), (timer) {
      if (!_isAlive || _isSleeping || !mounted) return;
      setState(() {
        _happiness = max(0, _happiness - 2);
        _hunger = min(100, _hunger + 1);
        if (_hunger >= 100) _isAlive = false;
        _saveData();
      });
    });
  }

  void _onTap() {
    if (!_isAlive) return;
    
    setState(() {
      _happiness = min(100, _happiness + 5);
      _showRandomPhrase();
    });
    
    _saveData();
  }

void _onDoubleTap() {
  if (!_isAlive) return;
  
  // Отменяем любые pending таймеры
  _cancelLongPressTimer();
  
  // Задержка для предотвращения конфликта с другими жестами
  Future.delayed(Duration(milliseconds: 100), () {
    if (mounted) {
      _toggleChatWindow();
    }
  });
}

  void _showChatWindow() async {
    if (_chatOverlayVisible) {
      _removeChatOverlay();
      return;
    }

    final pos = await windowManager.getPosition();
    final display = await screenRetriever.getPrimaryDisplay();
    final screenSize = display.size;

    double chatX = pos.dx - 600;
    double chatY = pos.dy - 900;

    chatX = chatX.clamp(0.0, screenSize.width - 600);
    chatY = chatY.clamp(0.0, screenSize.height - 900);

    _isFollowingCursor = false;
    _chatOverlayVisible = true;

    _chatOverlay = OverlayEntry(
      builder: (context) => MouseRegion(
        onEnter: (_) {
          _mouseOverWidgetOrChat = true;
          _isFollowingCursor = false;
        },
        onExit: (_) {
          _mouseOverWidgetOrChat = false;
          if (!_mouseOverWidgetOrChat && _chatOverlayVisible) {
            _removeChatOverlay();
          }
        },
        
      ),
    );

    Overlay.of(context)!.insert(_chatOverlay!);
    await windowManager.setAlwaysOnTop(false);
  }

  void _sendChatMessage(String message) async {
    _chatHistory.add({
      'type': 'user',
      'message': message,
      'timestamp': DateTime.now().toString(),
    });

    setState(() {});

    if (message.startsWith('http')) {
      await launchUrl(Uri.parse(message));
    } else {
      final response = await _callAIAPI(message);
      _chatHistory.add({
        'type': 'ai',
        'message': response,
        'timestamp': DateTime.now().toString(),
      });
    }

    setState(() {});
  //  _saveChatHistory();
  }

  void _removeChatOverlay() async {
    _chatOverlay?.remove();
    _chatOverlay = null;
    _chatOverlayVisible = false;
    _isFollowingCursor = false;
    await windowManager.setAlwaysOnTop(true);
  }

  bool _isSystemPath(String text) {
    final trimmed = text.trim();
    if (Platform.isWindows) {
      return trimmed.contains(':\\') || trimmed.startsWith('\\\\');
    } else {
      return trimmed.startsWith('/');
    }
  }
  Future<Uint8List?> _getFileIcon1(String filePath) async {
    const MethodChannel _fileIconChannel = MethodChannel('screenshot_channel');
    try {
    final result = await _fileIconChannel.invokeMethod('getFileIcon', filePath);
    return result as Uint8List?;
  } catch (e) {
    print('Error getting file icon: $e');
    return null;
  }
  }
void _onFileDropped(List<String> files) async {
  if (!_isAlive || files.isEmpty) return;

  // Создаем список для новых файлов
  final List<EatenFile> newFiles = [];
 
  for (final filePath in files) {
    final trimmedPath = filePath.trim();
    if (trimmedPath.isEmpty) continue;
    
    final isWeb = _isWebUrl(trimmedPath);
    final isSystemPath = _isSystemPath(trimmedPath);
    
    if (!isWeb && !isSystemPath) continue;
    
    Uint8List? iconBytes;
    String title="none";
    if (isWeb) {
      iconBytes = await _getFavicon(trimmedPath);
      title = await _getPageTitle(trimmedPath);
    } else if (isSystemPath) {
      iconBytes = await _getFileIcon1(trimmedPath);
      title = "none";
    }

    final newFile = EatenFile(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      path: trimmedPath,
      isWeb: isWeb,
      isStarred: false,
      openCount: 0,
      lastOpened: null,
      iconBytes: iconBytes,
      fileName: isWeb ? _getDomainName(trimmedPath) : path.basename(trimmedPath),
      pageTitle: title,
    );
  _openFile(newFile);
    newFiles.add(newFile);
  }

  setState(() {
    for (final newFile in newFiles) {
      // Ищем существующий файл с таким же path
      final existingFileIndex = _files.indexWhere((file) => file.path == newFile.path);
      
      if (existingFileIndex != -1) {
        // Если файл уже существует, удаляем его
        final existingFile = _files.removeAt(existingFileIndex);
        // Сохраняем данные из старого файла (звездочку, счетчик открытий и т.д.)
        newFile.isStarred = existingFile.isStarred;
        newFile.openCount = existingFile.openCount;
        newFile.lastOpened = existingFile.lastOpened;
        // Сохраняем иконку если новая не загрузилась
        if (newFile.iconBytes == null && existingFile.iconBytes != null) {
          newFile.iconBytes = existingFile.iconBytes;
        }
      }
      
      // Добавляем новый файл в начало списка
      _files.insert(0, newFile);
      _saveFile(newFile);
    }
    
    _hunger = max(0, _hunger - 100);
    
    // Ограничиваем общее количество файлов
    if (_files.length > 1000) {
      final filesToRemove = _files.sublist(1000);
      for (final file in filesToRemove) {
        _deleteFile(file); // Удаляем файлы из хранилища
      }
      _files.removeRange(1000, _files.length);
    }
  });

  _saveData();
  // _saveSharedFiles(); // ЭТУ СТРОЧКУ УДАЛЯЕМ, т.к. метод больше не существует
  _analyzeFile(files.last);

  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text('Файл принят: ${path.basename(files.last)}'), 
      duration: Duration(seconds: 2)
    ),
  );
}
void _onUrlDropped(String url) async {
  if (!_isAlive || url.isEmpty) return;

  final trimmedUrl = url.trim();
  if (trimmedUrl.isEmpty) return;

  // Проверяем, что это валидный URL
  if (!_isWebUrl(trimmedUrl)) return;
  String title = await _getPageTitle(trimmedUrl);
  // Получаем favicon для URL
  final iconBytes = await _getFavicon(trimmedUrl);

  final newFile = EatenFile(
    id: DateTime.now().millisecondsSinceEpoch.toString(),
    path: trimmedUrl,
    isWeb: true,
    isStarred: false,
    openCount: 0,
    lastOpened: null,
    iconBytes: iconBytes,
    fileName: _getDomainName(trimmedUrl),
    pageTitle: title,
  );

  setState(() {
    // Ищем существующий файл с таким же URL
    final existingFileIndex = _files.indexWhere((file) => file.path == newFile.path);
    
    if (existingFileIndex != -1) {
      // Если URL уже существует, удаляем его
      final existingFile = _files.removeAt(existingFileIndex);
      // Сохраняем данные из старого файла
      newFile.isStarred = existingFile.isStarred;
      newFile.openCount = existingFile.openCount;
      newFile.lastOpened = existingFile.lastOpened;
      // Сохраняем иконку если новая не загрузилась
      if (newFile.iconBytes == null && existingFile.iconBytes != null) {
        newFile.iconBytes = existingFile.iconBytes;
      }
    }
    
    // Добавляем новый файл в начало списка
    _files.insert(0, newFile);
    _saveFile(newFile);
    
    _hunger = max(0, _hunger - 100);
    
    // Ограничиваем общее количество файлов
    if (_files.length > 1000) {
      final filesToRemove = _files.sublist(1000);
      for (final file in filesToRemove) {
        _deleteFile(file); // Удаляем файлы из хранилища
      }
      _files.removeRange(1000, _files.length);
    }
  });

  _saveData();


  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text('URL принят: ${_getDomainName(trimmedUrl)}'), 
      duration: Duration(seconds: 2)
    ),
  );
}


// Вспомогательная функция для получения доменного имени
String _getDomainName(String url) {
  try {
    final uri = Uri.parse(url);
    return uri.host;
  } catch (e) {
    // Если не удалось распарсить URL, возвращаем оригинальную строку
    return url;
  }
}

// Добавьте этот метод для проверки URL
bool _isWebUrl(String text) {
  final trimmed = text.trim();
  return trimmed.startsWith('http://') || 
         trimmed.startsWith('https://') ||
         trimmed.startsWith('www.') ||
         (trimmed.contains('.') && 
         (trimmed.contains('/') || 
          trimmed.endsWith('.com') || 
          trimmed.endsWith('.ru') || 
          trimmed.endsWith('.org')));
}

// Добавьте этот метод для создания ярлыков URL
void _createShortcutForUrl(String url) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final shortcutsDir = Directory('${directory.path}/url_shortcuts');
    if (!shortcutsDir.existsSync()) {
      shortcutsDir.createSync(recursive: true);
    }

    final domain = _getDomainName(url);
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final shortcutFile = File('${shortcutsDir.path}/$domain-$timestamp.url');
    
    await shortcutFile.writeAsString('[InternetShortcut]\nURL=$url');
  } catch (e) {
    debugPrint('Error creating URL shortcut: $e');
  }
}



void _saveData() async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.setDouble('happiness', _happiness);
  await prefs.setDouble('hunger', _hunger);
  await prefs.setInt('level', _level);
  await prefs.setInt('days_alive', _daysAlive);
  await prefs.setString('api_key', _apiKey);
  await prefs.setBool('use_deepseek', _useDeepSeek);
  await _loadSharedFiles();
  await prefs.setDouble('user_position_x', _userSetPosition.dx);
  await prefs.setDouble('user_position_y', _userSetPosition.dy);
  await prefs.setBool('vision',_screenshotAnalyzeActive);
  await _saveSharedFiles(); // ← ДОБАВЬТЕ ЭТУ СТРОЧКУ
}


  void _analyzeFile(String filePath) async {
    final fileName = path.basename(filePath);
    final fileExtension = path.extension(filePath).toLowerCase();
    final fileSize = File(filePath).lengthSync();

    String fileMetadata = await _extractFileMetadata(filePath);

    String analysisPrompt = '''
Проанализируй файл: $fileName
Путь: $filePath
Размер: ${fileSize ~/ 1024} KB
Расширение: $fileExtension
$fileMetadata

Если тебе знаком название или ты можешь предположить что это за файл - дай обратную связь (например, музыкальная композиция, книга, программа). Если файл незнаком так и напиши "файл неопознан". Будь краток и информативен.
''';

    final response = await _callAIAPI(analysisPrompt);
    _chatHistory.add({
      'type': 'ai',
      'message': '📁 Анализ файла: $fileName\n$response',
      'timestamp': DateTime.now().toString(),
    });
    //_saveChatHistory();
    _saveFileResponse(filePath, response);
  }

  Future<void> _saveFileResponse(String filePath, String response) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/file_responses.json');
      
      Map<String, dynamic> responses = {};
      if (file.existsSync()) {
        final content = await file.readAsString();
        responses = json.decode(content);
      }
      
      responses[filePath] = response;
      await file.writeAsString(json.encode(responses));
    } catch (e) {
      print('Error saving file response: $e');
    }
  }

  Future<String> _extractFileMetadata(String filePath) async {
    try {
      final file = File(filePath);
      final stat = await file.stat();
      String metadata = 'Модификация: ${stat.modified}\n';

      if (file.existsSync()) {
        try {
          final bytes = await file.readAsBytes();
          if (bytes.length > 10) {
            final header = bytes.take(10).toList();
            if (header[0] == 0xFF && header[1] == 0xD8) {
              metadata += 'Тип: JPEG изображение\n';
            } else if (header[0] == 0x89 && header[1] == 0x50) {
              metadata += 'Тип: PNG изображение\n';
            } else if (header[0] == 0x50 && header[1] == 0x4B) {
              metadata += 'Тип: ZIP архив или Office документ\n';
            } else if (header[0] == 0x49 && header[1] == 0x44 && header[2] == 0x33) {
              metadata += 'Тип: MP3 файл с ID3 тегом\n';
            }
          }
        } catch (e) {}
      }

      if (filePath.toLowerCase().endsWith('.mp3') || 
          filePath.toLowerCase().endsWith('.wav') ||
          filePath.toLowerCase().endsWith('.flac') ||
          filePath.toLowerCase().endsWith('.m4a')) {
        metadata += 'Категория: Аудио файл\n';
      } else if (filePath.toLowerCase().endsWith('.txt') || 
                filePath.toLowerCase().endsWith('.doc') ||
                filePath.toLowerCase().endsWith('.docx') ||
                filePath.toLowerCase().endsWith('.pdf')) {
        metadata += 'Категория: Текстовый документ\n';
      } else if (filePath.toLowerCase().endsWith('.jpg') || 
                filePath.toLowerCase().endsWith('.png') ||
                filePath.toLowerCase().endsWith('.gif') ||
                filePath.toLowerCase().endsWith('.bmp')) {
        metadata += 'Категория: Изображение\n';
      } else if (filePath.toLowerCase().endsWith('.exe') ||
                filePath.toLowerCase().endsWith('.msi') ||
                filePath.toLowerCase().endsWith('.app')) {
        metadata += 'Категория: Исполняемый файл\n';
      }

      return metadata;
    } catch (e) {
      return 'Метаданные: недоступны\n';
    }
  }

  Future<String> _callAIAPI(String prompt) async {
    if (_apiKey.isEmpty) return 'API ключ не установлен. Настройте его в контекстном меню.';

    try {
      final url = _useDeepSeek
          ? 'https://api.deepseek.com/v1/chat/completions'
          : 'https://api.openai.com/v1/chat/completions';

      final response = await http.post(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $_apiKey',
        },
        body: json.encode({
          'model': _useDeepSeek ? 'deepseek-chat' : 'gpt-4',
          'messages': [{'role': 'user', 'content': prompt}],
          'max_tokens': 500,
          'temperature': 0.7,
        }),
      );

      if (response.statusCode == 200) {
        final jsonResponse = json.decode(response.body);
        return jsonResponse['choices'][0]['message']['content']?.trim() ?? 'Пустой ответ от API';
      } else {
        return 'Ошибка API: ${response.statusCode} - ${response.body}';
      }
    } catch (e) {
      return 'Ошибка соединения: $e';
    }
  }

  void _saveChatHistory() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final chatDir = Directory('${directory.path}/ai_chat');
      if (!chatDir.existsSync()) chatDir.createSync(recursive: true);

      final file = File('${chatDir.path}/chat_history.json');
      await file.writeAsString(json.encode(_chatHistory));
    } catch (e) {
      print('Error saving chat history: $e');
    }
  }

  Future<void> _createShortcutForFile(String targetPath) async {
    try {
      final exeDir = _getExeDirectory();
      final shortcutsDir = Directory(path.join(exeDir, 'Shortcuts'));
      if (!shortcutsDir.existsSync()) shortcutsDir.createSync(recursive: true);

      final fileName = path.basename(targetPath);
      final safeName = fileName.replaceAll(RegExp(r'[<>:"/\\|?*]'), '_');
      final shortcutPath = path.join(shortcutsDir.path, '$safeName.lnk');

      final ps = r'''
$target = "%TARGET%"
$shortcutPath = "%SHORTCUT%"
$w = New-Object -ComObject WScript.Shell
$sc = $w.CreateShortcut($shortcutPath)
$sc.TargetPath = $target
$sc.WorkingDirectory = (Split-Path $target)
$sc.Save()
''';

      final command = ps
          .replaceAll('%TARGET%', targetPath.replaceAll(r'%', '%%'))
          .replaceAll('%SHORTCUT%', shortcutPath.replaceAll(r'%', '%%'));

      final result = await Process.run('powershell',
          ['-NoProfile', '-NonInteractive', '-Command', command],
          runInShell: true);

      if (result.exitCode != 0) {
        final fallback = File(path.join(shortcutsDir.path, '$safeName.shortcut.txt'));
        await fallback.writeAsString(targetPath);
      }
    } catch (e) {
      try {
        final exeDir = _getExeDirectory();
        final shortcutsDir = Directory(path.join(exeDir, 'Shortcuts'));
        if (!shortcutsDir.existsSync()) shortcutsDir.createSync(recursive: true);
        final safeName = path.basename(targetPath).replaceAll(RegExp(r'[<>:"/\\|?*]'), '_');
        final fallback = File(path.join(shortcutsDir.path, '$safeName.shortcut.txt'));
        await fallback.writeAsString(targetPath);
      } catch (_) {}
    }
  }

  Widget _buildStatusBar(String label, double value, Color color) {
    return SizedBox(
      width: 120,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '$label: ${value.toInt()}%',
            style: TextStyle(color: Colors.white, fontSize: 10),
          ),
          SizedBox(height: 2),
          Container(
            height: 8,
            decoration: BoxDecoration(
              color: Colors.grey[700],
              borderRadius: BorderRadius.circular(4),
            ),
            child: FractionallySizedBox(
              alignment: Alignment.centerLeft,
              widthFactor: (value / 100).clamp(0.0, 1.0),
              child: Container(
                decoration: BoxDecoration(
                  color: color,
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _showFileViewer() async {

    const processId="eaten_files_all";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }

   final process =   await Process.start(
      Platform.resolvedExecutable,
      [
        'files',
        json.encode(_eatenFiles),
      ],
      runInShell: true,
    );

      ProcessManager().registerProcess(processId, process);
  }
 void _showScreenshotViewer() async {

       const processId="screenshoter";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process =  
    await Process.start(
      Platform.resolvedExecutable,
      [
        'screenshoter',
      ],
      runInShell: true,
    );

    ProcessManager().registerProcess(processId, process);
    
    


  }

  

  void _openFile(EatenFile filePath) async {
    try {
      if (Platform.isWindows) {
        await Process.run('start', ['""', filePath.path], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', [filePath.path]);
      } else {
        await Process.run('xdg-open', [filePath.path]);
      }
    } catch (e) {
      print('Error opening file: $e');
    }
  }

  void _openFileFolder(String filePath) {
    final directory = File(filePath).parent;
    try {
      if (Platform.isWindows) {
        Process.run('explorer', ['/select,', filePath], runInShell: true);
      } else if (Platform.isMacOS) {
        Process.run('open', ['-R', filePath]);
      } else {
        Process.run('xdg-open', [directory.path]);
      }
    } catch (e) {
      print('Error opening file folder: $e');
    }
  }

  void _clearEatenFiles() {
    setState(() {
      _eatenFiles.clear();
      _saveData();
    });
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Список съеденных файлов очищен'),
        duration: Duration(seconds: 2),
      ),
    );
  }

  void _showSettingsWindow() async {


         const processId="settings_window";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process = await Process.start(
      Platform.resolvedExecutable,
      [
            'settings',
      _apiKey,
      _useDeepSeek.toString(),
      _petName,
      _screenshotAnalyzeActive.toString(),
      ],
    );

    ProcessManager().registerProcess(processId, process);
    
    


  // После закрытия окна настроек перезагружаем настройки из SharedPreferences
  if (process.exitCode == 0) {
    _loadSavedData(); // Перезагружаем настройки из файла
  }
}



 void _showMacroKeyboardWindow() async {


         const processId="macro_keyboard";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process = await Process.start(
      Platform.resolvedExecutable,
      [
            'macro_keyboard',
      ],
    );

    ProcessManager().registerProcess(processId, process);
    
    


  // После закрытия окна настроек перезагружаем настройки из SharedPreferences
  if (process.exitCode == 0) {
    _loadSavedData(); // Перезагружаем настройки из файла
  }
}


  void _showAIWindow() async {


         const processId="ai_process";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process = await Process.start(
      Platform.resolvedExecutable,
      [
            'ai_open',
      ],
    );

    ProcessManager().registerProcess(processId, process);
    
    


  // После закрытия окна настроек перезагружаем настройки из SharedPreferences
  if (process.exitCode == 0) {
    _loadSavedData(); // Перезагружаем настройки из файла
  }
}

  void _showCNPWindow() async {
     const processId="cnp_window";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process = await Process.start(
      Platform.resolvedExecutable,
      [
        'clipboard-history',
       
      ],
    );

    ProcessManager().registerProcess(processId, process);
    
    
   
  }


void _copyVisibleAndOpenChatCopyCliplboardAsEntry() async {
  const chatProcessId = 'chat_window';
  
  try {
    // 1. Получаем информацию о текущем фокусе в Windows
    final focusInfo = await _getWindowsFocusInfo();
    
    if (focusInfo == null) {
      print('Не удалось получить информацию о фокусе');
      return;
    }
    
    // 2. Обработка файлов
    if (focusInfo.isFileSelection) {
      final filePath = focusInfo.selectedPath;
      if (filePath != null && filePath.isNotEmpty) {
        // 2.1 Копируем путь файла в буфер обмена
        await _copyToClipboard(filePath);
        
        // 2.2 Вызываем обработку файла в текущем классе
        _onFileDropped([filePath]);
        return; // Не открываем окно чата для файлов
      }
    }
    
    // 3. Обработка текста
    if (focusInfo.isTextSelection && focusInfo.selectedText != null) {
      final selectedText = focusInfo.selectedText!.trim();
      
      if (selectedText.isEmpty) {
        print('Выделенный текст пуст');
        return;
      }
      
      // 2. Копируем текст в буфер обмена
      await _copyToClipboard(selectedText);
      
      // 3.1 Проверяем является ли текст ссылкой
      if (_isWebUrl(selectedText)) {
        // 3.2 Обрабатываем ссылку в текущем классе
        _onUrlDropped(selectedText);
        return; // Не открываем окно чата для ссылок
      }
      
      // 3.1 Открываем окно чата для обычного текста
      String clipboardText = selectedText;
      
      // Если окно чата уже открыто - отправляем текст
      if (ProcessManager().hasProcess(chatProcessId)) {
        await _sendToServer(clipboardText);
        return;
      }
      
      // Открываем новое окно чата
      await _openChatWindowWithText(clipboardText, chatProcessId);
    }
    
  } catch (e) {
    print('Error in _copyVisibleAndOpenChatCopyCliplboardAsEntry: $e');
  }
}
static Future<void> _sendToServer(String data) async {
  try {
    final socket = await Socket.connect('localhost', 8080);
    // Явно кодируем в UTF-8
    final encodedData = utf8.encode(data);
    socket.add(encodedData);
    await socket.flush();
    socket.destroy();
  } catch (e) {
    print('Error sending data: $e');
  }
}



// Вспомогательная функция для открытия окна чата с текстом
// Вспомогательная функция для открытия окна чата с текстом
Future<void> _openChatWindowWithText(String clipboardText, String chatProcessId) async {
  try {
    final pos = await windowManager.getPosition();
    final emptyChatHistory = '[]'; // Пустой JSON

    // Запуск дочернего процесса чата
    final process = await Process.start(
      Platform.resolvedExecutable,
      [
        'chat',
        emptyChatHistory,
        pos.dx.toString(),
        pos.dy.toString(),
      ],
    );

    ProcessManager().registerProcess(chatProcessId, process);
    _isChatOpen = true;

    // Слушаем stderr процесса
    process.stderr.transform(utf8.decoder).listen((data) {
      // Обработка ошибок дочернего процесса
    });

    // Ждем пока чат будет готов принимать сообщения (с таймаутом 5 секунд)
    bool isReady = await _waitForChatReady(
      timeout: const Duration(seconds: 5),
      checkInterval: const Duration(milliseconds: 150),
    );

    

    if (isReady) {
      // Отправляем текст в открытое окно
      _sendToServer(clipboardText);
    } else {
      print('Chat window failed to become ready within timeout');
      return;
    }

    // Таймер для передачи координат
    Timer.periodic(const Duration(milliseconds: 25), (timer) async {
      if (!ProcessManager().hasProcess(chatProcessId)) {
        timer.cancel();
        return;
      }
      final currentPos = await windowManager.getPosition();
      final currentProc = ProcessManager().getProcess(chatProcessId);
      currentProc?.stdin.writeln('${currentPos.dx},${currentPos.dy}');
      await currentProc?.stdin.flush();
    });

    process.exitCode.then((code) {
      if (mounted) {
        setState(() {
          _isChatOpen = false;
        });
      }
      ProcessManager().killProcess(chatProcessId);
    });
    
  } catch (e) {
    print('Error opening chat window: $e');
    _isChatOpen = false;
  }
}

// Вспомогательная функция для ожидания готовности чата
Future<bool> _waitForChatReady({
  Duration timeout = const Duration(seconds: 5),
  Duration checkInterval = const Duration(milliseconds: 100),
}) async {
  final startTime = DateTime.now();
  
  while (DateTime.now().difference(startTime) < timeout) {
    if (_chatIsReadyToReceiveMessages) {
      return true;
    }
    await Future.delayed(checkInterval);
  }
  
  // Проверяем последний раз перед возвратом false
  return _chatIsReadyToReceiveMessages;
}


// Функция для копирования в буфер обмена
Future<void> _copyToClipboard(String text) async {
  try {
    await Clipboard.setData(ClipboardData(text: text));
  } catch (e) {
    print('Error copying to clipboard: $e');
  }
}


   void _showEssentialsViewer() async {


      const processId="essentials";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process =  
    await Process.start(
      Platform.resolvedExecutable,
      [
         'essentials',
      ],
      
    );

    ProcessManager().registerProcess(processId, process);
    


   
  }


    final List<Offset> _cursorHistory = [];
  Timer? _cursorHistoryTimer;
  DateTime _dragStartTime = DateTime.now();


   Offset _calculateRecentCursorVelocity() {
    if (_cursorHistory.length < 2) {
      // Если недостаточно данных, используем стандартную скорость из details
      return Offset.zero;
    }

    // Берем последние позиции из истории (последние 400 мс)
    final recentPoints = _cursorHistory;
    
    if (recentPoints.length < 2) {
      return Offset.zero;
    }

    // Первая и последняя точка в рассматриваемом интервале (400 мс)
    final firstPoint = recentPoints.first;
    final lastPoint = recentPoints.last;

    // Смещение за 400 мс
    final dx = lastPoint.dx - firstPoint.dx;
    final dy = lastPoint.dy - firstPoint.dy;

    // Скорость = смещение / время (преобразуем в пиксели в секунду)
    return Offset(dx / 0.4, dy / 0.4);
  }

  // Альтернативный метод - используем несколько последних точек для большей точности
  Offset _calculateSmoothCursorVelocity() {
    if (_cursorHistory.length < 5) {
      return Offset.zero;
    }

    // Берем последние 5 точек (примерно последние 80 мс)
    final recentPoints = _cursorHistory.length >= 5 
        ? _cursorHistory.sublist(_cursorHistory.length - 5)
        : _cursorHistory;

    double totalDx = 0;
    double totalDy = 0;
    int count = 0;

    // Рассчитываем скорость между соседними точками
    for (int i = 1; i < recentPoints.length; i++) {
      final dx = recentPoints[i].dx - recentPoints[i-1].dx;
      final dy = recentPoints[i].dy - recentPoints[i-1].dy;
      totalDx += dx;
      totalDy += dy;
      count++;
    }

    if (count == 0) return Offset.zero;

    // Средняя скорость за кадр (16 мс), преобразуем в секунду
    final avgDxPerFrame = totalDx / count;
    final avgDyPerFrame = totalDy / count;

    return Offset(avgDxPerFrame * 60, avgDyPerFrame * 60); // Преобразуем в пиксели/секунду
  }


  void _cleanOldCursorHistory() {
    final now = DateTime.now();
    final cutoffTime = now.subtract(Duration(milliseconds: 400));
    
    // Удаляем записи старше 400 мс
    _cursorHistory.removeWhere((position) {
      // Поскольку мы не храним временные метки для каждой позиции,
      // удаляем старые записи, оставляя только последние (предполагая 60 FPS)
      return _cursorHistory.indexOf(position) < _cursorHistory.length - 25; // ~400ms при 60 FPS
    });
  }

  
  void _onPanStart(DragStartDetails details) async {
    if (!_isAlive) return;
    
    _physicsTimer?.cancel();
    _isThrown = false;
    _velocity = Offset.zero;
    
    setState(() {
      _isDragging = true;
      _isFollowingCursor = false;
      _dragStartOffset = details.globalPosition;
      _mouseOverWidgetOrChat = true;
    });
    
    _animationTimer1?.cancel();
    _animationTimer1 = null;
    
    // Очищаем историю курсора при начале жеста
    _cursorHistory.clear();
    _dragStartTime = DateTime.now();
    
    // Запускаем таймер для сбора истории позиций курсора
    _cursorHistoryTimer = Timer.periodic(Duration(milliseconds: 16), (timer) {
      if (!_isDragging) {
        timer.cancel();
        return;
      }
      _cleanOldCursorHistory();
    });

    Offset? last_cursor_pos = await _getCursorPosition();

    _animationTimer1 = Timer.periodic(Duration(milliseconds: 16), (timer) async {
      Offset? cursorPos = await _getCursorPosition();
      if (cursorPos == null && last_cursor_pos != null) {
        cursorPos = last_cursor_pos;
      }
      if (last_cursor_pos == null) {
        return;
      }
      last_cursor_pos = cursorPos;
      
      // Сохраняем позицию курсора в историю
      _cursorHistory.add(cursorPos!);
      _cleanOldCursorHistory();
      
      final targetPos = Offset(
        cursorPos.dx - 110, // Смещение по X
        cursorPos.dy - 160, // Смещение по Y
      );
      
      // Получаем текущую позицию окна
      final currentPos = await windowManager.getPosition();

      // Вычисляем новую позицию с интерполяцией
      final newX = currentPos.dx + (targetPos.dx - currentPos.dx) * 0.1;
      final newY = currentPos.dy + (targetPos.dy - currentPos.dy) * 0.1;
      
      final newPos = Offset(newX, newY);
      
      setState(() {
        _position = newPos;
      });
      
      windowManager.setPosition(newPos);
    });
  }
  Timer? _animationTimer1;

void _onPanUpdate(DragUpdateDetails details) async {
  // Останавливаем предыдущий таймер, если он активен
 return;
}
void _onPanEnd(DragEndDetails details) async {
    if (!_isDragging) return;

    _animationTimer1?.cancel();
    _animationTimer1 = null;
    _cursorHistoryTimer?.cancel();
    _cursorHistoryTimer = null;

    Offset? cursorPos = await _getCursorPosition();
    if (cursorPos == null) {
      cursorPos = await windowManager.getPosition();
    }
    final startPosition = _dragStartOffset;
    double distance = (cursorPos! - startPosition).distance;
    
    // РАСЧЕТ СКОРОСТИ НА ОСНОВЕ ПОСЛЕДНИХ 400 МС КУРСОРА
    final velocity = _calculateRecentCursorVelocity();
    
    setState(() {
      _isDragging = false;
      
      // Используем рассчитанную скорость на основе истории курсора
      final scaledVelocity = Offset(
        velocity.dx / 30, 
        velocity.dy / 30
      );
      _velocity = Offset(
        scaledVelocity.dx.clamp(-21.0, 21.0),
        scaledVelocity.dy.clamp(-17.0, 17.0)
      );
      
      _isThrown = _velocity.distance > 2.0;
      
      // Исправляем формулы счастья и голода
      _happiness = (_happiness + (_velocity.distance / 10)).clamp(0, 100).toDouble();
      _hunger = (_hunger + (_velocity.distance / 14)).clamp(0, 100).toDouble();
      
      _idleOffset = 0;
    });

    if (_isThrown) {
      _startAnimation('walk');
      _startPhysicsEngine();
    } else {
      windowManager.getPosition().then((position) {
        setState(() {
          _userSetPosition = position;
          _userHasSetPosition = true;
        });
        _saveData();
        
        // Фиксируем виджет на высоте 150px от нижнего края экрана
        final targetY = _screenHeight - _windowHeight;
        _returnToUserPosition();
      });
    }
    
    // Очищаем историю после использования
    _cursorHistory.clear();
  }

  // Обработка драг-н-дропа файлов
  void _handleFileDrag() {
    if (!_isAlive || _isChatOpen)  return;
    
    _startAnimation('catch');
    
    // Плавное движение к курсору
    _moveToCursor();
  }

  void _moveToCursor() async {
  final initialPos = await windowManager.getPosition();
  Timer? timer;
  DateTime? startTime;
  
  timer = Timer.periodic(Duration(milliseconds: 16), (timer) async {
    final cursorPos = await _getCursorPosition();
    if (cursorPos == null) {
      timer.cancel();
      return;
    }
    
    startTime ??= DateTime.now();
    
    // Рассчитываем направление к курсору от начальной позиции
    final directionX = cursorPos.dx - _windowWidth / 2 - initialPos.dx;
    final directionY = max(cursorPos.dy - 150, 0.0) - initialPos.dy;
    
    // Вычисляем расстояние до курсора
    final distance = sqrt(directionX * directionX + directionY * directionY);
    
    // Ограничиваем максимальное расстояние 100 пикселями
    final limitedDistance = min(distance, 45.0);
    
    // Нормализуем направление (если расстояние не нулевое)
    final normalizedX = distance > 0 ? directionX / distance : 0.0;
    final normalizedY = distance > 0 ? directionY / distance : 0.0;
    
    // Вычисляем целевую позицию (не дальше 100 пикселей от начальной)
    final targetX = initialPos.dx + normalizedX * limitedDistance;
    final targetY = initialPos.dy + normalizedY * limitedDistance;
    
    // Анимация с фиксированной скоростью ~100px за 750ms
    final elapsed = DateTime.now().difference(startTime!).inMilliseconds;
    final progress = min(elapsed / 750.0, 1.0);
    final eased = Curves.easeInOut.transform(progress);
    
    // Текущая позиция окна
    final currentPos = await windowManager.getPosition();
    
    // Плавное движение к целевой позиции
    final newX = currentPos.dx + (targetX - currentPos.dx) * 0.015; // Коэффициент сглаживания
    final newY = currentPos.dy + (targetY - currentPos.dy) * 0.015;
    
    windowManager.setPosition(Offset(newX, newY));
    
    // Автоматическое завершение через 3 секунды бездействия (опционально)
    if ((elapsed > 7000 && progress >= 1.0)||_isDragging==false) {
      timer.cancel();
    }
  });
  
  // Функция для остановки анимации (можно вызвать извне)
  // _stopAnimation() => timer?.cancel();
}

void _returnToUserPosition() async {
  final currentPos = await windowManager.getPosition();
  Timer? timer;
  DateTime? startTime;
  
  timer = Timer.periodic(Duration(milliseconds: 16), (timer) async {
    startTime ??= DateTime.now();
    

    // Вычисляем целевую позицию для этого кадра (не дальше 100 пикселей)
    final targetX = _userSetPosition.dx;
    final targetY = _userSetPosition.dy;
    
    // Анимация с фиксированной скоростью ~100px за 750ms
    final elapsed = DateTime.now().difference(startTime!).inMilliseconds;
    final progress = min(elapsed / 750.0, 1.0);
    final eased = Curves.easeInOut.transform(progress);
    
    // Плавное движение к целевой позиции
    final newX = currentPos.dx + (targetX - currentPos.dx) * 0.2 +3; // Коэффициент сглаживания
    final newY = currentPos.dy + (targetY - currentPos.dy) * 0.2 +3;
    
    windowManager.setPosition(Offset(newX, newY));
   
    
 // Then in your code:
    if (((targetX-newX).abs() < 30 && (targetY-newY).abs() < 30)||elapsed>1200||_isDragging) {
      windowManager.setPosition(_userSetPosition); // Точная установка позиции
      timer.cancel();
      return;
    }
    
  });
}

Future<Offset?> _getCursorPosition() async {
  try {
    // Используем screen_retriever для получения позиции курсора
    final cursorInfo = await screenRetriever.getCursorScreenPoint();
    return Offset(cursorInfo.dx, cursorInfo.dy);
  } catch (e) {
    print('Error getting cursor position: $e');
    return null;
  }
}

  Widget _buildStatusBars() {

    bool should_show = (!_currentPhrase.isEmpty && _currentPhrase!="");
    return AnimatedOpacity(
      opacity: (_showStatus||should_show) ? 1.0 : 0.0,
      duration: Duration(milliseconds: 300),
      child: Container(
        padding: EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.8),
          borderRadius: BorderRadius.circular(10),
        ),
        child: Column(
          children: [
            if (_currentPhrase.isNotEmpty && _currentPhrase!="")
              Text(
                _currentPhrase,
                style: TextStyle(color: Colors.white, fontSize: 12),
              )
            else
              Column(
                children: [
                  Text('Lv.$_level $_petName', style: TextStyle(color: Colors.white)),
                  _buildStatusBar('Настроение', _happiness, Colors.green),
                  _buildStatusBar('Сытость', 100 - _hunger, Colors.orange),
                ],
              ),
          ],
        ),
      ),
    );
  }
  Future<void> getFocus() async {
      await windowManager.focus();
      const channel = MethodChannel('screenshot_channel');
      //final result = await channel.invokeMethod('getFocus');
      
  }

  void _test_to_build(){
    return;
  }


  
Widget _buildInteractiveWidget() {
  return Positioned.fill(

      child: Stack(
        children: [
          // Основная область - прозрачная для кликов ОС
             Positioned.fill(
            child: IgnorePointer(
              child: Container(
                color: Colors.transparent,
              ),
            ),
          ),
          
          // Область питомца с обработкой событий
          Positioned(
            left: 0,
            top: 0,
            width: _windowWidth,
            height: _windowHeight,
            child: Container(
              width: _windowWidth,
              height: _windowHeight,
              key: _petKey, 
              child: Stack(
                children: [
                  Positioned(
                    bottom: 0, 
                    left: (_windowWidth - 80) / 2, 
                    child: _buildPet(),
                  ),
                  Positioned(
                    bottom: 120,
                    left: 0,
                    right: 0,
                    child: Center(child: _buildStatusBars()),
                  ),
                ],
              ),
            ),
          ),

          if (_showRecentFiles)
            Positioned(
              left: 0,
              top: 15,
              child: _buildRecentFilesOverlay(),
            ),
        ],
      ),
    
  );
}
Widget _buildPet() {
  // Создаем общий GestureDetector для всех состояний
  final gestureDetector = GestureDetector(
    behavior: HitTestBehavior.opaque,
    onTap: _onTap,
    onDoubleTap: _onDoubleTap,
    onLongPressStart: (details) {
      _startLongPressTimer(details.globalPosition);
    },
    onLongPressEnd: (details) {
      _cancelLongPressTimer();
    },
    onLongPressCancel: _cancelLongPressTimer,
    onPanStart: (DragStartDetails details) => _onPanStart(details),
    onPanUpdate: (DragUpdateDetails details) => _onPanUpdate(details),
    onPanEnd: (DragEndDetails details) => _onPanEnd(details),
    child: _buildPetContent(),
  );

  return     Listener(
      onPointerDown: (PointerDownEvent evt) {
        if (evt.kind == PointerDeviceKind.mouse && evt.buttons == kSecondaryMouseButton) {
          _showContextMenuAtPosition();
        }
      },child: MouseRegion(
    onEnter: (event) async {
      if (Platform.isWindows) {
        await windowManager.setIgnoreMouseEvents(false);
      }
      await getFocus();
      if (!_isMovingWindow && !_isAnimatingDrop) {
        setState(() {
          _showStatus = true;
          _opacity = 1.0;
          _isHoveringPet=true;
        });
      }
      _startHoverTimer();
      _mouseOverWidgetOrChat = true;
      _lastCursorMove = DateTime.now();
      
      // Прерываем idle анимацию при наведении
      if (_currentAnimation == 'idle') {
        _startAnimation('idle'); // Сбрасываем анимацию
      }
    },
    onExit: (event) {

         if (Platform.isWindows && !_isHoveringRecentFiles && !_contextMenuOpen) {
        windowManager.setIgnoreMouseEvents(false);
      }

      if (!_isMovingWindow && !_isAnimatingDrop) {
        setState(() {
          _showStatus = false;
          _opacity = 0.0;
          _isHoveringPet=false;
        });
      }
      _cancelHoverTimer();
      _mouseOverWidgetOrChat = false;
    },
    onHover: (event) {
      _lastCursorMove = DateTime.now();
    },
    child: gestureDetector,
  ),);
}

Widget _buildPetContent() {
  if (!_isAlive) {
    return Icon(Icons.cancel, size: 60, color: Colors.red);
  }

  // Используем систему анимаций
  if (_animations[_currentAnimation] != null && _animations[_currentAnimation]!.isNotEmpty) {
    final currentFrame = _animations[_currentAnimation]![_currentFrameIndex];
    return Image.file(
      File(currentFrame.imagePath),
      width: 110,
      height: 100,
      fit: BoxFit.contain,
    );
  }

  // Fallback на статическое изображение
  return Image.asset(
    _isMusicPlaying ? 'assets/images/2.png' : 'assets/images/main_template.png',
    width: 80,
    height: 80,
    fit: BoxFit.contain,
  );
}


  void _animateWindowToPosition(Offset targetPosition) {
    _setMovingState(true);
    _isAnimatingDrop = true;
    
    windowManager.getPosition().then((startPos) {
      final startX = startPos.dx;
      final startY = startPos.dy;
      final duration = Duration(milliseconds: 500);
      final startTime = DateTime.now();

      Timer.periodic(Duration(milliseconds: 16), (timer) async {
        final t = DateTime.now().difference(startTime).inMilliseconds / duration.inMilliseconds;
        final eased = Curves.easeOut.transform(min(1.0, t));
        
        double curX = startX + (targetPosition.dx - startX) * eased;
        double curY = startY + (targetPosition.dy - startY) * eased;
        
        curX = curX.clamp(0.0, _screenWidth - _windowWidth);
        curY = curY.clamp(0.0, _screenHeight - _windowHeight);
        
        await windowManager.setPosition(Offset(curX, curY));
        
        if (t >= 1.0) {
          timer.cancel();
          _isAnimatingDrop = false;
          _setMovingState(false);
          setState(() {
            _userSetPosition = Offset(curX, curY);
            _userHasSetPosition = true;
          });
          _saveData();
        }
      });
    });
  }
  void _revealInExplorer(EatenFile filePath) async {
    try {
      if (Platform.isWindows) {
        await Process.run('explorer', ['/select,', filePath.path]);
      } else if (Platform.isMacOS) {
        await Process.run('open', ['-R', filePath.path]);
      } else if (Platform.isLinux) {
        final dir = path.dirname(filePath.path);
        await Process.run('xdg-open', [dir]);
      }
    } catch (e) {
      debugPrint('Error revealing file: $e');
    }
  }

  void _setMovingState(bool val) {
    if (_isMovingWindow == val) return;
    setState(() => _isMovingWindow = val);
  }

  void _startHoverTimer() {
    _hoverTimer?.cancel();
    _hoverTimer = Timer(Duration(milliseconds: 1500), () {
      if (mounted && !_isHoveringRecentFiles && !_contextMenuOpen && !_chatOverlayVisible) {
        setState(() => _showRecentFiles = true);
        _isFollowingCursor = false;
      }
    });
  }

  void _cancelHoverTimer() {
    _hoverTimer?.cancel();
    if (mounted && !_isHoveringRecentFiles) {
      setState(() => _showRecentFiles = false);
      if (!_contextMenuOpen && !_chatOverlayVisible) {
        _isFollowingCursor = false;
      }
    }
  }

  
Future<void> _startServer() async {
  final server = await ServerSocket.bind('localhost', 8081);
  print('Server listening on port 8080');

  server.listen((Socket socket) {
    final List<int> dataBuffer = [];
    
    socket.listen(
      (List<int> data) {
        dataBuffer.addAll(data);
      },
      onDone: () {
        // Декодируем все полученные данные как UTF-8
        final String receivedString = utf8.decode(dataBuffer);
         // Если окно чата уже открыто - отправляем текст

         
      if (ProcessManager().hasProcess("chat_window")) {
         _sendToServer(receivedString);
        return;
      }
      
      // Открываем новое окно чата
       
        _openChatWindowWithText(receivedString,"chat_window");
      },
      onError: (error) {
        print('Socket error: $error');
      }
    );
  });
}


Future<void> _startServer2() async {
  final server = await ServerSocket.bind('localhost', 8082);
  print('Server listening on port 8080');

  server.listen((Socket socket) {
    final List<int> dataBuffer = [];
    
    socket.listen(
      (List<int> data) {
        dataBuffer.addAll(data);
      },
      onDone: () {
        // Декодируем все полученные данные как UTF-8
        final String receivedString = utf8.decode(dataBuffer);
         // Если окно чата уже открыто - отправляем текст
        if (receivedString=="chat is ready"){
        setState(() {
          _chatIsReadyToReceiveMessages = true;
        });

        }
         
      },
      onError: (error) {
        print('Socket error: $error');
      }
    );
  });
}



Widget _buildRecentFilesOverlay() {
  if (!_showRecentFiles) return SizedBox.shrink();

// Сортируем файлы: сначала помеченные звездочкой, затем по частоте открытий, затем по давности последнего открытия
final sortedFiles = _files.toList()
  ..sort((a, b) {
    // 1. Сначала помеченные звездочкой
    if (a.isStarred && !b.isStarred) return -1;
    if (!a.isStarred && b.isStarred) return 1;
    
    // 2. Затем по частоте открытий (по убыванию)
    final openCountComparison = b.openCount.compareTo(a.openCount);
    if (openCountComparison != 0) return openCountComparison;
    
    // 3. Затем по давности последнего открытия (сначала недавно открытые)
    if (a.lastOpened != null && b.lastOpened != null) {
      return b.lastOpened!.compareTo(a.lastOpened!);
    }
    if (a.lastOpened != null) return -1;
    if (b.lastOpened != null) return 1;
    
    return 0;
  });
  return MouseRegion(
    onEnter: (_) {
      setState(() => _isHoveringRecentFiles = true);
    

    },
    onExit: (_) {
      setState(() => _isHoveringRecentFiles = false);
      if (!_contextMenuOpen && !_chatOverlayVisible) {
        _isFollowingCursor = false;
      }
       if (Platform.isWindows && !_isHoveringRecentFiles && !_contextMenuOpen) {
        windowManager.setIgnoreMouseEvents(false);
      }
    },
    child: Container(
      width: _windowWidth - 15,
      height: _windowHeight - 15,
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.9),
        borderRadius: BorderRadius.circular(12),
      ),
      child: ScrollConfiguration(
        behavior: ScrollConfiguration.of(context).copyWith(
          scrollbars: true,
          dragDevices: {
            PointerDeviceKind.touch,
            PointerDeviceKind.mouse,
          },
        ),
        child: GridView.builder(
          padding: EdgeInsets.all(6),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3,
            crossAxisSpacing: 4,
            mainAxisSpacing: 4,
            childAspectRatio: 1,
          ),
          itemCount: sortedFiles.isEmpty ? 1 : sortedFiles.length,
          itemBuilder: (context, index) {
            if (sortedFiles.isEmpty) {
              return Container(
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(6),
                ),
                child: Icon(Icons.folder_open, color: Colors.white54, size: 24),
              );
            }

            final file = sortedFiles[index];
            final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // Безопасная проверка на папку
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
            return MouseRegion(
              onEnter: (_) => _showFileTooltip(displayName),
              child: GestureDetector(
                onTap: () {
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // Нужно добавить этот метод
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
                },
                onLongPress: () {
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _searchWebTitle(file);
                  } else if (isDirectory) {
                    _revealInExplorer(file); // Нужно добавить этот метод
                  } else {
                    _revealInExplorer(file);
                  }
                  _isFollowingCursor = false;
                },
                
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(6),
                    border: Border.all(
                      color: file.isStarred ? Colors.yellow.withOpacity(0.5) : Colors.white.withOpacity(0.2), 
                      width: file.isStarred ? 2 : 1
                    ),
                  ),
                  child: Stack(
                    children: [
                      // Для папок
                      if (isDirectory)
                        Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(
                                Icons.folder,
                                size: 40,
                                color: Colors.green.shade300,
                              ),
                              SizedBox(height: 4),
                              Text(
                                displayName.length > 15 ? '${displayName.substring(0, 15)}...' : displayName,
                                style: TextStyle(
                                  color: Colors.green.shade300,
                                  fontSize: 9,
                                  fontWeight: file.isStarred ? FontWeight.bold : FontWeight.normal,
                                ),
                                textAlign: TextAlign.center,
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ],
                          ),
                        )
                      // Для web-файлов
                      else if (file.isWeb)
                        Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              if (file.iconBytes != null)
                                Image.memory(
                                  file.iconBytes!,
                                  width: 40,
                                  height: 40,
                                  fit: BoxFit.contain,
                                )
                              else
                                Icon(
                                  Icons.language,
                                  size: 40,
                                  color: Colors.blue,
                                ),
                              SizedBox(height: 4),
                              Text(
                                displayName.length > 15 ? '${displayName.substring(0, 15)}...' : displayName,
                                style: TextStyle(
                                  color: Colors.blue,
                                  fontSize: 9,
                                  fontWeight: file.isStarred ? FontWeight.bold : FontWeight.normal,
                                ),
                                textAlign: TextAlign.center,
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ],
                          ),
                        )
                      // Для обычных файлов
                      else
                        Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            // Проверяем, является ли файл изображением
                            if (_isImageFile(displayName))
                              ClipRRect(
                                borderRadius: BorderRadius.circular(4),
                                child: Image.file(
                                  File(file.path),
                                  width: 40,
                                  height: 40,
                                  fit: BoxFit.cover,
                                  errorBuilder: (context, error, stackTrace) {
                                    return Icon(
                                      Icons.insert_drive_file,
                                      size: 40,
                                      color: Colors.white,
                                    );
                                  },
                                ),
                              )
                            else if (file.iconBytes != null)
                              Image.memory(
                                file.iconBytes!,
                                width: 40,
                                height: 40,
                                fit: BoxFit.contain,
                              )
                            else
                              Icon(
                                Icons.insert_drive_file,
                                size: 40,
                                color: Colors.white,
                              ),
                            SizedBox(height: 4),
                            Text(
                              displayName.length > 15 ? '${displayName.substring(0, 15)}...' : displayName,
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 9,
                                fontWeight: file.isStarred ? FontWeight.bold : FontWeight.normal,
                              ),
                              textAlign: TextAlign.center,
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ],
                        ),
                      if (file.isStarred)
                        Positioned(
                          top: 2,
                          right: 2,
                          child: Icon(
                            Icons.star,
                            color: Colors.yellow,
                            size: 12,
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            );
          },
        ),
      ),
    ),
  );
}
// Функция для проверки, является ли файл изображением
bool _isImageFile(String fileName) {

  return fileName.endsWith('.jpg') || 
         fileName.endsWith('.jpeg') ||
         fileName.endsWith('.png') ||
         fileName.endsWith('.gif') ||
         fileName.endsWith('.bmp') ||
         fileName.endsWith('.webp') ||
         fileName.endsWith('.svg');
}

// Виджет для отображения превью изображения
Widget _buildImagePreview(String filePath) {
  try {
    return Container(
      width: 40,
      height: 40,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(4),
        child: Image.file(
          File(filePath),
          fit: BoxFit.cover,
          width: 40,
          height: 40,
          errorBuilder: (context, error, stackTrace) {
            // Если не удалось загрузить изображение, показываем стандартную иконку
            return Icon(
              Icons.insert_drive_file, 
              size: 40, 
              color: Colors.white
            );
          },
        ),
      ),
    );
  } catch (e) {
    // При ошибке показываем стандартную иконку файла
    return Icon(
      Icons.insert_drive_file, 
      size: 40, 
      color: Colors.white
    );
  }
}

// Метод для получения отображаемого имени файла
String _getDisplayFileName(dynamic file) {
  return file.isWeb ? _getDomainName(file.path) : path.basename(file.path);
}

// Функция для получения File объекта
Future<File> _getImageFile(String filePath) async {
  return File(filePath);
}


// Добавьте эти вспомогательные методы в класс:




Future<void> _openWebUrl(EatenFile url) async {
  String formattedUrl = url.path.trim();
  if (!formattedUrl.startsWith('http')) {
    formattedUrl = 'https://$formattedUrl';
  }
  
  if (await canLaunch(formattedUrl)) {
    await launch(formattedUrl);
  } else {
    debugPrint('Cannot launch URL: $formattedUrl');
  }
}

Future<void> _searchWebTitle(EatenFile url) async {
  final searchUrl = 'https://www.google.com/search?q=${Uri.encodeComponent(url.path)}';
  if (await canLaunch(searchUrl)) {
    await launch(searchUrl);
  }
}

// Убедитесь, что у вас есть импорт для url_launcher:
// import 'package:url_launcher/url_launcher.dart';

  Future<Uint8List?> _getFileIcon (EatenFile fileName) async {
    const MethodChannel _fileIconChannel = MethodChannel('screenshot_channel');
    try {
    final result = await _fileIconChannel.invokeMethod('getFileIcon', fileName.path);
    return result as Uint8List?;
  } catch (e) {
    print('Error getting file icon: $e');
    return null;
  }
  }

  void _showFileTooltip(String fileName) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(fileName),
        duration: Duration(seconds: 2),
        backgroundColor: Colors.black.withOpacity(0.8),
        behavior: SnackBarBehavior.floating,
        margin: EdgeInsets.only(bottom: 100, left: 20, right: 20),
      ),
    );
  }



@override
Widget build(BuildContext context) {
  return RepaintBoundary(
    key: _screenshotKey,
    child: RawKeyboardListener(
      focusNode: FocusNode(),
      autofocus: true,
      onKey: (event) {
        // Передаем события кейлоггеру
        _keyboardLogger.handleKeyEvent(event);
      },
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            Positioned.fill(
              child: DropTarget(
                onDragEntered: (detail) {
                  setState(() {
                    _isFollowingCursor = true;
                  });
                },
                onDragExited: (detail) {
                  setState(() {
                    _isFollowingCursor = false;
                    if (_userHasSetPosition) {
                     // _animateWindowToPosition(_userSetPosition);
                    }
                  });
                },
                onDragDone: (detail) {
                  final paths = <String>[];
                  try {
                    for (final f in detail.files) {
                      if (f.path != null && f.path.isNotEmpty) paths.add(f.path);
                    }
                  } catch (e) {}
                  if (paths.isNotEmpty) _onFileDropped(paths);
                  
                  setState(() {
                    _isFollowingCursor = false;
                    if (_userHasSetPosition) {
                     // _animateWindowToPosition(_userSetPosition);
                    }
                  });
                },
                child: Stack(
                  children: [
                    // Основное пространство - игнорирует события, кроме случаев когда открыто меню
                    Positioned.fill(
                      child: IgnorePointer(
                        ignoring: true, // Пропускаем события только когда меню открыто или режим выбора
                        child: Container(color: Colors.transparent),
                      ),
                    ),
                    // InteractiveWidget - всегда кликабелен
                    _buildInteractiveWidget(),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    ),
  );
}



// Добавьте эти методы в ваш основной класс
void _handleFileTap(dynamic file, bool isDirectory) {
  setState(() {
    _showRecentFiles = false;
    _isHoveringRecentFiles = false;
  });
  if (file.isWeb) {
    _openWebUrl(file);
  } else if (isDirectory) {
    _openFile(file);
  } else {
    _openFile(file);
  }
  _incrementOpenCount(file);
  _isFollowingCursor = false;
}

void _handleFileLongPress(dynamic file, bool isDirectory) {
  setState(() {
    _showRecentFiles = false;
    _isHoveringRecentFiles = false;
  });
  if (file.isWeb) {
    _searchWebTitle(file);
  } else if (isDirectory) {
    _revealInExplorer(file);
  } else {
    _revealInExplorer(file);
  }
  _isFollowingCursor = false;
}
@override
void dispose() {
  // Отмена всех таймеров3
   _phraseTimer?.cancel();
    _smtc.dispose();
  _clipboardTimer?.cancel();
  _longPressTimer?.cancel();
  _dayTimer?.cancel();
  _musicCheckTimer?.cancel();
  _stateTimer?.cancel();
  _movementTimer?.cancel();
  _hoverTimer?.cancel();
  _idleTimer?.cancel();
  _physicsTimer?.cancel();
  _animationTimer?.cancel();
  FileDragDropService.dispose(); // Важно: отключаем листенер
  // Остановка мониторинга
  stopMonitoring();
  
  // Закрытие процессов
  ProcessManager().killAllProcesses();
  _chatProcess?.kill();
  
  // Закрытие сетевых соединений
  _httpClient.close();
  
  // Удаление оверлеев
  _removeContextMenu();
  _removeChatOverlay();
  _submenuOverlay?.remove();
  _fileViewerOverlay?.remove();
  
  // Отписка от слушателей
  windowManager.removeListener(this);
  _keyboardLogger.dispose();
  
  // Очистка контроллеров
  _promptController.dispose();
  _hotkeyService.dispose();
  
  super.dispose();
}
 // Удалите метод _windowListener и добавьте вместо этого:
  @override
  void onWindowMove() async {
    if (_isChatOpen) {
      final pos = await windowManager.getPosition();
      final size = await windowManager.getSize();
      
      // TODO: Отправить новую позицию процессу чата через IPC
      // Например, через named pipe, socket или platform channel
      _sendPositionToChat(pos, size);
    }
  }

  void _sendPositionToChat(Offset position, ui.Size size) async {
    try {
      // Здесь реализация отправки позиции в процесс чата
      // Это может быть через platform channels, sockets или другие методы IPC
      print('New position: $position, size: $size');
    } catch (e) {
      print('Error sending position to chat: $e');
    }
  }

  @override
  void onWindowClose() async => await windowManager.hide();
  @override
  void onWindowFocus() {}
  @override
  void onWindowBlur() {}
}



class _FileGridItem extends StatefulWidget {
  final dynamic file;
  final String displayName;
  final bool isDirectory;
  final VoidCallback onTap;
  final VoidCallback onLongPress;

  const _FileGridItem({
    required this.file,
    required this.displayName,
    required this.isDirectory,
    required this.onTap,
    required this.onLongPress,
  });

  @override
  State<_FileGridItem> createState() => _FileGridItemState();
}

class _FileGridItemState extends State<_FileGridItem> {
  Timer? _autoOpenTimer;

  @override
  void dispose() {
    _autoOpenTimer?.cancel();
    super.dispose();
  }

  void _startAutoOpenTimer() {
    _autoOpenTimer?.cancel();
    _autoOpenTimer = Timer(Duration(seconds: 4), () {
      widget.onTap();
    });
  }

  void _cancelAutoOpenTimer() {
    _autoOpenTimer?.cancel();
  }

 //сюда_копипаста

 // Функция для проверки, является ли файл изображением
bool _isImageFile(String fileName) {

  return fileName.endsWith('.jpg') || 
         fileName.endsWith('.jpeg') ||
         fileName.endsWith('.png') ||
         fileName.endsWith('.gif') ||
         fileName.endsWith('.bmp') ||
         fileName.endsWith('.webp') ||
         fileName.endsWith('.svg');
}


  void _showFileTooltip(String fileName) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(fileName),
        duration: Duration(seconds: 2),
        backgroundColor: Colors.black.withOpacity(0.8),
        behavior: SnackBarBehavior.floating,
        margin: EdgeInsets.only(bottom: 100, left: 20, right: 20),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) {
        _showFileTooltip(widget.displayName);
        _startAutoOpenTimer();
      },
      onExit: (_) => _cancelAutoOpenTimer(),
      child: GestureDetector(
        onTap: () {
          _cancelAutoOpenTimer();
          widget.onTap();
        },
        onLongPress: () {
          _cancelAutoOpenTimer();
          widget.onLongPress();
        },
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.1),
            borderRadius: BorderRadius.circular(6),
            border: Border.all(
              color: widget.file.isStarred ? Colors.yellow.withOpacity(0.5) : Colors.white.withOpacity(0.2), 
              width: widget.file.isStarred ? 2 : 1
            ),
          ),
          child: Stack(
            children: [
              // Для папок
              if (widget.isDirectory)
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.folder,
                        size: 40,
                        color: Colors.green.shade300,
                      ),
                      SizedBox(height: 4),
                      Text(
                        widget.displayName.length > 15 ? '${widget.displayName.substring(0, 15)}...' : widget.displayName,
                        style: TextStyle(
                          color: Colors.green.shade300,
                          fontSize: 9,
                          fontWeight: widget.file.isStarred ? FontWeight.bold : FontWeight.normal,
                        ),
                        textAlign: TextAlign.center,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                )
              // Для web-файлов
              else if (widget.file.isWeb)
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      if (widget.file.iconBytes != null)
                        Image.memory(
                          widget.file.iconBytes!,
                          width: 40,
                          height: 40,
                          fit: BoxFit.contain,
                        )
                      else
                        Icon(
                          Icons.language,
                          size: 40,
                          color: Colors.blue,
                        ),
                      SizedBox(height: 4),
                      Text(
                        widget.displayName.length > 15 ? '${widget.displayName.substring(0, 15)}...' : widget.displayName,
                        style: TextStyle(
                          color: Colors.blue,
                          fontSize: 9,
                          fontWeight: widget.file.isStarred ? FontWeight.bold : FontWeight.normal,
                        ),
                        textAlign: TextAlign.center,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                )
              // Для обычных файлов
              else
                Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // Проверяем, является ли файл изображением
                    if (_isImageFile(widget.displayName))
                      ClipRRect(
                        borderRadius: BorderRadius.circular(4),
                        child: Image.file(
                          File(widget.file.path),
                          width: 40,
                          height: 40,
                          fit: BoxFit.cover,
                          errorBuilder: (context, error, stackTrace) {
                            return Icon(
                              Icons.insert_drive_file,
                              size: 40,
                              color: Colors.white,
                            );
                          },
                        ),
                      )
                    else if (widget.file.iconBytes != null)
                      Image.memory(
                        widget.file.iconBytes!,
                        width: 40,
                        height: 40,
                        fit: BoxFit.contain,
                      )
                    else
                      Icon(
                        Icons.insert_drive_file,
                        size: 40,
                        color: Colors.white,
                      ),
                    SizedBox(height: 4),
                    Text(
                      widget.displayName.length > 15 ? '${widget.displayName.substring(0, 15)}...' : widget.displayName,
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 9,
                        fontWeight: widget.file.isStarred ? FontWeight.bold : FontWeight.normal,
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              if (widget.file.isStarred)
                Positioned(
                  top: 2,
                  right: 2,
                  child: Icon(
                    Icons.star,
                    color: Colors.yellow,
                    size: 12,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}



class WindowsFocusInfo {
  final bool isFileSelection;
  final bool isTextSelection;
  final String? selectedText;
  final String? selectedPath;
  final String? error;
  
  WindowsFocusInfo({
    required this.isFileSelection,
    required this.isTextSelection,
    this.selectedText,
    this.selectedPath,
    this.error,
  });
  
  factory WindowsFocusInfo.fromJson(String jsonString) {
    try {
      final Map<String, dynamic> map = json.decode(jsonString);
      return WindowsFocusInfo(
        isFileSelection: map['isFileSelection'] ?? false,
        isTextSelection: map['isTextSelection'] ?? false,
        selectedText: map['selectedText'],
        selectedPath: map['selectedPath'],
        error: map['error'],
      );
    } catch (e) {
      return WindowsFocusInfo(
        isFileSelection: false,
        isTextSelection: false,
        error: 'JSON parsing error: $e',
      );
    }
  }
  
  factory WindowsFocusInfo.fromMap(Map<String, dynamic> map) {
    return WindowsFocusInfo(
      isFileSelection: map['isFileSelection'] ?? false,
      isTextSelection: map['isTextSelection'] ?? false,
      selectedText: map['selectedText'],
      selectedPath: map['selectedPath'],
      error: map['error'],
    );
  }
  
  bool get hasError => error != null;
  bool get hasSelection => isFileSelection || isTextSelection;
}


// Вспомогательные классы и методы
class ImageInfo {
  final img.Image image;
  final int width;
  final int height;
  final bool isLandscape;
  final bool isPortrait;
  final double aspectRatio;

  ImageInfo({
    required this.image,
    required this.width,
    required this.height,
    required this.isLandscape,
    required this.isPortrait,
    required this.aspectRatio,
  });
}

class ImagePlacement {
  final img.Image image;
  final int x;
  final int y;
  final int width;
  final int height;

  ImagePlacement({
    required this.image,
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });
}

class CollageStrategy {
  final int canvasWidth;
  final int canvasHeight;
  final List<ImagePlacement> placements;

  CollageStrategy({
    required this.canvasWidth,
    required this.canvasHeight,
    required this.placements,
  });
}

CollageStrategy _createHorizontalRowStrategy(List<img.Image> images, int maxWidth, int maxHeight) {
  final placements = <ImagePlacement>[];
  int currentX = 0;
  int rowHeight = 0;
  
  // Находим максимальную высоту для ряда
  for (final image in images) {
    rowHeight = rowHeight > image.height ? rowHeight : image.height;
  }
  
  // Масштабируем высоту под максимальную, если нужно
  if (rowHeight > maxHeight) {
    rowHeight = maxHeight;
  }
  
  // Размещаем изображения
  for (final image in images) {
    final scaleFactor = rowHeight / image.height;
    final scaledWidth = (image.width * scaleFactor).round();
    
    // Проверяем, не превысили ли максимальную ширину
    if (currentX + scaledWidth > maxWidth) {
      // Если превысили, создаем новый ряд
      break;
    }
    
    placements.add(ImagePlacement(
      image: image,
      x: currentX,
      y: 0,
      width: scaledWidth,
      height: rowHeight,
    ));
    
    currentX += scaledWidth;
  }
  
  return CollageStrategy(
    canvasWidth: currentX,
    canvasHeight: rowHeight,
    placements: placements,
  );
}

CollageStrategy _createVerticalColumnStrategy(List<img.Image> images, int maxWidth, int maxHeight) {
  final placements = <ImagePlacement>[];
  int currentY = 0;
  int columnWidth = 0;
  
  // Находим максимальную ширину для колонки
  for (final image in images) {
    columnWidth = columnWidth > image.width ? columnWidth : image.width;
  }
  
  // Масштабируем ширину под максимальную, если нужно
  if (columnWidth > maxWidth) {
    columnWidth = maxWidth;
  }
  
  // Размещаем изображения
  for (final image in images) {
    final scaleFactor = columnWidth / image.width;
    final scaledHeight = (image.height * scaleFactor).round();
    
    // Проверяем, не превысили ли максимальную высоту
    if (currentY + scaledHeight > maxHeight) {
      break;
    }
    
    placements.add(ImagePlacement(
      image: image,
      x: 0,
      y: currentY,
      width: columnWidth,
      height: scaledHeight,
    ));
    
    currentY += scaledHeight;
  }
  
  return CollageStrategy(
    canvasWidth: columnWidth,
    canvasHeight: currentY,
    placements: placements,
  );
}

CollageStrategy _createAdaptiveGridStrategy(List<img.Image> images, int maxWidth, int maxHeight, bool isLandscape) {
  final placements = <ImagePlacement>[];
  
  if (images.length <= 3) {
    // Для малого количества изображений - простой ряд или колонка
    if (isLandscape) {
      return _createHorizontalRowStrategy(images, maxWidth, maxHeight);
    } else {
      return _createVerticalColumnStrategy(images, maxHeight, maxWidth);
    }
  }
  
  // Для большего количества - сетка 2xN
  int cols = 2;
  int rows = (images.length / cols).ceil();
  
  int cellWidth = (maxWidth / cols).round();
  int cellHeight = (maxHeight / rows).round();
  
  for (int i = 0; i < images.length; i++) {
    final image = images[i];
    final row = i ~/ cols;
    final col = i % cols;
    
    // Вычисляем размеры с сохранением пропорций
    final double widthRatio = cellWidth / image.width;
    final double heightRatio = cellHeight / image.height;
    final double scale = widthRatio < heightRatio ? widthRatio : heightRatio;
    
    final scaledWidth = (image.width * scale).round();
    final scaledHeight = (image.height * scale).round();
    
    // Центрируем изображение в ячейке
    final x = col * cellWidth + (cellWidth - scaledWidth) ~/ 2;
    final y = row * cellHeight + (cellHeight - scaledHeight) ~/ 2;
    
    placements.add(ImagePlacement(
      image: image,
      x: x,
      y: y,
      width: scaledWidth,
      height: scaledHeight,
    ));
  }
  
  return CollageStrategy(
    canvasWidth: maxWidth,
    canvasHeight: rows * cellHeight,
    placements: placements,
  );
}

CollageStrategy _createMixedOrientationStrategy(List<img.Image> images, int maxWidth, int maxHeight) {
  final placements = <ImagePlacement>[];
  
  // Разделяем изображения по ориентации
  final landscapeImages = images.where((img) => img.width >= img.height).toList();
  final portraitImages = images.where((img) => img.height > img.width).toList();
  
  // Пробуем создать горизонтальный ряд из альбомных изображений
  if (landscapeImages.isNotEmpty) {
    final landscapeStrategy = _createHorizontalRowStrategy(landscapeImages, maxWidth, maxHeight ~/ 2);
    for (final placement in landscapeStrategy.placements) {
      placements.add(placement);
    }
  }
  
  // Добавляем портретные изображения ниже
  if (portraitImages.isNotEmpty) {
    final portraitStrategy = _createHorizontalRowStrategy(portraitImages, maxWidth, maxHeight ~/ 2);
    for (final placement in portraitStrategy.placements) {
      placements.add(ImagePlacement(
        image: placement.image,
        x: placement.x,
        y: maxHeight ~/ 2,
        width: placement.width,
        height: placement.height,
      ));
    }
  }
  
  return CollageStrategy(
    canvasWidth: maxWidth,
    canvasHeight: maxHeight,
    placements: placements,
  );
}

/// УЛЬТРА-ОПТИМИЗИРОВАННЫЙ CosineLSH для сверхразреженных векторов
class CosineLSH {
  static const int _bitsPerByte = 8;
  
  final int _numHyperplanes;
  final int _numBands;
  final int _rowsPerBand;
  final int _dimensions;
  final List<Map<int, double>> _hyperplanes;
  final List<Map<String, Uint8List>> _buckets; // Квантованные сигнатуры
  final Map<String, int> _vectorToBucket; // Быстрый поиск векторов
    final List<Map<String, Set<String>>> _bucketToVectors; // band → bucketKey → Set<vectorId>
  final Map<String, Uint8List> _vectorSignatures; // vectorId → полная сигнатура
  
  CosineLSH({
    required int dimensions,
    int numHyperplanes = 100,
    int numBands = 20,
    double sparsity = 0.01,
  })  : _numHyperplanes = numHyperplanes,
        _numBands = numBands,
                _bucketToVectors = List.generate(numBands, (_) => {}),
        _vectorSignatures = {},
        _rowsPerBand = numHyperplanes ~/ numBands,
        _dimensions = dimensions,
        _hyperplanes = [],
        _buckets = List.filled(numBands, {}),
        _vectorToBucket = {} {
    _initializeUltraHyperplanes(dimensions, sparsity);
  }

  /// УЛЬТРА-ОПТИМИЗИРОВАННАЯ инициализация гиперплоскостей
  void _initializeUltraHyperplanes(int dimensions, double sparsity) {
    final random = Random();
    final nonZeroCount = (dimensions * sparsity).round().clamp(1, 1000);
    final usedIndices = <int>{};
    
    for (int i = 0; i < _numHyperplanes; i++) {
      final hyperplane = <int, double>{};
      usedIndices.clear();
      
      // Создаем уникальные индексы для максимальной эффективности
      while (hyperplane.length < nonZeroCount) {
        final index = random.nextInt(dimensions);
        if (usedIndices.add(index)) {
          hyperplane[index] = random.nextGaussian();
        }
      }
      
      _normalizeSparseVector(hyperplane);
      _hyperplanes.add(hyperplane);
    }
  }

  /// СУПЕР-БЫСТРАЯ нормализация на месте
  void _normalizeSparseVector(Map<int, double> vector) {
    double normSquared = 0.0;
    for (final value in vector.values) {
      normSquared += value * value;
    }
    
    if (normSquared > 0) {
      final invNorm = 1.0 / sqrt(normSquared);
      for (final key in vector.keys) {
        vector[key] = vector[key]! * invNorm;
      }
    }
  }

  /// УЛЬТРА-ОПТИМИЗИРОВАННОЕ вычисление сигнатуры
  Uint8List _computeUltraSignature(Map<int, double> sparseVector) {
    final signatureBytes = Uint8List((_numHyperplanes + _bitsPerByte - 1) ~/ _bitsPerByte);
    
    for (int i = 0; i < _numHyperplanes; i++) {
      final hyperplane = _hyperplanes[i];
      double dotProduct = 0.0;
      
      // МАКСИМАЛЬНО ОПТИМИЗИРОВАННЫЙ цикл
      if (sparseVector.length < hyperplane.length) {
        for (final entry in sparseVector.entries) {
          final value = hyperplane[entry.key];
          if (value != null) {
            dotProduct += entry.value * value;
          }
        }
      } else {
        for (final entry in hyperplane.entries) {
          final value = sparseVector[entry.key];
          if (value != null) {
            dotProduct += value * entry.value;
          }
        }
      }
      
      // Установка бита без ветвлений
      if (dotProduct >= 0) {
        final byteIndex = i ~/ _bitsPerByte;
        final bitIndex = i % _bitsPerByte;
        signatureBytes[byteIndex] |= (1 << bitIndex);
      }
    }
    
    return signatureBytes;
  }

  /// КВАНТОВАННОЕ вычисление нормы (8x сжатие)
  double _computeQuantizedNorm(Map<int, double> vector) {
    double sum = 0.0;
    for (final value in vector.values) {
      sum += value * value;
    }
    return sqrt(sum);
  }

  /// МЕГА-ОПТИМИЗИРОВАННОЕ добавление вектора с поддержкой int и double
void addVector(String vectorId, dynamic vector) {
  if (vector is Map<int, double>) {
    final signature = _computeUltraSignature(vector);
    _addQuantizedSignature(vectorId, signature);
  } else if (vector is Map<int, int>) {
    final normalizedVector = _normalizeIntVector(vector);
    final signature = _computeUltraSignature(normalizedVector);
    _addQuantizedSignature(vectorId, signature);
  } else {
    throw ArgumentError('Vector must be Map<int, double> or Map<int, int>');
  }
}

/// УЛЬТРА-БЫСТРАЯ нормализация int вектора в double
Map<int, double> _normalizeIntVector(Map<int, int> intVector) {
  if (intVector.isEmpty) return {};
  
  // Вычисляем сумму за один проход
  int sum = 0;
  for (final value in intVector.values) {
    sum += value;
  }
  
  // Если сумма 0, возвращаем нулевой вектор
  if (sum == 0) return {};
  
  // Конвертируем в double с нормализацией за один проход
  final invSum = 1.0 / sum;
  final normalized = <int, double>{};
  
  for (final entry in intVector.entries) {
    normalized[entry.key] = entry.value * invSum;
  }
  
  return normalized;
}

/// Добавление уже нормализованного вектора (ЕЩЕ БЫСТРЕЕ)
void addNormalizedVector(String vectorId, List<double> normalizedVector) {
  final sparseVector = <int, double>{};
  for (int i = 0; i < normalizedVector.length; i++) {
    final value = normalizedVector[i];
    if (value != 0.0) {
      sparseVector[i] = value;
    }
  }
  final signature = _computeUltraSignature(sparseVector);
  _addQuantizedSignature(vectorId, signature);
}

/// Добавление int вектора с предварительной нормализацией
void addIntVector(String vectorId, Map<int, int> intVector) {
  final normalizedVector = _normalizeIntVector(intVector);
  final signature = _computeUltraSignature(normalizedVector);
  _addQuantizedSignature(vectorId, signature);
}
  /// КВАНТОВАННОЕ хранение сигнатур

  /// СУПЕР-БЫСТРЫЙ поиск похожих векторов
  Set<String> findSimilarVectors(Map<int, double> queryVector, {double threshold = 0.7}) {
    final querySignature = _computeUltraSignature(queryVector);
    return _findByQuantizedSignature(querySignature);
  }

  Set<String> findSimilarNormalized(List<double> normalizedVector, {double threshold = 0.7}) {
    final sparseVector = <int, double>{};
    for (int i = 0; i < normalizedVector.length; i++) {
      final value = normalizedVector[i];
      if (value != 0.0) {
        sparseVector[i] = value;
      }
    }
    return findSimilarVectors(sparseVector, threshold: threshold);
  }

  /// УЛЬТРА-ОПТИМИЗИРОВАННЫЙ поиск по квантованной сигнатуре
   /// ИСПРАВЛЕННОЕ квантованное хранение сигнатур
  void _addQuantizedSignature(String vectorId, Uint8List signature) {
    _vectorSignatures[vectorId] = signature;
    
    for (int band = 0; band < _numBands; band++) {
      final startByte = band * _rowsPerBand ~/ _bitsPerByte;
      final endByte = ((band + 1) * _rowsPerBand + _bitsPerByte - 1) ~/ _bitsPerByte;
      final bandSignature = Uint8List.sublistView(signature, startByte, endByte);
      
      final bandKey = _bytesToKey(bandSignature);
      
      // Сохраняем связь bucket → vectorId
      _bucketToVectors[band][bandKey] ??= <String>{};
      _bucketToVectors[band][bandKey]!.add(vectorId);
      
      // Сохраняем сигнатуру для быстрого сравнения
      _buckets[band][bandKey] = bandSignature;
    }
  }

  /// ПОЛНОСТЬЮ ИСПРАВЛЕННЫЙ поиск
  Set<String> _findByQuantizedSignature(Uint8List signature) {
    final candidates = <String>{};
    
    for (int band = 0; band < _numBands; band++) {
      final startByte = band * _rowsPerBand ~/ _bitsPerByte;
      final endByte = ((band + 1) * _rowsPerBand + _bitsPerByte - 1) ~/ _bitsPerByte;
      final bandSignature = Uint8List.sublistView(signature, startByte, endByte);
      
      final bandKey = _bytesToKey(bandSignature);
      final bucketVectors = _bucketToVectors[band][bandKey];
      
      if (bucketVectors != null) {
        // Проверяем точное совпадение сигнатур для каждого вектора
        for (final vectorId in bucketVectors) {
          final storedSignature = _vectorSignatures[vectorId];
          if (storedSignature != null && 
              _bandSignaturesMatch(bandSignature, storedSignature, band)) {
            candidates.add(vectorId);
          }
        }
      }
    }
    
    return candidates;
  }

  /// Проверка совпадения только нужной полосы сигнатур
  bool _bandSignaturesMatch(Uint8List queryBand, Uint8List storedFullSignature, int band) {
    final startByte = band * _rowsPerBand ~/ _bitsPerByte;
    final endByte = ((band + 1) * _rowsPerBand + _bitsPerByte - 1) ~/ _bitsPerByte;
    
    final storedBand = Uint8List.sublistView(storedFullSignature, startByte, endByte);
    
    return _signaturesMatch(queryBand, storedBand);
  }
  /// СВЕРХБЫСТРОЕ сравнение сигнатур
  bool _signaturesMatch(Uint8List a, Uint8List b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }

  /// ЭКСТРЕМАЛЬНО ОПТИМИЗИРОВАННОЕ косинусное сходство
  double exactCosineSimilarity(Map<int, double> vector1, Map<int, double> vector2) {
    // Быстрая проверка на пустые векторы
    if (vector1.isEmpty || vector2.isEmpty) return 0.0;
    
    double dotProduct = 0.0;
    double norm1Squared = 0.0;
    double norm2Squared = 0.0;
    
    // ОДИН проход для всех вычислений
    if (vector1.length < vector2.length) {
      for (final entry in vector1.entries) {
        final value1 = entry.value;
        final value2 = vector2[entry.key];
        norm1Squared += value1 * value1;
        if (value2 != null) {
          dotProduct += value1 * value2;
        }
      }
      for (final value2 in vector2.values) {
        norm2Squared += value2 * value2;
      }
    } else {
      for (final entry in vector2.entries) {
        final value2 = entry.value;
        final value1 = vector1[entry.key];
        norm2Squared += value2 * value2;
        if (value1 != null) {
          dotProduct += value1 * value2;
        }
      }
      for (final value1 in vector1.values) {
        norm1Squared += value1 * value1;
      }
    }
    
    if (norm1Squared == 0 || norm2Squared == 0) return 0.0;
    
    return dotProduct / (sqrt(norm1Squared) * sqrt(norm2Squared));
  }

  /// БЫСТРАЯ оценка через сигнатуры
  double estimateCosineSimilarity(Map<int, double> vector1, Map<int, double> vector2) {
    final signature1 = _computeUltraSignature(vector1);
    final signature2 = _computeUltraSignature(vector2);
    
    int matchingBits = 0;
    for (int i = 0; i < signature1.length; i++) {
      matchingBits += (signature1[i] & signature2[i]).bitCount;
    }
    
    return cos((1 - matchingBits / _numHyperplanes) * pi);
  }

  /// УЛЬТРА-ЭФФЕКТИВНЫЙ хэш для байтов
  String _bytesToKey(Uint8List bytes) {
    // Оптимизированный хэш для быстрого поиска
    final buffer = StringBuffer();
    for (int i = 0; i < min(bytes.length, 8); i++) {
      buffer.write(bytes[i].toRadixString(16).padLeft(2, '0'));
    }
    return buffer.toString();
  }

  /// Расширенная статистика с квантованием
  Map<String, dynamic> getStats() {
    int totalBuckets = 0;
    int totalVectors = _vectorToBucket.length;
    int totalHyperplaneElements = 0;
    int totalSignatureMemory = 0;
    
    for (final hyperplane in _hyperplanes) {
      totalHyperplaneElements += hyperplane.length;
    }
    
    for (final bucket in _buckets) {
      totalBuckets += bucket.length;
      for (final signature in bucket.values) {
        totalSignatureMemory += signature.length;
      }
    }
    
    final originalMemory = totalVectors * _numHyperplanes ~/ _bitsPerByte;
    final compressedMemory = totalSignatureMemory;
    final compressionRatio = originalMemory / compressedMemory;
    
    return {
      'dimensions': _dimensions,
      'numHyperplanes': _numHyperplanes,
      'numBands': _numBands,
      'totalVectors': totalVectors,
      'totalBuckets': totalBuckets,
      'hyperplaneSparsity': '${((1 - totalHyperplaneElements / (_hyperplanes.length * _dimensions)) * 100).toStringAsFixed(1)}%',
      'signatureMemory': '${compressedMemory / 1024} КБ',
      'compressionRatio': '${compressionRatio.toStringAsFixed(1)}x',
      'memoryPerVector': '${(compressedMemory / totalVectors).toStringAsFixed(2)} байт',
    };
  }

  /// Очистка с минимальными накладными расходами
  void clear() {
    for (final bucket in _buckets) {
      bucket.clear();
    }
    _vectorToBucket.clear();
  }
}

/// Расширение для быстрого подсчета битов
extension _BitCount on int {
  int get bitCount {
    var count = 0;
    var n = this;
    while (n > 0) {
      count += n & 1;
      n >>= 1;
    }
    return count;
  }
}
class SemanticSearchSystem {
  final CosineLSH _lsh;
  final int _maxDimensions;
  final Map<String, Map<int, double>> _vectorStorage;
  
  SemanticSearchSystem({
    required int maxDimensions,
    int numHyperplanes = 100,
    int numBands = 20,
  }) : _lsh = CosineLSH(
          dimensions: maxDimensions,
          numHyperplanes: numHyperplanes,
          numBands: numBands,
        ),
        _maxDimensions = maxDimensions,
        _vectorStorage = {};
  
  /// Добавление вектора с автоматической нормализацией и расширением
  void addVector(String vectorId, dynamic sparseVector) {
    // Нормализуем и расширяем вектор


    final normalizedVector = normalizeAndExpandVector(sparseVector);
    
    // Обрезаем до максимальной размерности если нужно
    final trimmedVector = normalizedVector.length > _maxDimensions 
        ? normalizedVector.sublist(0, _maxDimensions)
        : normalizedVector;
    
    // Конвертируем обратно в Map<int, double> для CosineLSH
    final preparedVector = _listToSparseMap(trimmedVector);
    
    // Сохраняем оригинальный вектор для точных вычислений
    _vectorStorage[vectorId] = preparedVector;
   
    // Добавляем в LSH индекс
    _lsh.addVector(vectorId, preparedVector);
  }

  
  List<double> normalizeAndExpandVector(dynamic inputVector) {
  if (inputVector is Map<int, double>) {
    return normalizeAndExpandVectorDouble(inputVector);
  } else if (inputVector is Map<int, int>) {
    return normalizeAndExpandVectorInt(inputVector);
  } else {
    throw ArgumentError('Input must be Map<int, double> or Map<int, int>');
  }
}

List<double> normalizeAndExpandVectorDouble(Map<int, double> inputVector) {
  if (inputVector.isEmpty) return [];
  final maxId = inputVector.keys.reduce((a, b) => a > b ? a : b);
  final sum = inputVector.values.reduce((a, b) => a + b);
  final result = List<double>.filled(maxId, 0.0);
  
  final sortedEntries = inputVector.entries.toList()
    ..sort((a, b) => a.key.compareTo(b.key));
  
  for (final entry in sortedEntries) {
    final index = entry.key - 1;
    if (index < result.length) {
      result[index] = sum == 0 ? 0.0 : entry.value / sum;
    }
  }
  
  return result;
}

List<double> normalizeAndExpandVectorInt(Map<int, int> inputVector) {
  if (inputVector.isEmpty) return [];
  final maxId = inputVector.keys.reduce((a, b) => a > b ? a : b);
  final sum = inputVector.values.reduce((a, b) => a + b);
  final result = List<double>.filled(maxId, 0.0);
  
  final sortedEntries = inputVector.entries.toList()
    ..sort((a, b) => a.key.compareTo(b.key));
  
  for (final entry in sortedEntries) {
    final index = entry.key - 1;
    if (index < result.length) {
      result[index] = sum == 0 ? 0.0 : entry.value / sum;
    }
  }
  
  return result;
}

  
  /// Добавление int-вектора
  void addVectorInt(String vectorId, Map<int, int> sparseVector) {
    final normalizedVector = normalizeAndExpandVectorInt(sparseVector);
    final trimmedVector = normalizedVector.length > _maxDimensions 
        ? normalizedVector.sublist(0, _maxDimensions)
        : normalizedVector;
    
    final preparedVector = _listToSparseMap(trimmedVector);
    _vectorStorage[vectorId] = preparedVector;
    _lsh.addVector(vectorId, preparedVector);
  }
  
  /// Поиск похожих векторов
  Set<String> findSimilarVectors(Map<int, double> queryVector, {double threshold = 0.7}) {
    final normalizedQuery = normalizeAndExpandVector(queryVector);
    final trimmedQuery = normalizedQuery.length > _maxDimensions 
        ? normalizedQuery.sublist(0, _maxDimensions)
        : normalizedQuery;
    
    final preparedQuery = _listToSparseMap(trimmedQuery);
    
    return _lsh.findSimilarVectors(preparedQuery, threshold: threshold);
  }
  
  /// Точное вычисление схожести
  double exactSimilarity(String vectorId1, String vectorId2) {
    final vector1 = _vectorStorage[vectorId1];
    final vector2 = _vectorStorage[vectorId2];
    
    if (vector1 == null || vector2 == null) return 0.0;
    
    return _lsh.exactCosineSimilarity(vector1, vector2);
  }
  
  /// Вспомогательный метод: List<double> → Map<int, double>
  Map<int, double> _listToSparseMap(List<double> list) {
    final map = <int, double>{};
    for (int i = 0; i < list.length; i++) {
      if (list[i] != 0.0) {
        map[i + 1] = list[i]; // +1 чтобы сохранить оригинальную индексацию
      }
    }
    return map;
  }
  
  /// Получение статистики
  Map<String, dynamic> getStats() {
    final lshStats = _lsh.getStats();
    return {
      ...lshStats,
      'storedVectors': _vectorStorage.length,
      'maxDimensions': _maxDimensions,
    };
  }
}
class RecommendationSystem {
  final CosineLSH _lsh;
  final Map<String, Map<int, double>> _userVectors;
  
  RecommendationSystem({required int dimensions})
      : _lsh = CosineLSH(dimensions: dimensions),
        _userVectors = {};
  
  void addUserPreferences(String userId, Map<int, double> preferences) {
    _userVectors[userId] = preferences;
    _lsh.addVector(userId, preferences);
  }
  
  Set<String> findSimilarUsers(String userId) {
    final userVector = _userVectors[userId];
    if (userVector == null) return {};
    
    return _lsh.findSimilarVectors(userVector);
  }
  
  double userSimilarity(String user1, String user2) {
    final vector1 = _userVectors[user1];
    final vector2 = _userVectors[user2];
    
    if (vector1 == null || vector2 == null) return 0.0;
    
    return _lsh.exactCosineSimilarity(vector1, vector2);
  }
}

// Использование
void example() {
  final recommender = RecommendationSystem(dimensions: 100);
  
  // Предпочтения пользователей (например, оценки товаров)
  recommender.addUserPreferences('user1', {0: 5.0, 1: 3.0, 2: 4.5});
  recommender.addUserPreferences('user2', {0: 4.8, 1: 3.2, 2: 4.6}); // Похож на user1
  recommender.addUserPreferences('user3', {10: 5.0, 11: 2.0}); // Другой профиль
  
  final similarUsers = recommender.findSimilarUsers('user1');
  print('Похожие на user1: $similarUsers'); // Найдет user2
}

class SemanticEmbedding {
  final List<double> vector;
  final DateTime createdAt;
  final String version;
  
  SemanticEmbedding({
    required this.vector,
    DateTime? createdAt,
    this.version = '1.0',
  }) : createdAt = createdAt ?? DateTime.now();
  
  // Сериализация для JSON
  Map<String, dynamic> toJson() => {
    'vector': vector,
    'createdAt': createdAt.toIso8601String(),
    'version': version,
  };
  
  factory SemanticEmbedding.fromJson(Map<String, dynamic> json) {
    return SemanticEmbedding(
      vector: List<double>.from(json['vector']),
      createdAt: DateTime.parse(json['createdAt']),
      version: json['version'] ?? '1.0',
    );
  }
  
  // Косинусная схожесть с другим эмбеддингом
  double similarityTo(SemanticEmbedding other) {
    double dot = 0.0, norm1 = 0.0, norm2 = 0.0;
    for (int i = 0; i < vector.length; i++) {
      dot += vector[i] * other.vector[i];
      norm1 += vector[i] * vector[i];
      norm2 += other.vector[i] * other.vector[i];
    }
    return dot / (sqrt(norm1) * sqrt(norm2));
  }
}
class EmbeddingService {
  final int embeddingDimensions;
  final bool useCompression;
  final Map<int, dynamic> _wordEmbeddings; // Может хранить оба типа
  final Map<int, dynamic> _neuronEmbeddings;
  final Map<int, dynamic> _fragmentEmbeddings;
  
  EmbeddingService({
    this.embeddingDimensions = 100,
    this.useCompression = true, // Включаем сжатие по умолчанию
  }) : _wordEmbeddings = {},
        _neuronEmbeddings = {},
        _fragmentEmbeddings = {};
  
  /// Генерация эмбеддинга (сжатого или обычного)
  dynamic _generateEmbeddingVector(List<double> vector) {
    if (useCompression) {
      return CompressedEmbedding(quantizedVector: CompressedEmbedding.quantize(vector));
    } else {
      return SemanticEmbedding(vector: vector);
    }
  }
   SemanticEmbedding generateWordEmbedding(Word word, Map<int, Word> allWords) {
    final vector = List<double>.filled(embeddingDimensions, 0.0);
    final random = Random(word.id);
    
    // Базовый вектор
    for (int i = 0; i < embeddingDimensions; i++) {
      vector[i] = (word.id * (i + 1)) % 1.0;
    }
    
    // Учитываем связи с другими словами
    double totalWeight = 0.0;
    word.ratings.forEach((otherWordId, rating) {
      final otherWord = allWords[otherWordId];
      if (otherWord != null && _wordEmbeddings.containsKey(otherWordId)) {
        final otherEmbedding = _wordEmbeddings[otherWordId]!;
        final weight = rating / word.allRating.toDouble();
        
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += otherEmbedding.vector[i] * weight;
        }
        totalWeight += weight;
      }
    });
    
    // Нормализация
    if (totalWeight > 0) {
      for (int i = 0; i < embeddingDimensions; i++) {
        vector[i] /= totalWeight;
      }
    }
    
    return SemanticEmbedding(vector: vector);
  }
  
  void _applySemanticTypeWeight(List<double> vector, String semanticType) {
    final weights = {
      'question': 1.2,
      'statement': 1.0,
      'command': 1.1,
      'exclamation': 1.15,
    };
    
    final weight = weights[semanticType] ?? 1.0;
    for (int i = 0; i < vector.length; i++) {
      vector[i] *= weight;
    }
  }
  
  void _applyNeuronRelations(Neuron neuron, List<double> vector, Map<int, Word> allWords) {
    // Учитываем рейтинги других нейронов
    neuron.neuronRatings.forEach((otherNeuronId, rating) {
      if (_neuronEmbeddings.containsKey(otherNeuronId)) {
        final otherEmbedding = _neuronEmbeddings[otherNeuronId]!;
        final influence = rating / 100.0; // Нормализация
        
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] = vector[i] * (1 - influence) + otherEmbedding.vector[i] * influence;
        }
      }
    });
  }

  SemanticEmbedding updateNeuronEmbedding(
    Neuron neuron, 
    Map<int, Word> allWords,
    Map<int, Fragment> allFragments,
  ) {
    final embedding = generateNeuronEmbedding(neuron, allWords, allFragments);
    _neuronEmbeddings[neuron.id] = embedding;
    return embedding;
  }

    SemanticEmbedding updateFragmentEmbedding(Fragment fragment, Map<int, Word> allWords) {
    final embedding = generateFragmentEmbedding(fragment, allWords);
    _fragmentEmbeddings[fragment.id] = embedding;
    return embedding;
  }

  SemanticEmbedding generateFragmentEmbedding(Fragment fragment, Map<int, Word> allWords) {
    final vector = List<double>.filled(embeddingDimensions, 0.0);
    int validWords = 0;
    
    for (final wordId in fragment.wordIds) {
      if (_wordEmbeddings.containsKey(wordId)) {
        final wordEmbedding = _wordEmbeddings[wordId]!;
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += wordEmbedding.vector[i];
        }
        validWords++;
      }
    }
    
    if (validWords > 0) {
      for (int i = 0; i < embeddingDimensions; i++) {
        vector[i] /= validWords;
      }
    }
    
    _applySemanticTypeWeight(vector, fragment.semanticType);
    return SemanticEmbedding(vector: vector);
  }

  SemanticEmbedding generateNeuronEmbedding(
    Neuron neuron, 
    Map<int, Word> allWords,
    Map<int, Fragment> allFragments,
  ) {
    final vector = List<double>.filled(embeddingDimensions, 0.0);
    int validComponents = 0;
    
    // Ключевые слова
    for (final wordId in neuron.keywords) {
      if (_wordEmbeddings.containsKey(wordId)) {
        final wordEmbedding = _wordEmbeddings[wordId]!;
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += wordEmbedding.vector[i];
        }
        validComponents++;
      }
    }
    
    // Связанные фрагменты
    for (final fragmentId in neuron.fragmentLinks) {
      if (_fragmentEmbeddings.containsKey(fragmentId)) {
        final fragmentEmbedding = _fragmentEmbeddings[fragmentId]!;
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += fragmentEmbedding.vector[i];
        }
        validComponents++;
      }
    }
    
    if (validComponents > 0) {
      for (int i = 0; i < embeddingDimensions; i++) {
        vector[i] /= validComponents;
      }
    }
    
    _applyNeuronRelations(neuron, vector, allWords);
    return SemanticEmbedding(vector: vector);
  }
  /// Обновление эмбеддинга слова
  dynamic updateWordEmbedding(Word word, Map<int, Word> allWords) {
    final rawVector = _computeRawWordEmbedding(word, allWords);
    final embedding = _generateEmbeddingVector(rawVector);
    _wordEmbeddings[word.id] = embedding;
    return embedding;
  }
  
  /// Получение вектора (автоматически распаковывает если нужно)
  List<double> getVector(dynamic embedding) {
    if (embedding is CompressedEmbedding) {
      return embedding.dequantize();
    } else if (embedding is SemanticEmbedding) {
      return embedding.vector;
    }
    return List<double>.filled(embeddingDimensions, 0.0);
  }
  
  /// Схожесть между любыми типами эмбеддингов
  double computeSimilarity(dynamic emb1, dynamic emb2) {
    if (emb1 is CompressedEmbedding && emb2 is CompressedEmbedding) {
      return emb1.fastSimilarityTo(emb2); // Используем оптимизированный метод
    }
    
    // Для смешанных типов или обычных эмбеддингов
    final vec1 = getVector(emb1);
    final vec2 = getVector(emb2);
    
    double dot = 0.0, norm1 = 0.0, norm2 = 0.0;
    for (int i = 0; i < vec1.length; i++) {
      dot += vec1[i] * vec2[i];
      norm1 += vec1[i] * vec1[i];
      norm2 += vec2[i] * vec2[i];
    }
    return dot / (sqrt(norm1) * sqrt(norm2));
  }
  
  /// Поиск похожих нейронов (работает с любым типом эмбеддингов)
  List<SimilarityResult> findSimilarNeurons(int neuronId, int topK, double minSimilarity) {
    final sourceEmbedding = _neuronEmbeddings[neuronId];
    if (sourceEmbedding == null) return [];
    
    final results = <SimilarityResult>[];
    
    _neuronEmbeddings.forEach((id, embedding) {
      if (id != neuronId) {
        final similarity = computeSimilarity(sourceEmbedding, embedding);
        if (similarity >= minSimilarity) {
          results.add(SimilarityResult(id: id, similarity: similarity));
        }
      }
    });
    
    results.sort((a, b) => b.similarity.compareTo(a.similarity));
    return results.take(topK).toList();
  }

   /// ✅ ПОЛУЧИТЬ существующий эмбеддинг (без пересчета)
  SemanticEmbedding? getWordEmbedding(int wordId) => _wordEmbeddings[wordId];
  SemanticEmbedding? getFragmentEmbedding(int fragmentId) => _fragmentEmbeddings[fragmentId];
  SemanticEmbedding? getNeuronEmbedding(int neuronId) => _neuronEmbeddings[neuronId];
  
  // Приватный метод вычисления сырого вектора
  List<double> _computeRawWordEmbedding(Word word, Map<int, Word> allWords) {
    final vector = List<double>.filled(embeddingDimensions, 0.0);
    final random = Random(word.id);
    
    // Используем наше расширение для Gaussian
    for (int i = 0; i < embeddingDimensions; i++) {
      vector[i] = random.nextGaussian() * 0.1; // Меньший разброс
    }
    
    // Остальная логика остается такой же...
    double totalWeight = 0.0;
    word.ratings.forEach((otherWordId, rating) {
      final otherWord = allWords[otherWordId];
      if (otherWord != null && _wordEmbeddings.containsKey(otherWordId)) {
        final otherEmbedding = _wordEmbeddings[otherWordId];
        final otherVector = getVector(otherEmbedding);
        final weight = rating / word.allRating.toDouble();
        
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += otherVector[i] * weight;
        }
        totalWeight += weight;
      }
    });
    
    if (totalWeight > 0) {
      for (int i = 0; i < embeddingDimensions; i++) {
        vector[i] /= totalWeight;
      }
    }
    
    return vector;
  }
}

class SimilarityResult {
  final int id;
  final double similarity;
  
  SimilarityResult({required this.id, required this.similarity});
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'similarity': similarity,
  };
}

class CompressedEmbedding {
  final List<int> quantizedVector;
  final DateTime createdAt;
  final String version;
  
  CompressedEmbedding({
    required this.quantizedVector,
    DateTime? createdAt,
    this.version = '1.0',
  }) : createdAt = createdAt ?? DateTime.now();
  
  // Квантование из double в int8
  static List<int> quantize(List<double> vector) {
    // Находим максимальное абсолютное значение для нормализации
    double maxAbs = vector.map((v) => v.abs()).reduce((a, b) => a > b ? a : b);
    if (maxAbs == 0.0) maxAbs = 1.0; // избегаем деления на 0
    
    return vector.map((v) {
      // Нормализуем к диапазону [-127, 127]
      double normalized = v / maxAbs;
      return (normalized * 127).round().clamp(-127, 127);
    }).toList();
  }
  
  // Восстановление при использовании
  List<double> dequantize() {
    return quantizedVector.map((v) => v / 127.0).toList();
  }
  
  // Сериализация для JSON (еще более компактная!)
  Map<String, dynamic> toJson() => {
    'q': quantizedVector, // 'q' вместо 'vector' для экономии места
    'c': createdAt.millisecondsSinceEpoch,
    'v': version,
  };
  
  factory CompressedEmbedding.fromJson(Map<String, dynamic> json) {
    return CompressedEmbedding(
      quantizedVector: List<int>.from(json['q']),
      createdAt: DateTime.fromMillisecondsSinceEpoch(json['c']),
      version: json['v'] ?? '1.0',
    );
  }
  
  // Косинусная схожесть между сжатыми эмбеддингами
  double similarityTo(CompressedEmbedding other) {
    final vec1 = dequantize();
    final vec2 = other.dequantize();
    
    double dot = 0.0, norm1 = 0.0, norm2 = 0.0;
    for (int i = 0; i < vec1.length; i++) {
      dot += vec1[i] * vec2[i];
      norm1 += vec1[i] * vec1[i];
      norm2 += vec2[i] * vec2[i];
    }
    return dot / (sqrt(norm1) * sqrt(norm2));
  }
  
  // Быстрая схожесть без деквантования (оптимизированная)
  double fastSimilarityTo(CompressedEmbedding other) {
    int dot = 0;
    int norm1 = 0;
    int norm2 = 0;
    
    for (int i = 0; i < quantizedVector.length; i++) {
      final v1 = quantizedVector[i];
      final v2 = other.quantizedVector[i];
      dot += v1 * v2;
      norm1 += v1 * v1;
      norm2 += v2 * v2;
    }
    
    return dot / (sqrt(norm1) * sqrt(norm2));
  }
}

extension NeuronEmbeddingExtension on Neuron {
  /// 🔄 Обновить эмбеддинг этого нейрона
  void updateEmbedding(EmbeddingService service, Map<int, Word> words, Map<int, Fragment> fragments) {
   // embedding = service.updateNeuronEmbedding(this, words, fragments);
  }
  
  /// ✅ Получить актуальный эмбеддинг (если есть)
  SemanticEmbedding? getEmbedding(EmbeddingService service) {
    //return embedding ?? service.getNeuronEmbedding(id);
  }
}

extension WordEmbeddingExtension on Word {
  /// 🔄 Обновить эмбеддинг этого слова
  void updateEmbedding(EmbeddingService service, Map<int, Word> allWords) {
    //embedding = service.updateWordEmbedding(this, allWords);
  }
  
  /// ✅ Получить актуальный эмбеддинг
  SemanticEmbedding? getEmbedding(EmbeddingService service) {
    //return embedding ?? service.getWordEmbedding(id);
  }
}

extension FragmentEmbeddingExtension on Fragment {
  /// 🔄 Обновить эмбеддинг этого фрагмента
  void updateEmbedding(EmbeddingService service, Map<int, Word> allWords) {
    //embedding = service.updateFragmentEmbedding(this, allWords);
  }
  
  /// ✅ Получить актуальный эмбеддинг
  SemanticEmbedding? getEmbedding(EmbeddingService service) {
    //return embedding ?? service.getFragmentEmbedding(id);
  }
}

// Добавляем в начало файла или в отдельный хелпер
extension GaussianRandom on Random {
  double nextGaussian() {
    // Box-Muller transform для генерации нормального распределения
    double u1 = 1.0 - nextDouble(); // (0,1] -> (0,1]
    double u2 = 1.0 - nextDouble();
    double radius = sqrt(-2.0 * log(u1));
    double theta = 2.0 * pi * u2;
    return radius * cos(theta);
  }
}

enum SemanticType {
  fact,           // Факт
  opinion,        // Мнение  
  instruction,    // Инструкция
  question,       // Вопрос
  hypothesis,     // Гипотеза
  definition,     // Определение
  comparison,     // Сравнение
  causal,         // Причинно-следственная связь
  temporal,       // Временное
  emotional,      // Эмоциональное
  unknown;        // Неопределенный тип

  /// Возвращает русское название типа
  String get displayName {
    return switch (this) {
      SemanticType.fact => 'факт',
      SemanticType.opinion => 'мнение', 
      SemanticType.instruction => 'инструкция',
      SemanticType.question => 'вопрос',
      SemanticType.hypothesis => 'гипотеза',
      SemanticType.definition => 'определение',
      SemanticType.comparison => 'сравнение',
      SemanticType.causal => 'причинно-следственная связь',
      SemanticType.temporal => 'временное утверждение',
      SemanticType.emotional => 'эмоциональное высказывание',
      SemanticType.unknown => 'неизвестный тип',
    };
  }

  /// Возвращает английское название (для JSON/API)
  String get name {
    return toString().split('.').last;
  }
}
class SemanticPatternDetector {
  /// Анализирует утверждение и определяет его семантический тип
  static SemanticType analyzeStatement(String text) {
    final cleanText = _preprocessText(text);
    
    // Проверяем паттерны в порядке приоритета
    if (_isQuestion(cleanText)) return SemanticType.question;
    if (_isFact(cleanText)) return SemanticType.fact;
    if (_isOpinion(cleanText)) return SemanticType.opinion;
    if (_isInstruction(cleanText)) return SemanticType.instruction;
    if (_isHypothesis(cleanText)) return SemanticType.hypothesis;
    if (_isDefinition(cleanText)) return SemanticType.definition;
    if (_isComparison(cleanText)) return SemanticType.comparison;
    if (_isCausal(cleanText)) return SemanticType.causal;
    if (_isTemporal(cleanText)) return SemanticType.temporal;
    if (_isEmotional(cleanText)) return SemanticType.emotional;
    
    return SemanticType.unknown;
  }
  
  /// Определяет ФАКТЫ
  static bool _isFact(String text) {
    final factPatterns = [
      // Паттерны утверждений фактов
      RegExp(r'^(является|это|составляет|равен|находится|содержит)'),
      RegExp(r'\d+(\s|\-)(лет|год|месяц|день|час|минут|секунд)'),
      RegExp(r'[0-9]+(%|градус|метр|километр|кг|г)'),
      RegExp(r'(по данным|согласно|исследования показывают|доказано)'),
      RegExp(r'(всегда|никогда|каждый|любой)'),
      // Утверждения в настоящем времени
      RegExp(r'\b(есть|существует|имеет|содержит)\b'),
    ];
    
    return factPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// Определяет МНЕНИЯ
  static bool _isOpinion(String text) {
    final opinionPatterns = [
      RegExp(r'\b(я думаю|по моему|на мой взгляд|считаю|полагаю)\b'),
      RegExp(r'\b(лучший|худший|красивый|уродливый|интересный|скучный)\b'),
      RegExp(r'\b(нравится|люблю|ненавижу|предпочитаю)\b'),
      RegExp(r'\b(возможно|вероятно|скорее всего|может быть)\b'),
      RegExp(r'\b(к сожалению|к счастью|жаль|рад)\b'),
    ];
    
    return opinionPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// Определяет ИНСТРУКЦИИ
  static bool _isInstruction(String text) {
    final instructionPatterns = [
      RegExp(r'^(нажми|введите|выберите|следуйте|используйте|установите)'),
      RegExp(r'\b(шаг|инструкция|руководство|как сделать)\b'),
      RegExp(r'\b(сначала|затем|потом|после этого|в конце)\b'),
      RegExp(r'[0-9]+\.\s'), // Нумерованные шаги
    ];
    
    return instructionPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// Определяет ВОПРОСЫ
  static bool _isQuestion(String text) {
    final questionPatterns = [
      RegExp(r'^\?|(\?)$'), // Заканчивается на ?
      RegExp(r'^(как|что|где|когда|почему|зачем|кто|чей|сколько)'),
      RegExp(r'\b(ли\??|не так ли\??|правильно\??|верно\??)\b'),
    ];
    
    return questionPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// Определяет ГИПОТЕЗЫ
  static bool _isHypothesis(String text) {
    final hypothesisPatterns = [
      RegExp(r'\b(если.*то|предположим|допустим|гипотетически)\b'),
      RegExp(r'\b(возможно|вероятно|может быть|скорее всего)\b'),
      RegExp(r'\b(предполагается|считается|полагают)\b'),
    ];
    
    return hypothesisPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// Определения
  static bool _isDefinition(String text) {
    return RegExp(r'^[А-Яа-я]+\s*—\s*|^[А-Яа-я]+\s*это\s*').hasMatch(text) ||
           text.contains('определение') ||
           text.contains('означает');
  }
  
  /// Сравнения
  static bool _isComparison(String text) {
    return text.contains('чем') || 
           text.contains('по сравнению') ||
           RegExp(r'\b(больше|меньше|лучше|хуже|сильнее|слабее)\b').hasMatch(text);
  }
  
  /// Причинно-следственные связи
  static bool _isCausal(String text) {
    return text.contains('потому что') ||
           text.contains('из-за') ||
           text.contains('в результате') ||
           text.contains('следовательно');
  }
  
  /// Временные утверждения
  static bool _isTemporal(String text) {
    return RegExp(r'\b(завтра|вчера|сегодня|потом|после|до|когда)\b').hasMatch(text);
  }
  
  /// Эмоциональные утверждения
  static bool _isEmotional(String text) {
    final emotionalWords = ['рад', 'грустно', 'злой', 'счастлив', 'отвратительно', 'прекрасно'];
    return emotionalWords.any((word) => text.contains(word));
  }
  
  static String _preprocessText(String text) {
    return text.toLowerCase().trim();
  }
}

class FactConfidenceAnalyzer {
  /// Оценивает уверенность в том, что утверждение - факт (0.0 - 1.0)
  static double analyzeFactConfidence(String text) {
    double confidence = 0.0;
    
    // Признаки высокофактических утверждений
    if (_containsNumbers(text)) confidence += 0.3;
    if (_containsScientificTerms(text)) confidence += 0.2;
    if (_hasFactualLanguage(text)) confidence += 0.3;
    if (_isVerifiable(text)) confidence += 0.2;
    
    // Штрафы за субъективные маркеры
    if (_containsOpinionMarkers(text)) confidence -= 0.3;
    if (_containsEmotionalLanguage(text)) confidence -= 0.2;
    
    return confidence.clamp(0.0, 1.0);
  }
  
  static bool _containsNumbers(String text) {
    return RegExp(r'\d+').hasMatch(text);
  }
  
  static bool _containsScientificTerms(String text) {
    final scientificWords = ['исследование', 'эксперимент', 'доказано', 'теория', 'закон'];
    return scientificWords.any((word) => text.toLowerCase().contains(word));
  }
  
  static bool _hasFactualLanguage(String text) {
    final factualMarkers = [
      'является', 'составляет', 'равен', 'соответствует', 
      'по данным', 'согласно', 'на основании'
    ];
    return factualMarkers.any((marker) => text.toLowerCase().contains(marker));
  }
  
  static bool _isVerifiable(String text) {
    // Утверждения, которые можно проверить
    return _containsNumbers(text) || 
           text.toLowerCase().contains('можно проверить') ||
           _containsSpecificReferences(text);
  }
  
  static bool _containsSpecificReferences(String text) {
    return RegExp(r'[А-Яа-я]+\s[0-9]+').hasMatch(text) || // "Глава 5"
           text.contains('исследование') ||
           text.contains('эксперимент');
  }
  
  static bool _containsOpinionMarkers(String text) {
    final opinionMarkers = ['я думаю', 'по моему', 'наверное', 'возможно'];
    return opinionMarkers.any((marker) => text.toLowerCase().contains(marker));
  }
  
  static bool _containsEmotionalLanguage(String text) {
    final emotionalWords = ['к сожалению', 'к счастью', 'ужасно', 'прекрасно'];
    return emotionalWords.any((word) => text.toLowerCase().contains(word));
  }
}

class SemanticAnalyzer1 {
  /// Полный анализ семантики утверждения
  static SemanticAnalysisResult analyze(String text) {
    final semanticType = SemanticPatternDetector.analyzeStatement(text);
    final factConfidence = FactConfidenceAnalyzer.analyzeFactConfidence(text);
    final entities = _extractEntities(text);
    final relations = _extractRelations(text);
    
    return SemanticAnalysisResult(
      text: text,
      semanticType: semanticType,
      factConfidence: factConfidence,
      entities: entities,
      relations: relations,
      isFactual: factConfidence > 0.7,
      isSubjective: semanticType == SemanticType.opinion || 
                   semanticType == SemanticType.emotional,
    );
  }
   static List<SemanticRelation> _extractRelations(String text) {
    return RelationExtractor.extractRelations(text);
  }
  /// Извлекает сущности из текста
  static List<SemanticEntity> _extractEntities(String text) {
    final entities = <SemanticEntity>[];
    
    // Простая реализация - можно улучшить с помощью вашей системы Word
    final words = text.split(RegExp(r'\s+'));
    
    for (final word in words) {
      if (_isPotentialEntity(word)) {
        entities.add(SemanticEntity(
          text: word,
          type: _classifyEntityType(word),
          position: text.indexOf(word),
        ));
      }
    }
    
    return entities;
  }
  
  static bool _isPotentialEntity(String word) {
    // Слова с заглавной буквы или длинные слова
    return word.length > 3 || 
           (word.isNotEmpty && word[0] == word[0].toUpperCase());
  }
  

  static final _temporalWords = {
    // Временные периоды
    'сегодня', 'завтра', 'вчера', 'сейчас', 'сразу', 'потом', 'позже',
    'скоро', 'недавно', 'давно', 'вскоре', 'сначала', 'после',
    
    // Дни недели
    'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота', 'воскресенье',
    
    // Месяцы
    'январь', 'февраль', 'март', 'апрель', 'май', 'июнь',
    'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь',
    
    // Времена года
    'весна', 'лето', 'осень', 'зима',
    
    // Части суток
    'утро', 'день', 'вечер', 'ночь', 'полдень', 'полночь',
    
    // Относительное время
    'прошлое', 'будущее', 'настоящее', 'следующий', 'предыдущий',
    'начало', 'конец', 'период', 'время', 'момент',
    
    // Частотные слова
    'всегда', 'никогда', 'иногда', 'часто', 'редко', 'обычно',
    'постоянно', 'регулярно', 'ежедневно', 'еженедельно',
    
    // Возрастные периоды
    'детство', 'юность', 'молодость', 'зрелость', 'старость',
  };

  static bool isTemporalWord(String word) {
    final cleanWord = word.toLowerCase().trim();
    return _temporalWords.contains(cleanWord) ||
           _matchesTemporalPattern(cleanWord);
  }

  static bool _matchesTemporalPattern(String word) {
    final temporalPatterns = [
      RegExp(r'^\d+:\d+$'), // 12:30
      RegExp(r'^\d+[чч]\.$'), // 12ч.
      RegExp(r'^\d+\s*(год|месяц|день|час|минут|секунд)$'), // 5 лет
      RegExp(r'^[0-9]+[-\–][0-9]+$'), // 2020-2023
      RegExp(r'^(в|на|до|после|через|во|с|по)$'), // временные предлоги
    ];

    return temporalPatterns.any((pattern) => pattern.hasMatch(word));
  }

  static final _locationWords = {
    // Общие локационные термины
    'город', 'деревня', 'село', 'поселок', 'столица', 'центр',
    'улица', 'площадь', 'проспект', 'бульвар', 'переулок',
    'дом', 'здание', 'сооружение', 'помещение', 'комната',
    
    // Географические объекты
    'страна', 'государство', 'республика', 'область', 'край',
    'район', 'округ', 'регион', 'территория', 'зона',
    'гора', 'река', 'озеро', 'море', 'океан', 'остров',
    'лес', 'поле', 'пустыня', 'долина', 'равнина',
    
    // Направления и положения
    'север', 'юг', 'запад', 'восток', 'северо-запад', 'юго-восток',
    'верх', 'низ', 'лево', 'право', 'центр', 'периферия',
    'внутри', 'снаружи', 'рядом', 'далеко', 'близко',
    
    // Типы мест
    'магазин', 'школа', 'больница', 'аптека', 'банк', 'офис',
    'ресторан', 'кафе', 'парк', 'сад', 'стадион', 'музей',
    'вокзал', 'аэропорт', 'порт', 'станция',
    
    // Предлоги места
    'в', 'на', 'у', 'около', 'возле', 'под', 'над', 'перед',
    'за', 'между', 'среди', 'через',
  };

  static final _locationPrefixes = {
    'ул.', 'пр.', 'пер.', 'б-р', 'г.', 'д.', 'к.', 'пос.', 'с.',
  };

  static final _countryNames = {
    'россия', 'рф', 'сша', 'китай', 'германия', 'франция', 'англия',
    'япония', 'индия', 'бразилия', 'канада', 'австралия',
  };

  static final _cityNames = {
    'москва', 'санкт-петербург', 'спб', 'нью-йорк', 'лондон',
    'париж', 'берлин', 'токио', 'пекин', 'сидней',
  };

  static bool isLocationWord(String word) {
    final cleanWord = word.toLowerCase().trim();
    
    return _locationWords.contains(cleanWord) ||
           _locationPrefixes.any((prefix) => cleanWord.startsWith(prefix)) ||
           _countryNames.contains(cleanWord) ||
           _cityNames.contains(cleanWord) ||
           _matchesLocationPattern(cleanWord) ||
           _isCapitalizedLocation(cleanWord, word);
  }

  static bool _matchesLocationPattern(String word) {
    final locationPatterns = [
      RegExp(r'^[А-Я][а-я]+\s*(область|край|район|республика)$'), // Московская область
      RegExp(r'^[А-Я][а-я]+-[А-Я][а-я]+$'), // Ростов-на-Дону
      RegExp(r'^[ул|пр|пер|б-р]\.\s+'), // ул. Ленина
      RegExp(r'^\d+[-–]\d+$'), // 5-й район
    ];

    return locationPatterns.any((pattern) => pattern.hasMatch(word));
  }

  static bool _isCapitalizedLocation(String cleanWord, String originalWord) {
    // Слова с заглавной буквы часто являются именами собственными (географическими)
    return originalWord.isNotEmpty && 
           originalWord[0] == originalWord[0].toUpperCase() &&
           cleanWord.length > 2 && // Исключаем короткие слова
           !_isCommonCapitalizedWord(cleanWord);
  }

  static bool _isCommonCapitalizedWord(String word) {
    final commonWords = {
      'я', 'ты', 'он', 'она', 'оно', 'мы', 'вы', 'они', // местоимения
      'это', 'то', 'вот', 'тут', 'там', 'здесь', // указательные
    };
    return commonWords.contains(word);
  }
  static EntityType _classifyEntityType(String word) {
    if (RegExp(r'[0-9]').hasMatch(word)) return EntityType.numeric;
    if (isTemporalWord(word)) return EntityType.temporal;
    if (isLocationWord(word)) return EntityType.location;
    return EntityType.concept;
  }
  

}

class SemanticAnalysisResult {
  final String text;
  final SemanticType semanticType;
  final double factConfidence;
  final List<SemanticEntity> entities;
  final List<SemanticRelation> relations;
  final bool isFactual;
  final bool isSubjective;
  
  SemanticAnalysisResult({
    required this.text,
    required this.semanticType,
    required this.factConfidence,
    required this.entities,
    required this.relations,
    required this.isFactual,
    required this.isSubjective,
  });
}

class SemanticEntity {
  final String text;
  final EntityType type;
  final int position;
  
  SemanticEntity({
    required this.text,
    required this.type,
    required this.position,
  });
}

enum EntityType { person, location, concept, numeric, temporal, object }

enum RelationType {
  isA,           // Таксономия: "кошка является животным"
  hasProperty,   // Свойство: "машина имеет колеса"
  partOf,        // Часть-целое: "рука является частью тела"
  causes,        // Причина: "дождь вызывает лужи"
  temporal,      // Временное: "завтрак перед работой"
  locatedIn,     // Локация: "Москва находится в России"
  comparesTo,    // Сравнение: "яблоко больше вишни"
  functional,    // Функциональное: "молоток используется для забивания"
  similarTo,     // Схожесть: "тигр похож на льва"
  oppositeTo,    // Противоположность: "день противоположен ночи"
}

class SemanticRelation {
  final RelationType type;
  final double confidence;
  final String? source;      // Источник отношения
  final String? target;      // Цель отношения
  final String? evidence;    // Текст, подтверждающий отношение
  final List<String>? tags;  // Дополнительные теги
  
  SemanticRelation({
    required this.type,
    required this.confidence,
    this.source,
    this.target,
    this.evidence,
    this.tags,
  });
  
  String get displayName => type.displayName;
  
  Map<String, dynamic> toJson() => {
    'type': type.name,
    'confidence': confidence,
    'source': source,
    'target': target,
    'evidence': evidence,
    'tags': tags,
  };
}

// Расширение для RelationType
extension RelationTypeExtensions on RelationType {
  String get displayName {
    return switch (this) {
      RelationType.isA => 'является',
      RelationType.hasProperty => 'имеет свойство',
      RelationType.partOf => 'является частью',
      RelationType.causes => 'вызывает',
      RelationType.temporal => 'временное отношение',
      RelationType.locatedIn => 'находится в',
      RelationType.comparesTo => 'сравнивается с',
      RelationType.functional => 'функциональное отношение',
      RelationType.similarTo => 'похож на',
      RelationType.oppositeTo => 'противоположен',
    };
  }
}

extension FragmentSemanticAnalysis on Fragment {
  SemanticAnalysisResult analyzeSemantics() {
    return SemanticAnalyzer1.analyze(text);
  }
  
  /// Быстрая проверка - является ли фрагмент фактом
  bool get isFactual {
    final analysis = analyzeSemantics();
    return analysis.isFactual;
  }
}
/*
extension NeuronSemanticAnalysis on Neuron {
  /// Анализирует семантику нейрона на основе его фрагментов
  List<SemanticAnalysisResult> analyzeFragmentsSemantics() {
    return fragmentLinks.map((fragmentId) {
      //final fragment = network.fragments[fragmentId];
      return fragment!.analyzeSemantics();
    }).toList();
  }
  
  /// Процент фактуальных фрагментов в нейроне
  double get factualPercentage {
    final analyses = analyzeFragmentsSemantics();
    if (analyses.isEmpty) return 0.0;
    
    final factualCount = analyses.where((a) => a.isFactual).length;
    return factualCount / analyses.length;
  }
}
*/
extension SemanticTypeExtensions on SemanticType {
  /// Для использования в UI
  String get capitalized {
    final name = displayName;
    return name[0].toUpperCase() + name.substring(1);
  }

  /// Для сохранения в базу данных
  String get databaseValue {
    return name;
  }

  /// Восстановление из строки
  static SemanticType? fromString(String value) {
    try {
      return SemanticType.values.firstWhere(
        (type) => type.name == value.toLowerCase() || 
                 type.displayName == value.toLowerCase(),
      );
    } catch (e) {
      return SemanticType.unknown;
    }
  }
}

class RelationExtractor {
  static List<SemanticRelation> extractRelations(String text) {
    final relations = <SemanticRelation>[];
    final cleanText = text.toLowerCase().trim();
    
    relations.addAll(_extractIsARelations(cleanText));
    relations.addAll(_extractHasRelations(cleanText));
    relations.addAll(_extractPartOfRelations(cleanText));
    relations.addAll(_extractCausalRelations(cleanText));
    relations.addAll(_extractTemporalRelations(cleanText));
    relations.addAll(_extractSpatialRelations(cleanText));
    relations.addAll(_extractComparativeRelations(cleanText));
    relations.addAll(_extractFunctionalRelations(cleanText));
    
    return relations;
  }
  
  /// Отношения "является" (таксономия)
  static List<SemanticRelation> _extractIsARelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A является B
      RegExp(r'(\w+)\s+является\s+(\w+)'),
      // A - это B
      RegExp(r'(\w+)\s*—\s*это\s*(\w+)'),
      RegExp(r'(\w+)\s*-\s*это\s*(\w+)'),
      // A есть B
      RegExp(r'(\w+)\s+есть\s+(\w+)'),
      // A представляет собой B
      RegExp(r'(\w+)\s+представляет\s+собой\s+(\w+)'),
      // A считается B
      RegExp(r'(\w+)\s+считается\s+(\w+)'),
      // A называется B
      RegExp(r'(\w+)\s+называется\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.isA,
            confidence: 0.85,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// Отношения владения/свойства
  static List<SemanticRelation> _extractHasRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A имеет B
      RegExp(r'(\w+)\s+имеет\s+(\w+)'),
      // A обладает B
      RegExp(r'(\w+)\s+обладает\s+(\w+)'),
      // A содержит B
      RegExp(r'(\w+)\s+содержит\s+(\w+)'),
      // у A есть B
      RegExp(r'у\s+(\w+)\s+есть\s+(\w+)'),
      // A состоит из B
      RegExp(r'(\w+)\s+состоит\s+из\s+(\w+)'),
      // A включает B
      RegExp(r'(\w+)\s+включает\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.hasProperty,
            confidence: 0.8,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// Отношения "часть-целое"
  static List<SemanticRelation> _extractPartOfRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A является частью B
      RegExp(r'(\w+)\s+является\s+частью\s+(\w+)'),
      // A входит в B
      RegExp(r'(\w+)\s+входит\s+в\s+(\w+)'),
      // A находится в B
      RegExp(r'(\w+)\s+находится\s+в\s+(\w+)'),
      // A внутри B
      RegExp(r'(\w+)\s+внутри\s+(\w+)'),
      // A относится к B
      RegExp(r'(\w+)\s+относится\s+к\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.partOf,
            confidence: 0.75,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// Причинно-следственные отношения
  static List<SemanticRelation> _extractCausalRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A приводит к B
      RegExp(r'(\w+)\s+приводит\s+к\s+(\w+)'),
      // A вызывает B
      RegExp(r'(\w+)\s+вызывает\s+(\w+)'),
      // из-за A происходит B
      RegExp(r'из-за\s+(\w+)\s+происходит\s+(\w+)'),
      // A является причиной B
      RegExp(r'(\w+)\s+является\s+причиной\s+(\w+)'),
      // B зависит от A
      RegExp(r'(\w+)\s+зависит\s+от\s+(\w+)'),
      // если A, то B
      RegExp(r'если\s+(\w+),\s+то\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.causes,
            confidence: 0.7,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// Временные отношения
  static List<SemanticRelation> _extractTemporalRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A происходит до B
      RegExp(r'(\w+)\s+происходит\s+до\s+(\w+)'),
      // A следует за B
      RegExp(r'(\w+)\s+следует\s+за\s+(\w+)'),
      // A во время B
      RegExp(r'(\w+)\s+во\s+время\s+(\w+)'),
      // A после B
      RegExp(r'(\w+)\s+после\s+(\w+)'),
      // A перед B
      RegExp(r'(\w+)\s+перед\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.temporal,
            confidence: 0.65,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// Пространственные отношения
  static List<SemanticRelation> _extractSpatialRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A находится в B
      RegExp(r'(\w+)\s+находится\s+в\s+(\w+)'),
      // A расположен в B
      RegExp(r'(\w+)\s+расположен\s+в\s+(\w+)'),
      // A над B
      RegExp(r'(\w+)\s+над\s+(\w+)'),
      // A под B
      RegExp(r'(\w+)\s+под\s+(\w+)'),
      // A рядом с B
      RegExp(r'(\w+)\s+рядом\s+с\s+(\w+)'),
      // A между B и C
      RegExp(r'(\w+)\s+между\s+(\w+)\s+и\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.locatedIn,
            confidence: 0.7,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// Сравнительные отношения
  static List<SemanticRelation> _extractComparativeRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A больше, чем B
      RegExp(r'(\w+)\s+больше,\s*чем\s+(\w+)'),
      // A лучше, чем B
      RegExp(r'(\w+)\s+лучше,\s*чем\s+(\w+)'),
      // A отличается от B
      RegExp(r'(\w+)\s+отличается\s+от\s+(\w+)'),
      // A похож на B
      RegExp(r'(\w+)\s+похож\s+на\s+(\w+)'),
      // A такой же как B
      RegExp(r'(\w+)\s+такой\s+же\s+как\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.comparesTo,
            confidence: 0.6,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// Функциональные отношения
  static List<SemanticRelation> _extractFunctionalRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A используется для B
      RegExp(r'(\w+)\s+используется\s+для\s+(\w+)'),
      // A предназначен для B
      RegExp(r'(\w+)\s+предназначен\s+для\s+(\w+)'),
      // A служит для B
      RegExp(r'(\w+)\s+служит\s+для\s+(\w+)'),
      // A помогает B
      RegExp(r'(\w+)\s+помогает\s+(\w+)'),
      // A влияет на B
      RegExp(r'(\w+)\s+влияет\s+на\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.functional,
            confidence: 0.65,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
}

// ========== СТОП-СЛОВА ==========
final Set<String> STOP_WORDS = {
  'и', 'в', 'во', 'не', 'что', 'он', 'на', 'я', 'с', 'со', 'как', 'а', 'то',
  'все', 'она', 'так', 'его', 'но', 'да', 'ты', 'к', 'у', 'же', 'вы', 'за',
  'бы', 'по', 'только', 'ее', 'её', 'мне', 'было', 'вот', 'от', 'меня',
  'еще', 'ещё', 'нет', 'о', 'из', 'ему', 'теперь', 'когда', 'даже', 'ну',
  'вдруг', 'ли', 'если', 'уже', 'или', 'ни', 'быть', 'был', 'него', 'до',
  'вас', 'нибудь', 'опять', 'уж', 'вам', 'ведь', 'там', 'потом', 'себя',
  'ничего', 'ей', 'может', 'они', 'тут', 'где', 'есть', 'надо', 'ней', 'для',
  'мы', 'тебя', 'их', 'чем', 'была', 'сам', 'чтоб', 'чтобы', 'без', 'будто',
  'чего', 'раз', 'тоже', 'себе', 'под', 'будет', 'ж', 'тогда', 'кто', 'этот',
  'того', 'потому', 'этого', 'какой', 'тот', 'какая', 'какое', 'какие', 'который',
  'та', 'тех', 'тем', 'теми', 'тому', 'тех', 'тех', 'тех', 'чей', 'чья', 'чье', 'чьи',
  'всё', 'всего', 'всей', 'всю', 'всею', 'всем', 'всех', 'всеми',
  'перед', 'при', 'об', 'про', 'над', 'через', 'после', 'между', 'из-за', 'изпод',
  'ибо', 'лишь', 'разве', 'пусть', 'давай', 'впрочем', 'зато', 'иначе',
  'ведь', 'уж', 'вон', 'всюду', 'где-то', 'куда', 'откуда', 'туда', 'сюда',
  'тогда-то', 'всё-таки', 'то-то', 'кое-кто', 'кое-что', 'кое-где', 'нигде',
  'никуда', 'никогда', 'ничто', 'никто', 'ничей', 'некто', 'нечто', 'некуда',
  'нельзя', 'всюду', 'здесь', 'сюда', 'отсюда', 'туда', 'оттуда', 'там', 'тут',
  'этим', 'этом', 'эти', 'эта', 'это', 'этих', 'этими', 'этому', 'этой', 'эту',
  'мой', 'моя', 'моё', 'мои', 'твой', 'твоя', 'твоё', 'твои', 'наш', 'наша', 'наше',
  'наши', 'ваш', 'ваша', 'ваше', 'ваши', 'ихний', 'ихняя', 'ихнее', 'ихние',
  'свой', 'своя', 'своё', 'свои', 'тот-то', 'этот-то', 'тот же', 'та же',
  'то же', 'те же', 'такой', 'такая', 'такое', 'такие', 'таков', 'такова',
  'таковы', 'таковое', 'таков-то', 'сей', 'сия', 'сие', 'сии', 'он же',
  'она же', 'оно же', 'они же', 'всякий', 'всякая', 'всякое', 'всякие',
  'каждый', 'каждая', 'каждое', 'каждые', 'самый', 'самая', 'самое', 'самые',
  'иной', 'иная', 'иное', 'иные', 'другой', 'другая', 'другое', 'другие',
  'какой-то', 'какая-то', 'какое-то', 'какие-то', 'чей-то', 'чья-то', 'чьё-то', 'чьи-то',
  'некоторый', 'некоторая', 'некоторое', 'некоторые', 'этак', 'так-то', 'вот-вот',
  'так-то', 'да-с', 'ага', ' ладно', 'ок', 'окей', 'ну-ка', 'ну же', 'ай', 'эй', 'ой',
  'алло', 'просто', 'почти', 'вроде', 'именно', 'всего', 'примерно', 'особенно',
  'давай-ка', 'всё ж', 'всё же', 'же', 'уж', 'либо', 'будь', 'будем', 'будешь',
  'будут', 'буду', 'есть', 'нету', 'неа', 'ага', 'эх', 'ах', 'ой', 'увы', 'увы', 'ага',
  'ну-ну', 'вон', 'отнюдь', 'едва', 'чуть', 'почти', 'сразу', 'опять-таки', 'ещё бы',
  'разве что', 'если бы', 'либо', 'ни-ни', 'неужели', 'чуть ли', 'чуть-чуть', 'едва ли',
  'хотя', 'пусть', 'пускай', 'раз', 'покуда', 'покамест', 'едва', 'пока', 'так как',
  'из-за того что', 'несмотря на', 'вследствие', 'чтобы не', 'дабы', 'ибо', 'затем',
  'вслед за', 'наряду с', 'при том', 'при этом', 'так же', 'в то время как', 'между тем',
  'тем не менее', 'однако', 'тоже', 'также', 'притом', 'зато', 'всё равно', 'всё-таки',
  'поэтому', 'следовательно', 'итак', 'таким образом', 'значит', 'ну а', 'а то', 'или же',
  'хотя бы', 'по крайней мере', 'по сути', 'в общем', 'в целом', 'по-моему', 'по-твоему',
  'по-нашему', 'по-вашему', 'возможно', 'наверное', 'кажется', 'якобы', 'словно', 'будто бы',
  'вроде бы', 'типа', 'мол', 'дескать', 'якобы', 'так сказать', 'в частности', 'то есть',
  'например', 'скажем', 'впрочем', 'однажды', 'некогда', 'всегда', 'часто', 'редко',
  'иногда', 'никогда', 'везде', 'где-либо', 'когда-либо', 'зачем', 'отчего', 'почему',
  'зачем-то', 'куда-либо', 'откуда-либо', 'когда-то', 'тогда-то', 'сейчас', 'теперь',
  'раньше', 'позже', 'вчера', 'сегодня', 'завтра', 'послезавтра', 'никогда', 'всегда',
  'едва ли', 'весь', 'вся', 'всё', 'все', 'всего', 'всей', 'всем', 'всеми', 'всех',
  'бывает', 'были', 'был', 'будет', 'будут', 'есть', 'нет', 'не было', 'не будет',
  'может', 'мог', 'смог', 'сможет', 'надо', 'нужно', 'следует', 'должен', 'следовало',
  'нельзя', 'можно', 'можно ли', 'нельзя ли', 'всё это', 'всё то', 'и так далее',
  'и тому подобное'
};

// ========== УТИЛИТЫ ==========
T min<T extends Comparable>(T a, T b) => a.compareTo(b) < 0 ? a : b;
T max<T extends Comparable>(T a, T b) => a.compareTo(b) > 0 ? a : b;

// ========== НОРМАЛИЗАЦИЯ ТЕКСТА ==========
class TextNormalizer {
  static String normalizeText(String text) {
    text = text.replaceAll(RegExp(r'\s+'), ' ').trim();
    if (!text.endsWith('.') && !text.endsWith('!') && !text.endsWith('?')) {
      text += '.';
    }
    if (text.isNotEmpty) {
      text = text[0].toUpperCase() + text.substring(1);
    }
    return text;
  }
}

// ========== СЕМАНТИЧЕСКИЙ АНАЛИЗ ==========
class SemanticAnalyzer {
  static String analyzeSemantics(String text) {
    text = text.toLowerCase();
    if (text.contains('?')) return 'вопрос';
    if (text.contains(RegExp(r'\b(да|нет|конечно|разумеется)\b'))) return 'утверждение';
    if (text.contains(RegExp(r'\b(сказал|ответил|спросил|продолжил)\b'))) return 'диалог';
    if (text.contains(RegExp(r'\b(потому|поэтому|следовательно|таким образом)\b'))) return 'объяснение';
    if (text.length < 50) return 'краткое высказывание';
    return 'повествование';
  }
}

// ========== СТЕММИНГ СЛОВ ==========
class WordStemmer {
  static final Map<String, String> _stemmingRules = {
    r'ся$': '', r'сь$': '', r'ое$': 'ый', r'ая$': 'ый', r'ие$': 'ий',
    r'ые$': 'ый', r'ому$': 'ый', r'ему$': 'ий', r'ими$': 'ий', r'ыми$': 'ый',
  };
  
  static String getStem(String word) {
    if (word.length < 3) return word;
    String stem = word.toLowerCase();
    for (final rule in _stemmingRules.entries) {
      final regex = RegExp(rule.key);
      if (regex.hasMatch(stem)) {
        stem = stem.replaceAll(regex, rule.value);
        break;
      }
    }
    return stem;
  }
}

// ========== ОПЕРАЦИИ С ВЕКТОРАМИ ==========
class VectorOperations {
  /// Находит пересечение двух векторов (только общие элементы)
  static Map<int, int> findCommonVector(Map<int, int> vec1, Map<int, int> vec2) {
    final common = <int, int>{};
    for (final entry in vec1.entries) {
      if (vec2.containsKey(entry.key)) {
        common[entry.key] = min(entry.value, vec2[entry.key]!);
      }
    }
    return common;
  }

  
  /// Самопроекция вектора: раскладывает все слова на собственные вектора и находит общее
  static Map<int, int> selfProjection(Map<int, int> vector, Map<int, Word> allWords) {
  if (vector.isEmpty) return {};
  
  final expandedVectors = <Map<int, int>>[];
  for (final wordId in vector.keys) {
    final word = allWords[wordId];
    if (word != null && word.ratings.isNotEmpty) {
      expandedVectors.add(word.ratings);
    }
  }
  
  if (expandedVectors.isEmpty) return vector;
  
  // Считаем частоту встречаемости и сумму значений для каждого индекса
  final indexFrequency = <int, int>{};
  final indexSum = <int, int>{};
  
  for (final vec in expandedVectors) {
    for (final entry in vec.entries) {
      final index = entry.key;
      final value = entry.value;
      
      indexFrequency[index] = (indexFrequency[index] ?? 0) + 1;
      indexSum[index] = (indexSum[index] ?? 0) + value;
    }
  }
  
  // Оставляем только индексы, встречающиеся как минимум 13 раз
  final commonVec = <int, int>{};
  for (final index in indexFrequency.keys) {
    if (indexFrequency[index]! >= 13) {
      commonVec[index] = indexSum[index]!;
    }
  }
  
  return commonVec;
}
  
  /// Поиск уникальных черт: слова с низким allRating но высоким ratings[contextWordId]
  static List<int> findUniqueFeatures(
    Map<int, int> vector,
    Map<int, Word> allWords,
    int limit,
  ) {
    final scores = <int, double>{};
    
    for (final entry in vector.entries) {
      final word = allWords[entry.key];
      if (word == null) continue;
      
      final avgConnectionStrength = entry.value / (word.allRating + 1);
      final uniquenessScore = avgConnectionStrength * 1000000 / (word.allRating + 1);
      scores[entry.key] = uniquenessScore;
    }
    
    final sortedEntries = scores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedEntries.take(limit).map((e) => e.key).toList();
  }

  /// Вычисляет разность векторов (качественное различие)
  static double vectorQualityDifference(Map<int, int> vec1, Map<int, int> vec2) {
    double difference = 0.0;
    final allKeys = {...vec1.keys, ...vec2.keys};
    
    for (final key in allKeys) {
      final val1 = vec1[key] ?? 0;
      final val2 = vec2[key] ?? 0;
      difference += (val1 - val2).abs().toDouble();
    }
    
    return difference;
  }
  
  /// Оптимизация нейронных связей и пересчет весов
  static void optimizeNeuralConnectionsRebuildWeights(Map<int, Word> words) async {
    for (final word in words.values) {
      final projectedVector = selfProjection(word.ratings, words);
      
      for (final entry in projectedVector.entries) {
        final otherWord = words[entry.key];
        if (otherWord == null) continue;
        
        final rating1 = word.ratings[entry.key];
        final rating2 = otherWord.ratings[word.id];
        
        if (rating1 == null || rating2 == null) continue;
        
        final normalizedRating1 = word.allRating > 0 ? rating1 / word.allRating : 0;
        final normalizedRating2 = otherWord.allRating > 0 ? rating2 / otherWord.allRating : 0;
        
        final multiplier = 1.0 + ((normalizedRating1 + normalizedRating2) / 2).clamp(0.999, 1.001);
        
        word.ratings[entry.key] = (entry.value * multiplier).round();
        otherWord.ratings[word.id] = (rating2 * multiplier).round();
      }
      
      word.allRating = word.ratings.values.fold(0, (a, b) => a + b);
    }
  }
}

// ========== КЛАССЫ ДАННЫХ ==========
class Word {
  final int id;
  Map<int, int> ratings;
  int allRating;
  double x, y, z;
  Set<int> sameWords;
  
  Word({
    required this.id,
    required this.ratings,
    required this.allRating,
    required this.x,
    required this.y,
    required this.z,
    Set<int>? sameWords,
  }) : sameWords = sameWords ?? <int>{};
  
  double get fontSize {
    if (allRating < 1000) return 12.0;
    if (allRating > 200000) return 18.0;
    return 12.0 + (allRating / 30000);
  }
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'ratings': ratings.map((k, v) => MapEntry(k.toString(), v)),
    'all_rating': allRating,
    'x': x, 'y': y, 'z': z,
    'same_words': sameWords.toList(),
  };
  
  factory Word.fromJson(Map<String, dynamic> json) => Word(
    id: json['id'],
    ratings: (json['ratings'] as Map).map((k, v) => MapEntry(int.parse(k), v as int)),
    allRating: json['all_rating'] ?? 0,
    x: (json['x'] ?? 0.0).toDouble(),
    y: (json['y'] ?? 0.0).toDouble(),
    z: (json['z'] ?? 0.0).toDouble(),
    sameWords: Set<int>.from(json['same_words'] ?? []),
  );
}

class Fragment {
  final int id;
  final String text;
  List<int> wordIds;
  int? packageId;
  String semanticType;
  
  Fragment({
    required this.id,
    required this.text,
    required this.wordIds,
    this.packageId,
    String? semanticType,
  }) : semanticType = semanticType ?? SemanticAnalyzer.analyzeSemantics(text);
  
  List<int> get keywords {
    final wordCounts = <int, int>{};
    for (final wordId in wordIds) {
      wordCounts[wordId] = (wordCounts[wordId] ?? 0) + 1;
    }
    
    final sortedEntries = wordCounts.entries.toList();
    sortedEntries.sort((a, b) => b.value.compareTo(a.value));
    
    return sortedEntries
        .take(5)
        .map((e) => e.key)
        .toList();
  }
  
  Map<String, dynamic> toJson() => {
    'id': id, 'text': text, 'word_ids': wordIds,
    'package_id': packageId, 'semantic_type': semanticType,
  };
  
  factory Fragment.fromJson(Map<String, dynamic> json) => Fragment(
    id: json['id'],
    text: json['text'],
    wordIds: List<int>.from(json['word_ids']),
    packageId: json['package_id'],
    semanticType: json['semantic_type'] ?? 'повествование',
  );
}

enum PackageStatus { through, permanent, done }

class Package {
  final int id;
  List<int> signature;
 
  List<int> keywords;
  PackageStatus status;
  List<int> fragmentLinks;
  List<int> neuronLinks;
    Map<int, int> signatureRatings;
  Package({

    required this.id,
    required this.signature,
    List<int>? keywords,
    required this.status,
    List<int>? fragmentLinks,
    List<int>? neuronLinks,
      Map<int, int>? signatureRatings,
  }) : 
      signatureRatings = signatureRatings ?? {},
    keywords = keywords ?? List.from(signature),
    fragmentLinks = fragmentLinks ?? [],
    neuronLinks = neuronLinks ?? [];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'signature': signature, 'keywords': keywords,
    'status': status.index, 'fragment_links': fragmentLinks, 'neuron_links': neuronLinks,
  };
  
  factory Package.fromJson(Map<String, dynamic> json) => Package(
    id: json['id'],
    signature: List<int>.from(json['signature']),
    keywords: List<int>.from(json['keywords']),
    status: PackageStatus.values[json['status']],
    fragmentLinks: List<int>.from(json['fragment_links']),
    neuronLinks: List<int>.from(json['neuron_links']),
  );
}
class Neuron {
  final int id;
  final int personalSynapseId;
  final String? sourceUrl;
  final String? pageTitle;
  String? fullPageContent;
  List<int> fragmentLinks;
  List<int> signature;
  List<int> keywords;
  List<int> packageLinks;
  Map<int, int> neuronRatings;
  int signature_allRating;
  Map<int, int> signatureRatings;
  double x;
  double y;
  double z;
  double screenX = 0;
  int allRating; // Убрали значение по умолчанию здесь
  double screenY = 0;
  
  Neuron({
    required this.id,
    required this.personalSynapseId,
    this.sourceUrl,
    this.pageTitle,
    this.fullPageContent,
    List<int>? fragmentLinks,
    List<int>? signature,
    List<int>? keywords,
    List<int>? packageLinks,
    Map<int, int>? neuronRatings,
    Map<int, int>? signatureRatings,
    int? signature_allRating,
    double? x,
    double? y,
    int? allRating, // Сделали nullable и убрали значение по умолчанию
    double? z,
  }) : 
    fragmentLinks = fragmentLinks ?? [],
    signature = signature ?? [],
    keywords = keywords ?? [],
    packageLinks = packageLinks ?? [],
    signature_allRating = signature_allRating ?? 0,
    neuronRatings = neuronRatings ?? {},
    allRating = allRating ?? 0, // Инициализируем здесь
    signatureRatings = signatureRatings ?? {},
    x = x ?? 0.0,
    y = y ?? 0.0,
    z = z ?? 0.0;

  
  void updateSignature(List<int> wordIds,OptimizedNeuralNetwork network) {
    final wordCounts = <int, int>{};
    for (final id in wordIds) {
      wordCounts[id] = (wordCounts[id] ?? 0) + 1;
    }
    
    // Обновляем signature ratings
    for (final entry in wordCounts.entries) {
      signatureRatings[entry.key] = (signatureRatings[entry.key] ?? 0) + entry.value;
      signature_allRating +=entry.value;
    }
    
    // Сортируем signature
    final sortedSignature = signatureRatings.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    signature = sortedSignature.take(50).map((e) => e.key).toList();
    
    // Формируем keywords
    final top20 = sortedSignature.take(20).map((e) => e.key).toList();
    
    // Для bottom 10 берем только из оставшихся 30 слов (позиции 20-49)
    final remainingWords = sortedSignature.skip(20).take(30).map((e) => e.key).toList();
    final sortedByLowRating = remainingWords.toList()
      ..sort((a, b) {
        final ratingA = network.words[a]?.allRating ?? 0;
        final ratingB = network.words[b]?.allRating ?? 0;
        return ratingA.compareTo(ratingB);
      });
    
    final bottom10 = sortedByLowRating.take(10).toList();
    
    // Объединяем - гарантированно получим 30 уникальных элементов
    keywords = [...top20, ...bottom10];
  }
  
  /// Express: отправляет сигнатуру в связанные нейроны и получает релевантные фрагменты
  Future<Package> express(
    OptimizedNeuralNetwork network,
    {Map<int, int>? customVector}
  ) async {
    Map<int, int> expressVector;
    
    if (customVector != null) {
      final superVector = _computeSuperVector(network);
      final projectedCustom = VectorOperations.selfProjection(customVector, network.words);
      expressVector = _averageVectors(superVector, projectedCustom);
    } else {
      expressVector = _computeSuperVector(network);
    }
    
    final allFragments = <int>[];
    
    for (final synapseId in network.synapses.keys) {
      final synapse = network.synapses[synapseId];
      if (synapse == null) continue;
      
      for (final neuronId in synapse.neuronLinks) {
        if (neuronId == id) continue;
        
        final targetNeuron = network.neurons[neuronId];
        if (targetNeuron == null) continue;
        
        final similarity = _calculateSimilarity(signatureRatings, targetNeuron.signatureRatings);
        if (similarity < 0.1) continue;
        
        final relevantFragments = _getRelevantFragments(
          targetNeuron,
          expressVector,
          network,
        );
        
        allFragments.addAll(relevantFragments);
        
        neuronRatings[neuronId] = (neuronRatings[neuronId] ?? 0) + (similarity * 100).round();
        targetNeuron.neuronRatings[id] = (targetNeuron.neuronRatings[id] ?? 0) + (similarity * 100).round();
        allRating+=(similarity * 100).round();
        targetNeuron.allRating+=(similarity * 100).round();
      }
    }
    
    final sortedEntries = expressVector.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    final keywords = sortedEntries.take(10).map((e) => e.key).toList();
    
    final pkg = Package(
      id: network.nextPackageId++,
      signature: expressVector.keys.toList(),
      keywords: keywords,
      status: PackageStatus.permanent,
      fragmentLinks: allFragments,
      neuronLinks: [id],
    );
    
    network.packages[pkg.id] = pkg;
    packageLinks.add(pkg.id);
    
    return pkg;
  }
  
  Map<int, int> _computeSuperVector(OptimizedNeuralNetwork network) {
    final superVector = <int, int>{};
    for (final fragId in fragmentLinks) {
      final frag = network.fragments[fragId];
      if (frag == null) continue;
      
      for (final wordId in frag.wordIds) {
        final word = network.words[wordId];
        if (word != null) {
          for (final entry in word.ratings.entries) {
            superVector[entry.key] = (superVector[entry.key] ?? 0) + entry.value;
          }
        }
      }
    }
    return VectorOperations.selfProjection(superVector, network.words);
  }
  
  Map<int, int> _averageVectors(Map<int, int> vec1, Map<int, int> vec2) {
    final avg = <int, int>{};
    final allKeys = {...vec1.keys, ...vec2.keys};
    
    for (final key in allKeys) {
      final val1 = vec1[key] ?? 0;
      final val2 = vec2[key] ?? 0;
      avg[key] = ((val1 + val2) / 2).round();
    }
    
    return avg;
  }
  
  List<int> _getRelevantFragments(
    Neuron targetNeuron,
    Map<int, int> expressVector,
    OptimizedNeuralNetwork network,
  ) {
    final fragmentScores = <int, double>{};
    
    for (final fragId in targetNeuron.fragmentLinks) {
      final frag = network.fragments[fragId];
      if (frag == null) continue;
      
      double score = 0.0;
      for (final wordId in frag.wordIds) {
        if (expressVector.containsKey(wordId)) {
          score += expressVector[wordId]!.toDouble();
        }
      }
      
      if (score > 0) {
        fragmentScores[fragId] = score;
      }
    }
    
    return (fragmentScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value)))
      .take(20)
      .map((e) => e.key)
      .toList();
  }
  
double _calculateSimilarity(Map<int, int> sig1, Map<int, int> sig2) {
  if (sig1.isEmpty || sig2.isEmpty) return 0.0;
  
  // Находим общие слова
  final commonWords = sig1.keys.toSet().intersection(sig2.keys.toSet());
  if (commonWords.isEmpty) return 0.0;
  
  // Вычисляем суммы всех значений для нормализации
  final sum1 = sig1.values.reduce((a, b) => a + b).toDouble();
  final sum2 = sig2.values.reduce((a, b) => a + b).toDouble();
  
  double totalSimilarity = 0.0;
  int count = 0;
  
  for (final wordId in commonWords) {
    final value1 = sig1[wordId]!.toDouble();
    final value2 = sig2[wordId]!.toDouble();
    
    // Нормализуем значения
    final normalized1 = value1 / sum1;
    final normalized2 = value2 / sum2;
    
    // Вычисляем соотношение векторов
    final vectorRatio = normalized1 / ((normalized2 / ((value1 + value2) / 2)));
    
    // Добавляем к общей схожести
    totalSimilarity += vectorRatio;
    count++;
  }
  
  return count > 0 ? totalSimilarity / count : 0.0;
}
  
  double calculateSimilarityTo(Neuron other, Map<int, Word> words, Map<int, String> wordLibrary) {
    if (signature.isEmpty || other.signature.isEmpty) return 0.0;
    
    final set1 = signature.toSet();
    final set2 = other.signature.toSet();
    final intersection = set1.intersection(set2).length;
    final union = set1.union(set2).length;
    
    double semanticSimilarity = union > 0 ? intersection / union : 0.0;
    
    double connectionStrength = 0.0;
    int commonWordsCount = 0;
    
    final intersectionSet = set1.intersection(set2);
    for (final wordId in intersectionSet) {
      final word = words[wordId];
      if (word != null) {
        final rating1 = word.ratings[other.id] ?? 0;
        final rating2 = word.ratings[id] ?? 0;
        connectionStrength += (rating1 + rating2) / 2.0;
        commonWordsCount++;
      }
    }
    
    if (commonWordsCount > 0) {
      connectionStrength /= commonWordsCount;
      semanticSimilarity *= (1.0 + connectionStrength / 10000.0);
    }
    
    return semanticSimilarity.clamp(0.0, 1.0);
  }
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'personal_synapse_id': personalSynapseId,
    'source_url': sourceUrl,
    'signature_ratings': signatureRatings.map((k, v) => MapEntry(k.toString(), v)),
    'page_title': pageTitle,
    'full_page_content': fullPageContent,
    'fragment_links': fragmentLinks,
    'signature': signature,
    'keywords': keywords,
    'package_links': packageLinks,
    'neuron_ratings': neuronRatings.map((k, v) => MapEntry(k.toString(), v)),
  };
  
  factory Neuron.fromJson(Map<String, dynamic> json) => Neuron(
    id: json['id'],
    personalSynapseId: json['personal_synapse_id'],
    sourceUrl: json['source_url'],
    pageTitle: json['page_title'],
    fullPageContent: json['full_page_content'],
    fragmentLinks: List<int>.from(json['fragment_links'] ?? []),
    signature: List<int>.from(json['signature'] ?? []),
    keywords: List<int>.from(json['keywords'] ?? []),
    packageLinks: List<int>.from(json['package_links'] ?? []),
    neuronRatings: (json['neuron_ratings'] as Map?)?.map((k, v) => MapEntry(int.parse(k), v as int)) ?? {},
    signatureRatings: (json['signature_ratings'] as Map?)?.map((k, v) => MapEntry(int.parse(k), v as int)) ?? {},
  );
}

class Synapse {
  final int id;
  List<int> synapseLinks;
  List<int> neuronLinks;
  
  Synapse({
    required this.id,
    List<int>? synapseLinks,
    List<int>? neuronLinks,
  }) : 
    synapseLinks = synapseLinks ?? [],
    neuronLinks = neuronLinks ?? [];
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'synapse_links': synapseLinks,
    'neuron_links': neuronLinks,
  };
  
  factory Synapse.fromJson(Map<String, dynamic> json) => Synapse(
    id: json['id'],
    synapseLinks: List<int>.from(json['synapse_links'] ?? []),
    neuronLinks: List<int>.from(json['neuron_links'] ?? []),
  );
}

// ========== КЛАСТЕР НЕЙРОНОВ ==========
class NeuronCluster {
  final String id;
  final String type;
  final String title;
  final String? domain;
  final String? path;
  final String? keyword;
  List<int> neuronIds;
  Map<int,int> signature;
  List<int> keywords;
  double x, y, z;
  bool isExpanded;
  bool isVisible;
  List<String> childClusterIds;
  String? parentClusterId;
  int depth;
  double size;
  DateTime lastUpdated;
  
  double animationProgress;
  double targetX, targetY, targetZ;
  double sourceX, sourceY, sourceZ;
  double glowIntensity;
  bool isDragging;
  
  NeuronCluster({
    required this.id,
    required this.type,
    required this.title,
    this.domain,
    this.path,
    this.keyword,
    List<int>? neuronIds,
    Map<int,int>? signature,
    List<int>? keywords,
    double? x,
    double? y,
    double? z,
    bool? isExpanded,
    bool? isVisible,
    List<String>? childClusterIds,
    this.parentClusterId,
    int? depth,
    double? size,
  }) : 
    neuronIds = neuronIds ?? [],
    signature = signature ?? {},
    keywords = keywords ?? [],
    x = x ?? 0.0,
    y = y ?? 0.0,
    z = z ?? 0.0,
    isExpanded = isExpanded ?? false,
    isVisible = isVisible ?? false,
    childClusterIds = childClusterIds ?? [],
    depth = depth ?? 0,
    size = size ?? 1.0,
    lastUpdated = DateTime.now(),
    animationProgress = 1.0,
    targetX = x ?? 0.0,
    targetY = y ?? 0.0,
    targetZ = z ?? 0.0,
    sourceX = x ?? 0.0,
    sourceY = y ?? 0.0,
    sourceZ = z ?? 0.0,
    glowIntensity = 0.0,
    isDragging = false;
  double hoverIntensity = 0.0;
  

  void startHover() {
    hoverIntensity = 0.2; // 20% прозрачности
  }

  void endHover() {
    // Hover будет плавно исчезать через updateAnimation
  }
  void updatePosition(double newX, double newY, double newZ) {
    sourceX = x;
    sourceY = y;
    sourceZ = z;
    targetX = newX;
    targetY = newY;
    targetZ = newZ;
    animationProgress = 0.0;
  }

  void updateAnimation(double deltaTime) {
    if (animationProgress < 1.0) {
      animationProgress = (animationProgress + deltaTime * 8.0).clamp(0.0, 1.0);
      final ease = _easeOutCubic(animationProgress);
      x = sourceX + (targetX - sourceX) * ease;
      y = sourceY + (targetY - sourceY) * ease;
      z = sourceZ + (targetZ - sourceZ) * ease;
    }
    
    // Анимация glow эффекта
    if (glowIntensity > 0.0) {
      glowIntensity = (glowIntensity - deltaTime * 2.0).clamp(0.0, 1.0);
    }
    
    // Анимация hover эффекта
    if (hoverIntensity > 0.0) {
      hoverIntensity = (hoverIntensity - deltaTime * 3.0).clamp(0.0, 0.2);
    }
  }

  double _easeOutCubic(double t) {
    return 1 - pow(1 - t, 3).toDouble();
  }

  

void updateSignature( OptimizedNeuralNetwork network) {
  final wordCounts = <int, int>{};

  List<int> wordIds = [];
  if (neuronIds!.isEmpty==false){
    for (final neuronId in neuronIds){
    final neuron = network.neurons[neuronId];
    if (neuron!=null) {
    for (final wordId in neuron!.keywords){
        wordIds.add(wordId);
    }}
    }
    
  }else{
    if (childClusterIds.isEmpty!=true){
      for (final clusterId in childClusterIds){
        final cluster = network.clusters[clusterId];
        if (cluster!=null){
            final sortedSignature = cluster!.signature.entries.toList()
              ..sort((a, b) => b.value.compareTo(a.value));
            
            for (final entry in sortedSignature){
              signature[entry.key]= (signature[entry.key]??0) + entry.value.toInt();  
            }

        }
      }


    }
    return;
  }
  for (final id in wordIds) {
    wordCounts[id] = (wordCounts[id] ?? 0) + 1;
  }
  for (final neuronId in neuronIds) {
    final neuron = network.neurons[neuronId];
    if (neuron != null) {
      for (final wordId in neuron.signatureRatings.keys) {
        wordCounts[wordId] = (neuron.signatureRatings[wordId] ?? 0) + 1;
      }
    }
  }
  // Обновляем signature ratings
  for (final entry in wordCounts.entries) {
    signature[entry.key] = (signature[entry.key] ?? 0) + entry.value;
  }
  
  // Сортируем signature по убыванию значений
  final sortedSignature = signature.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));
  
  // Берем 20 самых высоких значений сигнатуры
  final top20 = sortedSignature
      .take(20)
      .map((e) => e.key)
      .toList();
  
  // Для bottom 10 берем только из оставшихся 30 слов (позиции 20-49)
  final remainingWords = sortedSignature.skip(20).map((e) => e.key).toList();
  final sortedByLowRating = remainingWords.toList()
    ..sort((a, b) {
      final ratingA = network.words[a]?.allRating ?? 0;
      final ratingB = network.words[b]?.allRating ?? 0;
      return ratingA.compareTo(ratingB);
    });
  
  final bottom10 = sortedByLowRating.take(10).toList();
  
  // Объединяем - гарантированно получим 30 уникальных элементов
  keywords = [...top20, ...bottom10];
}
  
  void startGlow() {
    glowIntensity = 1.0;
  }

  void startDrag() {
    isDragging = true;
    glowIntensity = 0.8;
  }

  void endDrag() {
    isDragging = false;
    glowIntensity = 0.0;
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': type,
      'title': title,
      'domain': domain,
      'path': path,
      'keyword': keyword,
      'neuronIds': neuronIds,
      'signature': signature.map((k, v) => MapEntry(k.toString(), v)),
      'keywords': keywords,
      'x': x,
      'y': y,
      'z': z,
      'isExpanded': isExpanded,
      'isVisible': isVisible,
      'childClusterIds': childClusterIds,
      'parentClusterId': parentClusterId,
      'depth': depth,
      'size': size,
      'lastUpdated': lastUpdated.toIso8601String(),
    };
  }

  factory NeuronCluster.fromJson(Map<String, dynamic> json) {
    return NeuronCluster(
      id: json['id'],
      type: json['type'],
      title: json['title'],
      domain: json['domain'],
      path: json['path'],
      keyword: json['keyword'],
      neuronIds: List<int>.from(json['neuronIds'] ?? []),
      signature:   (json['signature_ratings'] as Map?)?.map((k, v) => MapEntry(int.parse(k), v as int)) ?? {},
      keywords: List<int>.from(json['keywords'] ?? []),
      x: (json['x'] ?? 0.0).toDouble(),
      y: (json['y'] ?? 0.0).toDouble(),
      z: (json['z'] ?? 0.0).toDouble(),
      isExpanded: json['isExpanded'] ?? false,
      isVisible: json['isVisible'] ?? true,
      childClusterIds: List<String>.from(json['childClusterIds'] ?? []),
      parentClusterId: json['parentClusterId'],
      depth: json['depth'] ?? 0,
      size: (json['size'] ?? 1.0).toDouble(),
    );
  }
}

// ========== ОПТИМИЗИРОВАННАЯ НЕЙРОСЕТЬ ==========
class OptimizedNeuralNetwork {
  final Map<int, String> wordLibrary = {};

  final Map<String, int> wordIndex = {};
  final Map<int, Word> words = {};
  final Map<int, Fragment> fragments = {};
  final Map<int, Neuron> neurons = {};
  final Map<int, Synapse> synapses = {};
  final Map<int, Package> packages = {};
  final Map<String, NeuronCluster> clusters = {};
  final SemanticSearchSystem searchSystem = SemanticSearchSystem(
        maxDimensions: 50000, // Максимальная размерность векторов
        numHyperplanes: 15,
        numBands: 20,
      );
  int nextWordId = 1;
  int nextFragmentId = 1;
  int nextNeuronId = 1;
  int nextSynapseId = 1;
  int nextPackageId = 1;
  
  final Random random = Random();
  
  static const int MAX_VECTOR_SIZE = 600;
  
  Map<int, int> currentSearchVector = {};
  List<int> currentSearchWords = [];
  
  final List<NavigationStep> navigationHistory = [];
  static const int maxHistorySteps = 10;
  
  Set<int> selectedWordIds = {};
  Set<int> selectedNeuronIds = {};
  Set<int> selectedFragmentIds = {};
  Set<String> expandedClusterIds = {};
  
  VisualizationMode visualizationMode = VisualizationMode.words;
  final List<String> clusterHistory = [];
  int historyIndex = -1;
  final Set<int> searchedNeurons = {};
  int currentSearchIndex = -1;
  
  bool _isAnimating = false;
  final Map<String, List<AnimationStage>> _animationQueue = {};
  
  final String clustersDataPath = 'qwa_ai_bd/neural_clusters_data_ai.json';
  
  // Новые поля для управления камерой и перетаскиванием
  double _cameraX = 0.0;
  double _cameraY = 0.0;
  double _cameraScale = 1.0;
  String? _draggedClusterId;
  Offset? _dragStartOffset;
  Offset? _clusterStartOffset;
  bool hasVisualChanges = false;
  OptimizedNeuralNetwork() {
    _initializeRootNeuron();
    //createTestClusters();
  }
  
  void _initializeRootNeuron() {
    final rootSynapse = Synapse(id: 0);
    synapses[0] = rootSynapse;
    
    final rootNeuron = Neuron(id: 0, personalSynapseId: 0);
    neurons[0] = rootNeuron;
    
    rootSynapse.neuronLinks.add(0);
  }


  void updateAnimations(double deltaTime) {
    hasVisualChanges = false;
    
    for (final cluster in clusters.values) {
      final oldX = cluster.x;
      final oldY = cluster.y;
      final oldZ = cluster.z;
      final oldGlow = cluster.glowIntensity;
      final oldHover = cluster.hoverIntensity;
      
      cluster.updateAnimation(deltaTime);
      
      // Проверяем, были ли визуальные изменения
      if (cluster.x != oldX || cluster.y != oldY || cluster.z != oldZ ||
          cluster.glowIntensity != oldGlow || cluster.hoverIntensity != oldHover) {
        hasVisualChanges = true;
      }
    }}

List<Neuron> searchNeuronsByKeywords(String query) {
    final keywords = _extractWords(query);
    if (keywords.isEmpty) return [];

    final neuronScores = <Neuron, double>{};

    for (final neuron in neurons.values) {
      if (neuron.id == 0) continue;

      double score = 0.0;
      for (final keyword in keywords) {
        final wordId = wordIndex[keyword];
        if (wordId != null && neuron.signature.contains(wordId)) {
          score += 1.0;
        }
      }

      if (score > 0) {
        final signatureStrength = neuron.signature
            .where((wordId) => keywords.any((k) => wordIndex[k] == wordId))
            .map((wordId) => words[wordId]?.allRating ?? 0)
            .fold(0, (a, b) => a + b) / 1000.0;

        final totalScore = score * (1 + signatureStrength);
        neuronScores[neuron] = totalScore;
      }
    }

    final sortedEntries = neuronScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedEntries.map((e) => e.key).toList();
  }
  Future<void> createTestClusters() async {
  print('🛠️ Creating test clusters...');
  return;
  // Очищаем существующие кластеры
  clusters.clear();
  
  // Создаем корневой кластер
  clusters['root'] = NeuronCluster(
    id: 'root',
    type: 'root',
    title: 'Root',
    x: 0.0,
    y: 300.0, // Помещаем внизу
    z: 0.0,
    depth: 0,
    size: 2.0,
    isExpanded: false,
    isVisible: true,
  );

  // Создаем несколько тестовых дочерних кластеров
  final testDomains = ['example.com', 'test.org', 'demo.net'];
  for (int i = 0; i < testDomains.length; i++) {
    final domain = testDomains[i];
    final clusterId = 'domain_$domain';
    
    clusters[clusterId] = NeuronCluster(
      id: clusterId,
      type: 'domain',
      title: domain,
      domain: domain,
      x: 0.0,
      y: 300.0 - (i * 100), // Располагаем выше родителя
      z: 0.0, // Немного разбрасываем по Z
      depth: 1,
      size: 1.5,
      isExpanded: false,
      isVisible: false, // Изначально скрыты
    );
    
    // Добавляем в дочерние корневого кластера
    clusters['root']!.childClusterIds.add(clusterId);
    clusters[clusterId]!.parentClusterId = 'root';
  }

  print('✅ Test clusters created: ${clusters.length} clusters');
  setState(() {});
}
  /// Поиск фрагментов по тексту
  List<Fragment> searchFragments(String query) {
    final keywords = query.toLowerCase().split(' ').where((w) => w.length > 2).toList();
    if (keywords.isEmpty) return [];

    final fragmentScores = <Fragment, int>{};

    for (final fragment in fragments.values) {
      int score = 0;
      final text = fragment.text.toLowerCase();

      for (final keyword in keywords) {
        if (text.contains(keyword)) {
          score += keyword.length;
        }
      }

      if (score > 0) {
        fragmentScores[fragment] = score;
      }
    }

    final sortedEntries = fragmentScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedEntries.map((e) => e.key).toList();
  }

  // ========== ВЫБОР ЭЛЕМЕНТОВ ==========
  void selectWord(int wordId, {bool withShift = false}) {
    if (withShift) {
      if (selectedWordIds.contains(wordId)) {
        selectedWordIds.remove(wordId);
      } else {
        selectedWordIds.add(wordId);
      }
    } else {
      selectedWordIds = {wordId};
    }
    selectedNeuronIds.clear();
    selectedFragmentIds.clear();
    
    // Обновляем выделенные фрагменты на основе выбранных слов
    _updateFragmentsFromSelectedWords();
    
    addNavigationStep(NavigationStep(type: 'word', id: wordId));
  }
  
  void selectNeuron(int neuronId, {bool withShift = false}) {
    if (withShift) {
      if (selectedNeuronIds.contains(neuronId)) {
        selectedNeuronIds.remove(neuronId);
      } else {
        selectedNeuronIds.add(neuronId);
      }
    } else {
      selectedNeuronIds = {neuronId};
    }
    selectedWordIds.clear();
    selectedFragmentIds.clear();
    
    // Обновляем выделенные слова на основе выбранного нейрона
    //_updateWordsFromSelectedNeuron();
    
    addNavigationStep(NavigationStep(type: 'neuron', id: neuronId));
  }
  
  void selectFragment(int fragmentId, {bool withShift = false}) {
    if (withShift) {
      if (selectedFragmentIds.contains(fragmentId)) {
        selectedFragmentIds.remove(fragmentId);
      } else {
        selectedFragmentIds.add(fragmentId);
      }
    } else {
      selectedFragmentIds = {fragmentId};
    }
    selectedWordIds.clear();
    selectedNeuronIds.clear();
    
    // Обновляем выделенные слова на основе выбранного фрагмента
    _updateWordsFromSelectedFragment();
    
    addNavigationStep(NavigationStep(type: 'fragment', id: fragmentId));
  }
  
  void clearSelection() {
    selectedWordIds.clear();
    selectedNeuronIds.clear();
    selectedFragmentIds.clear();
  }
 // ========== ИСТОРИЯ НАВИГАЦИИ ==========
  void addNavigationStep(NavigationStep step) {
    navigationHistory.add(step);
    if (navigationHistory.length > maxHistorySteps) {
      navigationHistory.removeAt(0);
    }
  }
  
  void navigateToStep(int index) {
    if (index < 0 || index >= navigationHistory.length) return;
    
    final step = navigationHistory[index];
    switch (step.type) {
      case 'word':
        selectedWordIds = {step.id!};
        selectedNeuronIds.clear();
        selectedFragmentIds.clear();
        break;
      case 'neuron':
        selectedNeuronIds = {step.id!};
        selectedWordIds.clear();
        selectedFragmentIds.clear();
        break;
      case 'fragment':
        selectedFragmentIds = {step.id!};
        selectedWordIds.clear();
        selectedNeuronIds.clear();
        break;
      case 'search':
        // Восстанавливаем поисковый запрос
        currentSearchVector = _buildSearchVector(step.query!);
        break;
    }
  }
  
  /// Поиск фрагментов по нескольким словам
  List<Fragment> findFragmentsWithAllWords(Set<int> wordIds) {
    final result = <Fragment>[];
    
    for (final fragment in fragments.values) {
      final fragmentWordSet = fragment.wordIds.toSet();
      if (wordIds.every((wordId) => fragmentWordSet.contains(wordId))) {
        result.add(fragment);
      }
    }
    
    // Сортируем по релевантности (количество вхождений искомых слов)
    result.sort((a, b) {
      final countA = a.wordIds.where((id) => wordIds.contains(id)).length;
      final countB = b.wordIds.where((id) => wordIds.contains(id)).length;
      return countB.compareTo(countA);
    });
    
    return result;
  }

   /// Получение композитного вектора для набора слов
  Map<int, int> getCompositeVector(Set<int> wordIds) {
    final compositeVector = <int, int>{};
    
    for (final wordId in wordIds) {
      final word = words[wordId];
      if (word != null) {
        for (final entry in word.ratings.entries) {
          compositeVector[entry.key] = (compositeVector[entry.key] ?? 0) + entry.value;
        }
      }
    }
    
    return VectorOperations.selfProjection(compositeVector, words);
  }

  /// Слияние нескольких нейронов в один
  Future<Neuron> mergeNeurons(Set<int> neuronIds) async {
    final newNeuronId = nextNeuronId++;
    final newSynapseId = nextSynapseId++;
    
    final newSynapse = Synapse(id: newSynapseId);
    synapses[newSynapseId] = newSynapse;
    
    final allFragments = <int>[];
    final allPackages = <int>[];
    final neuronRatings = <int, int>{};
    String combinedTitle = '';
    
    for (final neuronId in neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      allFragments.addAll(neuron.fragmentLinks);
      allPackages.addAll(neuron.packageLinks);
      
      for (final entry in neuron.neuronRatings.entries) {
        neuronRatings[entry.key] = (neuronRatings[entry.key] ?? 0) + entry.value;
      }
      
      if (neuron.pageTitle != null) {
        combinedTitle += '${neuron.pageTitle} + ';
      }
    }
    
    final newNeuron = Neuron(
      id: newNeuronId,
      personalSynapseId: newSynapseId,
      pageTitle: combinedTitle.isNotEmpty ? combinedTitle.substring(0, combinedTitle.length - 3) : 'Merged Neuron',
      fragmentLinks: allFragments,
      packageLinks: allPackages,
      neuronRatings: neuronRatings,
    );
    
    final allWordIds = <int>[];
    for (final fragId in allFragments) {
      final frag = fragments[fragId];
      if (frag != null) {
        allWordIds.addAll(frag.wordIds);
      }
    }
    newNeuron.updateSignature(allWordIds,this);
    
    neurons[newNeuronId] = newNeuron;
    newSynapse.neuronLinks.add(newNeuronId);
    
    for (final parentId in neuronIds) {
      newNeuron.neuronRatings[parentId] = 10000;
      final parent = neurons[parentId];
      if (parent != null) {
        parent.neuronRatings[newNeuronId] = 10000;
      }
    }
    
    return newNeuron;
  }
  
  /// Обработка связей между выбранными нейронами
  Future<void> processNeuronConnections(Set<int> neuronIds) async {
    final neuronsList = neuronIds
        .map((id) => neurons[id])
        .where((n) => n != null)
        .cast<Neuron>()
        .toList();
    
    for (int i = 0; i < neuronsList.length; i++) {
      final neuron1 = neuronsList[i];
      
      final superVec1 = <int, int>{};
      for (final fragId in neuron1.fragmentLinks) {
        final frag = fragments[fragId];
        if (frag == null) continue;
        for (final wordId in frag.wordIds) {
          final word = words[wordId];
          if (word != null) {
            for (final entry in word.ratings.entries) {
              superVec1[entry.key] = (superVec1[entry.key] ?? 0) + entry.value;
            }
          }
        }
      }
      final commonVec1 = VectorOperations.selfProjection(superVec1, words);
      
      for (int j = i + 1; j < neuronsList.length; j++) {
        final neuron2 = neuronsList[j];
        
        final superVec2 = <int, int>{};
        for (final fragId in neuron2.fragmentLinks) {
          final frag = fragments[fragId];
          if (frag == null) continue;
          for (final wordId in frag.wordIds) {
            final word = words[wordId];
            if (word != null) {
              for (final entry in word.ratings.entries) {
                superVec2[entry.key] = (superVec2[entry.key] ?? 0) + entry.value;
              }
            }
          }
        }
        final commonVec2 = VectorOperations.selfProjection(superVec2, words);
        
        final difference = VectorOperations.vectorQualityDifference(commonVec1, commonVec2);
        final similarity = 1000000 / (difference + 1);
        final rating = similarity.round();
        
        neuron1.neuronRatings[neuron2.id] = (neuron1.neuronRatings[neuron2.id] ?? 0) + rating;
        neuron2.neuronRatings[neuron1.id] = (neuron2.neuronRatings[neuron1.id] ?? 0) + rating;
      }
    }
  }
  
  /// Копирование текста из выбранных нейронов в буфер обмена
  Future<void> copyNeuronsToClipboard(Set<int> neuronIds) async {
    final allText = StringBuffer();
    
    for (final neuronId in neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      if (neuron.pageTitle != null) {
        allText.writeln('=== ${neuron.pageTitle} ===');
      }
      
      for (final fragId in neuron.fragmentLinks) {
        final frag = fragments[fragId];
        if (frag != null) {
          allText.writeln(frag.text);
        }
      }
      allText.writeln();
    }
    
    await Clipboard.setData(ClipboardData(text: allText.toString()));
  }
  
  /// Копирование фрагментов в буфер обмена
  Future<void> copyFragmentsToClipboard(List<int> fragmentIds) async {
    final allText = StringBuffer();
    
    for (final fragId in fragmentIds) {
      final frag = fragments[fragId];
      if (frag != null) {
        allText.writeln(frag.text);
      }
    }
    
    await Clipboard.setData(ClipboardData(text: allText.toString()));
  }
  
  /// Создание визуализации слов для выбранных нейронов
  Map<int, Word> createNeuronWordsVisualization(Set<int> neuronIds) {
    final wordScores = <int, double>{};
    
    for (final neuronId in neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      for (final fragId in neuron.fragmentLinks) {
        final frag = fragments[fragId];
        if (frag == null) continue;
        
        for (final wordId in frag.wordIds) {
          final word = words[wordId];
          if (word != null) {
            wordScores[wordId] = (wordScores[wordId] ?? 0.0) + word.allRating.toDouble();
          }
        }
      }
    }
    
    // Создаем новую проекцию слов
    final projectedWords = <int, Word>{};
    for (final entry in wordScores.entries) {
      final originalWord = words[entry.key];
      if (originalWord != null) {
        final projectedWord = Word(
          id: originalWord.id,
          ratings: Map.from(originalWord.ratings),
          allRating: originalWord.allRating,
          x: originalWord.x,
          y: originalWord.y,
          z: originalWord.z,
          sameWords: Set.from(originalWord.sameWords),
        );
        projectedWords[entry.key] = projectedWord;
      }
    }
    
    return projectedWords;
  }

  
  void _updateWordsFromSelectedFragment() {
    if (selectedFragmentIds.isEmpty) return;
    
    final wordSet = <int>{};
    for (final fragmentId in selectedFragmentIds) {
      final fragment = fragments[fragmentId];
      if (fragment != null) {
        wordSet.addAll(fragment.wordIds);
      }
    }
    selectedWordIds = wordSet;
  }
  
  void _updateFragmentsFromSelectedWords() {
    if (selectedWordIds.isEmpty) return;
    
    final fragmentScores = <int, int>{};
    for (final fragment in fragments.values) {
      int score = 0;
      for (final wordId in fragment.wordIds) {
        if (selectedWordIds.contains(wordId)) {
          score++;
        }
      }
      if (score > 0) {
        fragmentScores[fragment.id] = score;
      }
    }
    
    final sortedFragments = fragmentScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    selectedFragmentIds = sortedFragments.take(10).map((e) => e.key).toSet();
  }

  
  // ========== ПОИСК И ФИЛЬТРАЦИЯ ==========
  Map<int, int> _buildSearchVector(String query) {
    final wordTexts = _extractWords(query);
    final promptWordIds = wordTexts
        .map((w) => wordIndex[w])
        .where((id) => id != null)
        .cast<int>()
        .toList();
    
    if (promptWordIds.isEmpty) return {};
    
    final superVector = <int, int>{};
    for (final wordId in promptWordIds) {
      final word = words[wordId];
      if (word != null) {
        for (final entry in word.ratings.entries) {
          superVector[entry.key] = (superVector[entry.key] ?? 0) + entry.value;
        }
      }
    }
    
    return VectorOperations.selfProjection(superVector, words);
  }
  // ========== ОСНОВНЫЕ МЕТОДЫ КЛАСТЕРИЗАЦИИ ==========
  Future<void> updateClusters() async {
    print('🚀 Starting advanced cluster update with ${neurons.length} neurons');
    
    //await _loadClustersFromFile();
    
    if (!clusters.containsKey('root')) {
      clusters['root'] = NeuronCluster(
        id: 'root',
        type: 'root',
        title: 'Neural Network Root',
        x: 0.0,
        y: 0.0,
        z: 0.0,
        depth: 0,
        size: 2.0,
      );
    }
    clusters['root']!.isVisible=true;
     clusters['root']!.isExpanded=false;
    await _createIntermediateClusters();
    await _createUrlDomainClusters();
    //await _createKeywordClusters();
    
    //_positionAllClusters();
    //await _saveClustersToFile();

    await AppLogger.writeLog('✅ Cluster update complete: ${clusters.length} clusters');
  }


  
// НОВЫЙ МЕТОД: создаем промежуточные кластеры
Future<void> _createIntermediateClusters() async {
  print('🏗️ Creating intermediate clusters');
  
  // Создаем интернет-кластер как промежуточный
  if (!clusters.containsKey('internet')) {
    final internetCluster = NeuronCluster(
      id: 'internet',
      type: 'internet',
      title: 'Internet',
      depth: 1,
      size: 1.8,
    );
    clusters['internet'] = internetCluster;
    clusters['root']!.childClusterIds.add('internet');
    internetCluster.parentClusterId = 'root';
    print('➕ Created internet cluster');
  }
  
  // Создаем кластер для ключевых слов как промежуточный
  if (!clusters.containsKey('keyword_clusters')) {
    final keywordCluster = NeuronCluster(
      id: 'keyword_clusters',
      type: 'keyword_root',
      title: 'Keywords',
      depth: 1,
      size: 1.8,
    );
    clusters['keyword_clusters'] = keywordCluster;
    clusters['root']!.childClusterIds.add('keyword_clusters');
    keywordCluster.parentClusterId = 'root';
    print('➕ Created keyword_clusters container');
  }
}

Future<void> _createUrlDomainClusters() async {
  final domainNeuronsMap = <String, List<int>>{};
  final categoryNeuronsMap = <String, Map<String, List<int>>>{}; // категория -> домен -> нейроны
  final pathNeuronsMap = <String, Map<String, Map<String, List<int>>>>{}; // категория -> домен -> путь -> нейроны
  
  // Нормализация категорий (оставляем вашу функцию без изменений)
  String _normalizeCategory(String pathSegment) {
    final normalized = pathSegment.toLowerCase();
    
    // Форумные категории
    if (normalized.contains('forum')) return 'forums';
    if (normalized.contains('chat')) return 'chats';
    if (normalized.contains('board')) return 'forums';
    if (normalized.contains('discussion')) return 'forums';
    
    // Медиа категории
    if (normalized.contains('audio')) return 'audio';
    if (normalized.contains('music')) return 'audio';
    if (normalized.contains('video')) return 'video';
    if (normalized.contains('movie')) return 'video';
    if (normalized.contains('podcast')) return 'audio';
    
    // Текстовые категории
    if (normalized.contains('book')) return 'books';
    if (normalized.contains('wiki')) return 'wiki';
    if (normalized.contains('article')) return 'articles';
    if (normalized.contains('blog')) return 'blogs';
    if (normalized.contains('news')) return 'news';
    if (normalized.contains('story')) return 'stories';
    if (normalized.contains('song')) return 'songs';
    if (normalized.contains('poem')) return 'poems';
    
    // Пользовательские категории
    if (normalized.contains('user')) return 'users';
    if (normalized.contains('profile')) return 'profiles';
    if (normalized.contains('account')) return 'accounts';
    
    // Прочие
    if (normalized.contains('archive')) return 'archives';
    if (normalized.contains('download')) return 'downloads';
    if (normalized.contains('file')) return 'files';
    
    return normalized;
  }
  
  // Группировка по диапазонам (пагинация по 20 элементов)
  String _getRangeGroup(int number, int groupSize) {
    final lower = (number ~/ groupSize) * groupSize + 1;
    final upper = lower + groupSize - 1;
    return '$lower-$upper';
  }
  
  // Анализ URL и группировка
  for (final neuron in neurons.values) {
    if (neuron.id == 0 || neuron.sourceUrl == null) continue;
    
    try {
      final uri = Uri.parse(neuron.sourceUrl!);
      final domain = uri.host;
      
      // Группировка по доменам
      domainNeuronsMap[domain] = [...domainNeuronsMap[domain] ?? [], neuron.id];
      
      // Анализ пути для категоризации
      if (uri.path.isNotEmpty && uri.path != '/') {
        final pathSegments = uri.path.split('/').where((s) => s.isNotEmpty).toList();
        
        if (pathSegments.isNotEmpty) {
          final firstSegment = pathSegments[0];
          final category = _normalizeCategory(firstSegment);
          
          // Инициализация структур данных для категории
          if (!categoryNeuronsMap.containsKey(category)) {
            categoryNeuronsMap[category] = {};
          }
          if (!pathNeuronsMap.containsKey(category)) {
            pathNeuronsMap[category] = {};
          }
          
          // Группировка по доменам внутри категории
          categoryNeuronsMap[category]![domain] = [
            ...categoryNeuronsMap[category]![domain] ?? [],
            neuron.id
          ];
          
          // Анализ пути для создания иерархии
          if (pathSegments.length >= 2) {
            final secondSegment = pathSegments[1];
            
            // Определяем базовый путь (например, "book/1")
            final basePath = '$firstSegment/$secondSegment';
            
            if (!pathNeuronsMap[category]!.containsKey(domain)) {
              pathNeuronsMap[category]![domain] = {};
            }
            
            // Извлекаем числовой идентификатор для пагинации
            int? pageNumber;
            
            // Пытаемся найти числовой идентификатор в сегментах пути
            for (int i = 2; i < pathSegments.length; i++) {
              pageNumber = int.tryParse(pathSegments[i]);
              if (pageNumber != null) break;
            }
            
            // Если не нашли в последующих сегментах, пробуем второй сегмент
            if (pageNumber == null) {
              pageNumber = int.tryParse(secondSegment);
            }
            
            String groupKey;
            if (pageNumber != null) {
              // Группируем по диапазонам по 20 элементов
              groupKey = _getRangeGroup(pageNumber, 20);
            } else {
              // Если нет числового идентификатора, группируем по значению второго сегмента
              groupKey = secondSegment;
            }
            
            final pathKey = '$basePath/$groupKey';
            
            pathNeuronsMap[category]![domain]![pathKey] = [
              ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
              neuron.id
            ];
          } else {
            // Если только один сегмент пути, добавляем в общую группу домена
            final pathKey = '$firstSegment/general';
            if (!pathNeuronsMap[category]!.containsKey(domain)) {
              pathNeuronsMap[category]![domain] = {};
            }
            pathNeuronsMap[category]![domain]![pathKey] = [
              ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
              neuron.id
            ];
          }
        }
      }
    } catch (e) {
      print('⚠️ Error parsing URL for neuron ${neuron.id}: ${neuron.sourceUrl}');
    }
  }
  
  // Создание корневого кластера "internet"
  if (!clusters.containsKey('internet')) {
    clusters['internet'] = NeuronCluster(
      id: 'internet',
      type: 'root',
      title: 'Internet',
      neuronIds: [],
      depth: 0,
      size: 2.0,
    );
  }
  
  // Создание иерархии: категория → домен → пагинационные кластеры
  for (final category in categoryNeuronsMap.keys) {
    final categoryClusterId = 'category_$category';
    
    // Создаем кластер категории
    if (!clusters.containsKey(categoryClusterId)) {
      clusters[categoryClusterId] = NeuronCluster(
        id: categoryClusterId,
        type: 'category',
        title: category,
        neuronIds: [],
        depth: 1,
        size: 1.8,
      );
      
      // Привязываем к корневому кластеру
      clusters['internet']!.childClusterIds.add(categoryClusterId);
      clusters[categoryClusterId]!.parentClusterId = 'internet';
    }
    
    // Обрабатываем домены внутри категории
    for (final domain in categoryNeuronsMap[category]!.keys) {
      final domainClusterId = '${category}_domain_$domain';
      
      // Создаем доменный кластер
      if (!clusters.containsKey(domainClusterId)) {
        clusters[domainClusterId] = NeuronCluster(
          id: domainClusterId,
          type: 'domain',
          title: domain,
          domain: domain,
          neuronIds: [],
          depth: 2,
          size: 1.5,
        );
        
        // Привязываем к категории
        clusters[categoryClusterId]!.childClusterIds.add(domainClusterId);
        clusters[domainClusterId]!.parentClusterId = categoryClusterId;
      }
      
      // Обрабатываем пути внутри домена
      final domainPaths = pathNeuronsMap[category]?[domain] ?? {};
      
      for (final pathKey in domainPaths.keys) {
        final neuronsInPath = domainPaths[pathKey]!;
        
        if (neuronsInPath.length >= 5) {
          // Создаем пагинационный кластер
          final pageClusterId = '${domainClusterId}_$pathKey';
          
          clusters[pageClusterId] = NeuronCluster(
            id: pageClusterId,
            type: 'page_group',
            title: '$pathKey (${neuronsInPath.length})',
            domain: domain,
            path: pathKey,
            neuronIds: neuronsInPath,
            depth: 3,
            size: 1.1,
          );
          
          // Привязываем к доменному кластеру
          clusters[domainClusterId]!.childClusterIds.add(pageClusterId);
          clusters[pageClusterId]!.parentClusterId = domainClusterId;
        } else {
          // Мало нейронов - добавляем напрямую в доменный кластер
          clusters[domainClusterId]!.neuronIds.addAll(neuronsInPath);
        }
      }
      
      // Если в домене остались нейроны без специфичных путей, добавляем их
      final domainNeurons = categoryNeuronsMap[category]![domain]!;
      final assignedNeurons = domainPaths.values.expand((list) => list).toSet();
      final remainingNeurons = domainNeurons.where((id) => !assignedNeurons.contains(id)).toList();
      
      if (remainingNeurons.isNotEmpty) {
        clusters[domainClusterId]!.neuronIds.addAll(remainingNeurons);
      }
    }
  }
  
  // Также создаем отдельные доменные кластеры для нейронов без категорий
  for (final domain in domainNeuronsMap.keys) {
    final domainClusterId = 'domain_$domain';
    
    // Проверяем, не был ли уже создан этот домен в какой-либо категории
    final existsInCategory = clusters.values.any((cluster) => 
        cluster.id.contains('_domain_$domain') && cluster.type == 'domain');
    
    if (!existsInCategory && !clusters.containsKey(domainClusterId)) {
      clusters[domainClusterId] = NeuronCluster(
        id: domainClusterId,
        type: 'domain',
        title: domain,
        domain: domain,
        neuronIds: domainNeuronsMap[domain]!,
        depth: 1,
        size: 1.5,
      );
      
      // Привязываем к корневому кластеру
      clusters['internet']!.childClusterIds.add(domainClusterId);
      clusters[domainClusterId]!.parentClusterId = 'internet';
    }
  }
  
  // Обновление сигнатур всех кластеров
  for (final cluster in clusters.values) {
    if (cluster.neuronIds.isNotEmpty) {
      cluster.updateSignature(this);
    }
  }
  
  print('✅ Created URL hierarchy: ${clusters.length} clusters');
}
  

  Future<void> _createUrlDomainClustersDD() async {
  final domainNeuronsMap = <String, List<int>>{};
  final domainNeuronsMapChanging  = <String, List<int>>{};
  final categoryNeuronsMap = <String, Map<String, List<int>>>{}; // категория -> домен -> нейроны
  final pathNeuronsMap = <String, Map<String, Map<String, List<int>>>>{}; // категория -> домен -> путь -> нейроны
  
  // Нормализация категорий (оставляем вашу функцию без изменений)
  String _normalizeCategory(String pathSegment) {
    final normalized = pathSegment.toLowerCase();
    
    // Форумные категории
    if (normalized.contains('forum')) return 'forums';
    if (normalized.contains('chat')) return 'chats';
    if (normalized.contains('board')) return 'forums';
    if (normalized.contains('discussion')) return 'forums';
    
    // Медиа категории
    if (normalized.contains('audio')) return 'audio';
    if (normalized.contains('music')) return 'audio';
    if (normalized.contains('video')) return 'video';
    if (normalized.contains('movie')) return 'video';
    if (normalized.contains('podcast')) return 'audio';
    
    // Текстовые категории
    if (normalized.contains('book')) return 'books';
    if (normalized.contains('wiki')) return 'wiki';
    if (normalized.contains('article')) return 'articles';
    if (normalized.contains('blog')) return 'blogs';
    if (normalized.contains('news')) return 'news';
    if (normalized.contains('story')) return 'stories';
    if (normalized.contains('song')) return 'songs';
    if (normalized.contains('poem')) return 'poems';
    
    // Пользовательские категории
    if (normalized.contains('user')) return 'users';
    if (normalized.contains('profile')) return 'profiles';
    if (normalized.contains('account')) return 'accounts';
    
    // Прочие
    if (normalized.contains('archive')) return 'archives';
    if (normalized.contains('download')) return 'downloads';
    if (normalized.contains('file')) return 'files';
    
    return "generic";
  }
  
  // Группировка по диапазонам (пагинация по 20 элементов)
  String _getRangeGroup(int number, int groupSize) {
    final lower = (number ~/ groupSize) * groupSize + 1;
    final upper = lower + groupSize - 1;
    return '$lower-$upper';
  }
  
          final regex = RegExp(r'\d+');
         
  // Анализ URL и группировка
  for (final neuron in neurons.values) {
    if (neuron.id == 0 || neuron.sourceUrl == null) continue;
    
    try {
      final uri = Uri.parse(neuron.sourceUrl!);
      final domain = uri.host;
      
      // Группировка по доменам
      domainNeuronsMap[domain] = [...domainNeuronsMap[domain] ?? [], neuron.id];
      
      // Анализ пути для категоризации
      if (uri.path.isNotEmpty && uri.path != '/') {
        final pathSegments = uri.path.split('/').where((s) => s.isNotEmpty).toList();
          final firstSegment = pathSegments[0];
            final secondSegment = pathSegments[1];
            
        if (pathSegments.isNotEmpty) {
      String category = "generic";
          int indexCat = 0;
          for (final path in pathSegments) {
              category = _normalizeCategory(path);
              indexCat= pathSegments.indexOf(path);
              if (category != "generic") break;
          }
          

          
          // Инициализация структур данных для категории
          if (!categoryNeuronsMap.containsKey(category)) {
            categoryNeuronsMap[category] = {};
          }
          if (!pathNeuronsMap.containsKey(category)) {
            pathNeuronsMap[category] = {};
          }
          
          // Группировка по доменам внутри категории
          categoryNeuronsMap[category]![domain] = [
            ...categoryNeuronsMap[category]![domain] ?? [],
            neuron.id
          ];
          
          // Анализ пути для создания иерархии
          if (pathSegments.length >= 2) {
          
            // Определяем базовый путь (например, "book/1")
            final basePath = '$firstSegment/$secondSegment';
            
            if (!pathNeuronsMap[category]!.containsKey(domain)) {
              pathNeuronsMap[category]![domain] = {};
            }
            
            // Извлекаем числовой идентификатор для пагинации
            int? pageNumber;
            
            // Пытаемся найти числовой идентификатор в сегментах пути
            for (int i = 2; i < pathSegments.length; i++) {
              if (i==indexCat) continue;
              final matches = regex.allMatches(pathSegments[i]);
              for (final match in matches) {
                final number = int.tryParse(match.group(0)!);
                if (number != null) {
                  pageNumber = number;
                }
              }
              if (pageNumber != null) break;
            }
            
            // Если не нашли в последующих сегментах, пробуем второй сегмент
            if (pageNumber == null) {
              final matches = regex.allMatches(secondSegment);
              for (final match in matches) {
                final number = int.tryParse(match.group(0)!);
                if (number != null) {
                  pageNumber = number;
                }
              }
              if (pageNumber != null) break;
            }
            
            String groupKey;
            if (pageNumber != null) {
              // Группируем по диапазонам по 20 элементов
              groupKey = _getRangeGroup(pageNumber, 20);
            } else {
              // Если нет числового идентификатора, группируем по значению второго сегмента
              groupKey = secondSegment;
            }
            
            final pathKey = '$basePath/$groupKey';
            
            pathNeuronsMap[category]![domain]![pathKey] = [
              ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
              neuron.id
            ];
          } else {
            // Если только один сегмент пути, добавляем в общую группу домена
            final pathKey = '$firstSegment/general';
            if (!pathNeuronsMap[category]!.containsKey(domain)) {
              pathNeuronsMap[category]![domain] = {};
            }
            pathNeuronsMap[category]![domain]![pathKey] = [
              ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
              neuron.id
            ];
          }
        }
      }
    } catch (e) {
      print('⚠️ Error parsing URL for neuron ${neuron.id}: ${neuron.sourceUrl}');
    }
  }
  
  // Создание корневого кластера "internet"
  if (!clusters.containsKey('internet')) {
    clusters['internet'] = NeuronCluster(
      id: 'internet',
      type: 'root',
      title: 'Internet',
      neuronIds: [],
      depth: 0,
      size: 2.0,
    );
  }
  
  // Создание иерархии: категория → домен → пагинационные кластеры
  for (final category in categoryNeuronsMap.keys) {
    final categoryClusterId = 'category_$category';
    
    // Создаем кластер категории
    if (!clusters.containsKey(categoryClusterId)) {
      clusters[categoryClusterId] = NeuronCluster(
        id: categoryClusterId,
        type: 'category',
        title: category,
        neuronIds: [],
        depth: 1,
        size: 1.8,
      );
      
      // Привязываем к корневому кластеру
      clusters['internet']!.childClusterIds.add(categoryClusterId);
      clusters[categoryClusterId]!.parentClusterId = 'internet';
    }
    
    // Обрабатываем домены внутри категории
    for (final domain in categoryNeuronsMap[category]!.keys) {
      final domainClusterId = '${category}_domain_$domain';
      
      // Создаем доменный кластер
      if (!clusters.containsKey(domainClusterId)) {
        clusters[domainClusterId] = NeuronCluster(
          id: domainClusterId,
          type: 'domain',
          title: domain,
          domain: domain,
          neuronIds: [],
          depth: 2,
          size: 1.5,
        );
        
        // Привязываем к категории
        clusters[categoryClusterId]!.childClusterIds.add(domainClusterId);
        clusters[domainClusterId]!.parentClusterId = categoryClusterId;
      }
      
      // Обрабатываем пути внутри домена
      final domainPaths = pathNeuronsMap[category]?[domain] ?? {};
      
      for (final pathKey in domainPaths.keys) {
        final neuronsInPath = domainPaths[pathKey]!;
        
        if (neuronsInPath.length >= 5) {
          // Создаем пагинационный кластер
          final pageClusterId = '${domainClusterId}_$pathKey';
          
          clusters[pageClusterId] = NeuronCluster(
            id: pageClusterId,
            type: 'page_group',
            title: '$pathKey (${neuronsInPath.length})',
            domain: domain,
            path: pathKey,
            neuronIds: neuronsInPath,
            depth: 3,
            size: 1.1,
          );
          
          // Привязываем к доменному кластеру
          clusters[domainClusterId]!.childClusterIds.add(pageClusterId);
          clusters[pageClusterId]!.parentClusterId = domainClusterId;
        } else {
          // Мало нейронов - добавляем напрямую в доменный кластер
          clusters[domainClusterId]!.neuronIds.addAll(neuronsInPath);
        }
      }
      
      // Если в домене остались нейроны без специфичных путей, добавляем их
      final domainNeurons = categoryNeuronsMap[category]![domain]!;
      final assignedNeurons = domainPaths.values.expand((list) => list).toSet();
      final remainingNeurons = domainNeurons.where((id) => !assignedNeurons.contains(id)).toList();
      
      if (remainingNeurons.isNotEmpty) {
        clusters[domainClusterId]!.neuronIds.addAll(remainingNeurons);
      }
    }
  }
  
  // Также создаем отдельные доменные кластеры для нейронов без категорий
  for (final domain in domainNeuronsMap.keys) {
    final domainClusterId = 'domain_$domain';
    
    // Проверяем, не был ли уже создан этот домен в какой-либо категории
    final existsInCategory = clusters.values.any((cluster) => 
        cluster.id.contains('_domain_$domain') && cluster.type == 'domain');
    
    if (!existsInCategory && !clusters.containsKey(domainClusterId)) {
      clusters[domainClusterId] = NeuronCluster(
        id: domainClusterId,
        type: 'domain',
        title: domain,
        domain: domain,
        neuronIds: domainNeuronsMap[domain]!,
        depth: 1,
        size: 1.5,
      );
      
      // Привязываем к корневому кластеру
      clusters['internet']!.childClusterIds.add(domainClusterId);
      clusters[domainClusterId]!.parentClusterId = 'internet';
    }
  }
  
  // Обновление сигнатур всех кластеров
  for (final cluster in clusters.values) {
    if (cluster.neuronIds.isNotEmpty) {
      cluster.updateSignature(this);
    }
  }
  
  print('✅ Created URL hierarchy: ${clusters.length} clusters');
}



Future<void> _createUrlDomainClustersShouldRework() async {
  final domainNeuronsMap = <String, List<int>>{};
  final categoryNeuronsMap = <String, Map<String, List<int>>>{};
  final pathNeuronsMap = <String, Map<String, Map<String, List<int>>>>{};
  final keywordNeuronsMap = <String, Map<String, List<int>>>{}; // keyword -> domain -> neurons
  final numericPatternsMap = <String, Map<String, List<int>>>{}; // pattern -> domain -> neurons

  // Расширенный словарь нормализации категорий
  String _normalizeCategory(String pathSegment) {
    final normalized = pathSegment.toLowerCase();
    
    // Форумные категории
    if (normalized.contains('forum')) return 'forums';
    if (normalized.contains('chat')) return 'chats';
    if (normalized.contains('board')) return 'forums';
    if (normalized.contains('discussion')) return 'forums';
    if (normalized.contains('thread')) return 'threads';
    if (normalized.contains('topic')) return 'topics';
    
    // Медиа категории
    if (normalized.contains('audio')) return 'audio';
    if (normalized.contains('music')) return 'audio';
    if (normalized.contains('video')) return 'video';
    if (normalized.contains('movie')) return 'video';
    if (normalized.contains('film')) return 'video';
    if (normalized.contains('podcast')) return 'audio';
    if (normalized.contains('stream')) return 'streams';
    if (normalized.contains('live')) return 'live';
    
    // Текстовые категории
    if (normalized.contains('book')) return 'books';
    if (normalized.contains('wiki')) return 'wiki';
    if (normalized.contains('article')) return 'articles';
    if (normalized.contains('blog')) return 'blogs';
    if (normalized.contains('news')) return 'news';
    if (normalized.contains('story')) return 'stories';
    if (normalized.contains('song')) return 'songs';
    if (normalized.contains('poem')) return 'poems';
    if (normalized.contains('text')) return 'texts';
    if (normalized.contains('doc')) return 'documents';
    if (normalized.contains('document')) return 'documents';
    
    // Пользовательские категории
    if (normalized.contains('user')) return 'users';
    if (normalized.contains('profile')) return 'profiles';
    if (normalized.contains('account')) return 'accounts';
    if (normalized.contains('member')) return 'members';
    
    // Поиск и теги
    if (normalized.contains('search')) return 'search';
    if (normalized.contains('query')) return 'search';
    if (normalized.contains('tag')) return 'tags';
    if (normalized.contains('category')) return 'categories';
    if (normalized.contains('label')) return 'labels';
    
    // Прочие важные категории
    if (normalized.contains('archive')) return 'archives';
    if (normalized.contains('download')) return 'downloads';
    if (normalized.contains('file')) return 'files';
    if (normalized.contains('image')) return 'images';
    if (normalized.contains('photo')) return 'photos';
    if (normalized.contains('picture')) return 'images';
    if (normalized.contains('gallery')) return 'galleries';
    if (normalized.contains('product')) return 'products';
    if (normalized.contains('item')) return 'items';
    if (normalized.contains('shop')) return 'shop';
    if (normalized.contains('store')) return 'store';
    
    return normalized;
  }

  // Универсальный парсер числовых паттернов
  Map<String, dynamic> _parseNumericPattern(List<String> pathSegments) {
    final numbers = <int>[];
    final patterns = <String>[];
    
    for (final segment in pathSegments) {
      // Пытаемся извлечь чисто числовые значения
      final number = int.tryParse(segment);
      if (number != null) {
        numbers.add(number);
        continue;
      }
      
      // Ищем числовые паттерны в смешанных строках
      final regex = RegExp(r'(\d+)');
      final matches = regex.allMatches(segment);
      
      for (final match in matches) {
        final numericValue = int.tryParse(match.group(0)!);
        if (numericValue != null) {
          numbers.add(numericValue);
        }
      }
      
      // Анализируем паттерны типа: page1, item_123, v2.0 и т.д.
      if (segment.contains(RegExp(r'[a-zA-Z]+\d+'))) {
        patterns.add(segment);
      }
    }
    
    // Определяем тип числового паттерна
    String patternType = 'unknown';
    if (numbers.isNotEmpty) {
      numbers.sort();
      final range = numbers.last - numbers.first;
      final count = numbers.length;
      
      if (count >= 3 && range <= 100) {
        patternType = 'sequential';
      } else if (count >= 2 && numbers.every((n) => n % 10 == 0)) {
        patternType = 'pagination';
      } else if (numbers.any((n) => n > 1000000)) {
        patternType = 'id_large';
      } else if (numbers.any((n) => n > 1000)) {
        patternType = 'id_medium';
      } else {
        patternType = 'id_small';
      }
    }
    
    return {
      'numbers': numbers,
      'patterns': patterns,
      'pattern_type': patternType,
      'primary_number': numbers.isNotEmpty ? numbers.first : null,
    };
  }

  // Извлечение ключевых слов из query параметров и хэштегов
  List<String> _extractKeywords(Uri uri) {
    final keywords = <String>{};
    
    // Из query параметров
    if (uri.hasQuery) {
      final queryParams = uri.queryParameters;
      for (final key in ['q', 'query', 'search', 'tag', 'keyword']) {
        final value = queryParams[key];
        if (value != null && value.isNotEmpty) {
          keywords.addAll(value.split(RegExp(r'[+\s,]')).where((word) => 
              word.length > 2).map((word) => word.toLowerCase()));
        }
      }
    }
    
    // Из фрагмента (хэштеги)
    if (uri.fragment.isNotEmpty) {
      final fragment = uri.fragment;
      if (fragment.contains('#')) {
        keywords.addAll(fragment.split('#').where((tag) => 
            tag.length > 2).map((tag) => tag.toLowerCase()));
      }
    }
    
    return keywords.toSet().toList();
  }

  // Анализ URL и группировка
  for (final neuron in neurons.values) {
    if (neuron.id == 0 || neuron.sourceUrl == null) continue;
    
    try {
      final uri = Uri.parse(neuron.sourceUrl!);
      final domain = uri.host;
      
      // Группировка по доменам
      domainNeuronsMap[domain] = [...domainNeuronsMap[domain] ?? [], neuron.id];
      
      // Извлечение ключевых слов
      final keywords = _extractKeywords(uri);
      for (final keyword in keywords) {
        if (!keywordNeuronsMap.containsKey(keyword)) {
          keywordNeuronsMap[keyword] = {};
        }
        keywordNeuronsMap[keyword]![domain] = [
          ...keywordNeuronsMap[keyword]![domain] ?? [],
          neuron.id
        ];
      }
      
      // Анализ пути для категоризации
      if (uri.path.isNotEmpty && uri.path != '/') {
        final pathSegments = uri.path.split('/').where((s) => s.isNotEmpty).toList();
        
        if (pathSegments.isNotEmpty) {
          // Анализ числовых паттернов
          final numericAnalysis = _parseNumericPattern(pathSegments);
          final numbers = numericAnalysis['numbers'] as List<int>;
          final patternType = numericAnalysis['pattern_type'] as String;
          
          if (numbers.isNotEmpty) {
            final patternKey = '${patternType}_${numbers.length}';
            if (!numericPatternsMap.containsKey(patternKey)) {
              numericPatternsMap[patternKey] = {};
            }
            numericPatternsMap[patternKey]![domain] = [
              ...numericPatternsMap[patternKey]![domain] ?? [],
              neuron.id
            ];
          }
          
          // Обработка категорий на основе первого сегмента
          final firstSegment = pathSegments[0];
          final category = _normalizeCategory(firstSegment);
          
          // Инициализация структур данных для категории
          if (!categoryNeuronsMap.containsKey(category)) {
            categoryNeuronsMap[category] = {};
          }
          if (!pathNeuronsMap.containsKey(category)) {
            pathNeuronsMap[category] = {};
          }
          
          // Группировка по доменам внутри категории
          categoryNeuronsMap[category]![domain] = [
            ...categoryNeuronsMap[category]![domain] ?? [],
            neuron.id
          ];
          
          // Создание иерархии пути
          String pathKey = firstSegment;
          
          if (pathSegments.length >= 2) {
            final secondSegment = pathSegments[1];
            final secondCategory = _normalizeCategory(secondSegment);
            
            // Если второй сегмент тоже является категорией, используем комбинацию
            if (secondCategory != secondSegment.toLowerCase()) {
              pathKey = '$firstSegment/$secondCategory';
            } else {
              pathKey = '$firstSegment/$secondSegment';
            }
            
            // Добавляем числовую информацию если есть
            if (numbers.isNotEmpty) {
              final primaryNumber = numericAnalysis['primary_number'] as int?;
              if (primaryNumber != null) {
                pathKey = '$pathKey/$primaryNumber';
              }
            }
          }
          
          if (!pathNeuronsMap[category]!.containsKey(domain)) {
            pathNeuronsMap[category]![domain] = {};
          }
          
          pathNeuronsMap[category]![domain]![pathKey] = [
            ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
            neuron.id
          ];
        }
      }
    } catch (e) {
      print('⚠️ Error parsing URL for neuron ${neuron.id}: ${neuron.sourceUrl}');
    }
  }
  
  // Создание корневого кластера "internet"
  if (!clusters.containsKey('internet')) {
    clusters['internet'] = NeuronCluster(
      id: 'internet',
      type: 'root',
      title: 'Internet',
      neuronIds: [],
      depth: 0,
      size: 2.0,
    );
  }
  
  // Создание кластера для ключевых слов
  if (!clusters.containsKey('keywords') && keywordNeuronsMap.isNotEmpty) {
    clusters['keywords'] = NeuronCluster(
      id: 'keywords',
      type: 'keyword_root',
      title: 'Keywords',
      neuronIds: [],
      depth: 1,
      size: 1.8,
    );
    clusters['internet']!.childClusterIds.add('keywords');
    clusters['keywords']!.parentClusterId = 'internet';
  }
  
  // Создание кластеров для ключевых слов
  for (final keyword in keywordNeuronsMap.keys) {
    final keywordClusterId = 'keyword_${keyword.replaceAll(RegExp(r'[^a-zA-Z0-9]'), '_')}';
    
    clusters[keywordClusterId] = NeuronCluster(
      id: keywordClusterId,
      type: 'keyword',
      title: 'Keyword: $keyword',
      neuronIds: [],
      depth: 2,
      size: 1.3,
    );
    
    // Привязываем к корню ключевых слов
    clusters['keywords']!.childClusterIds.add(keywordClusterId);
    clusters[keywordClusterId]!.parentClusterId = 'keywords';
    
    // Создаем подкластеры по доменам для каждого ключевого слова
    for (final domain in keywordNeuronsMap[keyword]!.keys) {
      final domainKeywordClusterId = '${keywordClusterId}_$domain';
      final neurons = keywordNeuronsMap[keyword]![domain]!;
      
      clusters[domainKeywordClusterId] = NeuronCluster(
        id: domainKeywordClusterId,
        type: 'keyword_domain',
        title: '$domain: $keyword',
        domain: domain,
        neuronIds: neurons,
        depth: 3,
        size: 1.1,
      );
      
      clusters[keywordClusterId]!.childClusterIds.add(domainKeywordClusterId);
      clusters[domainKeywordClusterId]!.parentClusterId = keywordClusterId;
    }
  }
  
  // Создание кластера для числовых паттернов
  if (!clusters.containsKey('numeric_patterns') && numericPatternsMap.isNotEmpty) {
    clusters['numeric_patterns'] = NeuronCluster(
      id: 'numeric_patterns',
      type: 'numeric_root',
      title: 'Numeric Patterns',
      neuronIds: [],
      depth: 1,
      size: 1.8,
    );
    clusters['internet']!.childClusterIds.add('numeric_patterns');
    clusters['numeric_patterns']!.parentClusterId = 'internet';
  }
  
  // Создание кластеров для числовых паттернов
  for (final pattern in numericPatternsMap.keys) {
    final patternClusterId = 'pattern_${pattern.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_')}';
    
    clusters[patternClusterId] = NeuronCluster(
      id: patternClusterId,
      type: 'numeric_pattern',
      title: 'Pattern: $pattern',
      neuronIds: [],
      depth: 2,
      size: 1.4,
    );
    
    clusters['numeric_patterns']!.childClusterIds.add(patternClusterId);
    clusters[patternClusterId]!.parentClusterId = 'numeric_patterns';
    
    for (final domain in numericPatternsMap[pattern]!.keys) {
      final domainPatternClusterId = '${patternClusterId}_$domain';
      final neurons = numericPatternsMap[pattern]![domain]!;
      
      clusters[domainPatternClusterId] = NeuronCluster(
        id: domainPatternClusterId,
        type: 'pattern_domain',
        title: '$domain: $pattern',
        domain: domain,
        neuronIds: neurons,
        depth: 3,
        size: 1.1,
      );
      
      clusters[patternClusterId]!.childClusterIds.add(domainPatternClusterId);
      clusters[domainPatternClusterId]!.parentClusterId = patternClusterId;
    }
  }
  
  // Создание иерархии: категория → домен → пагинационные кластеры
  for (final category in categoryNeuronsMap.keys) {
    final categoryClusterId = 'category_$category';
    
    // Создаем кластер категории
    if (!clusters.containsKey(categoryClusterId)) {
      clusters[categoryClusterId] = NeuronCluster(
        id: categoryClusterId,
        type: 'category',
        title: category,
        neuronIds: [],
        depth: 1,
        size: 1.8,
      );
      
      // Привязываем к корневому кластеру
      clusters['internet']!.childClusterIds.add(categoryClusterId);
      clusters[categoryClusterId]!.parentClusterId = 'internet';
    }
    
    // Обрабатываем домены внутри категории
    for (final domain in categoryNeuronsMap[category]!.keys) {
      final domainClusterId = '${category}_domain_$domain';
      
      // Создаем доменный кластер
      if (!clusters.containsKey(domainClusterId)) {
        clusters[domainClusterId] = NeuronCluster(
          id: domainClusterId,
          type: 'domain',
          title: domain,
          domain: domain,
          neuronIds: [],
          depth: 2,
          size: 1.5,
        );
        
        // Привязываем к категории
        clusters[categoryClusterId]!.childClusterIds.add(domainClusterId);
        clusters[domainClusterId]!.parentClusterId = categoryClusterId;
      }
      
      // Обрабатываем пути внутри домена
      final domainPaths = pathNeuronsMap[category]?[domain] ?? {};
      
      for (final pathKey in domainPaths.keys) {
        final neuronsInPath = domainPaths[pathKey]!;
        
        if (neuronsInPath.length >= 3) { // Уменьшил порог для лучшего покрытия
          // Создаем пагинационный кластер
          final pageClusterId = '${domainClusterId}_${pathKey.replaceAll(RegExp(r'[^a-zA-Z0-9]'), '_')}';
          
          clusters[pageClusterId] = NeuronCluster(
            id: pageClusterId,
            type: 'page_group',
            title: '$pathKey (${neuronsInPath.length})',
            domain: domain,
            path: pathKey,
            neuronIds: neuronsInPath,
            depth: 3,
            size: 1.1,
          );
          
          // Привязываем к доменному кластеру
          clusters[domainClusterId]!.childClusterIds.add(pageClusterId);
          clusters[pageClusterId]!.parentClusterId = domainClusterId;
        } else {
          // Мало нейронов - добавляем напрямую в доменный кластер
          clusters[domainClusterId]!.neuronIds.addAll(neuronsInPath);
        }
      }
      
      // Если в домене остались нейроны без специфичных путей, добавляем их
      final domainNeurons = categoryNeuronsMap[category]![domain]!;
      final assignedNeurons = domainPaths.values.expand((list) => list).toSet();
      final remainingNeurons = domainNeurons.where((id) => !assignedNeurons.contains(id)).toList();
      
      if (remainingNeurons.isNotEmpty) {
        clusters[domainClusterId]!.neuronIds.addAll(remainingNeurons);
      }
    }
  }
  
  // Также создаем отдельные доменные кластеры для нейронов без категорий
  for (final domain in domainNeuronsMap.keys) {
    final domainClusterId = 'domain_$domain';
    
    // Проверяем, не был ли уже создан этот домен в какой-либо категории
    final existsInCategory = clusters.values.any((cluster) => 
        cluster.id.contains('_domain_$domain') && cluster.type == 'domain');
    
    if (!existsInCategory && !clusters.containsKey(domainClusterId)) {
      clusters[domainClusterId] = NeuronCluster(
        id: domainClusterId,
        type: 'domain',
        title: domain,
        domain: domain,
        neuronIds: domainNeuronsMap[domain]!,
        depth: 1,
        size: 1.5,
      );
      
      // Привязываем к корневому кластеру
      clusters['internet']!.childClusterIds.add(domainClusterId);
      clusters[domainClusterId]!.parentClusterId = 'internet';
    }
  }
  
  // Обновление сигнатур всех кластеров
  for (final cluster in clusters.values) {
    if (cluster.neuronIds.isNotEmpty) {
      cluster.updateSignature(this);
    }
  }
  
  print('✅ Created URL hierarchy: ${clusters.length} clusters');
  print('   - Categories: ${categoryNeuronsMap.length}');
  print('   - Keywords: ${keywordNeuronsMap.length}');
  print('   - Numeric patterns: ${numericPatternsMap.length}');
  print('   - Domains: ${domainNeuronsMap.length}');
}

void _buildClusterHierarchy(Map<String, Map<String, dynamic>> structuredClusters) {
  if (!clusters.containsKey('internet')) {
    clusters['internet'] = NeuronCluster(
      id: 'internet', type: 'root', title: 'Internet', neuronIds: [], depth: 0, size: 2.0,
    );
  }
  
  for (final category in structuredClusters.keys) {
    final categoryClusterId = 'category_$category';
    clusters[categoryClusterId] = NeuronCluster(
      id: categoryClusterId, type: 'category', 
      title: '${category[0].toUpperCase()}${category.substring(1)}',
      neuronIds: [], depth: 1, size: 1.8,
    );
    
    clusters['internet']!.childClusterIds.add(categoryClusterId);
    clusters[categoryClusterId]!.parentClusterId = 'internet';
    
    final categoryData = structuredClusters[category]!;
    
    for (final domain in categoryData['domains'].keys) {
      final domainData = categoryData['domains'][domain];
      final domainClusterId = '${category}_$domain';
      
      clusters[domainClusterId] = NeuronCluster(
        id: domainClusterId, type: 'domain', title: domain, domain: domain,
        neuronIds: [], depth: 2, size: 1.5,
      );
      
      clusters[categoryClusterId]!.childClusterIds.add(domainClusterId);
      clusters[domainClusterId]!.parentClusterId = categoryClusterId;
      
      // Кластеры для книг
      for (final bookId in domainData['books'].keys) {
        final bookNeurons = domainData['books'][bookId];
        final bookClusterId = '${domainClusterId}_book_$bookId';
        clusters[bookClusterId] = NeuronCluster(
          id: bookClusterId, type: 'book', title: 'Book $bookId (${bookNeurons.length})',
          neuronIds: bookNeurons, depth: 3, size: 1.3,
        );
        clusters[domainClusterId]!.childClusterIds.add(bookClusterId);
        clusters[bookClusterId]!.parentClusterId = domainClusterId;
      }
      
      // Кластеры для страниц
      for (final pageRange in domainData['pages'].keys) {
        final pageNeurons = domainData['pages'][pageRange];
        if (pageNeurons.length >= 3) {
          final pageClusterId = '${domainClusterId}_pages_$pageRange';
          clusters[pageClusterId] = NeuronCluster(
            id: pageClusterId, type: 'page_range', title: 'Pages $pageRange (${pageNeurons.length})',
            neuronIds: pageNeurons, depth: 3, size: 1.1,
          );
          clusters[domainClusterId]!.childClusterIds.add(pageClusterId);
          clusters[pageClusterId]!.parentClusterId = domainClusterId;
        } else {
          clusters[domainClusterId]!.neuronIds.addAll(pageNeurons);
        }
      }
      
      // Оставшиеся нейроны
      final assignedNeurons = [
        ...domainData['books'].values.expand((list) => list),
        ...domainData['pages'].values.expand((list) => list),
        ...domainData['chapters'].values.expand((list) => list),
      ].toSet();
      
      final remainingNeurons = domainData['neurons']
          .where((id) => !assignedNeurons.contains(id)).toList();
      
      clusters[domainClusterId]!.neuronIds.addAll(remainingNeurons);
    }
  }
}

  
  Future<void> _createKeywordClusters() async {
    final keywordNeuronsMap = <String, List<int>>{};
    final keywordScores = <String, double>{};
    
    for (final neuron in neurons.values) {
      if (neuron.id == 0) continue;
      
      final topKeywords = _getTopKeywordsForNeuron(neuron, 10);
      for (final keyword in topKeywords) {
        if (!keywordNeuronsMap.containsKey(keyword)) {
          keywordNeuronsMap[keyword] = [];
        }
        keywordNeuronsMap[keyword]!.add(neuron.id);
        
        final wordEntry = wordIndex[keyword];

        double allRatingWordEntry = (words[wordEntry]!.allRating ?? 0).toDouble();
        double neuronAllRating = (neuron.allRating ?? 0).toDouble();
    keywordScores[keyword] = keywordScores[keyword] ?? 0.0 + allRatingWordEntry +neuronAllRating;
      }
    }
    
    final sortedKeywords = keywordScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    for (final entry in sortedKeywords) {
      final keyword = entry.key;
      final neuronIds = keywordNeuronsMap[keyword]!;
      
      if (neuronIds.length >= 5) {
        await _createKeywordClusterHierarchy(keyword, neuronIds);
      }
    }
  }
  
  Future<void> _createKeywordClusterHierarchy(String keyword, List<int> neuronIds) async {
    const maxNeuronsPerCluster = 100;
    int clusterIndex = 0;
    
    for (int i = 0; i < neuronIds.length; i += maxNeuronsPerCluster) {
      final endIndex = min(i + maxNeuronsPerCluster, neuronIds.length);
      final clusterNeuronIds = neuronIds.sublist(i, endIndex);
      
      final clusterId = 'keyword_${keyword.hashCode}_$clusterIndex';
      clusterIndex++;
      
      if (!clusters.containsKey(clusterId)) {
        final cluster = NeuronCluster(
          id: clusterId,
          type: 'keyword',
          title: '$keyword [${clusterIndex + 1}]',
          keyword: keyword,
          neuronIds: clusterNeuronIds,
          depth: 1,
          size: 1.0,
        );
        
        clusters[clusterId] = cluster;
        clusters['root']!.childClusterIds.add(clusterId);
        cluster.parentClusterId = 'root';
      } else {
        clusters[clusterId]!.neuronIds = clusterNeuronIds;
        clusters[clusterId]!.updateSignature( this);
      }
    }
  }
  
  List<String> _getTopKeywordsForNeuron(Neuron neuron, int limit) {

  final wordScores = <int, double>{};
  
  // Сначала вычисляем scores для слов из signatureRatings нейрона
   for (final wordId in neuron.signatureRatings.keys) {
    final word = network.words[wordId];
    if (word != null) {
      double score = neuron.signatureRatings[wordId]!.toDouble();
      for (final otherWordId in network.words.keys) {
        final otherWord = network.words[otherWordId];
        if (otherWord != word) {
          final connection = network.words[otherWordId]!.ratings[wordId] ?? 0;
          score += connection * 0.1;
        }
      }
      wordScores[wordId] = score;
    }
  }
  
  
  final sortedWords = wordScores.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));
  
  // Топ-15 с самым высоким рейтингом
  final topKeywords = sortedWords
      .take(15)
      .map((entry) => network.wordLibrary[entry.key] ?? 'unknown')
      .where((word) => word.length > 2)
      .toList();
  
  // Для нижних 5 используем рейтинг из network.words
  final bottomWords = <MapEntry<int, double>>[];
  
  for (final wordId in neuron.signatureRatings.keys) {
    final word = network.words[wordId];
    if (word != null) {
      // Используем allRating из network.words как основной рейтинг
      final globalScore = word.allRating.toDouble();
      bottomWords.add(MapEntry(wordId, globalScore));
    }
  }
  
  // Сортируем по возрастанию рейтинга из network.words
  bottomWords.sort((a, b) => a.value.compareTo(b.value));
  
  final bottomKeywords = bottomWords
      .take(5)
      .map((entry) => network.wordLibrary[entry.key] ?? 'unknown')
      .where((word) => word.length > 2)
      .toList();
  
  return [...topKeywords, ...bottomKeywords];
}


  // ========== ПОЗИЦИОНИРОВАНИЕ КЛАСТЕРОВ ==========
  void _positionAllClusters() {
    print('📍 Positioning ${clusters.length} clusters');
    
    clusters['root']?.updatePosition(0.0, 0.0, 0.0);
    //3_positionChildClusters('root', 0.0, 0.0, 0);
    
    for (final cluster in clusters.values) {
      cluster.updateSignature(  this);
    }
  }
  
  void _positionChildClusters(String parentId, double parentX, double parentY, int depth) {
    final parent = clusters[parentId];
    if (parent == null) return;
    
    final children = parent.childClusterIds
        .map((id) => clusters[id])
        .whereType<NeuronCluster>()
        .toList();
    
    if (children.isEmpty) return;
    
    final angleStep = (2 * pi) / children.length;
    final radius = 250.0 + (depth * 50.0);
    
    for (int i = 0; i < children.length; i++) {
      final child = children[i];
      final angle = i * angleStep;
      
      double childX, childY, childZ;
      
      // Чередуем направления: четная глубина - вверх, нечетная - вправо
      if (depth % 2 == 0) {
        // Вверх
        childX = parentX + radius * cos(angle) * 0.3;
        childY = parentY - radius * 0.8;
        childZ = radius * sin(angle) * 0.5;
      } else {
        // Вправо
        childX = parentX + radius * 0.8;
        childY = parentY + radius * sin(angle) * 0.3;
        childZ = radius * cos(angle) * 0.5;
      }
      
      //child?.updatePosition(childX, childY, childZ);
      child?.depth = depth + 1;
      child?.size = 1.0 / (depth * 0.3 + 1);
      
      // Рекурсивно позиционируем детей, но только если кластер развернут
      if (child?.isExpanded == true) {
        _positionChildClusters(child!.id, childX, childY, depth + 1);
      }
    }
  }
  
  // ИСПРАВЛЕННЫЙ МЕТОД - убираем рекурсию
  int _countExpandedChildren(String clusterId) {
    final cluster = clusters[clusterId];
    if (cluster == null) return 0;
    
    int count = 0;
    final queue = Queue<String>();
    queue.addAll(cluster.childClusterIds);
    
    while (queue.isNotEmpty) {
      final currentId = queue.removeFirst();
      final current = clusters[currentId];
      if (current == null) continue;
      
      if (current.isExpanded) {
        count++;
        queue.addAll(current.childClusterIds);
        
        // Если это листовой кластер, добавляем нейроны
        if (current.childClusterIds.isEmpty) {
          count += current.neuronIds.length.toInt();
        }
      }
    }
    
    return count;
  }

  // ========== УПРАВЛЕНИЕ КЛАСТЕРАМИ И АНИМАЦИЯ ==========
  Future<void> toggleClusterExpansion(String clusterId) async {
    final cluster = clusters[clusterId];
    if (cluster == null || _isAnimating) return;
    
    _isAnimating = true;
    
    clusterHistory.add(clusterId);
    historyIndex = clusterHistory.length - 1;
    
    if (cluster.isExpanded) {
      await _collapseCluster(cluster);
    } else {
      await _expandCluster(cluster);
    }
    
    _isAnimating = false;
    await _saveClustersToFile();
  }
  
  Future<void> _expandCluster(NeuronCluster cluster) async {
    cluster.isExpanded = true;
    expandedClusterIds.add(cluster.id);
    
    for (final childId in cluster.childClusterIds) {
      final child = clusters[childId];
      if (child != null) {
        child.isVisible = true;
        child.updatePosition(child.targetX, child.targetY, child.targetZ);
      }
    }
    
    if (cluster.childClusterIds.isEmpty) {
      _positionNeuronsInCluster(cluster);
    }
    
    await _animateClusterExpansion(cluster);
    _adjustCameraToFitClusters();
  }
  
  Future<void> _collapseCluster(NeuronCluster cluster) async {
    cluster.isExpanded = false;
    expandedClusterIds.remove(cluster.id);
    
    _hideAllChildren(cluster.id);
    _resetNeuronsToCluster(cluster);
    
    await _animateClusterCollapse(cluster);
    _adjustCameraToFitClusters();
  }
  
  void _hideAllChildren(String clusterId) {
    final cluster = clusters[clusterId];
    if (cluster == null) return;
    
    for (final childId in cluster.childClusterIds) {
      final child = clusters[childId];
      if (child != null) {
        child.isVisible = false;
        child.isExpanded = false;
        expandedClusterIds.remove(childId);
        _hideAllChildren(childId);
      }
    }
  }

  Future<void> _animateClusterExpansion(NeuronCluster cluster) async {
    final stages = <AnimationStage>[];
    final childCount = cluster.childClusterIds.length;
    
    stages.add(AnimationStage(
      duration: 0.1,
      action: () {
        cluster.size = 1.2;
        cluster.startGlow();
      },
    ));
    
    for (int i = 0; i < cluster.childClusterIds.length; i++) {
      final childId = cluster.childClusterIds[i];
      final child = clusters[childId];
      if (child != null) {
        final duration = 0.15 - (i * 0.01);
        stages.add(AnimationStage(
          duration: duration.clamp(0.05, 0.15),
          action: () {
            child.isVisible = true;
            child.animationProgress = 0.0;
            child.sourceX = cluster.x;
            child.sourceY = cluster.y;
            child.sourceZ = cluster.z;
            child.startGlow();
          },
        ));
      }
    }
    
    stages.add(AnimationStage(
      duration: 0.05,
      action: () {
        cluster.size = 1.0;
      },
    ));
    
    await _executeAnimationStages(stages);
  }
  
  Future<void> _animateClusterCollapse(NeuronCluster cluster) async {
    final stages = <AnimationStage>[];
    
    stages.add(AnimationStage(
      duration: 0.1,
      action: () {
        cluster.size = 0.9;
        cluster.startGlow();
      },
    ));
    
    stages.add(AnimationStage(
      duration: 0.1,
      action: () {
        cluster.size = 1.0;
      },
    ));
    
    await _executeAnimationStages(stages);
  }
  
  Future<void> _executeAnimationStages(List<AnimationStage> stages) async {
    for (final stage in stages) {
      stage.action();
      await Future.delayed(Duration(milliseconds: (stage.duration * 1000).round()));
    }
  }
  
  void _positionNeuronsInCluster(NeuronCluster cluster) {
    final clusterNeurons = cluster.neuronIds
        .map((id) => neurons[id])
        .whereType<Neuron>()
        .toList();
    
    final angleStep = pi / (clusterNeurons.length + 1);
    
    for (int i = 0; i < clusterNeurons.length; i++) {
      final neuron = clusterNeurons[i];
      final angle = (i + 1) * angleStep;
      final radius = 150.0;
      
      neuron.x = cluster.x + radius * cos(angle - pi/2);
      neuron.y = cluster.y + radius * sin(angle - pi/2);
      neuron.z = cluster.z;
    }
  }
  
  void _resetNeuronsToCluster(NeuronCluster cluster) {
    final random = Random(cluster.id.hashCode);
    
    for (final neuronId in cluster.neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      neuron.x = cluster.x + random.nextDouble() * 40 - 20;
      neuron.y = cluster.y + random.nextDouble() * 40 - 20;
      neuron.z = cluster.z;
    }
  }

  // ========== УПРАВЛЕНИЕ ПЕРЕТАСКИВАНИЕМ ==========
  void startClusterDrag(String clusterId, Offset startOffset) {
    final cluster = clusters[clusterId];
    if (cluster == null) return;
    
    _draggedClusterId = clusterId;
    _dragStartOffset = startOffset;
    _clusterStartOffset = Offset(cluster.x, cluster.y);
    cluster.startDrag();
  }
  
  void updateClusterDrag(Offset currentOffset) {
    if (_draggedClusterId == null || _dragStartOffset == null || _clusterStartOffset == null) return;
    
    final cluster = clusters[_draggedClusterId!];
    if (cluster == null) return;
    
    final delta = currentOffset - _dragStartOffset!;
    final newX = _clusterStartOffset!.dx + delta.dx / _cameraScale;
    final newY = _clusterStartOffset!.dy + delta.dy / _cameraScale;
    
    cluster.updatePosition(newX, newY, cluster.z);
    
    if (cluster.isExpanded) {
      _moveNeuronsWithCluster(cluster, newX, newY);
    }
  }
  
  void endClusterDrag() {
    if (_draggedClusterId != null) {
      final cluster = clusters[_draggedClusterId!];
      cluster?.endDrag();
    }
    
    _draggedClusterId = null;
    _dragStartOffset = null;
    _clusterStartOffset = null;
  }
  
  void _moveNeuronsWithCluster(NeuronCluster cluster, double newX, double newY) {
    final deltaX = newX - cluster.x;
    final deltaY = newY - cluster.y;
    
    for (final neuronId in cluster.neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron != null) {
        neuron.x += deltaX;
        neuron.y += deltaY;
      }
    }
  }

  // ========== УПРАВЛЕНИЕ КАМЕРОЙ ==========
  void _adjustCameraToFitClusters() {
    if (clusters.isEmpty) return;
    
    double minX = double.infinity;
    double maxX = double.negativeInfinity;
    double minY = double.infinity;
    double maxY = double.negativeInfinity;
    
    for (final cluster in clusters.values) {
      if (!cluster.isVisible) continue;
      
      minX = min(minX, cluster.x);
      maxX = max(maxX, cluster.x);
      minY = min(minY, cluster.y);
      maxY = max(maxY, cluster.y);
    }
    
    final centerX = (minX + maxX) / 2;
    final centerY = (minY + maxY) / 2;
    final width = maxX - minX;
    final height = maxY - minY;
    final maxDimension = max(width, height);
    
    _cameraX = -centerX;
    _cameraY = -centerY;
    _cameraScale = maxDimension > 0 ? 800 / maxDimension : 1.0;
  }
  
  void moveCameraToNeuron(int neuronId) {
    final neuron = neurons[neuronId];
    if (neuron == null) return;
    
    _cameraX = -neuron.x;
    _cameraY = -neuron.y;
    _cameraScale = 2.0;
  }

  // ========== УПРАВЛЕНИЕ ИСТОРИЕЙ И ПОИСКОМ ==========
  void undo() {
    if (historyIndex > 0) {
      historyIndex--;
      final clusterId = clusterHistory[historyIndex];
      final cluster = clusters[clusterId];
      if (cluster != null && cluster.isExpanded) {
        toggleClusterExpansion(clusterId);
      }
    }
  }
  
  void redo() {
    if (historyIndex < clusterHistory.length - 1) {
      historyIndex++;
      final clusterId = clusterHistory[historyIndex];
      final cluster = clusters[clusterId];
      if (cluster != null && !cluster.isExpanded) {
        toggleClusterExpansion(clusterId);
      }
    }
  }
  
  void setSearchedNeurons(Set<int> neuronIds) {
    searchedNeurons.clear();
    searchedNeurons.addAll(neuronIds);
    currentSearchIndex = searchedNeurons.isNotEmpty ? 0 : -1;
    
    _expandClustersToNeurons(neuronIds);
    if (neuronIds.isNotEmpty) {
      moveCameraToNeuron(neuronIds.first);
    }
  }
  
  void _expandClustersToNeurons(Set<int> neuronIds) {
    final clustersToExpand = <String>{};
    
    for (final neuronId in neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      for (final cluster in clusters.values) {
        if (cluster.neuronIds.contains(neuronId)) {
          _addClusterAndAncestorsToSet(cluster.id, clustersToExpand);
        }
      }
    }
    
    for (final clusterId in clustersToExpand) {
      final cluster = clusters[clusterId];
      if (cluster != null && !cluster.isExpanded) {
        toggleClusterExpansion(clusterId);
      }
    }
  }
  
  void _addClusterAndAncestorsToSet(String clusterId, Set<String> clusterSet) {
    if (clusterSet.contains(clusterId)) return;
    
    clusterSet.add(clusterId);
    
    final cluster = clusters[clusterId];
    if (cluster?.parentClusterId != null) {
      _addClusterAndAncestorsToSet(cluster!.parentClusterId!, clusterSet);
    }
  }
  
  void navigateToNextSearchedNeuron() {
    if (searchedNeurons.isEmpty) return;
    
    currentSearchIndex = (currentSearchIndex + 1) % searchedNeurons.length;
    _focusOnNeuron(searchedNeurons.elementAt(currentSearchIndex));
  }
  
  void navigateToPreviousSearchedNeuron() {
    if (searchedNeurons.isEmpty) return;
    
    currentSearchIndex = (currentSearchIndex - 1) % searchedNeurons.length;
    if (currentSearchIndex < 0) currentSearchIndex = searchedNeurons.length - 1;
    
    _focusOnNeuron(searchedNeurons.elementAt(currentSearchIndex));
  }
  
  void _focusOnNeuron(int neuronId) {
    moveCameraToNeuron(neuronId);
  }

  // ========== СОХРАНЕНИЕ И ЗАГРУЗКА ==========
  Future<void> _saveClustersToFile() async {
    try {
      final clustersJson = {
        'clusters': clusters.values.map((cluster) => cluster.toJson()).toList(),
        'lastUpdated': DateTime.now().toIso8601String(),
      };
      
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/$clustersDataPath');
      await file.create(recursive: true);
      await file.writeAsString(jsonEncode(clustersJson));
      
      print('💾 Clusters saved to: $clustersDataPath');
    } catch (e) {
      print('❌ Error saving clusters: $e');
    }
  }
  
  Future<void> _loadClustersFromFile() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/$clustersDataPath');
      
      if (await file.exists()) {
        final data = await file.readAsString();
        final jsonData = jsonDecode(data);
        clusters.clear();
        
        for (final clusterJson in jsonData['clusters']) {
          final cluster = NeuronCluster.fromJson(clusterJson);
          clusters[cluster.id] = cluster;
        }
        
        print('📂 Loaded ${clusters.length} clusters from file');
      }
    } catch (e) {
      print('❌ Error loading clusters: $e');
      clusters.clear();
    }
  }



  // ========== ОСТАЛЬНЫЕ МЕТОДЫ ==========
  void setState(VoidCallback fn) {
    fn();
  }

  List<String> _extractWords(String text) {
    return text
        .toLowerCase()
        .split(RegExp(r'[^\wа-яА-ЯёЁ]+', unicode: true))
        .where((w) => w.length > 2)
        .toList();
  }



  Future<void> trainTest(Function(String) onProgress) async {
    onProgress('Начало обучения...');
    
    for (int chapter = 1; chapter <= 121; chapter++) {
      final url = 'https://hpmor.ru/book/1/$chapter/';
      
      onProgress('Обработка главы $chapter/121...');
      
      try {
        await processWebsite(url, onProgress);
        
        final fragmentCount = fragments.length;
        final wordCount = words.length;
        onProgress('Глава $chapter: $wordCount слов, $fragmentCount фрагментов');
        
        final recentFragments = fragments.values
            .where((f) => f.id > max(0, fragmentCount - 50))
            .take(10)
            .toList();
        
        for (final fragment in recentFragments) {
          final shortText = fragment.text.length > 60 
              ? fragment.text.substring(0, 60) + "..." 
              : fragment.text;
        }
        
        final topWords = getTopWords(10);
        final topWordsText = topWords
            .map((w) => '${wordLibrary[w.id]}:${w.allRating}')
            .join(', ');
        onProgress('  Топ слова: $topWordsText');
        
        if (chapter % 10 == 0) {
          await saveToFile();
          onProgress('Чекпоинт главы $chapter сохранён');
        }
      } catch (e) {
        onProgress('Ошибка главы $chapter: $e');
      }
      
      await Future.delayed(Duration(milliseconds: 100));
    }
    
    await saveToFile();
    onProgress('Обучение завершено! ${words.length} слов, ${fragments.length} фрагментов');
  }


  Future<void> trainTest2(Function(String) onProgress) async {
    onProgress('Начало обучения...');
    
    for (int chapter = 1; chapter <= 98; chapter++) {
      final url = 'https://strugacki.ru/book_25/${1002+chapter}.html';
      
      onProgress('Обработка главы $chapter/93...');
      
      try {
        await processWebsite(url, onProgress);
        
        final fragmentCount = fragments.length;
        final wordCount = words.length;
        onProgress('Глава $chapter: $wordCount слов, $fragmentCount фрагментов');
        
        final recentFragments = fragments.values
            .where((f) => f.id > max(0, fragmentCount - 50))
            .take(10)
            .toList();
        
        for (final fragment in recentFragments) {
          final shortText = fragment.text.length > 60 
              ? fragment.text.substring(0, 60) + "..." 
              : fragment.text;
        }
        
        final topWords = getTopWords(10);
        final topWordsText = topWords
            .map((w) => '${wordLibrary[w.id]}:${w.allRating}')
            .join(', ');
        onProgress('  Топ слова: $topWordsText');
        
        if (chapter % 10 == 0) {
          await saveToFile();
          onProgress('Чекпоинт главы $chapter сохранён');
        }
      } catch (e) {
        onProgress('Ошибка главы $chapter: $e');
      }
      
      await Future.delayed(Duration(milliseconds: 1000));
    }
    
    await saveToFile();
    onProgress('Обучение завершено! ${words.length} слов, ${fragments.length} фрагментов');
  }
  
  List<int> _removeDuplicateFragments(List<int> fragmentIds) {
    final seenTexts = <String>{};
    final uniqueIds = <int>[];
    
    for (final id in fragmentIds) {
      final fragment = fragments[id];
      if (fragment != null && !seenTexts.contains(fragment.text)) {
        seenTexts.add(fragment.text);
        uniqueIds.add(id);
      }
    }
    return uniqueIds;
  }
  
  Future<List<int>> _generateLine2WithPossibilityVector(List<int> line1Words, List<int> promptWordIds) async {
    final possibilityVector = <int, int>{};
    
    for (final wordId in line1Words) {
      for (final fragment in fragments.values) {
        final wordIds = fragment.wordIds;
        for (int i = 0; i < wordIds.length - 1; i++) {
          if (wordIds[i] == wordId) {
            final nextWordId = wordIds[i + 1];
            if (!STOP_WORDS.contains(wordLibrary[nextWordId])) {
              possibilityVector[nextWordId] = (possibilityVector[nextWordId] ?? 0) + 1;
            }
          }
        }
      }
    }
    
    if (possibilityVector.isEmpty) {
      final line2SuperVector = <int, int>{};
      for (final wordId in line1Words) {
        final word = words[wordId];
        if (word != null) {
          for (final entry in word.ratings.entries) {
            line2SuperVector[entry.key] = 
                (line2SuperVector[entry.key] ?? 0) + entry.value;
          }
        }
      }
      
      return (line2SuperVector.entries.toList()
        ..sort((a, b) => b.value.compareTo(a.value)))
          .take(50)
          .map((e) => e.key)
          .toList();
    }
    
    final totalOccurrences = possibilityVector.values.fold(0, (a, b) => a + b);
    final weightVector = <int, double>{};
    for (final entry in possibilityVector.entries) {
      weightVector[entry.key] = entry.value / totalOccurrences;
    }
    
    final scoredWords = <int, double>{};
    for (final wordId in weightVector.keys) {
      final word = words[wordId];
      if (word != null) {
        final wordVectorSum = word.ratings.values.fold(0, (a, b) => a + b);
        final contextScore = wordVectorSum > 0 ? word.allRating / wordVectorSum : 0.0;
        scoredWords[wordId] = weightVector[wordId]! * contextScore;
      }
    }
    
    return (scoredWords.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value)))
        .take(50)
        .map((e) => e.key)
        .toList();
  }

/// Генерация пятой линии - интеллектуальный ответ с максимальным allRating
Future<List<int>> makeLine5ForAPrompt(List<int> promptWordIds) async {
  if (promptWordIds.isEmpty) {
    
    await AppLogger.writeLog("makeLine5 no prompt");
    return [];}
  
  // Строим супервектор из промпта
  final promptSuperVector = <int, int>{};
  for (final wordId in promptWordIds) {
    final word = words[wordId];
    if (word != null) {
      for (final entry in word.ratings.entries) {
        promptSuperVector[entry.key] = (promptSuperVector[entry.key] ?? 0) + entry.value;
      }
    }
  }
  
  // Самопроекция для получения качественного вектора
  final promptVector = VectorOperations.selfProjection(promptSuperVector, words);
  if (promptVector.isEmpty) return [];
  
  // Находим слова с максимальным пересечением и высоким allRating
  final wordScores = <int, _WordScore>{};
  
  for (final wordId in promptVector.keys) {
    final word = words[wordId];
    if (word == null) continue;
    
    // Вычисляем пересечение векторов (схожесть)
    double vectorIntersection = 0.0;
    for (final entry in word.ratings.entries) {
      if (promptVector.containsKey(entry.key)) {
        vectorIntersection += min(entry.value, promptVector[entry.key]!).toDouble();
      }
    }
    
    // Нормализуем пересечение
    final maxPossibleIntersection = word.ratings.values.fold(0, (a, b) => a + b);
    final normalizedIntersection = maxPossibleIntersection > 0 ? 
        vectorIntersection / maxPossibleIntersection : 0.0;
    
    // Учитываем allRating
    final allRatingScore = word.allRating / 1000000.0; // Нормализуем
    
    // Комбинированный score: 70% пересечение, 30% allRating
    final combinedScore = (normalizedIntersection * 0.7) + (allRatingScore * 0.3);
    
    wordScores[wordId] = _WordScore(
      wordId: wordId,
      intersectionScore: normalizedIntersection,
      allRatingScore: allRatingScore,
      combinedScore: combinedScore,
    );
  }
  
  // Сортируем по комбинированному score
  final sortedScores = wordScores.values.toList()
    ..sort((a, b) => b.combinedScore.compareTo(a.combinedScore));
  await AppLogger.writeLog("makeLine5 finished with ${sortedScores.length} output");
  // Берем топ 50 слов
  return sortedScores.take(50).map((score) => score.wordId).toList();
}



/// Нормализация вектора по формуле: (rating1/allRating1 + rating2/allRating2) / 2
Map<int, double> _normalizeVectorWithMutualProbability(Map<int, int> vector) {
  final normalized = <int, double>{};
  final wordIds = vector.keys.toList();
  
  // Для каждой пары слов в векторе вычисляем взаимную вероятность
  for (int i = 0; i < wordIds.length; i++) {
    final word1Id = wordIds[i];
    final word1 = network.words[word1Id];
    if (word1 == null) continue;
    
    for (int j = 0; j < wordIds.length; j++) {
      if (i == j) continue; // Пропускаем одинаковые слова
      
      final word2Id = wordIds[j];
      final word2 = network.words[word2Id];
      if (word2 == null) continue;
      
      // Вычисляем взаимные рейтинги
      final rating1to2 = word1.ratings[word2Id] ?? 0;
      final rating2to1 = word2.ratings[word1Id] ?? 0;
      
      // Применяем формулу: (rating1/allRating1 + rating2/allRating2) / 2
      final prob1 = word1.allRating > 0 ? rating1to2 / word1.allRating : 0;
      final prob2 = word2.allRating > 0 ? rating2to1 / word2.allRating : 0;
      
      final mutualProbability = (prob1 + prob2) / 2;
      
      // Распределяем вероятность между обоими словами
      normalized[word1Id] = (normalized[word1Id] ?? 0) + mutualProbability;
      normalized[word2Id] = (normalized[word2Id] ?? 0) + mutualProbability;
    }
  }
  
  // Нормализуем чтобы сумма вероятностей = 1
  final total = normalized.values.fold(0.0, (a, b) => a + b);
  if (total > 0) {
    for (final key in normalized.keys) {
      normalized[key] = normalized[key]! / total;
    }
  }
  
  return normalized;
}
_VectorStats _analyzeVector(Map<int, int> vector) {
  if (vector.isEmpty) {
    return _VectorStats(
      network: network,
      minValue: 0.0,
      maxValue: 0.0,
      valueRange: 0.0,
      mean: 0.0,
      standardDeviation: 0.0,
    );
  }

  // Нормализуем вектор по формуле взаимных вероятностей
  final normalizedVector = _normalizeVectorWithMutualProbability(vector);
  
  final values = normalizedVector.values.toList();
  final minValue = values.reduce((a, b) => a < b ? a : b);
  final maxValue = values.reduce((a, b) => a > b ? a : b);
  final valueRange = maxValue - minValue;
  
  final mean = values.fold(0.0, (a, b) => a + b) / values.length;
  final variance = values.map((v) => pow(v - mean, 2)).fold(0.0, (a, b) => a + b) / values.length;
  final standardDeviation = sqrt(variance);

  return _VectorStats(
    network: network,
    minValue: minValue,
    maxValue: maxValue,
    valueRange: valueRange,
    mean: mean,
    standardDeviation: standardDeviation,
  );
}




/// Генерация строки — «line8» — осмысленный ответ (string)
Future<String> makeLine8ForAPrompt(List<int> promptWordIds) async {
  if (promptWordIds.isEmpty) {
    await AppLogger.writeLog("makeLine8 no prompt");
    return '';
  }

  // Получаем кандидатов из уже существующих генераторов параллельно
  final results = await Future.wait([
   makeLine6ForAPrompt(promptWordIds),
    makeLine5ForAPrompt(promptWordIds),
  ]);

  final candidates7 = results[0]; // вероятно более «сложные» кандидаты
  final candidates5 = results[1]; // более частотные / глобальные

  // Собираем и взвешиваем кандидатов
  final scoreMap = <int, double>{};
  int pos = 0;
  for (final id in candidates7) {
    // даём больший вес тем что из makeLine7 (ранг + allRating)
    final w = words[id];
    final base = (w?.allRating ?? 1).toDouble();
    scoreMap[id] = (scoreMap[id] ?? 0.0) + base * (1.0 + (100.0 / (1 + pos)));
    pos++;
  }
  pos = 0;
  for (final id in candidates5) {
    final w = words[id];
    final base = (w?.allRating ?? 1).toDouble();
    scoreMap[id] = (scoreMap[id] ?? 0.0) + base * (0.6 + (50.0 / (1 + pos)));
    pos++;
  }

  if (scoreMap.isEmpty) {
    await AppLogger.writeLog("makeLine8 no candidates");
    return '';
  }

  // Сортируем кандидатов по скору
  final sorted = scoreMap.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));

  // Убираем дубликаты, стоп-слова и собираем финальный порядок
  final used = <int>{};
  final finalIds = <int>[];
  final rng = Random();

  // Список коннекторов для естественности
  final connectors = ['и', 'но', 'а', 'также', 'затем', 'однако'];

  // Функция проверки стоп-слов (использует существующий STOP_WORDS set)
  bool isStopWordId(int id) {
    final wname = wordLibrary[id];
    if (wname == null) return true;
    return STOP_WORDS.contains(wname.toLowerCase());
  }

  // Сначала пробуем взять первый значимый (не-стоп) как начало
  for (final e in sorted) {
    final id = e.key;
    if (used.contains(id)) continue;
    if (isStopWordId(id)) continue;
    finalIds.add(id);
    used.add(id);
    break;
  }

  // Затем добавляем ещё слов до длины предложения (6..12)
  final targetLen = min(12, max(6, 6 + rng.nextInt(7))); // 6..12
  for (final e in sorted) {
    if (finalIds.length >= targetLen) break;
    final id = e.key;
    if (used.contains(id)) continue;
    finalIds.add(id);
    used.add(id);
  }

  // Если получилось мало слов — добавим несколько стоп-слов по необходимости
  if (finalIds.length < 4) {
    for (final e in sorted) {
      if (finalIds.length >= 4) break;
      final id = e.key;
      if (used.contains(id)) continue;
      finalIds.add(id);
      used.add(id);
    }
  }

  // Построение строки с простыми связками: вставляем периодически коннектор
  final wordsOut = <String>[];
  for (int i = 0; i < finalIds.length; i++) {
    final id = finalIds[i];
    final token = wordLibrary[id] ?? '';
    if (token.isEmpty) continue;

    // Иногда вставляем связку перед словом для естественности
    if (i > 1 && rng.nextDouble() < 0.18) {
      wordsOut.add(connectors[rng.nextInt(connectors.length)]);
    }

    wordsOut.add(token);
  }

  if (wordsOut.isEmpty) return '';

  // Преобразование в валидную фразу: корректировка пунктуации, заглавная буква
  String sentence = wordsOut.join(' ');

  // Убираем лишние пробелы перед запятыми/точками (если такие возникнут)
  sentence = sentence.replaceAll(RegExp(r'\s+,'), ',');
  sentence = sentence.replaceAll(RegExp(r'\s+\.'), '.');

  // Ограничение длины символов (без разрыва слов)
  if (sentence.length > 240) {
    sentence = sentence.substring(0, 240);
    // Обрезаем до последнего пробела чтобы не резать слово
    final lastSpace = sentence.lastIndexOf(' ');
    if (lastSpace > 0) sentence = sentence.substring(0, lastSpace);
    sentence = sentence.trim();
    sentence = sentence + '...';
  }

  // Заглавная первая буква
  sentence = sentence.trim();
  if (sentence.isNotEmpty) {
    sentence = sentence[0].toUpperCase() + sentence.substring(1);
  }

  // Завершающий знак
  if (!RegExp(r'[.!?]$').hasMatch(sentence)) {
    sentence = '$sentence.';
  }

  await AppLogger.writeLog("makeLine8 finished: $sentence");
  return sentence;
}


Future<List<int>> makeLine7ForAPrompt(List<int> promptWordIds) async {
  if (promptWordIds.isEmpty) {
    await AppLogger.writeLog("makeLine7 no prompt");
    return [];
  }
  return [];

  // Кэшируем нормализованные векторы слов чтобы не пересчитывать каждый раз
  final normalizedWordCache = <int, Map<int, double>>{};
  
  // Строим супервектор из промпта и самопроекция
  final promptSuperVector = <int, int>{};
  for (final wordId in promptWordIds) {
    final word = words[wordId];
    if (word != null) {
      for (final entry in word.ratings.entries) {
        promptSuperVector[entry.key] = (promptSuperVector[entry.key] ?? 0) + entry.value;
      }
    }
  }
  
  final originalPromptVector = VectorOperations.selfProjection(promptSuperVector, words);
  if (originalPromptVector.isEmpty) return [];

  // Нормализуем исходный вектор по новой формуле
  final normalizedPromptVector = _normalizeVectorWithFormula(originalPromptVector);
  
  final resultWords = <int>[];
  Map<int, double> currentVector = Map<int, double>.from(normalizedPromptVector);
  final usedWordIds = Set<int>.from(promptWordIds);
  
  // Статистика по allRating для балансировки
  int highRatingCount = 0;
  int mediumRatingCount = 0;
  int lowRatingCount = 0;

  // Предварительно вычисляем тензорные операции для промпта
  Map<int, double> processedVector = _applyTensorOperations(currentVector);
  double currentEntropy = _calculateShannonEntropy(processedVector);
  _VectorStats vectorStats = _analyzeEnhancedVector(processedVector);

  // Пошагово добавляем 11 слов с оптимизированной логикой
  for (int step = 0; step < 9; step++) {
    final allRatingBalance = _calculateAllRatingBalance(highRatingCount, mediumRatingCount, lowRatingCount);
    
    final strategy = _determineEnhancedStrategy(
      currentEntropy, 
      vectorStats, 
      allRatingBalance,
      step
    );

    await AppLogger.writeLog(
      "Step $step: entropy=${currentEntropy.toStringAsFixed(3)}, "
      "balance=[H:$highRatingCount M:$mediumRatingCount L:$lowRatingCount]"
    );

    final candidateScores = <int, _EnhancedCandidateScore>{};

    // Ограничиваем поиск кандидатов только топ-N слов из текущего вектора
    final candidateWordIds = _getTopCandidateWords(processedVector, 100); // Ограничиваем до 100 кандидатов

    for (final wordId in candidateWordIds) {
      if (usedWordIds.contains(wordId)) continue;
      
      final word = words[wordId];
      if (word == null) continue;

      // Используем кэш для нормализованного вектора слова
      final wordNormalized = normalizedWordCache[wordId] ?? _normalizeWordVector(word);
      normalizedWordCache[wordId] = wordNormalized;

      // Быстрое вычисление сходства без полного перебора
      final similarityScore = _calculateFastSimilarity(processedVector, wordNormalized);
      
      // Быстрое предсказание нового вектора (простое сложение)
      final predictedVector = _fastVectorAddition(processedVector, wordNormalized);
      
      // Применяем тензорные операции к предсказанному вектору
      final predictedProcessedVector = _applyTensorOperations(predictedVector);
      final predictedEntropy = _calculateShannonEntropy(predictedProcessedVector);
      final entropyChange = predictedEntropy - currentEntropy;

      // Оценка баланса allRating
      final wordAllRating = word.allRating;
      final allRatingScore = _evaluateAllRatingContribution(
        wordAllRating, 
        strategy, 
        highRatingCount, 
        mediumRatingCount, 
        lowRatingCount
      );

      final combinedScore = strategy.calculateScore(
        similarityScore: similarityScore,
        entropyChange: entropyChange,
        allRatingScore: allRatingScore,
        currentStep: step,
      );

      candidateScores[wordId] = _EnhancedCandidateScore(
        wordId: wordId,
        similarityScore: similarityScore,
        entropyChange: entropyChange,
        allRatingScore: allRatingScore,
        combinedScore: combinedScore,
        wordAllRating: wordAllRating,
      );
    }

    if (candidateScores.isEmpty) break;

    // Выбираем лучшего кандидата
    final bestCandidate = _getBestCandidate(candidateScores);
    final bestWordId = bestCandidate.wordId;
    final bestWord = words[bestWordId];

    // Добавляем слово и обновляем статистику
    resultWords.add(bestWordId);
    usedWordIds.add(bestWordId);
    
    // Обновляем счетчики allRating
    if (bestWord != null) {
      if (bestWord.allRating > 500000) highRatingCount++;
      else if (bestWord.allRating > 100000) mediumRatingCount++;
      else lowRatingCount++;
    }

    // ОПТИМИЗАЦИЯ: Быстрое обновление текущего вектора
    final bestWordNormalized = normalizedWordCache[bestWordId] ?? _normalizeWordVector(bestWord!);
    currentVector = _fastVectorAddition(currentVector, bestWordNormalized!);
    
    // ОПТИМИЗАЦИЯ: Обновляем processedVector и энтропию инкрементально
    processedVector = _applyTensorOperations(currentVector);
    currentEntropy = _calculateShannonEntropy(processedVector);
    vectorStats = _analyzeEnhancedVector(processedVector);

    // Упрощенное согласование с промптом
    _fastReconcileWithPrompt(currentVector, normalizedPromptVector, step / 11.0);
  }
final line7 = resultWords.map((id)=>wordLibrary[id]??'').join(' ');
  await AppLogger.writeLog("makeLine7 finished with ${resultWords.length} words: ${resultWords} line7: ${line7}");
  

  return resultWords;
}

/// ОПТИМИЗИРОВАННЫЕ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ

/// Быстрое сложение векторов
Map<int, double> _fastVectorAddition(Map<int, double> vector1, Map<int, double> vector2) {
  final result = Map<int, double>.from(vector1);
  for (final entry in vector2.entries) {
    result[entry.key] = (result[entry.key] ?? 0) + entry.value;
  }
  return result;
}

/// Быстрое вычисление сходства
double _calculateFastSimilarity(Map<int, double> vector, Map<int, double> wordVector) {
  double similarity = 0.0;
  int commonCount = 0;
  
  // Итерируем только по меньшему вектору для оптимизации
  final searchVector = wordVector.length < vector.length ? wordVector : vector;
  final targetVector = wordVector.length < vector.length ? vector : wordVector;
  
  for (final entry in searchVector.entries) {
    if (targetVector.containsKey(entry.key)) {
      similarity += min(entry.value, targetVector[entry.key]!);
      commonCount++;
    }
  }
  
  return commonCount > 0 ? similarity / commonCount : 0.0;
}

/// Выбор топ-N кандидатов для ограничения поиска
List<int> _getTopCandidateWords(Map<int, double> vector, int limit) {
  final entries = vector.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));
  
  final topWords = entries.take(limit).map((e) => e.key).toList();
  final bottomWords = entries.reversed.take(15).map((e) => e.key).toList();
  
  return [...topWords, ...bottomWords];
}

/// Быстрый выбор лучшего кандидата
_EnhancedCandidateScore _getBestCandidate(Map<int, _EnhancedCandidateScore> candidates) {
  _EnhancedCandidateScore? bestCandidate;
  double bestScore = -double.infinity;
  
  for (final candidate in candidates.values) {
    if (candidate.combinedScore > bestScore) {
      bestScore = candidate.combinedScore;
      bestCandidate = candidate;
    }
  }
  
  return bestCandidate!;
}

/// Упрощенное согласование с промптом
void _fastReconcileWithPrompt(
  Map<int, double> currentVector, 
  Map<int, double> promptVector, 
  double progress
) {
  final promptWeight = 0.3 * (1.0 - progress);
  
  for (final entry in promptVector.entries) {
    currentVector[entry.key] = (currentVector[entry.key] ?? 0) * (1 - promptWeight) + 
                              entry.value * promptWeight;
  }
}
 
double _calculateShannonEntropy(Map<int, double> vector) {
  if (vector.isEmpty) return 0.0;

  final values = vector.values.toList();
  final total = values.fold(0.0, (a, b) => a + b);
  
  if (total <= 0 || total.isInfinite || total.isNaN) return 0.0;

  double entropy = 0.0;
  for (final value in values) {
    if (value <= 0) continue;
    final probability = value / total;
    if (probability > 0 && !probability.isInfinite && !probability.isNaN) {
      entropy -= probability * log(probability);
    }
  }

  // Защита от некорректных значений
  return entropy.isNaN || entropy.isInfinite ? 0.0 : entropy;
}
/// Нормализация вектора по формуле: (rating1/allRating1 + rating2/allRating2) / 2
Map<int, double> _normalizeVectorWithFormula(Map<int, int> vector) {
  final normalized = <int, double>{};
  final wordIds = vector.keys.toList();
  
  for (int i = 0; i < wordIds.length; i++) {
    for (int j = i + 1; j < wordIds.length; j++) {
      final word1Id = wordIds[i];
      final word2Id = wordIds[j];
      
      final word1 = words[word1Id];
      final word2 = words[word2Id];
      
      if (word1 == null || word2 == null) continue;
      
      final rating1to2 = word1.ratings[word2Id] ?? 0;
      final rating2to1 = word2.ratings[word1Id] ?? 0;
      
      final prob1 = word1.allRating > 0 ? rating1to2 / word1.allRating : 0;
      final prob2 = word2.allRating > 0 ? rating2to1 / word2.allRating : 0;
      
      final mutualWeight = (prob1 + prob2) / 2;
      
      // Распределяем вес между обоими словами
      normalized[word1Id] = (normalized[word1Id] ?? 0) + mutualWeight;
      normalized[word2Id] = (normalized[word2Id] ?? 0) + mutualWeight;
    }
  }
  
  return normalized;
}

/// Нормализация вектора отдельного слова
Map<int, double> _normalizeWordVector(Word word) {
  final normalized = <int, double>{};
  
  for (final entry in word.ratings.entries) {
    final otherWord = words[entry.key];
    if (otherWord != null) {
      final rating1to2 = entry.value;
      final rating2to1 = otherWord.ratings[word.id] ?? 0;
      
      final prob1 = word.allRating > 0 ? rating1to2 / word.allRating : 0;
      final prob2 = otherWord.allRating > 0 ? rating2to1 / otherWord.allRating : 0;
      
      final mutualWeight = (prob1 + prob2) / 2;
      
      normalized[entry.key] = mutualWeight;
    }
  }
  
  return normalized;
}

/// Тензорные операции для обработки вектора
Map<int, double> _applyTensorOperations(Map<int, double> vector) {
  if (vector.isEmpty) return vector;
  
  final processed = Map<int, double>.from(vector);
  
  // 1. Нормализация L2 с защитой от деления на ноль
  final l2Norm = sqrt(vector.values.map((v) => v * v).fold(0.0, (a, b) => a + b));
  if (l2Norm > 1e-10) { // Защита от слишком малых значений
    for (final key in processed.keys) {
      processed[key] = processed[key]! / l2Norm;
    }
  }
  
  // 2. Нелинейное преобразование с ограничением
  for (final key in processed.keys) {
    processed[key] = max(0.0, min(1.0, processed[key]! * 1.5 - 0.2)); // Ограничиваем диапазон
  }
  
  // 3. Softmax с защитой от переполнения
  final maxVal = processed.values.fold(-double.infinity, (a, b) => max(a, b));
  final expValues = processed.values.map((v) => exp(v - maxVal)).toList(); // Стабилизация
  final sumExp = expValues.fold(0.0, (a, b) => a + b);
  
  if (sumExp > 1e-10) {
    final keys = processed.keys.toList();
    for (int i = 0; i < keys.length; i++) {
      processed[keys[i]] = expValues[i] / sumExp;
    }
  }
  
  return processed;
}
/// Расчет баланса allRating
double _calculateAllRatingBalance(int high, int medium, int low) {
  final total = high + medium + low;
  if (total == 0) return 0.5;
  
  final highRatio = high / total;
  final lowRatio = low / total;
  
  // Идеальный баланс: 40% high, 30% medium, 30% low
  const idealHigh = 0.4;
  const idealLow = 0.3;
  
  final highDeviation = (highRatio - idealHigh).abs();
  final lowDeviation = (lowRatio - idealLow).abs();
  
  return 1.0 - (highDeviation + lowDeviation) / 2;
}



/// Генерация шестой линии - минимальный allRating, максимальная связь
Future<List<int>> makeLine6ForAPrompt(List<int> promptWordIds) async {
    if (promptWordIds.isEmpty) {
    
    await AppLogger.writeLog("makeLine6 no prompt");
    return [];}
  
  // Строим супервектор из промпта
  final promptSuperVector = <int, int>{};
  for (final wordId in promptWordIds) {
    final word = words[wordId];
    if (word != null) {
      for (final entry in word.ratings.entries) {
        promptSuperVector[entry.key] = (promptSuperVector[entry.key] ?? 0) + entry.value;
      }
    }
  }
  
  final promptVector = VectorOperations.selfProjection(promptSuperVector, words);
  if (promptVector.isEmpty) return [];
  
  final wordScores = <int, _WordScore>{};
  
  for (final wordId in promptVector.keys) {
    final word = words[wordId];
    if (word == null) continue;
    
    // Вычисляем пересечение векторов
    double vectorIntersection = 0.0;
    for (final entry in word.ratings.entries) {
      if (promptVector.containsKey(entry.key)) {
        vectorIntersection += min(entry.value, promptVector[entry.key]!).toDouble();
      }
    }
    
    final maxPossibleIntersection = word.ratings.values.fold(0, (a, b) => a + b);
    final normalizedIntersection = maxPossibleIntersection > 0 ? 
        vectorIntersection / maxPossibleIntersection : 0.0;
    
    // Инвертируем allRating (чем меньше - тем лучше)
    final invertedAllRating = 1.0 / (word.allRating + 1); // +1 чтобы избежать деления на 0
    
    // Комбинированный score: 80% пересечение, 20% инвертированный allRating
    final combinedScore = (normalizedIntersection * 0.8) + (invertedAllRating * 0.2);
    
    wordScores[wordId] = _WordScore(
      wordId: wordId,
      intersectionScore: normalizedIntersection,
      allRatingScore: invertedAllRating,
      combinedScore: combinedScore,
    );
  }
  
  final sortedScores = wordScores.values.toList()
    ..sort((a, b) => b.combinedScore.compareTo(a.combinedScore));
  await AppLogger.writeLog("makeLine6 finished with ${sortedScores.length} output");
  return sortedScores.take(50).map((score) => score.wordId).toList();
}

  // ========== ОБРАБОТКА ЗАПРОСОВ ==========

/// Обновляем метод обработки запросов
Future<Map<String, dynamic>> processQueryAdvanced(String query) async {
  final wordTexts = _extractWords(query);
  final promptWordIds = wordTexts
      .map((w) => wordIndex[w])
      .where((id) => id != null)
      .cast<int>()
      .toList();
  
  if (promptWordIds.isEmpty) {
    return {'line1': '', 'line2': '', 'line3': '', 'line5': '', 'line6': '','line7':'', 'fragments': []};
  }
  
  currentSearchWords = promptWordIds;
  //selectedWordIds = promptWordIds.toSet();
  final querySemantics = SemanticAnalyzer.analyzeSemantics(query);
  
  final superVector = <int, int>{};
  for (final wordId in promptWordIds) {
    final word = words[wordId];
    if (word != null) {
      for (final entry in word.ratings.entries) {
        superVector[entry.key] = (superVector[entry.key] ?? 0) + entry.value;
      }
    }
  }
  
  final promptVector = VectorOperations.selfProjection(superVector, words);
  currentSearchVector = promptVector;
  
  // Генерация всех линий
  final line1Words = promptWordIds.take(10).toList();
  final line1 = line1Words.map((id) => wordLibrary[id] ?? '').join(' ');
  
  final line2Words = await _generateLine2WithPossibilityVector(line1Words, promptWordIds);
  final line2 = TextNormalizer.normalizeText(
      line2Words.map((id) => wordLibrary[id] ?? '').join(' '));
  
  final line3Fragments = await _findFragmentsWithMaxCoverage(promptVector, promptWordIds, querySemantics);
  final uniqueFragments = _removeDuplicateFragments(line3Fragments);
  final line3 = uniqueFragments
      .take(10)
      .map((id) => fragments[id]?.text ?? '')
      .join(' ... ');
  
  // Новые линии 5 и 6
  final line5Words = await makeLine5ForAPrompt(promptWordIds);
  final line5 = line5Words.take(20).map((id) => wordLibrary[id] ?? '').join(' ');
  
  final line6Words = await makeLine6ForAPrompt(promptWordIds);
  final line6 = line6Words.take(20).map((id) => wordLibrary[id] ?? '').join(' ');
  

  final line7Words = await makeLine7ForAPrompt(promptWordIds);
  final line7 = line7Words.map((id)=>wordLibrary[id]??'').join(' ');
  await AppLogger.writeLog("generated line7: ${line7}");
 
 final pkg = Package(
    id: nextPackageId++,
    signature: promptWordIds,
    keywords: promptWordIds,
    status: PackageStatus.through,
    fragmentLinks: List.from(uniqueFragments),
  );
  await AppLogger.writeLog("generated line7: ${line7}");
    AppLogger.writeLog("package made");
  packages[pkg.id] = pkg;
  
  await _routePackage(pkg, 0, <int>{});
   await AppLogger.writeLog("package sent and returned");
  final uniqueResultFragments = _removeDuplicateFragments(pkg.fragmentLinks)
      .take(100)
      .map((id) => fragments[id]?.text ?? '')
      .where((t) => t.isNotEmpty)
      .toList();
  
  return {
    'line1': line1,
    'line2': line2,
    'line3': line3,
    'line5': line5,
    'line6': line6,
    'line7': line7,
    'fragments': uniqueResultFragments,
    'package_status': pkg.status.toString(),
    'semantics': querySemantics,
  };
}


  OptimizedNeuralNetwork get self => this;
  
  // или
  OptimizedNeuralNetwork get network => this;
/// Улучшенный анализ вектора с дополнительной статистикой
/// Улучшенный анализ вектора с поддержкой double
_VectorStats _analyzeEnhancedVector(Map<int, double> vector) {
  if (vector.isEmpty) {
    return _VectorStats(
      network: network,
      minValue: 0.0,
      maxValue: 0.0,
      valueRange: 0.0,
      mean: 0.0,
      standardDeviation: 0.0,
    );
  }

  final values = vector.values.toList();
  final minValue = values.reduce((a, b) => a < b ? a : b);
  final maxValue = values.reduce((a, b) => a > b ? a : b);
  final valueRange = maxValue - minValue;
  
  final mean = values.fold(0.0, (a, b) => a + b) / values.length;
  final variance = values.map((v) => pow(v - mean, 2)).fold(0.0, (a, b) => a + b) / values.length;
  final standardDeviation = sqrt(variance);

  return _VectorStats(
    network: network,
    minValue: minValue,
    maxValue: maxValue,
    valueRange: valueRange,
    mean: mean,
    standardDeviation: standardDeviation,
  );
}
/// Расчет сходства между вектором и словом
double _calculateVectorSimilarity(Map<int, double> vector, Word word) {
  double similarity = 0.0;
  int commonWords = 0;
  
  for (final entry in word.ratings.entries) {
    if (vector.containsKey(entry.key)) {
      final wordObj = words[entry.key];
      if (wordObj != null) {
        // Используем нормализованные веса
        final rating1to2 = entry.value;
        final rating2to1 = wordObj.ratings[word.id] ?? 0;
        
        final prob1 = word.allRating > 0 ? rating1to2 / word.allRating : 0;
        final prob2 = wordObj.allRating > 0 ? rating2to1 / wordObj.allRating : 0;
        
        final mutualWeight = (prob1 + prob2) / 2;
        final vectorWeight = vector[entry.key] ?? 0;
        
        similarity += min(mutualWeight, vectorWeight);
        commonWords++;
      }
    }
  }
  
  // Нормализуем по количеству общих слов
  return commonWords > 0 ? similarity / commonWords : 0.0;
}

/// Оценка вклада allRating в баланс
double _evaluateAllRatingContribution(
  int wordAllRating, 
  _EnhancedStrategy strategy,
  int highCount, 
  int mediumCount, 
  int lowCount
) {
  final total = highCount + mediumCount + lowCount;
  if (total == 0) return 1.0;
  
  final highRatio = highCount / total;
  final lowRatio = lowCount / total;
  
  // Определяем категорию текущего слова
  final bool isHighRating = wordAllRating > 500000;
  final bool isLowRating = wordAllRating < 100000;
  
  // Оцениваем нужность этого слова для баланса
  if (strategy.preferHighRating && isHighRating) {
    // Награждаем высокорейтинговые слова если их мало
    return highRatio < 0.4 ? 1.5 : 0.8;
  }
  
  if (strategy.preferLowRating && isLowRating) {
    // Награждаем низкорейтинговые слова если их мало
    return lowRatio < 0.3 ? 1.5 : 0.8;
  }
  
  if (!strategy.preferHighRating && isHighRating) {
    // Штрафуем высокорейтинговые слова если их много
    return highRatio > 0.5 ? 0.3 : 0.7;
  }
  
  if (!strategy.preferLowRating && isLowRating) {
    // Штрафуем низкорейтинговые слова если их много
    return lowRatio > 0.4 ? 0.3 : 0.7;
  }
  
  // Среднерейтинговые слова всегда хороши для баланса
  return 1.0;
}

/// Согласование текущего вектора с промптом
void _reconcileWithPromptVector(
  Map<int, double> currentVector, 
  Map<int, double> promptVector, 
  double progress
) {
  // Вес промпта уменьшается по мере прогресса
  final promptWeight = 0.5 * (1.0 - progress);
  final currentWeight = 1.0 - promptWeight;
  
  // Создаем объединенный набор ключей
  final allKeys = {...currentVector.keys, ...promptVector.keys};
  
  for (final key in allKeys) {
    final currentValue = currentVector[key] ?? 0;
    final promptValue = promptVector[key] ?? 0;
    
    // Взвешенное усреднение
    currentVector[key] = (currentValue * currentWeight) + (promptValue * promptWeight);
  }
  
  // Нормализуем результат
  final maxValue = currentVector.values.fold(0.0, (a, b) => max(a, b));
  if (maxValue > 0) {
    for (final key in currentVector.keys) {
      currentVector[key] = currentVector[key]! / maxValue;
    }
  }
}
  Future<void> _routePackage(Package pkg, int synapseId, Set<int> visited) async {
    if (pkg.status == PackageStatus.done) return;
    if (pkg.fragmentLinks.length >= 100) {
      pkg.status = PackageStatus.done;
      pkg.neuronLinks.add(0);
      return;
    }
    
    if (visited.contains(synapseId)) return;
    visited.add(synapseId);
    
    final synapse = synapses[synapseId];
    if (synapse == null) return;
    
    // Получаем ключевые слова пакета
    final pkgKeywords = _getPackageKeywords(pkg);
    final minKeywordMatch = (pkgKeywords.length * 0.15).ceil(); // 15% от ключевых слов
    
    for (final neuronId in synapse.neuronLinks) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      final similarity = _calculateSimilarity(pkg.signatureRatings, neuron.signatureRatings);
      
      if (similarity >= 0.7) {
        // Проверяем постоянные пакеты нейрона
        for (final packageId in neuron.packageLinks) {
          final permPkg = packages[packageId];
          if (permPkg != null && (permPkg.status == PackageStatus.permanent || permPkg.status == PackageStatus.done)) {
            // Фильтруем фрагменты по ключевым словам
            final filteredFragments = _filterFragmentsByKeywords(
              permPkg.fragmentLinks, 
              pkgKeywords, 
              minKeywordMatch
            );
            pkg.fragmentLinks.addAll(filteredFragments);
          }
        }
        
        // Фильтруем фрагменты нейрона по ключевым словам
        final filteredNeuronFragments = _filterFragmentsByKeywords(
          neuron.fragmentLinks, 
          pkgKeywords, 
          minKeywordMatch
        );
        pkg.fragmentLinks.addAll(filteredNeuronFragments);
        
        // Обновляем рейтинги связей между нейронами
        for (final linkedNeuronId in pkg.neuronLinks) {
          final linkedNeuron = neurons[linkedNeuronId];
          if (linkedNeuron != null && linkedNeuronId != neuronId) {
            linkedNeuron.neuronRatings[neuronId] = 
                (linkedNeuron.neuronRatings[neuronId] ?? 0) + (similarity * 100).round().toInt();
            neuron.neuronRatings[linkedNeuronId] = 
                (neuron.neuronRatings[linkedNeuronId] ?? 0) + (similarity * 100).round().toInt();
          }
        }
        
        if (pkg.fragmentLinks.length >= 100) {
          pkg.status = PackageStatus.done;
          pkg.neuronLinks.add(neuronId);
          neurons[neuronId]!.packageLinks.add(pkg.id);
          return;
        }
      }
    }
    
    for (final linkedSynapseId in synapse.synapseLinks) {
      if (linkedSynapseId != synapseId && !visited.contains(linkedSynapseId)) {
        await _routePackage(pkg, linkedSynapseId, visited);
        if (pkg.status == PackageStatus.done) return;
      }
    }
  }

  // Вспомогательные методы

  /// Извлекает ключевые слова из пакета на основе signatureRatings
  List<int> _getPackageKeywords(Package pkg) {
    final keywordScores = <int, double>{};
    
    for (final entry in pkg.signatureRatings.entries) {
      final wordId = entry.key;
      final score = entry.value;

      keywordScores[wordId] = score.toDouble();
    }
    
    // Сортируем по убыванию рейтинга и берем топ-20
    final sortedKeywords = keywordScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedKeywords
        .take(40)
        .map((entry) => entry.key)
        .toList();
  }

  /// Фильтрует фрагменты по ключевым словам
  List<int> _filterFragmentsByKeywords(
    List<int> fragmentIds, 
    List<int> keywords, 
    int minKeywordMatch
  ) {
    if (keywords.isEmpty || minKeywordMatch == 0) {
      return fragmentIds; // Если нет ключевых слов, возвращаем все фрагменты
    }
    
    final filteredFragments = <int>[];
    
    for (final fragmentId in fragmentIds) {
      final fragment = fragments[fragmentId];
      if (fragment == null) continue;

      // Считаем количество совпадающих ключевых слов
      int matchCount = 0;
      for (final keyword in keywords) {
 
        if (fragment.wordIds.contains(keyword)) {
          matchCount++;
          if (matchCount >= minKeywordMatch) {
            break; // Достаточно совпадений
          }
        }
      }
      
      // Добавляем фрагмент если достаточно совпадений
      if (matchCount >= minKeywordMatch) {
        filteredFragments.add(fragmentId);
      }
    }
    
    return filteredFragments;
  }

  /// Альтернативная версия фильтрации с использованием signature фрагментов
  List<int> _filterFragmentsBySignature(
    List<int> fragmentIds, 
    List<int> pkgKeywords, 
    int minKeywordMatch
  ) {
    if (pkgKeywords.isEmpty || minKeywordMatch == 0) {
      return fragmentIds;
    }
    
    final filteredFragments = <int>[];
    
    for (final fragmentId in fragmentIds) {
      final fragment = fragments[fragmentId];
      if (fragment == null) continue;
      
      // Получаем ключевые слова фрагмента из его signature
      final fragmentKeywords = _getFragmentKeywords(fragment);
      
      // Считаем пересечение ключевых слов
      final intersection = pkgKeywords.toSet().intersection(
        fragmentKeywords.toSet()
      );
      
      // Добавляем фрагмент если достаточно совпадений
      if (intersection.length >= minKeywordMatch) {
        filteredFragments.add(fragmentId);
      }
    }
    
    return filteredFragments;
  }

  /// Извлекает ключевые слова из фрагмента на основе его signature
  List<int> _getFragmentKeywords(Fragment fragment) {
    final keywords = <int>[];
    
    for (final wordId in fragment.wordIds) {
      keywords.add(wordId);
    }
    
    return keywords;
  }
double _calculateSimilarity(Map<int, int> sig1, Map<int, int> sig2) {
  if (sig1.isEmpty || sig2.isEmpty) return 0.0;
  
  // Находим общие слова
  final commonWords = sig1.keys.toSet().intersection(sig2.keys.toSet());
  if (commonWords.isEmpty) return 0.0;
  
  // Вычисляем суммы всех значений для нормализации
  final sum1 = sig1.values.reduce((a, b) => a + b).toDouble();
  final sum2 = sig2.values.reduce((a, b) => a + b).toDouble();
  
  double totalSimilarity = 0.0;
  int count = 0;
  
  for (final wordId in commonWords) {
    final value1 = sig1[wordId]!.toDouble();
    final value2 = sig2[wordId]!.toDouble();
    
    // Нормализуем значения
    final normalized1 = value1 / sum1;
    final normalized2 = value2 / sum2;
    
    // Вычисляем соотношение векторов
    final vectorRatio = normalized1 / ((normalized2 / ((value1 + value2) / 2)));
    
    // Добавляем к общей схожести
    totalSimilarity += vectorRatio;
    count++;
  }
  
  return count > 0 ? totalSimilarity / count : 0.0;
}
Future<void> processWebsite(String url, Function(String) onProgress) async {
    try {
      final client = http.Client();
      final response = await client.get(Uri.parse(url));
      client.close();
      
      if (response.statusCode != 200) {
        onProgress('  Ошибка HTTP: ${response.statusCode}');
        return;
      }

      // Улучшенное определение кодировки
      String html;
      final contentType = response.headers['content-type'];
      
      if (contentType?.contains('windows-1251') == true) {
        html = await _decodeWindows1251(response.bodyBytes);
        onProgress('  Декодируем windows-1251');
      } else {
        // Пробуем определить кодировку по содержимому
        html = await _autoDetectEncoding(response.bodyBytes);
        onProgress('  Автоопределение кодировки');
      }

      final document = html_parser.parse(html);
      
      String? pageTitle;
      final titleElement = document.querySelector('title');
      if (titleElement != null) {
        pageTitle = titleElement.text.trim();
        onProgress('  Заголовок: $pageTitle');
        
        // Проверяем корректность заголовка
        if (_containsGibberish(pageTitle)) {
          onProgress('  ⚠️ Заголовок содержит некорректные символы - проблема с кодировкой');
        }
      }

      final texts = <String>[];
      String fullContent = '';
      
      // Целевые селекторы для этого сайта
   
        onProgress('  Пробуем альтернативные селекторы...');
        final alternativeSelectors = ['p', '.text', 'div', 'span','p.text','div.cont p', '.text p'];
        for (final selector in alternativeSelectors) {
          final elements = document.querySelectorAll(selector);
          onProgress('  Селектор $selector: ${elements.length} элементов');
          for (final element in elements) {
            final text = element.text.trim();
            if (text.length > 30 && 
                !_containsGibberish(text) &&
                !_isNavigation(text)) {
              texts.add(text);
              fullContent += text + ' ';
              
            }
          }
        
        }
   

      // Если все еще пусто, пробуем получить весь текст из body
      if (texts.isEmpty) {
        onProgress('  Пробуем извлечь весь текст из body...');
        final bodyText = document.body?.text ?? '';
        if (bodyText.length > 100 && !_containsGibberish(bodyText)) {
          // Разбиваем на предложения
          final sentences = bodyText.split(RegExp(r'[.!?]+'));
          for (final sentence in sentences) {
            final trimmed = sentence.trim();
            if (trimmed.length > 20 && !_isNavigation(trimmed)) {
              texts.add(trimmed);
              fullContent += trimmed + ' ';
            }
          }
        }
      }

      onProgress('  Итого текстовых блоков: ${texts.length}');
      onProgress('  Общий объем текста: ${fullContent.length} символов');
      
      if (texts.isEmpty) {
        onProgress('  Не удалось извлечь текстовое содержимое');
        
        // Для отладки выведем первые 500 символов сырого HTML
        final rawPreview = html.length > 500 ? html.substring(0, 500) + '...' : html;
        onProgress('  Сырой HTML (первые 500 символов): $rawPreview');
        return;
      }
      
      // Проверяем качество извлеченного текста
      if (_containsGibberish(fullContent)) {
        onProgress('  ⚠️ Извлеченный текст содержит некорректные символы');
      }
      
      final neuronId = nextNeuronId++;
      final synapseId = nextSynapseId++;
      
      onProgress('  Создаем нейрон #$neuronId...');
      
      final synapse = Synapse(id: synapseId);
      synapses[synapseId] = synapse;
      
      final neuron = Neuron(
        id: neuronId,
        personalSynapseId: synapseId,
        sourceUrl: url,
        pageTitle: pageTitle,
        fullPageContent: fullContent.trim(),
      );
      neurons[neuronId] = neuron;
      
      synapse.neuronLinks.add(neuronId);
      
      if (neurons.length > 1) {
        final rootSynapse = synapses[0]!;
        rootSynapse.synapseLinks.add(synapseId);
        synapse.synapseLinks.add(0);
      }
      
      final allWordIds = <int>[];
      onProgress('  Обрабатываем тексты...');
      
      // Обрабатываем тексты с прогрессом
      for (int i = 0; i < texts.length; i++) {
        onProgress('  Текст ${i + 1}/${texts.length}...');
        await _processText(texts[i], neuron, allWordIds);
      }
      
      if (allWordIds.isNotEmpty) {
        neuron.updateSignature(allWordIds,network);
        onProgress('  Сигнатура обновлена: ${allWordIds.length} слов');
      }
      
      onProgress('  Создаем пакеты для фрагментов...');
      for (final fragmentId in neuron.fragmentLinks) {
        final fragment = fragments[fragmentId];
        if (fragment != null && fragment.wordIds.isNotEmpty) {
          await _createPackageForFragment(fragment, neuron);
        }
      }
      
      await _checkNeuronSimilarity(neuron, onProgress);
      //await neuron.express(this);
      onProgress('  Express создан для нейрона #$neuronId');
      
      //await updateClusters();
      onProgress('  ✅ Обработка завершена');
      
    } catch (e) {
      onProgress('  ❌ Исключение при обработке: $e');
    }
  }

Future<String> _decodeWindows1251(List<int> bytes) async {
  try {
    // Конвертируем List<int> в Uint8List
    final uint8List = Uint8List.fromList(bytes);
    final result = await CharsetConverter.decode('windows-1251', uint8List);
    return result ?? utf8.decode(bytes, allowMalformed: true);
  } catch (e) {
    return utf8.decode(bytes, allowMalformed: true);
  }
}
String _manualEncodingFix(String text) {
  final replacements = {
    'Ð': 'Н', 'Ñ': 'О', 'Ò': 'П', 'Ó': 'Р', 'Ô': 'С', 'Õ': 'Т', 'Ö': 'У',
    '×': 'Ф', 'Ø': 'Х', 'Ù': 'Ц', 'Ú': 'Ч', 'Û': 'Ш', 'Ü': 'Щ', 'Ý': 'Ъ',
    'Þ': 'Ы', 'ß': 'Ь', 'à': 'Э', 'á': 'Ю', 'â': 'Я',
    'ã': 'а', 'ä': 'б', 'å': 'в', 'æ': 'г', 'ç': 'д', 'è': 'е', 'é': 'ж',
    'ê': 'з', 'ë': 'и', 'ì': 'й', 'í': 'к', 'î': 'л', 'ï': 'м', 'ð': 'н',
    'ñ': 'о', 'ò': 'п', 'ó': 'р', 'ô': 'с', 'õ': 'т', 'ö': 'у', '÷': 'ф',
    'ø': 'х', 'ù': 'ц', 'ú': 'ч', 'û': 'ш', 'ü': 'щ', 'ý': 'ъ', 'þ': 'ы',
    'ÿ': 'ь',
    'Â': 'А', 'Ã': 'Б', 'Ä': 'В', 'Å': 'Г', 'Æ': 'Д', 'Ç': 'Е', 'È': 'Ж',
    'É': 'З', 'Ê': 'И', 'Ë': 'Й', 'Ì': 'К', 'Í': 'Л', 'Î': 'М', 'Ï': 'Н',
  };
  
  String result = text;
  replacements.forEach((wrong, correct) {
    result = result.replaceAll(wrong, correct);
  });
  
  return result;
}

/// Автоопределение кодировки
Future<String> _autoDetectEncoding(List<int> bytes) async {
  // Сначала пробуем UTF-8
  try {
    final utf8Text = utf8.decode(bytes, allowMalformed: false);
    if (!_containsGibberish(utf8Text)) {
      return utf8Text;
    }
  } catch (e) {}
  
  // Пробуем windows-1251
  try {
    final win1251Text = await _decodeWindows1251(bytes);
    if (!_containsGibberish(win1251Text)) {
      return win1251Text;
    }
  } catch (e) {}
  
  // Пробуем latin1
  try {
    final latin1Text = latin1.decode(bytes);
    final convertedText = _latin1ToCyrillic(latin1Text);
    if (!_containsGibberish(convertedText)) {
      return convertedText;
    }
  } catch (e) {}
  
  // Последний вариант
  return utf8.decode(bytes, allowMalformed: true);
}

/// Проверка на "абракадабру" (некорректные символы)
bool _containsGibberish(String text) {
  // Проверяем наличие некорректных последовательностей символов
  final gibberishPattern = RegExp(r'[ÂÐâð]'); // Типичные артефакты неправильной кодировки
  final cyrillicPattern = RegExp(r'[а-яА-ЯёЁ]');
  
  // Если есть артефакты И мало кириллицы - вероятно проблема с кодировкой
  final hasGibberish = gibberishPattern.hasMatch(text);
  final hasCyrillic = cyrillicPattern.hasMatch(text);
  final cyrillicRatio = text.split('').where((c) => cyrillicPattern.hasMatch(c)).length / text.length;
  
  return hasGibberish || (text.isNotEmpty && cyrillicRatio < 0.1);
}

/// Конвертация latin1 в кириллицу (простая замена)
String _latin1ToCyrillic(String text) {
  final Map<String, String> replacements = {
    'Â': 'А', 'â': 'а', 'Ð': 'Д', 'ð': 'д',
    '': 'Е', '': 'В', '': 'Р'
  };
  
  String result = text;
  replacements.forEach((from, to) {
    result = result.replaceAll(from, to);
  });
  
  return result;
}


  bool _isNavigation(String text) {
    final navigationPatterns = [
      'главная', 'биография', 'отзыв', 'следующая', 'предыдущая', 
      'оглавление', 'страница', 'комментарии', '©', 'яндекс.метрика',
      '1, 2, 3,', '4, 5, 6,'
    ];
    return navigationPatterns.any((pattern) => text.toLowerCase().contains(pattern));
  }

 

  bool _containsCyrillic(String text) {
    return RegExp(r'[а-яА-ЯёЁ]').hasMatch(text);
  }

  Future<void> _processText(String text, Neuron neuron, List<int> allWordIds) async {
    final sentences = _splitIntoSentences(text);
    
    for (final sentence in sentences) {
      if (sentence.trim().length < 3) continue;
      
      final wordTexts = _extractWords(sentence);
      if (wordTexts.isEmpty) continue;
      
      final fragment = Fragment(
        id: nextFragmentId++,
        text: sentence,
        wordIds: [],
      );
      
      fragments[fragment.id] = fragment;
      neuron.fragmentLinks.add(fragment.id);
      
      final sentenceWordIds = <int>[];
      for (final wordText in wordTexts) {
        final wordId = _getOrCreateWordId(wordText);
        if (wordId > 0) {
          sentenceWordIds.add(wordId);
          allWordIds.add(wordId);
        }
      }
      
      for (final wordId in sentenceWordIds) {
        final wordText = wordLibrary[wordId]!;
        if (!STOP_WORDS.contains(wordText)) {
          fragment.wordIds.add(wordId);
        }
      }
      
      _computeRatingsForSentence(sentenceWordIds);
    }
  }

  List<String> _splitIntoSentences(String text) {
    return text
        .split(RegExp(r'[.!?]+'))
        .map((s) => s.trim())
        .where((s) => s.length > 3)
        .toList();
  }

  int _getOrCreateWordId(String wordText) {
    final normalizedWord = wordText.toLowerCase().trim();
    
    if (normalizedWord.isEmpty || normalizedWord.length < 2) return -1;
    if (!RegExp(r'[а-яА-ЯёЁa-zA-Z]').hasMatch(normalizedWord)) return -1;
    
    int? wordId = wordIndex[normalizedWord];
    
    if (wordId == null) {
      wordId = nextWordId++;
      wordLibrary[wordId] = normalizedWord;
      wordIndex[normalizedWord] = wordId;
      
      words[wordId] = Word(
        id: wordId,
        ratings: {},
        allRating: 0,
        x: random.nextDouble() * 1000,
        y: random.nextDouble() * 1000,
        z: random.nextDouble() * 1000,
      );

    }
    
    return wordId;
  }

  void _computeRatingsForSentence(List<int> wordIds) {
    for (int i = 0; i < wordIds.length; i++) {
      final wordId = wordIds[i];
      final wordText = wordLibrary[wordId]!;
      if (STOP_WORDS.contains(wordText)) continue;

      double leftBonus = 1.0;
      for (int left = i - 1; left >= 0 && left >= i - 1; left--) {
        final leftWordText = wordLibrary[wordIds[left]]!;
        if (STOP_WORDS.contains(leftWordText)) {
          leftBonus += 0.1;
        } else {
          break;
        }
      }

      for (int j = max(0, i - 10); j <= min(wordIds.length - 1, i + 10); j++) {
        if (i == j) continue;
        final otherWordId = wordIds[j];
        final otherWordText = wordLibrary[otherWordId]!;
        if (STOP_WORDS.contains(otherWordText)) continue;

        final distance = (i - j).abs();
        double betweenBonus = 1.0;

        int stopWordsBetween = 0;
        for (int k = min(i, j) + 1; k < max(i, j); k++) {
          final betweenWordText = wordLibrary[wordIds[k]]!;
          if (STOP_WORDS.contains(betweenWordText)) stopWordsBetween++;
        }

        betweenBonus += stopWordsBetween * 0.05;
        final totalBonus = leftBonus * betweenBonus;
        final rating = ((5.0 / distance) * totalBonus * 100).round();

        _updateWordRating(wordId, otherWordId, rating);
      }
    }
  }

  void _updateWordRating(int wordId, int otherId, int rating) {
    final word = words[wordId];
    if (word == null) return;
    
    word.ratings[otherId] = (word.ratings[otherId] ?? 0) + rating;
    
    if (word.ratings.length > MAX_VECTOR_SIZE) {
      final sorted = word.ratings.entries.toList()
        ..sort((a, b) => b.value.compareTo(a.value));
      
      word.ratings.clear();
      for (int i = 0; i < MAX_VECTOR_SIZE; i++) {
        word.ratings[sorted[i].key] = sorted[i].value;
      }
    }
    
    word.allRating = word.ratings.values.fold(0, (a, b) => a + b);
    
    final otherWord = words[otherId];
    if (otherWord != null) {
      otherWord.ratings[wordId] = (otherWord.ratings[wordId] ?? 0) + (rating ~/ 2);
      if (otherWord.ratings.length > MAX_VECTOR_SIZE) {
        final sorted = otherWord.ratings.entries.toList()
          ..sort((a, b) => b.value.compareTo(a.value));
        otherWord.ratings.clear();
        for (int i = 0; i < MAX_VECTOR_SIZE; i++) {
          otherWord.ratings[sorted[i].key] = sorted[i].value;
        }
      }
      otherWord.allRating = otherWord.ratings.values.fold(0, (a, b) => a + b);
    }
  }

  Future<void> _createPackageForFragment(Fragment fragment, Neuron neuron) async {
    if (fragment.wordIds.isEmpty) return;
    
    final pkg = Package(
      id: nextPackageId++,
      signature: List.from(fragment.wordIds),
      keywords: fragment.wordIds.take(10).toList(),
      status: PackageStatus.permanent,
      fragmentLinks: [fragment.id],
      neuronLinks: [neuron.id],
    );
    
    packages[pkg.id] = pkg;
    fragment.packageId = pkg.id;
    neuron.packageLinks.add(pkg.id);
  }

  Future<List<int>> _findFragmentsWithMaxCoverage(
    Map<int, int> superVector, 
    List<int> promptWordIds, 
    String querySemantics
  ) async {
    final fragmentScores = <int, double>{};
    final usedWords = Set<int>.from(promptWordIds);
    
    for (final fragment in fragments.values) {
      if (fragment.semanticType != querySemantics && querySemantics != 'повествование') {
        continue;
      }
      
      final fragmentWordSet = fragment.wordIds.toSet();
      final relevantWords = fragmentWordSet.difference(usedWords);
      if (relevantWords.isEmpty) continue;
      
      double coverageScore = 0.0;
      int coveredCount = 0;
      
      for (final wordId in relevantWords) {
        if (superVector.containsKey(wordId)) {
          coverageScore += superVector[wordId]!;
          coveredCount++;
        }
      }
      
      final coverageRatio = coveredCount / relevantWords.length;
      final lengthBonus = fragment.wordIds.length > 10 ? 1.0 : 0.5;
      
      final normalizedScore = coverageScore * coverageRatio * lengthBonus;
      fragmentScores[fragment.id] = normalizedScore;
    }
    
    final sortedFragments = fragmentScores.entries
        .toList()
        ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedFragments
        .where((entry) => entry.value > 0)
        .take(20)
        .map((e) => e.key)
        .toList();
  }
  Future<void> _checkNeuronSimilarity(Neuron newNeuron, Function(String) onProgress) async {
    for (final existingNeuron in neurons.values) {
      if (existingNeuron.id == newNeuron.id || existingNeuron.id == 0) continue;
      
      final similarity = _calculateSimilarity(
        newNeuron.signatureRatings,
        existingNeuron.signatureRatings,
      );
      
      if (similarity > 0.3) {
        newNeuron.neuronRatings[existingNeuron.id] = (similarity * 1000).round();
        existingNeuron.neuronRatings[newNeuron.id] = (similarity * 1000).round();
        
        onProgress('  Связь с нейроном #${existingNeuron.id}: ${(similarity * 100).toStringAsFixed(1)}%');
      }
    }
  }


  // ... остальные методы остаются без изменений
  void optimizeWordPositions() {
    for (int i = 0; i < 20; i++) {
      Future.delayed(Duration(milliseconds: 1100), () {
        optimizeWordPositions1();
      });
    }
  }

  void optimizeWordPositions1() {
    final topWords = getTopWords(150);
    if (topWords.length < 2) return;
    
    _initializeStemBasedPositions(topWords);
    _applyStrongWordRepulsion(topWords);
    _applyStrongWordAttraction(topWords);
    _applyClusterAttraction(topWords);
    _applyFinalStabilization(topWords);
  }

  void _initializeStemBasedPositions(List<Word> topWords) {
    final stemGroups = <String, List<Word>>{};
    
    for (final word in topWords) {
      final wordText = wordLibrary[word.id] ?? '';
      final stem = WordStemmer.getStem(wordText);
      
      if (!stemGroups.containsKey(stem)) {
        stemGroups[stem] = [];
      }
      stemGroups[stem]!.add(word);
    }
    
    final groups = stemGroups.values.toList();
    final groupCount = groups.length;
    
    for (int i = 0; i < groupCount; i++) {
      final group = groups[i];
      if (group.length == 1) continue;
      
      final phi = acos(-1.0 + 2.0 * i / groupCount);
      final theta = sqrt(groupCount * pi) * phi;
      
      final centerX = 500.0 + 300.0 * sin(phi) * cos(theta);
      final centerY = 500.0 + 300.0 * sin(phi) * sin(theta);
      final centerZ = 500.0 + 300.0 * cos(phi);
      
      for (int j = 0; j < group.length; j++) {
        final word = group[j];
        final angle = 2 * pi * j / group.length;
        final radius = 20.0 + (word.allRating / 1550000).clamp(0.0, 50.0);
        
        word.x = centerX + radius * cos(angle);
        word.y = centerY + radius * sin(angle);
        word.z = centerZ + (j % 2 == 0 ? radius * 0.5 : -radius * 0.5);
      }
    }
    
    for (final word in topWords) {
      if (word.x == 0.0 && word.y == 0.0 && word.z == 0.0) {
        word.x = random.nextDouble() * 800 + 100;
        word.y = random.nextDouble() * 800 + 100;
        word.z = random.nextDouble() * 800 + 100;
      }
    }
  }

  void _applyStrongWordRepulsion(List<Word> topWords) {
    final strongWords = topWords.where((w) => w.allRating > 1550000).toList();
    
    for (int i = 0; i < strongWords.length; i++) {
      final word1 = strongWords[i];
      
      for (int j = i + 1; j < strongWords.length; j++) {
        final word2 = strongWords[j];
        
        final dx = word1.x - word2.x;
        final dy = word1.y - word2.y;
        final dz = word1.z - word2.z;
        final distance = sqrt(dx * dx + dy * dy + dz * dz);
        
        final minDistance = 150.0 + (word1.allRating + word2.allRating) / 150000.0;
        
        if (distance < minDistance) {
          final force = (minDistance - distance) / distance * 0.5;
          
          word1.x += dx * force * (word1.allRating / (word1.allRating + word2.allRating));
          word1.y += dy * force * (word1.allRating / (word1.allRating + word2.allRating));
          word1.z += dz * force * (word1.allRating / (word1.allRating + word2.allRating));
          
          word2.x -= dx * force * (word2.allRating / (word1.allRating + word2.allRating));
          word2.y -= dy * force * (word2.allRating / (word1.allRating + word2.allRating));
          word2.z -= dz * force * (word2.allRating / (word1.allRating + word2.allRating));
        }
      }
    }
  }

  void _applyStrongWordAttraction(List<Word> topWords) {
    final strongWords = topWords.where((w) => w.allRating > 1550000).toList();
    
    for (final strongWord in strongWords) {
      final attractionStrength = (strongWord.allRating / 1550000.0).clamp(0.1, 2.0);
      
      final strongConnections = strongWord.ratings.entries
          .toList()
          ..sort((a, b) => b.value.compareTo(a.value));
      
      final connectionsToProcess = strongConnections.take(30).toList();
      
      for (final connection in connectionsToProcess) {
        final otherWord = words[connection.key];
        if (otherWord == null || otherWord == strongWord) continue;
        
        final connectionStrength = connection.value / strongWord.allRating;
        
        final dx = strongWord.x - otherWord.x;
        final dy = strongWord.y - otherWord.y;
        final dz = strongWord.z - otherWord.z;
        final distance = sqrt(dx * dx + dy * dy + dz * dz);
        
        final targetDistance = 50.0 + (1.0 - connectionStrength) * 200.0;
        
        if (distance > targetDistance) {
          final force = (distance - targetDistance) / distance * 
                       connectionStrength * 
                       attractionStrength * 0.3;
          
          otherWord.x += dx * force;
          otherWord.y += dy * force;
          otherWord.z += dz * force;
        }
      }
    }
  }

  void _applyClusterAttraction(List<Word> topWords) {
    final clusterCenters = <Word>[];
    
    for (final word in topWords) {
      if (word.allRating > 20000 && word.ratings.length > 10) {
        clusterCenters.add(word);
      }
    }
    
    final clusterPositions = <Word, List<double>>{};
    
    for (final center in clusterCenters) {
      double sumX = center.x;
      double sumY = center.y;
      double sumZ = center.z;
      int count = 1;
      
      final strongConnections = center.ratings.entries
          .where((e) => e.value > center.allRating * 0.1)
          .take(20)
          .toList();
      
      for (final connection in strongConnections) {
        final otherWord = words[connection.key];
        if (otherWord != null) {
          sumX += otherWord.x;
          sumY += otherWord.y;
          sumZ += otherWord.z;
          count++;
        }
      }
      
      clusterPositions[center] = [sumX / count, sumY / count, sumZ / count];
    }
    
    final clusters = clusterPositions.entries.toList();
    
    for (int i = 0; i < clusters.length; i++) {
      final cluster1 = clusters[i];
      
      for (int j = i + 1; j < clusters.length; j++) {
        final cluster2 = clusters[j];
        
        final commonConnections = _findCommonStrongConnections(
          cluster1.key, 
          cluster2.key
        );
        
        if (commonConnections > 3) {
          final dx = cluster1.value[0] - cluster2.value[0];
          final dy = cluster1.value[1] - cluster2.value[1];
          final dz = cluster1.value[2] - cluster2.value[2];
          final distance = sqrt(dx * dx + dy * dy + dz * dz);
          
          final targetDistance = 100.0 + commonConnections * 20.0;
          
          if (distance > targetDistance) {
            final force = (distance - targetDistance) / distance * 0.1;
            
            _moveClusterTowards(cluster1.key, cluster2.value, force * 0.5);
            _moveClusterTowards(cluster2.key, cluster1.value, force * 0.5);
          }
        }
      }
    }
  }

  void _moveClusterTowards(Word center, List<double> target, double force) {
    final dx = target[0] - center.x;
    final dy = target[1] - center.y;
    final dz = target[2] - center.z;
    
    center.x += dx * force;
    center.y += dy * force;
    center.z += dz * force;
    
    final strongConnections = center.ratings.entries
        .where((e) => e.value > center.allRating * 0.1)
        .take(15)
        .toList();
    
    for (final connection in strongConnections) {
      final otherWord = words[connection.key];
      if (otherWord != null) {
        otherWord.x += dx * force * 0.3;
        otherWord.y += dy * force * 0.3;
        otherWord.z += dz * force * 0.3;
      }
    }
  }

  int _findCommonStrongConnections(Word word1, Word word2) {
    int commonCount = 0;
    
    final threshold1 = word1.allRating * 0.05;
    final threshold2 = word2.allRating * 0.05;
    
    for (final entry in word1.ratings.entries) {
      if (entry.value > threshold1) {
        final otherRating = word2.ratings[entry.key];
        if (otherRating != null && otherRating > threshold2) {
          commonCount++;
        }
      }
    }
    
    return commonCount;
  }

  void _applyFinalStabilization(List<Word> topWords) {
    for (final word in topWords) {
      word.x = word.x.clamp(50.0, 950.0);
      word.y = word.y.clamp(50.0, 950.0);
      word.z = word.z.clamp(50.0, 950.0);
    }
    
    for (final word in topWords) {
      if (word.allRating < 5000) {
        word.x += (random.nextDouble() - 0.5) * 10.0;
        word.y += (random.nextDouble() - 0.5) * 10.0;
        word.z += (random.nextDouble() - 0.5) * 10.0;
      }
    }
  }

  List<Word> getTopWords(int limit) {
     final sorted = words.values.toList()
    ..sort((a, b) => b.allRating.compareTo(a.allRating));
  
  final filtered = sorted.where((word) => 
    !STOP_WORDS.contains(wordLibrary[word.id]!.toLowerCase())
  ).toList();
  
  final topWords = filtered.take(limit).toList();
  final bottomWords = filtered.reversed.take(15).toList();
  
  return [...topWords, ...bottomWords];
}


  Future<void> saveToFile() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/neural_network_v2.json');
      
      final data = {
        'word_library': wordLibrary.map((k, v) => MapEntry(k.toString(), v)),
        'words': words.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'fragments': fragments.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'neurons': neurons.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'synapses': synapses.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'packages': packages.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'next_word_id': nextWordId,
        'next_fragment_id': nextFragmentId,
        'next_neuron_id': nextNeuronId,
        'next_synapse_id': nextSynapseId,
        'next_package_id': nextPackageId,
      };
      
      await file.writeAsString(jsonEncode(data));
    } catch (e) {
      print('Ошибка сохранения: $e');
    }
  }

  Future<void> loadFromFile() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/neural_network_v2.json');
      
      if (!await file.exists()) return;
      
      final content = await file.readAsString();
      final data = jsonDecode(content);
      
      wordLibrary.clear();
      wordIndex.clear();
      (data['word_library'] as Map).forEach((k, v) {
        final id = int.parse(k);
        wordLibrary[id] = v;
        wordIndex[v] = id;
      });
      
      words.clear();
      (data['words'] as Map).forEach((k, v) {
        words[int.parse(k)] = Word.fromJson(v);
      });
      
      fragments.clear();
      (data['fragments'] as Map).forEach((k, v) {
        fragments[int.parse(k)] = Fragment.fromJson(v);
      });
      
      neurons.clear();
      if (data['neurons'] != null) {
        (data['neurons'] as Map).forEach((k, v) {
          neurons[int.parse(k)] = Neuron.fromJson(v);
        });
      }
      
      synapses.clear();
      if (data['synapses'] != null) {
        (data['synapses'] as Map).forEach((k, v) {
          synapses[int.parse(k)] = Synapse.fromJson(v);
        });
      }
      
      packages.clear();
      if (data['packages'] != null) {
        (data['packages'] as Map).forEach((k, v) {
          packages[int.parse(k)] = Package.fromJson(v);
        });
      }
      
      nextWordId = data['next_word_id'] ?? 1;
      nextFragmentId = data['next_fragment_id'] ?? 1;
      nextNeuronId = data['next_neuron_id'] ?? 1;
      nextSynapseId = data['next_synapse_id'] ?? 1;
      nextPackageId = data['next_package_id'] ?? 1;
      
      optimizeWordPositions();
      

      for (final word in words.entries){

        searchSystem.addVector("word_${word.key}", word.value.ratings);
      }
      
      
      for (final fragment in fragments.entries){
        final Map<int,double> fragmentVector = {};
        for(final wordId in fragment.value.wordIds){
          fragmentVector[wordId]=fragmentVector[wordId]?? 0+1;
        }
        searchSystem.addVector("fragment_${fragment.key}", fragmentVector);
      }
      
      for (final neuron in neurons.entries){

        searchSystem.addVector("neuron_${neuron.key}", neuron.value.signatureRatings);
      }


      
      print('Загружено: ${words.length} слов, ${fragments.length} фрагментов, ${neurons.length} нейронов');
    } catch (e) {
      print('Ошибка загрузки: $e');
    }
  }
}

// ========== ВСПОМОГАТЕЛЬНЫЕ КЛАССЫ ==========
class NavigationStep {
  final String type;
  final int? id;
  final String? query;
  final DateTime timestamp;
  
  NavigationStep({
    required this.type,
    this.id,
    this.query,
  }) : timestamp = DateTime.now();
  
  String get displayText {
    switch (type) {
      case 'word':
        return 'Слово #$id';
      case 'neuron':
        return 'Нейрон #$id';
      case 'fragment':
        return 'Фрагмент #$id';
      case 'search':
        return 'Поиск: $query';
      default:
        return 'Неизвестный шаг';
    }
  }
}

enum VisualizationMode {
  words,
  neurons,
  fragments
}
class _WordScore {
  final int wordId;
  final double intersectionScore;
  final double allRatingScore;
  final double combinedScore;
  
  _WordScore({
    required this.wordId,
    required this.intersectionScore,
    required this.allRatingScore,
    required this.combinedScore,
  });
}
class AnimationStage {
  final double duration;
  final VoidCallback action;
  
  AnimationStage({required this.duration, required this.action});
}

class Projected3D {
  final double dx;
  final double dy;
  final double depth;
  
  Projected3D({required this.dx, required this.dy, required this.depth});
}

// ========== ВИЗУАЛИЗАТОРЫ ==========
class InteractiveWordVisualization3D extends StatefulWidget {
  final OptimizedNeuralNetwork network;
  final Set<int> selectedWordIds;
  final Function(int, bool) onWordSelected;
  
  const InteractiveWordVisualization3D({
    Key? key,
    required this.network,
    required this.selectedWordIds,
    required this.onWordSelected,
  }) : super(key: key);
  
  @override
  _InteractiveWordVisualization3DState createState() => _InteractiveWordVisualization3DState();
}

class _InteractiveWordVisualization3DState extends State<InteractiveWordVisualization3D> {
  double _rotationX = 0.0;
  double _rotationY = 0.0;
  double _scale = 1.0;
  Offset _offset = Offset.zero;
  Offset? _lastLeftPanPosition;
  Offset? _lastRightPanPosition;
  bool _isRightMouseDown = false;
  int? _primaryButtonPointer;
  int? _secondaryButtonPointer;
  bool _shiftPressed = false;

  @override
  void initState() {
    super.initState();
    RawKeyboard.instance.addListener(_handleKeyEvent);
  }

  @override
  void dispose() {
    RawKeyboard.instance.removeListener(_handleKeyEvent);
    super.dispose();
  }

  void _handleKeyEvent(RawKeyEvent event) {
    if (event.logicalKey == LogicalKeyboardKey.shiftLeft || 
        event.logicalKey == LogicalKeyboardKey.shiftRight) {
      setState(() {
        _shiftPressed = event is RawKeyDownEvent;
      });
    } 
    
  }

  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerSignal: (pointerSignal) {
        if (pointerSignal is PointerScrollEvent) {
          setState(() {
            _scale = (_scale * (1.0 + pointerSignal.scrollDelta.dy * -0.001))
                .clamp(0.1, 3.0);
          });
        }
      },
      onPointerDown: (event) {
        if (event.kind == PointerDeviceKind.mouse) {
          if (event.buttons == kPrimaryButton) {
            _primaryButtonPointer = event.pointer;
            _lastLeftPanPosition = event.position;
          } else if (event.buttons == kSecondaryButton) {
            _secondaryButtonPointer = event.pointer;
            _lastRightPanPosition = event.position;
            _isRightMouseDown = true;
          }
        } else {
          _primaryButtonPointer = event.pointer;
          _lastLeftPanPosition = event.position;
        }
      },
      onPointerMove: (event) {
        if (event.kind == PointerDeviceKind.mouse) {
          if (_primaryButtonPointer == event.pointer && _lastLeftPanPosition != null) {
            setState(() {
              final delta = event.position - _lastLeftPanPosition!;
              _rotationY += delta.dx * 0.01;
              _rotationX += delta.dy * 0.01;
              _lastLeftPanPosition = event.position;
            });
          } else if (_secondaryButtonPointer == event.pointer && _lastRightPanPosition != null) {
            setState(() {
              final delta = event.position - _lastRightPanPosition!;
              _offset += Offset(delta.dx, delta.dy);
              _lastRightPanPosition = event.position;
            });
          }
        } else if (_primaryButtonPointer == event.pointer && _lastLeftPanPosition != null) {
          setState(() {
            final delta = event.position - _lastLeftPanPosition!;
            _rotationY += delta.dx * 0.01;
            _rotationX += delta.dy * 0.01;
            _lastLeftPanPosition = event.position;
          });
        }
      },
      onPointerUp: (event) {
        if (_primaryButtonPointer == event.pointer) {
          _primaryButtonPointer = null;
          _lastLeftPanPosition = null;
        }
        if (_secondaryButtonPointer == event.pointer) {
          _secondaryButtonPointer = null;
          _lastRightPanPosition = null;
          _isRightMouseDown = false;
        }
      },
      onPointerCancel: (event) {
        if (_primaryButtonPointer == event.pointer) {
          _primaryButtonPointer = null;
          _lastLeftPanPosition = null;
        }
        if (_secondaryButtonPointer == event.pointer) {
          _secondaryButtonPointer = null;
          _lastRightPanPosition = null;
          _isRightMouseDown = false;
        }
      },
      child: MouseRegion(
        onHover: (event) {
          if (event.kind == PointerDeviceKind.mouse) {
            if (event.buttons == kPrimaryButton && _primaryButtonPointer == null) {
              _primaryButtonPointer = -1;
              _lastLeftPanPosition = event.position;
            } else if (event.buttons == kSecondaryButton && _secondaryButtonPointer == null) {
              _secondaryButtonPointer = -1;
              _lastRightPanPosition = event.position;
              _isRightMouseDown = true;
            }
          }
        },
        child: GestureDetector(
          onScaleUpdate: (details) {
            if (!_isRightMouseDown) {
              setState(() {
                _scale = (_scale * details.scale).clamp(0.1, 3.0);
              });
            }
          },
          onTapDown: (details) {
            final shiftPressed = _isShiftKeyPressed();
            _handleTap(details.localPosition, shiftPressed);
          },
          child: CustomPaint(
            size: Size.infinite,
            painter: Word3DPainter(
              words: widget.network.getTopWords(150),
              wordLibrary: widget.network.wordLibrary,
              allWords: widget.network.words,
              rotationX: _rotationX,
              rotationY: _rotationY,
              scale: _scale,
              offset: _offset,
              selectedWordIds: widget.selectedWordIds,
              searchVector: widget.network.currentSearchVector,
              searchWords: widget.network.currentSearchWords,
            ),
          ),
        ),
      ),
    );
  }

  bool _isShiftKeyPressed() {
    return _shiftPressed;
  }

  void _handleTap(Offset position, bool shiftPressed) {
    final RenderBox box = context.findRenderObject() as RenderBox;
    final size = box.size;
    final words = widget.network.getTopWords(150);
    final centerX = size.width / 2 + _offset.dx;
    final centerY = size.height / 2 + _offset.dy;
    
    int? clickedWordId;
    double minDistance = 30.0;
    
    for (final word in words) {
      final projected = _project3DTo2D(
        word.x - 500, word.y - 500, word.z - 500,
        centerX, centerY, _rotationX, _rotationY, _scale,
      );
      
      final distance = sqrt(
        pow(projected.dx - position.dx, 2) + 
        pow(projected.dy - position.dy, 2)
      );
      
      if (distance < minDistance) {
        minDistance = distance;
        clickedWordId = word.id;
      }
    }
    
    if (clickedWordId != null) {
      widget.onWordSelected(clickedWordId, shiftPressed);
    }
  }
  
  Offset _project3DTo2D(double x, double y, double z, double centerX, double centerY, 
                        double rotationX, double rotationY, double scale) {
    final cosY = cos(rotationY);
    final sinY = sin(rotationY);
    final cosX = cos(rotationX);
    final sinX = sin(rotationX);
    
    var x1 = x * cosY - z * sinY;
    var z1 = x * sinY + z * cosY;
    var y1 = y;
    
    final y2 = y1 * cosX - z1 * sinX;
    final z2 = y1 * sinX + z1 * cosX;
    
    final perspective = 1000 / (1000 + z2);
    final screenX = centerX + x1 * scale * perspective;
    final screenY = centerY + y2 * scale * perspective;
    
    return Offset(screenX, screenY);
  }
}

class Word3DPainter extends CustomPainter {
  final List<Word> words;
  final Map<int, String> wordLibrary;
  final Map<int, Word> allWords;
  final double rotationX;
  final double rotationY;
  final double scale;
  final Offset offset;
  final Set<int> selectedWordIds;
  final Map<int, int> searchVector;
  final List<int> searchWords;
  
  Word3DPainter({
    required this.words,
    required this.wordLibrary,
    required this.allWords,
    required this.rotationX,
    required this.rotationY,
    required this.scale,
    required this.offset,
    required this.selectedWordIds,
    required this.searchVector,
    required this.searchWords,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    if (words.isEmpty) return;
    
    final centerX = size.width / 2 + offset.dx;
    final centerY = size.height / 2 + offset.dy;
    
    final projectedWords = <_ProjectedWord>[];
    
    for (final word in words) {
      final pos = _project3DTo2D(
        word.x - 500, word.y - 500, word.z - 500,
        centerX, centerY,
      );
      
      projectedWords.add(_ProjectedWord(
        word: word,
        screenX: pos.dx,
        screenY: pos.dy,
        depth: pos.depth,
      ));
    }
    
    projectedWords.sort((a, b) => a.depth.compareTo(b.depth));
    
    final selectedWords = selectedWordIds.map((id) => allWords[id]).whereType<Word>().toList();
    final connectedWordIds = <int>{};
    
    for (final selectedWord in selectedWords) {
      connectedWordIds.addAll(selectedWord.ratings.keys);
    }
    
    final searchVectorWords = searchVector.keys.toSet();
    final commonSearchWords = <int>{};
    
    if (searchWords.isNotEmpty) {
      for (final wordId in searchVectorWords) {
        if (searchWords.contains(wordId)) {
          commonSearchWords.add(wordId);
        }
      }
    }
    
    for (final projWord in projectedWords) {
      if (selectedWordIds.contains(projWord.word.id)) {
        _drawConnections(canvas, projWord, projectedWords, true, Colors.amber);
      }
    }
    
    for (final projWord in projectedWords) {
      if (searchWords.contains(projWord.word.id) && !selectedWordIds.contains(projWord.word.id)) {
        _drawConnections(canvas, projWord, projectedWords, false, Colors.green);
      }
    }
    
    for (final projWord in projectedWords) {
      final isSelected = selectedWordIds.contains(projWord.word.id);
      final isConnected = connectedWordIds.contains(projWord.word.id);
      final isInSearch = searchVectorWords.contains(projWord.word.id);
      final isCommonSearch = commonSearchWords.contains(projWord.word.id);
       _drawConnections(canvas, projWord, projectedWords, false, Colors.purple.withOpacity(0.69));
      double opacity = 1.0;
      if (selectedWordIds.isNotEmpty && !isSelected && !isConnected) {
        opacity = 0.3;
      }
      
      if (searchVectorWords.isNotEmpty && !isInSearch && selectedWordIds.isEmpty) {
        opacity = 0.2;
      }
      
      Color textColor;
      if (isSelected) {
        textColor = Color(0xFFFFD700);
      } else if (isCommonSearch) {
        textColor = Color(0xFF00FF7F);
      } else if (isInSearch) {
        textColor = Colors.lightGreen;
      } else if (isConnected && selectedWords.isNotEmpty) {
        double maxConnectionStrength = 0.0;
        for (final selectedWord in selectedWords) {
          final rating = selectedWord.ratings[projWord.word.id] ?? 0;
          if (rating > 0) {
            final maxRating = selectedWord.ratings.values.reduce((a, b) => a > b ? a : b);
            final strength = rating / maxRating.toDouble();
            maxConnectionStrength = max(maxConnectionStrength, strength);
          }
        }
        
        final baseColor = _getColorFromText(wordLibrary[projWord.word.id] ?? '');
        textColor = Color.lerp(baseColor, Colors.white, maxConnectionStrength * 0.7)!;
      } else {
        textColor = _getColorFromText(wordLibrary[projWord.word.id] ?? '');
      }
      
      _drawWord(canvas, projWord, opacity, textColor);
    }
  }
  
  void _drawConnections(Canvas canvas, _ProjectedWord projWord, List<_ProjectedWord> allProjected, bool isSelected, Color baseColor) {
    final word = projWord.word;
    if (word.ratings.isEmpty) return;
    bool isUsualConnect = (baseColor ==  Colors.purple.withOpacity(0.69));
    final sortedConnections = word.ratings.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    final connectionsToProcess = sortedConnections.take(isSelected ? 10 : 5).toList();
    
    for (final entry in connectionsToProcess) {
      final otherWord = allWords[entry.key];
      if (otherWord == null) continue;
      
      final otherProj = allProjected.firstWhere(
        (p) => p.word.id == entry.key,
        orElse: () => _ProjectedWord(word: otherWord, screenX: projWord.screenX, screenY: projWord.screenY, depth: 0),
      );
      
      final maxRating = word.ratings.values.reduce((a, b) => a > b ? a : b);
      final normalizedRating = entry.value / maxRating.toDouble();
      
      double opacity = isSelected ? (normalizedRating * 0.8).clamp(0.3, 0.9) : 0.2;
      double strokeWidth = isSelected ? (normalizedRating * 4 + 1.0).clamp(1.0, 3.0) : 1.0;
      
      final connectionColor = isSelected ? 
          Color.lerp(baseColor.withOpacity(0.5), baseColor, normalizedRating)! :
          baseColor.withOpacity(opacity);
      
      final paint = Paint()
        ..color = connectionColor
        ..strokeWidth = strokeWidth
        ..style = PaintingStyle.stroke;
      
      canvas.drawLine(
        Offset(projWord.screenX, projWord.screenY),
        Offset(otherProj.screenX, otherProj.screenY),
        paint,
      );
      
      if (isSelected && normalizedRating > 0.3) {
        final dotPaint = Paint()
          ..color = baseColor.withOpacity(normalizedRating * 0.8)
          ..style = PaintingStyle.fill;
        
        canvas.drawCircle(
          Offset(otherProj.screenX, otherProj.screenY),
          1 * strokeWidth,
          dotPaint,
        );
      }
    }
  }
  
  void _drawWord(Canvas canvas, _ProjectedWord projWord, double opacity, Color color) {
    final wordText = wordLibrary[projWord.word.id] ?? 'unknown';
    final scaleFactor = projWord.word.allRating / (words.isNotEmpty ? words[0].allRating : 1);
    final baseSize = 12.0 * scale;
    final fontSize = baseSize + scaleFactor * 6 * scale;
    
    final backgroundPaint = Paint()
      ..color = Colors.black.withOpacity(opacity * 0.7)
      ..style = PaintingStyle.fill;
    
    final textSpan = TextSpan(
      text: wordText,
      style: TextStyle(
        color: color.withOpacity(opacity),
        fontSize: fontSize,
        fontWeight: FontWeight.bold,
        shadows: [
          Shadow(
            blurRadius: 3.0,
            color: Colors.black.withOpacity(opacity * 0.8),
            offset: Offset(1.0, 1.0),
          ),
        ],
      ),
    );
    
    final textPainter = TextPainter(
      text: textSpan,
      textDirection: ui.TextDirection.ltr,
    );
    
    textPainter.layout();
    
    final textOffset = Offset(
      projWord.screenX - textPainter.width / 2,
      projWord.screenY - textPainter.height / 2,
    );
    
    final backgroundRect = Rect.fromCenter(
      center: Offset(projWord.screenX, projWord.screenY),
      width: textPainter.width + 8,
      height: textPainter.height + 4,
    );
    
    canvas.drawRect(backgroundRect, backgroundPaint);
    
    textPainter.paint(canvas, textOffset);
    
    if (selectedWordIds.contains(projWord.word.id)) {
      final highlightPaint = Paint()
        ..color = Colors.yellow.withOpacity(0.3)
        ..strokeWidth = 2
        ..style = PaintingStyle.stroke;
      
      canvas.drawCircle(
        Offset(projWord.screenX, projWord.screenY),
        textPainter.width / 2 + 6,
        highlightPaint,
      );
    }
  }
  
  _Projected3D _project3DTo2D(double x, double y, double z, double centerX, double centerY) {
    final cosY = cos(rotationY);
    final sinY = sin(rotationY);
    final cosX = cos(rotationX);
    final sinX = sin(rotationX);
    
    var x1 = x * cosY - z * sinY;
    var z1 = x * sinY + z * cosY;
    var y1 = y;
    
    final y2 = y1 * cosX - z1 * sinX;
    final z2 = y1 * sinX + z1 * cosX;
    
    final perspective = 1000 / (1000 + z2);
    final screenX = centerX + x1 * scale * perspective;
    final screenY = centerY + y2 * scale * perspective;
    
    return _Projected3D(dx: screenX, dy: screenY, depth: z2);
  }
  
  Color _getColorFromText(String text) {
    int hash = 0;
    for (int i = 0; i < text.length; i++) {
      hash = text.codeUnitAt(i) + ((hash << 5) - hash);
    }
    
    int r = ((hash & 0xFF0000) >> 16);
    int g = ((hash & 0x00FF00) >> 8);
    int b = (hash & 0x0000FF);
    
    r = (r * 1.4).toInt().clamp(0, 255);
    g = (g * 1.4).toInt().clamp(0, 255);
    b = (b * 1.4).toInt().clamp(0, 255);
    
    return Color.fromRGBO(r, g, b, 1.0);
  }
  
  @override
  bool shouldRepaint(Word3DPainter oldDelegate) {
    return oldDelegate.rotationX != rotationX ||
        oldDelegate.rotationY != rotationY ||
        oldDelegate.scale != scale ||
        oldDelegate.offset != offset ||
        oldDelegate.selectedWordIds.length != selectedWordIds.length ||
        oldDelegate.searchVector.length != searchVector.length;
  }
}

class _ProjectedWord {
  final Word word;
  final double screenX;
  final double screenY;
  final double depth;
  
  _ProjectedWord({required this.word, required this.screenX, required this.screenY, required this.depth});
}

class _Projected3D {
  final double dx;
  final double dy;
  final double depth;
  
  _Projected3D({required this.dx, required this.dy, required this.depth});
}

// ========== ОСНОВНОЕ ПРИЛОЖЕНИЕ ==========
class NeuralNetworkApp extends StatefulWidget {
  @override
  _NeuralNetworkAppState createState() => _NeuralNetworkAppState();
}

class _NeuralNetworkAppState extends State<NeuralNetworkApp> {
  final OptimizedNeuralNetwork network = OptimizedNeuralNetwork();
  final TextEditingController _chatController = TextEditingController();
  final TextEditingController _searchController = TextEditingController();
  final List<ChatMessage1> _messages = [];
  bool _isProcessing = false;
  bool _shiftPressed = false;
  bool _ctrlPressed = false;
  
  @override
  void initState() {
    super.initState();
    _loadNetwork();
    RawKeyboard.instance.addListener(_handleKeyEvent);
    
    
  }
  
  @override
  void dispose() {
    RawKeyboard.instance.removeListener(_handleKeyEvent);
    super.dispose();
  }
  
  void _handleKeyEvent(RawKeyEvent event) {
    if (event.logicalKey == LogicalKeyboardKey.shiftLeft || 
        event.logicalKey == LogicalKeyboardKey.shiftRight) {
      setState(() {
        _shiftPressed = event is RawKeyDownEvent;
      });
    } else if (event.logicalKey == LogicalKeyboardKey.controlLeft ||
               event.logicalKey == LogicalKeyboardKey.controlRight) {
      setState(() {
        _ctrlPressed = event is RawKeyDownEvent;
      });
    }
    
    if (event is RawKeyDownEvent) {
      if (_ctrlPressed) {
        if (event.logicalKey == LogicalKeyboardKey.keyZ) {
          if (_shiftPressed) {
            network.redo();
          } else {
            network.undo();
          }
          setState(() {});
        } else if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
          network.navigateToNextSearchedNeuron();
          setState(() {});
        } else if (event.logicalKey == LogicalKeyboardKey.arrowLeft) {
          network.navigateToPreviousSearchedNeuron();
          setState(() {});
        }
      }
    }
  }

  Future<void> _loadNetwork() async {
    await network.loadFromFile();
    await network.updateClusters();
    _addMessage('Система загружена: ${network.words.length} слов, ${network.neurons.length} нейронов', isSystem: true);
  }
  
  void _addMessage(String text, {bool isSystem = false}) {
    setState(() {
      _messages.add(ChatMessage1(
        text: text,
        isSystem: isSystem,
        timestamp: DateTime.now(),
      ));
    });
  }
 Future<void> _trainFromRange(String command) async {
  try {
    final parts = command.split(' ');
    if (parts.length < 5 || parts[0] != '--train' || parts[1] != 'from' || parts[3] != 'to') {
      _addMessage('Invalid command format. Use: --train from START_URL to END_URL', isSystem: true);
      return;
    }
    
    final startUrl = parts[2];
    final endUrl = parts[4];
    
    // Находим числовую разницу между URL
    final result = _findNumericDifference(startUrl, endUrl);
    
    if (result == null) {
      _addMessage('Could not find numeric difference between URLs', isSystem: true);
      return;
    }
    
    final (baseUrl, startNumber, endNumber, formatNumber) = result;
    
    if (startNumber >= endNumber) {
      _addMessage('Start number must be less than end number', isSystem: true);
      return;
    }
    
    final total = endNumber - startNumber + 1;
    _addMessage('Training: from $startNumber to $endNumber ($total URLs)', isSystem: true);
    
    int processed = 0;
    
    for (int i = startNumber; i <= endNumber; i++) {
      final formattedNumber = formatNumber(i);
      final currentUrl = baseUrl.replaceFirst('{NUM}', formattedNumber.toString());
      
      _addMessage('[$processed/$total] Processing: $currentUrl', isSystem: true);
      
      try {
        await network.processWebsite(currentUrl, (progress) {
          _addMessage('  $progress', isSystem: true);
        });
        processed++;
        
        await Future.delayed(Duration(milliseconds: 500));
        
      } catch (e) {
        _addMessage('  Failed: $e', isSystem: true);
      }
    }
    
    _addMessage('Completed! Processed $processed/$total URLs', isSystem: true);
    setState(() {});
    
  } catch (e) {
    _addMessage('Error: $e', isSystem: true);
  }
}

(String, int, int, String Function(int))? _findNumericDifference(String startUrl, String endUrl) {
  // Ищем все числовые последовательности в URL
  final startNumbers = _extractAllNumbers(startUrl);
  final endNumbers = _extractAllNumbers(endUrl);
  
  if (startNumbers.isEmpty || endNumbers.isEmpty) {
    return null;
  }
  
  // Ищем первую пару чисел, которые отличаются
  for (int i = 0; i < min(startNumbers.length, endNumbers.length); i++) {
    final startNum = startNumbers[i];
    final endNum = endNumbers[i];
    
    if (startNum.value != endNum.value) {
      // Нашли различающиеся числа
      final startNumber = startNum.value;
      final endNumber = endNum.value;
      
      // Создаем базовый URL с плейсхолдером
      final baseUrl = startUrl.replaceFirst(startNum.match, '{NUM}');
      
      // Функция для форматирования числа (сохраняет ведущие нули если есть)
      String formatNumber(int num) {
        if (startNum.match.length > endNum.match.length) {
          // Сохраняем форматирование из startUrl
          return num.toString().padLeft(startNum.match.length, '0');
        } else if (endNum.match.length > startNum.match.length) {
          // Сохраняем форматирование из endUrl
          return num.toString().padLeft(endNum.match.length, '0');
        }
        return num.toString();
      }
      
      return (baseUrl, startNumber, endNumber, formatNumber);
    }
  }
  
  return null;
}

List<NumberMatch> _extractAllNumbers(String url) {
  final matches = <NumberMatch>[];
  final regex = RegExp(r'\d+');
  final allMatches = regex.allMatches(url);
  
  for (final match in allMatches) {
    final number = int.tryParse(match.group(0)!);
    if (number != null) {
      matches.add(NumberMatch(
        value: number,
        match: match.group(0)!,
        start: match.start,
        end: match.end,
      ));
    }
  }
  
  return matches;
}


int? _extractNumberFromUrl(String url) {
  // Ищем последовательность цифр в URL
  final regex = RegExp(r'/(\d+)(?:\?|$|/)');
  final match = regex.firstMatch(url);
  
  if (match != null) {
    return int.tryParse(match.group(1)!);
  }
  
  return null;
}

String _replaceNumberInUrl(String url, int newNumber) {
  // Заменяем число в URL на новое
  return url.replaceAllMapped(
    RegExp(r'/(\d+)(?:\?|$|/)'),
    (match) => '/$newNumber${match.group(2) ?? ''}'
  );
}
Future<void> testHash(String text) async {
  // Поиск похожих
  final Map<int, double> myQueryVector = {};
  final splitter = text.trim().split(" ");
  
  for (final word in splitter) {
    final wordElement = network.wordIndex[word]; // Добавил network.
    if (wordElement != null) {
      final wordObject = network.words[wordElement]; // Добавил network.
      if (wordObject != null) {
        final vector = wordObject.ratings;
        for (final element in vector.entries) { // Исправил 'element' на 'final element'
          myQueryVector[element.key] = (myQueryVector[element.key] ?? 0) + 
                                      (element.value / wordObject.allRating);
        }
      }
    }
  }
  
  final similarDocs = network.searchSystem.findSimilarVectors(myQueryVector); // Добавил network.
  List<String> all_elements = [];
  
  for (final message in similarDocs) {
    if (message.startsWith("word_")) {
      final number = int.tryParse(message.substring(5));
      if (number != null) {
        final word = network.wordLibrary[number]; // Добавил network.
        if (word != null) all_elements.add(word);
      }
    } else if (message.startsWith("fragment_")) {
      final number = int.tryParse(message.substring(9));
      if (number != null) {
        final fragment = network.fragments[number]; // Добавил network.
        if (fragment != null) all_elements.add(fragment.text);
      }
    } else if (message.startsWith("neuron_")) {
      final number = int.tryParse(message.substring(7));
      if (number != null) {
        final neuron = network.neurons[number]; // Исправил wordLibrary на neurons
        if (neuron?.pageTitle != null) all_elements.add(neuron!.pageTitle!);
      }
    }
  }

  _addMessage("Some answer done ${all_elements.take(100).join(', ')}"); // Исправил скобку
}
  Future<void> _handleMessage(String text) async {
    if (text.isEmpty) return;
    
    _addMessage(text);
    _chatController.clear();
    setState(() => _isProcessing = true);
    
    try {
      if (text.startsWith("search: ")){
        await testHash(text.substring(7,text.length));
      
      }else
      if (text.startsWith("--train ")){
        await _trainFromRange(text);
      
      }else
      if (text.startsWith("http://") || text.startsWith("https://")) {
        await network.processWebsite(text, (progress) {
          _addMessage(progress, isSystem: true);
        });
        setState(() {});
      } else if (text == '/train') {
        await network.trainTest((progress) {
          _addMessage(progress, isSystem: true);
        });
        setState(() {});
      } else if (text == '/train2') {
        await network.trainTest2((progress) {
          _addMessage(progress, isSystem: true);
        });
        setState(() {});
      }else if (text == '/optimize') {
        network.optimizeWordPositions();
        _addMessage('Позиции слов оптимизированы', isSystem: true);
        setState(() {});
      } else if (text == '/optimizeNeuralConnectionsRebuildWeights') {
        VectorOperations.optimizeNeuralConnectionsRebuildWeights(network.words);
        _addMessage('Нейронные связи оптимизированы', isSystem: true);
        setState(() {});
      } else {
        final result = await network.processQueryAdvanced(text);
        
        if (result['line1'].toString().isNotEmpty) {
          _addMessage('Ключевые слова: ${result['line1']}', isSystem: true);
        }
        
        if (result['line2'].toString().isNotEmpty) {
          _addMessage('Контекст: ${result['line2']}', isSystem: true);
        }
        if (result['line3'].toString().isNotEmpty) {
          _addMessage('Контекст: ${result['line3']}', isSystem: true);
        }
      
        if (result['line5'].toString().isNotEmpty) {
          _addMessage('Entropy Increase: ${result['line5']}', isSystem: true);
         
        }
         if (result['line6'].toString().isNotEmpty) {
          _addMessage('Entropy descrease: ${result['line6']}', isSystem: true);
        }
         if (result['line7'].toString().isNotEmpty) {
          _addMessage('Entropy descrease: ${result['line7']}', isSystem: true);
        }
        final fragments = result['fragments'] as List<String>;
        if (fragments.isNotEmpty) {
          _addMessage('Найдено ${fragments.length} релевантных фрагментов', isSystem: true);
          for (int i = 0; i < min(5, fragments.length); i++) {
            _addMessage(fragments[i]);
          }
        }
        
        setState(() {});
      }
    } catch (e) {
      _addMessage('Ошибка: $e', isSystem: true);
    }
    
    setState(() => _isProcessing = false);
  }
  
  void _handleSearchUpdate(String text) {
    if (text.isEmpty) {
      setState(() {
        network.currentSearchVector.clear();
        network.currentSearchWords.clear();
      });
      return;
    }
    
    switch (network.visualizationMode) {
      case VisualizationMode.words:
        _handleWordSearch(text);
        break;
      case VisualizationMode.neurons:
        _handleNeuronSearch(text);
        break;
      case VisualizationMode.fragments:
        _handleFragmentSearch(text);
        break;
    }
  }
  
  void _handleWordSearch(String text) {
    final wordTexts = network._extractWords(text);
    final promptWordIds = wordTexts
        .map((w) => network.wordIndex[w])
        .where((id) => id != null)
        .cast<int>()
        .toList();
    
    if (promptWordIds.isEmpty) return;
    
    final superVector = <int, int>{};
    for (final wordId in promptWordIds) {
      final word = network.words[wordId];
      if (word != null) {
        for (final entry in word.ratings.entries) {
          superVector[entry.key] = (superVector[entry.key] ?? 0) + entry.value;
        }
      }
    }
    
    final projectedVector = VectorOperations.selfProjection(superVector, network.words);
    
    setState(() {
      network.currentSearchVector = projectedVector;
      network.currentSearchWords = promptWordIds;
    });
  }
  
  void _handleNeuronSearch(String text) {
    final foundNeurons = network.searchNeuronsByKeywords(text);
    setState(() {
      network.selectedNeuronIds = foundNeurons.take(10).map((n) => n.id).toSet();
    });
  }
  
  void _handleFragmentSearch(String text) {
    final foundFragments = network.searchFragments(text);
    setState(() {
      network.selectedFragmentIds = foundFragments.take(10).map((f) => f.id).toSet();
    });
  }
  
  void _handleWordSelected(int wordId, bool withShift) {
    setState(() {
      network.selectWord(wordId, withShift: withShift || _shiftPressed);
    });
  }
  
  void _handleNeuronSelected(int neuronId, bool withShift) {
    setState(() {
      network.selectNeuron(neuronId, withShift: withShift || _shiftPressed);
    });
  }

  void _handleFragmentSelected(int fragmentId, bool withShift) {
    setState(() {
      network.selectFragment(fragmentId, withShift: withShift || _shiftPressed);
      
      if (network.selectedFragmentIds.isNotEmpty) {
        final allFragmentWordIds = <int>{};
        for (final selectedFragmentId in network.selectedFragmentIds) {
          final fragment = network.fragments[selectedFragmentId];
          if (fragment != null) {
            allFragmentWordIds.addAll(fragment.wordIds);
          }
        }
        network.selectedWordIds = allFragmentWordIds;
      }
    });
  }

  void _handleClusterTapped(String clusterId) {
    network.toggleClusterExpansion(clusterId);
    setState(() {});
  }

  void _changeVisualizationMode(VisualizationMode mode) {
    setState(() {
      network.visualizationMode = mode;
      _searchController.clear();
      network.currentSearchVector.clear();
      network.currentSearchWords.clear();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Advanced Neural Network System'),
        backgroundColor: Colors.deepPurple,
        actions: [
          IconButton(
            icon: Icon(Icons.save),
            onPressed: () => network.saveToFile(),
            tooltip: 'Сохранить',
          ),
          IconButton(
            icon: Icon(Icons.auto_awesome),
            onPressed: () {
              network.optimizeWordPositions();
              _addMessage('Оптимизация запущена', isSystem: true);
              setState(() {});
            },
            tooltip: 'Оптимизировать',
          ),
        ],
      ),
      body: Row(
        children: [
          Expanded(flex: 3, child: _buildChatPanel()),
          Expanded(flex: 2, child: _buildVisualizationPanel()),
          if (network.selectedWordIds.isNotEmpty || 
              network.selectedNeuronIds.isNotEmpty || 
              network.selectedFragmentIds.isNotEmpty)
            Container(
              width: MediaQuery.of(context).size.width * 0.3,
              child: _buildDetailsPanel(),
            ),
        ],
      ),
    );
  }
  
  Widget _buildChatPanel() {
    return Container(
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.deepPurple.withOpacity(0.1),
              borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
            ),
            child: Row(
              children: [
                Icon(Icons.chat, color: Colors.deepPurple),
                SizedBox(width: 8),
                Text('Нейро-чат', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                Spacer(),
                if (_isProcessing)
                  Row(
                    children: [
                      SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2)),
                      SizedBox(width: 8),
                      Text('${network.words.length} слов', style: TextStyle(fontSize: 12, color: Colors.grey)),
                    ],
                  ),
              ],
            ),
          ),
          Expanded(
            child: ListView.builder(
              reverse: true,
              itemCount: _messages.length,
              itemBuilder: (context, index) {
                final message = _messages[_messages.length - 1 - index];
                return ChatBubble(
                  message: message,
                  onWordTap: (word) {
                    _searchController.text = word;
                    _handleSearchUpdate(word);
                  },
                );
              },
            ),
          ),
          Container(
            padding: EdgeInsets.all(8),
            decoration: BoxDecoration(
              border: Border(top: BorderSide(color: Colors.grey)),
            ),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _chatController,
                    decoration: InputDecoration(
                      hintText: 'URL, /neurons, /optimize или запрос...',
                      border: OutlineInputBorder(),
                    ),
                    onSubmitted: _handleMessage,
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.send),
                  onPressed: () => _handleMessage(_chatController.text),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildVisualizationPanel() {
    return Container(
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.blue.withOpacity(0.1),
              borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
            ),
            child: Column(
              children: [
                Row(
                  children: [
                    Icon(Icons.auto_awesome, color: Colors.blue),
                    SizedBox(width: 8),
                    Text(
                      _getVisualizationTitle(),
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                  ],
                ),
                SizedBox(height: 8),
                TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: _getSearchHint(),
                    prefixIcon: Icon(Icons.search),
                    border: OutlineInputBorder(),
                    contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  ),
                  onChanged: _handleSearchUpdate,
                ),
                if (network.navigationHistory.isNotEmpty) ...[
                  SizedBox(height: 8),
                  Container(
                    height: 30,
                    child: ListView.builder(
                      scrollDirection: Axis.horizontal,
                      itemCount: network.navigationHistory.length,
                      itemBuilder: (context, index) {
                        final step = network.navigationHistory[index];
                        return Padding(
                          padding: EdgeInsets.only(right: 8),
                          child: ActionChip(
                            label: Text(
                              step.displayText,
                              style: TextStyle(fontSize: 9),
                            ),
                            onPressed: () => network.navigateToStep(index),
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ],
            ),
          ),
          Expanded(
            child: OverflowBox(
              maxWidth: MediaQuery.of(context).size.width * 0.7,
              maxHeight: MediaQuery.of(context).size.height * 0.7,
              child: ClipRect(
                child: _buildVisualization(),
              ),
            ),
          ),
          Container(
            padding: EdgeInsets.all(12),
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(color: Colors.grey, width: 1.0),
              ),
              color: Colors.grey.withOpacity(0.1),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildVisualizationButton('Слова', Icons.text_fields, VisualizationMode.words),
                _buildVisualizationButton('Нейроны', Icons.hub, VisualizationMode.neurons),
                _buildVisualizationButton('Фрагменты', Icons.article, VisualizationMode.fragments),
                _buildStatItem('Слова', network.words.length.toString()),
                _buildStatItem('Фрагменты', network.fragments.length.toString()),
                _buildStatItem('Нейроны', network.neurons.length.toString()),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildVisualization() {
    switch (network.visualizationMode) {
      case VisualizationMode.words:
        return InteractiveWordVisualization3D(
          network: network,
          selectedWordIds: network.selectedWordIds,
          onWordSelected: _handleWordSelected,
        );
      case VisualizationMode.neurons:
        return AdvancedNeuron3DVisualization(
          network: network,
          selectedNeuronIds: network.selectedNeuronIds,
          onNeuronSelected: _handleNeuronSelected,
          onClusterTapped: _handleClusterTapped,
          sendMessage: _addMessage,
        );
      case VisualizationMode.fragments:
        return Fragment3DVisualization(
          network: network,
          selectedFragmentIds: network.selectedFragmentIds,
          onFragmentSelected: _handleFragmentSelected,
          neuronIds: network.selectedNeuronIds.isNotEmpty ? 
              network.selectedNeuronIds : null,
        );
    }
  }
  
  Widget _buildVisualizationButton(String label, IconData icon, VisualizationMode mode) {
    return GestureDetector(
      onTap: () => _changeVisualizationMode(mode),
      child: Container(
        padding: EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: network.visualizationMode == mode ? Colors.blue : Colors.grey,
          borderRadius: BorderRadius.circular(20),
        ),
        child: Row(
          children: [
            Icon(icon, size: 16, color: Colors.white),
            SizedBox(width: 4),
            Text(label, style: TextStyle(fontSize: 12, color: Colors.white)),
          ],
        ),
      ),
    );
  }
  
  Widget _buildDetailsPanel() {
    if (network.selectedWordIds.isNotEmpty) {
      return _buildWordDetailsPanel();
    } else if (network.selectedNeuronIds.isNotEmpty) {
      return _buildNeuronDetailsPanel();
    } else if (network.selectedFragmentIds.isNotEmpty) {
      return _buildFragmentDetailsPanel();
    }
    return SizedBox.shrink();
  }

  Widget _buildWordDetailsPanel() {
    final wordId = network.selectedWordIds.isNotEmpty ? network.selectedWordIds.first : null;
    if (wordId == null) return SizedBox.shrink();
    
    final word = network.words[wordId];
    if (word == null) return SizedBox.shrink();
    
    final wordText = network.wordLibrary[wordId] ?? 'Unknown';
    
    return Container(
      width: MediaQuery.of(context).size.width * 0.3,
      height: MediaQuery.of(context).size.height,
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.orange),
        borderRadius: BorderRadius.circular(8),
        color: Colors.black.withOpacity(0.9),
      ),
      child: DefaultTabController(
        length: 3,
        child: Column(
          children: [
            Container(
              decoration: BoxDecoration(
                color: Colors.orange.withOpacity(0.3),
                borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
              ),
              child: Column(
                children: [
                  Padding(
                    padding: EdgeInsets.all(12),
                    child: Row(
                      children: [
                        Icon(Icons.label, color: Colors.orange, size: 20),
                        SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            wordText,
                            style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.white),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        IconButton(
                          icon: Icon(Icons.close, color: Colors.white, size: 20),
                          onPressed: () => network.clearSelection(),
                        ),
                      ],
                    ),
                  ),
                  TabBar(
                    labelColor: Colors.orange,
                    unselectedLabelColor: Colors.white70,
                    indicatorColor: Colors.orange,
                    tabs: [
                      Tab(text: 'Connections'),
                      Tab(text: 'Fragments'),
                      Tab(text: 'Composite'),
                    ],
                  ),
                ],
              ),
            ),
            Expanded(
              child: TabBarView(
                children: [
                  _buildConnectionsTab(word),
                  _buildFragmentsTab(word),
                  _buildCompositeTab(word),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildConnectionsTab(Word word) {
      final connections = word.ratings.entries.toList();
      connections.sort((a, b) => b.value.compareTo(a.value));

      final topWords = connections.take(40).map((e) => e.key).toList();
      final bottomWords = connections.reversed.take(20).map((e) => e.key).toList();
      final listToShow = [...topWords, ...bottomWords];

    //votsuda 
    return ListView.builder(
      padding: EdgeInsets.all(12),
      itemCount: min(listToShow.length, 50),
      itemBuilder: (context, index) {
        final conn = connections[index];
        final connWord = network.wordLibrary[conn.key] ?? 'Unknown';
        
        return Card(
          color: Colors.grey[850],
          child: ListTile(
            leading: CircleAvatar(
              backgroundColor: Colors.orange,
              child: Text('${index + 1}', style: TextStyle(fontSize: 10)),
            ),
            title: Text(connWord, style: TextStyle(color: Colors.white)),
            trailing: Chip(
              label: Text('${conn.value}'),
              backgroundColor: Colors.orange,
            ),
            onTap: () => _handleWordSelected(conn.key, _shiftPressed),
          ),
        );
      },
    );
  }

  Widget _buildFragmentsTab(Word word) {
    final allFragments = network.fragments.values
        .where((f) => f.wordIds.contains(word.id))
        .toList();
    
    return ListView.builder(
      padding: EdgeInsets.all(12),
      itemCount: allFragments.length,
      itemBuilder: (context, index) {
        final frag = allFragments[index];
        
        return Card(
          color: Colors.grey[850],
          margin: EdgeInsets.only(bottom: 8),
          child: Padding(
            padding: EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  frag.text,
                  style: TextStyle(color: Colors.white70, fontSize: 12),
                ),
                SizedBox(height: 8),
                Chip(
                  label: Text(frag.semanticType),
                  backgroundColor: Colors.blue,
                  labelStyle: TextStyle(fontSize: 10, color: Colors.white),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildCompositeTab(Word word) {
    return StatefulBuilder(
      builder: (context, setState) {
        return Column(
          children: [
            Padding(
              padding: EdgeInsets.all(12),
              child: Row(
                children: [
                  Text('Выделенные слова: ${network.selectedWordIds.length}', 
                      style: TextStyle(color: Colors.white)),
                  Spacer(),
                  if (network.selectedWordIds.length > 1)
                    ElevatedButton.icon(
                      icon: Icon(Icons.search, size: 16),
                      label: Text('Поиск по словам'),
                      onPressed: _searchWithSelectedWords,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.blue,
                        padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      ),
                    ),
                ],
              ),
            ),
            Expanded(
              child: _buildCompositeSearchResults(),
            ),
          ],
        );
      },
    );
  }

  Widget _buildCompositeSearchResults() {
    if (network.selectedWordIds.length < 2) {
      return Center(
        child: Text('Выделите несколько слов (Shift+Click)', 
            style: TextStyle(color: Colors.white70)),
      );
    }
    
    final fragments = network.findFragmentsWithAllWords(network.selectedWordIds);
    final compositeVector = network.getCompositeVector(network.selectedWordIds);
    
    final uniqueFragments = _removeDuplicateFragments(fragments);
    
    return Column(
      children: [
        Padding(
          padding: EdgeInsets.all(8),
          child: Text('Композитный вектор: ${compositeVector.length} связей\n'
                      'Уникальных фрагментов: ${uniqueFragments.length}',
              style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        ),
        Expanded(
          child: ListView.builder(
            itemCount: uniqueFragments.length,
            itemBuilder: (context, index) {
              final fragment = uniqueFragments[index];
              final isSelected = network.selectedFragmentIds.contains(fragment.id);
              
              return Card(
                color: isSelected ? Colors.blue.withOpacity(0.3) : Colors.grey[850],
                margin: EdgeInsets.all(4),
                child: ListTile(
                  title: Text(
                    fragment.text,
                    style: TextStyle(color: Colors.white, fontSize: 12),
                  ),
                  trailing: isSelected ? Icon(Icons.check_circle, color: Colors.blue) : null,
                  onTap: () {
                    setState(() {
                      if (_shiftPressed) {
                        if (isSelected) {
                          network.selectedFragmentIds.remove(fragment.id);
                        } else {
                          network.selectedFragmentIds.add(fragment.id);
                        }
                      } else {
                        network.selectedFragmentIds = {fragment.id};
                      }
                      
                      _highlightWordsInFragment(fragment);
                    });
                  },
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  List<Fragment> _removeDuplicateFragments(List<Fragment> fragments) {
    final seenTexts = <String>{};
    final uniqueFragments = <Fragment>[];
    
    for (final fragment in fragments) {
      final normalizedText = fragment.text.trim().toLowerCase();
      if (!seenTexts.contains(normalizedText)) {
        seenTexts.add(normalizedText);
        uniqueFragments.add(fragment);
      }
    }
    
    return uniqueFragments;
  }

  void _highlightWordsInFragment(Fragment fragment) {
    final fragmentWordIds = fragment.wordIds.toSet();
    setState(() {
      network.selectedWordIds = fragmentWordIds;
    });
  }

  void _searchWithSelectedWords() {
    if (network.selectedWordIds.length < 2) return;
    
    final compositeVector = network.getCompositeVector(network.selectedWordIds);
    final fragments = network.findFragmentsWithAllWords(network.selectedWordIds);
    
    setState(() {
      network.currentSearchVector = compositeVector;
    });
    
    _addMessage('Найдено ${fragments.length} фрагментов с выделенными словами', isSystem: true);
  }

  Widget _buildNeuronDetailsPanel() {
    return Container(
      width: MediaQuery.of(context).size.width * 0.3,
      height: MediaQuery.of(context).size.height,
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.purple),
        borderRadius: BorderRadius.circular(8),
        color: Colors.black.withOpacity(0.9),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.purple.withOpacity(0.3),
              borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
            ),
            child: Row(
              children: [
                Icon(Icons.hub, color: Colors.purple),
                SizedBox(width: 8),
                Expanded(
                  child: Text(
                    '${network.selectedNeuronIds.length} нейронов выбрано',
                    style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.close, color: Colors.white),
                  onPressed: () => network.clearSelection(),
                ),
              ],
            ),
          ),
          
          if (network.selectedNeuronIds.isNotEmpty) ...[
            Padding(
              padding: EdgeInsets.all(8),
              child: Wrap(
                spacing: 8,
                runSpacing: 8,
                children: [
                  if (network.selectedNeuronIds.length >= 2) ...[
                    ElevatedButton.icon(
                      icon: Icon(Icons.merge),
                      label: Text('New Neuron'),
                      onPressed: _mergeSelectedNeurons,
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
                    ),
                    ElevatedButton.icon(
                      icon: Icon(Icons.link),
                      label: Text('Process'),
                      onPressed: _processSelectedNeurons,
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),
                    ),
                  ],
                  ElevatedButton.icon(
                    icon: Icon(Icons.article),
                    label: Text('Show Fragments'),
                    onPressed: _createFragmentVisualizationFromNeurons,
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),
                  ),
                  ElevatedButton.icon(
                    icon: Icon(Icons.content_copy),
                    label: Text('Copy'),
                    onPressed: _copySelectedNeuronsToClipboard,
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.orange),
                  ),
                  ElevatedButton.icon(
                    icon: Icon(Icons.auto_awesome),
                    label: Text('Show Words'),
                    onPressed: _createWordsVisualizationFromNeurons,
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.purple),
                  ),
                ],
              ),
            ),
          ],
          
          Expanded(
            child: _buildNeuronFragmentsList(),
          ),
        ],
      ),
    );
  }

  void _createFragmentVisualizationFromNeurons() {
    if (network.selectedNeuronIds.isEmpty) return;
    
    setState(() {
      network.visualizationMode = VisualizationMode.fragments;
    });
    
    _addMessage('Создана визуализация фрагментов для ${network.selectedNeuronIds.length} нейронов', isSystem: true);
  }

  Future<void> _mergeSelectedNeurons() async {
    if (network.selectedNeuronIds.length < 2) return;
    
    final newNeuron = await network.mergeNeurons(network.selectedNeuronIds);
    _addMessage('Создан объединенный нейрон #${newNeuron.id} из ${network.selectedNeuronIds.length} нейронов', isSystem: true);
    
    setState(() {
      network.selectedNeuronIds = {newNeuron.id};
    });
  }

  Future<void> _processSelectedNeurons() async {
    if (network.selectedNeuronIds.length < 2) return;
    
    await network.processNeuronConnections(network.selectedNeuronIds);
    _addMessage('Обработано ${network.selectedNeuronIds.length} нейронов, связи усилены', isSystem: true);
    setState(() {});
  }

  Future<void> _copySelectedNeuronsToClipboard() async {
    if (network.selectedNeuronIds.isEmpty) return;
    
    await network.copyNeuronsToClipboard(network.selectedNeuronIds);
    _addMessage('Текст ${network.selectedNeuronIds.length} нейронов скопирован в буфер', isSystem: true);
  }

  Future<void> _copySelectedFragmentsToClipboard() async {
    if (network.selectedFragmentIds.isEmpty) return;
    
    await network.copyFragmentsToClipboard(network.selectedFragmentIds.toList());
    _addMessage('Текст ${network.selectedFragmentIds.length} фрагментов скопирован в буфер', isSystem: true);
  }

  Widget _buildNeuronFragmentsList() {
    final selectedNeuronId = network.selectedNeuronIds.isNotEmpty ? network.selectedNeuronIds.first : null;
    if (selectedNeuronId == null) return Center(child: Text('Выберите нейрон', style: TextStyle(color: Colors.white)));
    
    final neuron = network.neurons[selectedNeuronId];
    if (neuron == null) return Center(child: Text('Нейрон не найден', style: TextStyle(color: Colors.white)));
    
    final fragmentIds = neuron.fragmentLinks;
    
    return StatefulBuilder(
      builder: (context, setState) {
        return Column(
          children: [
            Padding(
              padding: EdgeInsets.all(8),
              child: Row(
                children: [
                  Text('Фрагменты: ${fragmentIds.length}', 
                      style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                  Spacer(),
                  if (network.selectedFragmentIds.isNotEmpty)
                    ElevatedButton.icon(
                      icon: Icon(Icons.content_copy, size: 16),
                      label: Text('Копировать выделенные'),
                      onPressed: _copySelectedFragmentsToClipboard,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.green,
                        padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      ),
                    ),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: fragmentIds.length,
                itemBuilder: (context, index) {
                  final fragmentId = fragmentIds[index];
                  final fragment = network.fragments[fragmentId];
                  if (fragment == null) return SizedBox.shrink();
                  
                  final isSelected = network.selectedFragmentIds.contains(fragmentId);
                  
                  return Card(
                    color: isSelected ? Colors.green.withOpacity(0.3) : Colors.grey[850],
                    margin: EdgeInsets.all(4),
                    child: ListTile(
                      title: Text(
                        fragment.text.length > 100 
                            ? fragment.text.substring(0, 100) + "..." 
                            : fragment.text,
                        style: TextStyle(color: Colors.white, fontSize: 12),
                      ),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          SizedBox(height: 4),
                          Wrap(
                            spacing: 4,
                            children: fragment.keywords.take(3).map((wordId) {
                              final wordText = network.wordLibrary[wordId] ?? '';
                              return GestureDetector(
                                onTap: () => _handleWordTap(wordText),
                                child: Chip(
                                  label: Text(wordText, style: TextStyle(fontSize: 8)),
                                  backgroundColor: Colors.purple.withOpacity(0.5),
                                ),
                              );
                            }).toList(),
                          ),
                        ],
                      ),
                      trailing: isSelected ? Icon(Icons.check_circle, color: Colors.green) : null,
                      onTap: () {
                        setState(() {
                          if (_shiftPressed) {
                            if (isSelected) {
                              network.selectedFragmentIds.remove(fragmentId);
                            } else {
                              network.selectedFragmentIds.add(fragmentId);
                            }
                          } else {
                            network.selectedFragmentIds = {fragmentId};
                          }
                        });
                      },
                      onLongPress: () {
                        _showFragmentDetail(fragment);
                      },
                    ),
                  );
                },
              ),
            ),
          ],
        );
      },
    );
  }

  void _showFragmentDetail(Fragment fragment) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: Colors.black,
        surfaceTintColor: Colors.transparent,
        title: Row(
          children: [
            Icon(Icons.article, color: Colors.green),
            SizedBox(width: 8),
            Text('Фрагмент #${fragment.id}', style: TextStyle(color: Colors.white)),
          ],
        ),
        content: Container(
          width: MediaQuery.of(context).size.width * 0.8,
          height: MediaQuery.of(context).size.height * 0.8,
          child: _buildFragmentDetailContent(fragment),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Закрыть', style: TextStyle(color: Colors.white)),
          ),
          ElevatedButton(
            onPressed: () {
              Clipboard.setData(ClipboardData(text: fragment.text));
              Navigator.of(context).pop();
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Текст скопирован в буфер')),
              );
            },
            child: Text('Копировать текст'),
          ),
        ],
      ),
    );
  }

  Widget _buildFragmentDetailContent(Fragment fragment) {
    final containingNeurons = network.neurons.values
        .where((neuron) => neuron.fragmentLinks.contains(fragment.id))
        .toList();
    
    final allFragments = network.fragments.values.toList();
    final currentIndex = allFragments.indexWhere((f) => f.id == fragment.id);
    final previousFragment = currentIndex > 0 ? allFragments[currentIndex - 1] : null;
    final nextFragment = currentIndex < allFragments.length - 1 ? allFragments[currentIndex + 1] : null;
    
    return DefaultTabController(
      length: 3,
      child: Column(
        children: [
          TabBar(
            labelColor: Colors.green,
            unselectedLabelColor: Colors.white70,
            indicatorColor: Colors.green,
            tabs: [
              Tab(text: 'Текст'),
              Tab(text: 'Ключевые слова'),
              Tab(text: 'Контекст'),
            ],
          ),
          Expanded(
            child: TabBarView(
              children: [
                SingleChildScrollView(
                  padding: EdgeInsets.all(16),
                  child: SelectableText(
                    fragment.text,
                    style: TextStyle(color: Colors.white, fontSize: 14),
                  ),
                ),
                
                _buildKeywordsTab(fragment),
                
                _buildContextTab(fragment, containingNeurons, previousFragment, nextFragment),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildKeywordsTab(Fragment fragment) {
    return Padding(
      padding: EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Ключевые слова:', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: fragment.keywords.map((wordId) {
              final wordText = network.wordLibrary[wordId] ?? '';
              return GestureDetector(
                onTap: () {
                  Navigator.of(context).pop();
                  network.selectWord(wordId);
                  setState(() {});
                },
                child: Chip(
                  label: Text(wordText),
                  backgroundColor: Colors.green.withOpacity(0.3),
                ),
              );
            }).toList(),
          ),
          SizedBox(height: 16),
          Text('Сигнатура:', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          SizedBox(height: 8),
          Text(
            fragment.semanticType,
            style: TextStyle(color: Colors.white70),
          ),
        ],
      ),
    );
  }

  Widget _buildContextTab(Fragment fragment, List<Neuron> containingNeurons, Fragment? previousFragment, Fragment? nextFragment) {
    return Padding(
      padding: EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Принадлежит нейронам:', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          SizedBox(height: 8),
          if (containingNeurons.isEmpty)
            Text('Не принадлежит ни одному нейрону', style: TextStyle(color: Colors.white70)),
          ...containingNeurons.map((neuron) => ListTile(
            leading: Icon(Icons.hub, color: Colors.purple),
            title: Text(neuron.pageTitle ?? 'Neuron #${neuron.id}', style: TextStyle(color: Colors.white)),
            onTap: () {
              Navigator.of(context).pop();
              network.selectNeuron(neuron.id);
              setState(() {});
            },
          )).toList(),
          
          SizedBox(height: 16),
          Text('Соседние фрагменты:', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          SizedBox(height: 8),
          if (previousFragment != null) 
            _buildNeighborFragmentTile(previousFragment, 'Предыдущий'),
          if (nextFragment != null)
            _buildNeighborFragmentTile(nextFragment, 'Следующий'),
        ],
      ),
    );
  }

  Widget _buildNeighborFragmentTile(Fragment fragment, String label) {
    return Card(
      color: Colors.grey[850],
      child: ListTile(
        leading: Icon(Icons.article, color: Colors.blue),
        title: Text(label, style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        subtitle: Text(
          fragment.text.length > 100 ? fragment.text.substring(0, 100) + "..." : fragment.text,
          style: TextStyle(color: Colors.white70),
        ),
        onTap: () {
          Navigator.of(context).pop();
          _showFragmentDetail(fragment);
        },
      ),
    );
  }

  void _createWordsVisualizationFromNeurons() {
    if (network.selectedNeuronIds.isEmpty) return;
    
    final projectedWords = network.createNeuronWordsVisualization(network.selectedNeuronIds);
    
    setState(() {
      network.visualizationMode = VisualizationMode.words;
    });
    
    _addMessage('Создана визуализация слов для ${network.selectedNeuronIds.length} нейронов', isSystem: true);
  }

  void _handleWordTap(String wordText) {
    _searchController.text = wordText;
    _handleSearchUpdate(wordText);
  }

  Widget _buildFragmentDetailsPanel() {
    return Container(
      height: MediaQuery.of(context).size.height,
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.green),
        borderRadius: BorderRadius.circular(8),
        color: Colors.black.withOpacity(0.9),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.green.withOpacity(0.3),
              borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
            ),
            child: Row(
              children: [
                Icon(Icons.article, color: Colors.green),
                SizedBox(width: 8),
                Expanded(
                  child: Text(
                    '${network.selectedFragmentIds.length} фрагментов выбрано',
                    style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.close, color: Colors.white),
                  onPressed: () => network.clearSelection(),
                ),
              ],
            ),
          ),
          if (network.selectedFragmentIds.isNotEmpty) ...[
            Padding(
              padding: EdgeInsets.all(8),
              child: ElevatedButton.icon(
                icon: Icon(Icons.content_copy),
                label: Text('Копировать в буфер'),
                onPressed: _copySelectedFragmentsToClipboard,
                style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
              ),
            ),
          ],
          Expanded(
            child: ListView.builder(
              itemCount: network.selectedFragmentIds.length,
              itemBuilder: (context, index) {
                final fragmentId = network.selectedFragmentIds.elementAt(index);
                final fragment = network.fragments[fragmentId];
                if (fragment == null) return SizedBox.shrink();
                
                return Card(
                  color: Colors.grey[850],
                  margin: EdgeInsets.all(8),
                  child: Padding(
                    padding: EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          fragment.text,
                          style: TextStyle(color: Colors.white, fontSize: 12),
                        ),
                        SizedBox(height: 8),
                        Wrap(
                          spacing: 4,
                          children: fragment.keywords.map((wordId) {
                            final wordText = network.wordLibrary[wordId] ?? '';
                            return Chip(
                              label: Text(wordText, style: TextStyle(fontSize: 8)),
                              backgroundColor: Colors.green.withOpacity(0.5),
                            );
                          }).toList(),
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Column(
      children: [
        Text(value, style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.deepPurple)),
        Text(label, style: TextStyle(fontSize: 12, color: Colors.grey)),
      ],
    );
  }

  String _getVisualizationTitle() {
    switch (network.visualizationMode) {
      case VisualizationMode.words:
        return '3D Визуализация слов';
      case VisualizationMode.neurons:
        return '3D Граф нейронов';
      case VisualizationMode.fragments:
        return '3D Визуализация фрагментов';
    }
  }

  String _getSearchHint() {
    switch (network.visualizationMode) {
      case VisualizationMode.words:
        return 'Поиск слов...';
      case VisualizationMode.neurons:
        return 'Поиск нейронов...';
      case VisualizationMode.fragments:
        return 'Поиск фрагментов...';
    }
  }
}


class NumberMatch {
  final int value;
  final String match;
  final int start;
  final int end;
  
  NumberMatch({
    required this.value,
    required this.match,
    required this.start,
    required this.end,
  });
}

class ChatMessage1 {
  final String text;
  final bool isSystem;
  final DateTime timestamp;
  
  ChatMessage1({required this.text, required this.isSystem, required this.timestamp});
}

class ChatBubble extends StatelessWidget {
  final ChatMessage1 message;
  final Function(String)? onWordTap;
  
  const ChatBubble({Key? key, required this.message, this.onWordTap}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Container(
      margin: EdgeInsets.symmetric(vertical: 4, horizontal: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            message.isSystem ? Icons.settings : Icons.person,
            size: 16,
            color: message.isSystem ? Colors.grey : Colors.blue,
          ),
          SizedBox(width: 8),
          Expanded(
            child: Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: message.isSystem ? Colors.grey.withOpacity(0.1) : Colors.blue.withOpacity(0.1),
                borderRadius: BorderRadius.circular(12),
              ),
              child: _buildClickableText(message.text),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildClickableText(String text) {
    final words = text.split(' ');
    return Wrap(
      children: words.map((word) {
        return GestureDetector(
          onTap: () => onWordTap?.call(word),
          child: Container(
            margin: EdgeInsets.only(right: 4),
            child: Text(
              '$word ',
              style: TextStyle(
                fontSize: 14,
                color: _isClickableWord(word) ? Colors.blue : null,
                decoration: _isClickableWord(word) ? TextDecoration.underline : TextDecoration.none,
              ),
            ),
          ),
        );
      }).toList(),
    );
  }
  
  bool _isClickableWord(String word) {
    return word.length > 3 && 
           RegExp(r'^[a-zA-Zа-яА-ЯёЁ]+$').hasMatch(word) &&
           !STOP_WORDS.contains(word.toLowerCase());
  }
}
class AdvancedNeuron3DVisualization extends StatefulWidget {
  final OptimizedNeuralNetwork network;
  final Set<int> selectedNeuronIds;
  final Function(int, bool) onNeuronSelected;
  final Function(String) onClusterTapped;
  final Function(String, {bool isSystem}) sendMessage; // Измените здесь
  
  const AdvancedNeuron3DVisualization({
    Key? key,
    required this.network,
    required this.selectedNeuronIds,
    required this.onNeuronSelected,
    required this.onClusterTapped,
    required this.sendMessage,
  }) : super(key: key);
  
  @override
  _AdvancedNeuron3DVisualizationState createState() => _AdvancedNeuron3DVisualizationState();
}

class _AdvancedNeuron3DVisualizationState extends State<AdvancedNeuron3DVisualization> 
    with SingleTickerProviderStateMixin {
  // Новая система координат - камера смотрит на сцену
  double _cameraX = 0.0;
  double _cameraY = 0.0;
  double _cameraZ = 1000.0; // Камера смотрит сверху
  double _cameraScale = 1.0;
  
  // Вращение камеры
  double _rotationX = 0.0;
  double _rotationY = 0.0;
  
  // Перетаскивание
  Offset? _lastPanOffset;
  bool _isPanning = false;
  String? _hoveredClusterId;
  String? _draggedClusterId;
  Offset? _dragStartOffset;
  Offset? _clusterStartOffset;
  
  // Анимация
  late AnimationController _animationController;
  final Map<String, double> _clusterGlowIntensities = {};
  final Map<String, double> _connectionWeights = {};
    bool _isAnimating = false;
  String? _expandingClusterId;
  @override
  void initState() {
    super.initState();
    
    // Инициализация позиции корневого кластера внизу сцены
    _initializeRootClusterPosition();
    
        _animationController = AnimationController(
      vsync: this,
      duration: Duration(milliseconds: 16),
    )..addListener(_onAnimationTick);
    
    
    _animationController.repeat();
    _initializeConnectionWeights();
  }
   
  void _onAnimationTick() {
    if (!mounted) return;
    
    widget.network.updateAnimations(1/60);
    _updateConnectionWeights();
    
    // Обновляем состояние только если есть изменения
    if (widget.network.hasVisualChanges) {
      setState(() {});
    }
  }
  void _initializeRootClusterPosition() {
    final rootCluster = widget.network.clusters['root'];
    if (rootCluster != null) {
      // Помещаем корневой кластер внизу сцены
      rootCluster.updatePosition(0.0, 300.0, 0.0);
      
      // Позиционируем дочерние кластеры вокруг него вверх
      _positionChildClusters('root', 0.0, 300.0, 0);
    }
  }
  
  void _positionChildClusters(String parentId, double parentX, double parentY, int depth) {
    final parent = widget.network.clusters[parentId];
    if (parent == null) return;
    
    final children = parent.childClusterIds
        .map((id) => widget.network.clusters[id])
        .whereType<NeuronCluster>()
        .toList();
    
    if (children.isEmpty) return;
    
    final angleStep = (2 * pi) / children.length;
    final radius = 150.0 + (depth * 50.0);
    
    for (int i = 0; i < children.length; i++) {
      final child = children[i];
      final angle = i * angleStep;
      
      double childX, childY, childZ;
      
      // Чередуем направления: четная глубина - вверх, нечетная - вправо
      if (depth % 2 == 0) {
        // Вверх
        childX = parentX - (children.length*200)/2+i*200;
        childY = parentY - 300;
        
      } else {
        // Вправо
        childX = parentX + radius * 0.8;
        childY = parentY + radius * sin(angle) * 0.3;
        
      }
      
      child?.updatePosition(childX, childY, 0);
      child?.depth = depth + 1;
      child?.size = 1.0 / (depth * 0.3 + 1);
      
      // Рекурсивно позиционируем детей, но только если кластер развернут
     if (child?.childClusterIds.isNotEmpty ?? false) {
      _positionChildClusters(child!.id, childX, childY, depth + 1);
    }
    }
  }
  
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  
  void _initializeConnectionWeights() {
    for (final cluster in widget.network.clusters.values) {
      if (cluster.parentClusterId != null) {
        final weight = _calculateConnectionWeight(cluster.id);
        _connectionWeights[cluster.id] = weight;
      }
    }
  }
  
  void _updateConnectionWeights() {
    for (final cluster in widget.network.clusters.values) {
      if (cluster.parentClusterId != null) {
        final weight = _calculateConnectionWeight(cluster.id);
        _connectionWeights[cluster.id] = weight;
      }
    }
  }
  
  double _calculateConnectionWeight(String clusterId) {
    final cluster = widget.network.clusters[clusterId];
    if (cluster == null || cluster.parentClusterId == null) return 1.0;
    
    double weight = 1.0;
    int expandedCount = _countExpandedChildren(clusterId);
    weight += expandedCount * 0.05;
    
    final depth = cluster.depth;
    weight += depth * 0.02;
    
    return weight.clamp(1.0, 3.0);
  }
  
  
  // ИСПРАВЛЕННЫЙ МЕТОД - убираем рекурсию
  int _countExpandedChildren(String clusterId) {
    final cluster = widget.network.clusters[clusterId];
    if (cluster == null) return 0;
    
    int count = 0;
    final queue = Queue<String>();
    queue.addAll(cluster.childClusterIds);
    
    while (queue.isNotEmpty) {
      final currentId = queue.removeFirst();
      final current = widget.network.clusters[currentId];
      if (current == null) continue;
      
      if (current.isExpanded) {
        count++;
        queue.addAll(current.childClusterIds);
        
        // Если это листовой кластер, добавляем нейроны
        if (current.childClusterIds.isEmpty) {
          count += current.neuronIds.length;
        }
      }
    }
    
    return count;
  }

  // ПЕРЕИМЕНОВАЛ в _toggleClusterExpansion
Future<void> _toggleClusterExpansion(String clusterId) async {
  if (_isAnimating) return;
  
  _isAnimating = true;
  _expandingClusterId = clusterId;
  
  final cluster = widget.network.clusters[clusterId];
  if (cluster == null) {
    _isAnimating = false;
    _expandingClusterId = null;
    return;
  }
  
  // Переключаем состояние
  final wasExpanded = cluster.isExpanded;
  cluster.isExpanded = !wasExpanded;
  
  widget.sendMessage('🎯 Toggling cluster ${cluster.id} from $wasExpanded to ${cluster.isExpanded}. ${cluster.childClusterIds.length} ${cluster.neuronIds.length}');
  
  if (cluster.isExpanded) {
    // РАЗВОРАЧИВАЕМ - показываем детей
    await _showChildClusters(clusterId);
  } else {
    // СВОРАЧИВАЕМ - скрываем детей
    await _hideChildClusters(clusterId);
  }
  
  // ОБНОВЛЯЕМ ПОЗИЦИИ после изменения состояния
  //_updateClusterPositions();
  
  // ФОРСИРУЕМ ОБНОВЛЕНИЕ UI
  if (mounted) {
          setState(() {});
        }
  
  _isAnimating = false;
  _expandingClusterId = null;
}
  
  Future<void> _showChildClusters(String parentId) async {
    final parent = widget.network.clusters[parentId];
    if (parent == null) return;
    List<String> myReports = [];
    for (final childId in parent.childClusterIds) {
      final child = widget.network.clusters[childId];
      if (child != null) {
        child.isVisible = true;

        // Анимация появления с задержкой
        final index = parent.childClusterIds.indexOf(childId);
        //await Future.delayed(Duration(milliseconds: 150 - (10 * index).clamp(50, 150)));
        final newX = parent.x+(35-(parent.childClusterIds.length*90)/2+90*index)*_cameraScale;
        final newY = parent.y-60*_cameraScale;
        if (child.neuronIds.isEmpty!=true){
            myReports.add("opening parent cluster ${parent.id}, ${parent.x}, ${parent.y}, ${newX}, ${newY}, ${parent.childClusterIds.length}, ${index}");
        }
        
        child.x=newX;
        child.y=newY;
        
      }
    }

    for (final report in myReports){
      //await AppLogger.writeLog(report);
    }

  }
  
  Future<void> _hideChildClusters(String parentId) async {
    final parent = widget.network.clusters[parentId];
    if (parent == null) return;
    
    // Скрываем всех детей рекурсивно
    final allChildren = _getAllChildren(parentId);
    for (final childId in allChildren) {
      final child = widget.network.clusters[childId];
      if (child != null) {
        child.isVisible = false;
        child.isExpanded = false; // Сворачиваем тоже
      }
    }
    
   
  }
  
  // Вспомогательный метод для получения всех детей (включая вложенных)
  List<String> _getAllChildren(String parentId) {
    final result = <String>[];
    final queue = Queue<String>();
    queue.addAll(widget.network.clusters[parentId]?.childClusterIds ?? []);
    
    while (queue.isNotEmpty) {
      final currentId = queue.removeFirst();
      result.add(currentId);
      queue.addAll(widget.network.clusters[currentId]?.childClusterIds ?? []);
    }
    
    return result;
  }
  
  void _updateClusterPositions() {
    final rootCluster = widget.network.clusters['root'];
    if (rootCluster != null) {
      _positionChildClusters('root', rootCluster.x, rootCluster.y, 0);
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onScaleStart: (details) {
        _lastPanOffset = details.focalPoint;
        _isPanning = true;
      },
      onScaleUpdate: (details) {
        if (_isPanning && _lastPanOffset != null) {
          final delta = details.focalPoint - _lastPanOffset!;
          setState(() {
            // Панорамирование сцены
            _cameraX -= delta.dx / _cameraScale;
            _cameraY -= delta.dy / _cameraScale;
          });
          _lastPanOffset = details.focalPoint;
        }
        
        // Зум
        if (details.scale != 1.0) {
          setState(() {
            _cameraScale = (_cameraScale * details.scale).clamp(0.1, 5.0);
          });
        }
      },
      onScaleEnd: (details) {
        _isPanning = false;
        _lastPanOffset = null;
      },
      onTapDown: (details) {
        _handleTap(details.localPosition);
      },
      child: MouseRegion(
        onHover: (event) {
          _handleHover(event.localPosition);
        },
        onExit: (event) {
          setState(() {
            _hoveredClusterId = null;
          });
        },
        child: Listener(
          onPointerSignal: (pointerSignal) {
            if (pointerSignal is PointerScrollEvent) {
              setState(() {
                _cameraScale = (_cameraScale * (1.0 + pointerSignal.scrollDelta.dy * -0.001))
                    .clamp(0.05, 2.0);
              });
            }
          },
          onPointerDown: (event) {
            _handlePointerDown(event.position);
          },
          onPointerMove: (event) {
            _handlePointerMove(event.position);
          },
          onPointerUp: (event) {
            _handlePointerUp();
          },
          child: CustomPaint(
            size: Size.infinite,
            painter: _AdvancedNeuron3DPainter(
              network: widget.network,
              cameraX: _cameraX,
              cameraY: _cameraY,
              cameraZ: _cameraZ,
              cameraScale: _cameraScale,
              rotationX: _rotationX,
              rotationY: _rotationY,
              selectedNeuronIds: widget.selectedNeuronIds,
              hoveredClusterId: _hoveredClusterId,
              draggedClusterId: _draggedClusterId,
              connectionWeights: _connectionWeights,
            ),
          ),
        ),
      ),
    );
  }
  
  void _handleHover(Offset position) {
    final hitResult = _findHitObject(position);
    setState(() {
      _hoveredClusterId = hitResult.clusterId;
      
      if (hitResult.clusterId != null) {
        _clusterGlowIntensities[hitResult.clusterId!] = 0.2;
      }
    });
  }
  void _startClusterGlowAnimation(String clusterId) {
  final cluster = widget.network.clusters[clusterId];
  if (cluster == null) return;

  // Запускаем анимацию свечения
  cluster.glowIntensity = 1.0;
  setState(() {});

  // Плавно уменьшаем свечение в течение 500 мс
  const totalDuration = 500;
  const steps = 10;
  const stepDuration = totalDuration ~/ steps;
  
  for (int i = 1; i <= steps; i++) {
    Future.delayed(Duration(milliseconds: stepDuration * i), () {
      if (mounted && widget.network.clusters.containsKey(clusterId)) {
        final currentCluster = widget.network.clusters[clusterId];
        if (currentCluster != null) {
          currentCluster.glowIntensity = 1.0 - (i / steps);
          setState(() {});
        }
      }
    });
  }
}
  void _handleTap(Offset position) {
    final hitResult = _findHitObject(position);
    
    if (hitResult.clusterId != null) {
            _startClusterGlowAnimation(hitResult.clusterId!);
      _toggleClusterExpansion(hitResult.clusterId!);
      //widget.onClusterTapped(hitResult.clusterId!);
    } else if (hitResult.neuronId != null) {
      widget.onNeuronSelected(hitResult.neuronId!, false);
    }
  }
  
  void _handlePointerDown(Offset position) {
    return;
    final hitResult = _findHitObject(position);
    
    if (hitResult.clusterId != null) {
      _draggedClusterId = hitResult.clusterId;
      _dragStartOffset = position;
      final cluster = widget.network.clusters[hitResult.clusterId]!;
      _clusterStartOffset = Offset(cluster.x, cluster.y);
      
      _clusterGlowIntensities[hitResult.clusterId!] = 0.8;
    }
  }
  
  void _handlePointerMove(Offset position) {
    return;
    if (_draggedClusterId != null && _dragStartOffset != null && _clusterStartOffset != null) {
      final cluster = widget.network.clusters[_draggedClusterId!];
      if (cluster != null) {
        final delta = (position - _dragStartOffset!) / _cameraScale;
        final newX = _clusterStartOffset!.dx + delta.dx;
        final newY = _clusterStartOffset!.dy + delta.dy;
        
        cluster.updatePosition(newX, newY, cluster.z);
        
        if (cluster.isExpanded && cluster.childClusterIds.isEmpty) {
          _moveNeuronsWithCluster(cluster, newX, newY);
        }
        
        setState(() {});
      }
    }
  }
  
  void _handlePointerUp() {
    return;
    if (_draggedClusterId != null) {
      _clusterGlowIntensities[_draggedClusterId!] = 0.0;
    }
    _draggedClusterId = null;
    _dragStartOffset = null;
    _clusterStartOffset = null;
  }
  
  void _moveNeuronsWithCluster(NeuronCluster cluster, double newX, double newY) {
    final deltaX = newX - cluster.x;
    final deltaY = newY - cluster.y;
    
    for (final neuronId in cluster.neuronIds) {
      final neuron = widget.network.neurons[neuronId];
      if (neuron != null) {
        neuron.x += deltaX;
        neuron.y += deltaY;
      }
    }
  }
  
  void _startClusterExpansionAnimation(String clusterId) {
    final cluster = widget.network.clusters[clusterId];
    if (cluster == null) return;
    
    _clusterGlowIntensities[clusterId] = 1.0;
    
    Future.delayed(Duration(milliseconds: 300), () {
      if (mounted) {
        setState(() {
          _clusterGlowIntensities[clusterId] = 0.0;
        });
      }
    });
  }


  HitResult _findHitObject(Offset position) {
  final box = context.findRenderObject() as RenderBox;
  final size = box.size;
  
  final centerX = size.width / 2 - _cameraX;
  final centerY = size.height / 2 - _cameraY;
  
  // Проверяем кластеры
  for (final cluster in widget.network.clusters.values) {
    if (!cluster.isVisible) continue;
    
    final projected = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
    final clusterSize = 40.0 * _cameraScale * cluster.size;
    final distance = (Offset(projected.dx, projected.dy) - position).distance;
    
    if (distance < clusterSize) {
      return HitResult(clusterId: cluster.id);
    }
  }
  
  // Проверяем нейроны в развернутых кластерах
  for (final cluster in widget.network.clusters.values) {
    if (!cluster.isExpanded || !cluster.isVisible || cluster.childClusterIds.isNotEmpty) continue;
    
    final clusterScreenPos = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
    final startX = clusterScreenPos.dx +  35* _cameraScale - cluster.neuronIds.length.clamp(1,5)*31/2 * _cameraScale;
    final startY = clusterScreenPos.dy - 10* _cameraScale - (cluster.neuronIds.length*11/(cluster.neuronIds.length~/5)) * _cameraScale;
    
    for (int i = 0; i < cluster.neuronIds.length; i++) {
      final neuronId = cluster.neuronIds[i];
      final neuron = widget.network.neurons[neuronId];
      if (neuron == null) continue;
      
      // Вычисляем позицию так же как при отрисовке
      final neuronX = startX + (30 * (i%5)) * _cameraScale;
      final neuronY = startY + (i~/5 * 11.0) * _cameraScale;
      
      final neuronRect = Rect.fromCenter(
        center: Offset(neuronX, neuronY),
        width: 30.0 * _cameraScale,
        height: 10.0 * _cameraScale,
      );
      
      if (neuronRect.contains(position)) {
        return HitResult(neuronId: neuronId);
      }
    }
  }
  
  return HitResult();
}
  
  Offset _projectToScreen(double x, double y, double z, double centerX, double centerY) {
    // Упрощенная проекция 3D в 2D с учетом камеры
    final screenX = centerX + (x * _cameraScale);
    final screenY = centerY + (y * _cameraScale);
    
    return Offset(screenX, screenY);
  }
}



class _AdvancedNeuron3DPainter extends CustomPainter {
  final OptimizedNeuralNetwork network;
  final double cameraX;
  final double cameraY;
  final double cameraZ;
  final double cameraScale;
  final double rotationX;
  final double rotationY;
  final Set<int> selectedNeuronIds;
  final String? hoveredClusterId;
  final String? draggedClusterId;
  final Map<String, double> connectionWeights;
  
  _AdvancedNeuron3DPainter({
    required this.network,
    required this.cameraX,
    required this.cameraY,
    required this.cameraZ,
    required this.cameraScale,
    required this.rotationX,
    required this.rotationY,
    required this.selectedNeuronIds,
    required this.hoveredClusterId,
    required this.draggedClusterId,
    required this.connectionWeights,
  });
    final Map<String, ui.Picture> _neuronCardCache = {};
  double _lastCameraScale = 1.0;
  
  
  @override
  void paint(Canvas canvas, Size size) {
    final centerX = size.width / 2 - cameraX;
    final centerY = size.height / 2 - cameraY;
    
    // Сначала вычисляем позиции всех кластеров с учетом коллизий
    //_resolveClusterCollisions(size, centerX, centerY);
    
    _drawConnections(canvas, size, centerX, centerY);
    _drawClusters(canvas, size, centerX, centerY);
    _drawNeurons(canvas, size, centerX, centerY);
    _lastCameraScale = cameraScale;
  }

  void _resolveClusterCollisions(Size size, double centerX, double centerY) {
    final clusters = network.clusters.values.where((c) => c.isVisible).toList();
    
    // Сортируем по глубине для обработки от дальних к ближним
    clusters.sort((a, b) => a.depth.compareTo(b.depth));
    
    for (int i = 0; i < clusters.length; i++) {
      final clusterA = clusters[i];
      final posA = _projectToScreen(clusterA.x, clusterA.y, clusterA.z, centerX, centerY);
      final baseSizeA = 40.0 * cameraScale * clusterA.size;
      final rectA = Rect.fromCircle(center: posA, radius: baseSizeA);
      
      // Расширенный прямоугольник с учетом минимальных отступов
      final expandedRectA = Rect.fromLTRB(
        rectA.left - 50 * cameraScale,
        rectA.top - 75 * cameraScale,  
        rectA.right + 50 * cameraScale,
        rectA.bottom + 75 * cameraScale,
      );
      
      for (int j = i + 1; j < clusters.length; j++) {
        final clusterB = clusters[j];
        final posB = _projectToScreen(clusterB.x, clusterB.y, clusterB.z, centerX, centerY);
        final baseSizeB = 40.0 * cameraScale * clusterB.size;
        final rectB = Rect.fromCircle(center: posB, radius: baseSizeB);
        
        final expandedRectB = Rect.fromLTRB(
          rectB.left - 50 * cameraScale,
          rectB.top - 75 * cameraScale,
          rectB.right + 50 * cameraScale,
          rectB.bottom + 75 * cameraScale,
        );
        
        // Проверяем пересечение расширенных прямоугольников
        if (expandedRectA.overlaps(expandedRectB)) {
          _resolveCollision(clusterA, clusterB, posA, posB, expandedRectA, expandedRectB, centerX, centerY);
        }
      }
    }
  }

  void _resolveCollision(
    NeuronCluster clusterA, 
    NeuronCluster clusterB, 
    Offset posA, 
    Offset posB,
    Rect rectA,
    Rect rectB,
    double centerX,
    double centerY,
  ) {
    final intersection = rectA.intersect(rectB);
    
    if (intersection.width > 0 && intersection.height > 0) {
      // Вычисляем вектор отталкивания
      final centerA = rectA.center;
      final centerB = rectB.center;
      
      final dx = centerB.dx - centerA.dx;
      final dy = centerB.dy - centerA.dy;
      final distance = sqrt(dx * dx + dy * dy);
      
      if (distance > 0) {
        // Минимальное расстояние между центрами с учетом отступов
        final minDistance = (rectA.width / 2) + (rectB.width / 2);
        final overlap = minDistance - distance;
        
        if (overlap > 0) {
          // Нормализованный вектор направления
          final nx = dx / distance;
          final ny = dy / distance;
          
          // Смещение для устранения коллизии
          final offsetX = nx * overlap * 0.5;
          final offsetY = ny * overlap * 0.5;
          
          // Применяем смещение к обоим кластерам
          // Обновляем реальные координаты кластера B
          final newScreenX = posB.dx + offsetX;
          final newScreenY = posB.dy + offsetY;
          
          // Конвертируем обратно в мировые координаты
          final newWorldX = (newScreenX - centerX) / cameraScale;
          final newWorldY = (newScreenY - centerY) / cameraScale;
          
          // Обновляем позицию кластера B
          clusterB.x = newWorldX;
          clusterB.y = newWorldY;
        }
      }
    }
  }


  void _drawDebugCollisionZones(Canvas canvas, List<Rect> clusterRects) {
    // Включите эту функцию для отладки коллизий
    final bool showDebug = false;
    
    if (showDebug) {
      for (final rect in clusterRects) {
        final expandedRect = Rect.fromLTRB(
          rect.left - 50 * cameraScale,
          rect.top - 75 * cameraScale,
          rect.right + 50 * cameraScale,
          rect.bottom + 75 * cameraScale,
        );
        
        final debugPaint = Paint()
          ..color = Colors.red.withOpacity(0.3)
          ..style = PaintingStyle.stroke
          ..strokeWidth = 1;
          
        canvas.drawRect(expandedRect, debugPaint);
      }
    }
  }
  
  void _drawConnections(Canvas canvas, Size size, double centerX, double centerY) {
    for (final cluster in network.clusters.values) {
      if (!cluster.isVisible || cluster.parentClusterId == null) continue;
      
      final parent = network.clusters[cluster.parentClusterId!];
      if (parent != null && parent.isVisible) {
        _drawConnectionLine(canvas, parent, cluster, centerX, centerY);
      }
    }
  }

void _drawNeuronConnections(Canvas canvas, Neuron neuron, Offset neuronPosition, Size size) {
  // Упрощенный поиск связей - только по общим словам в сигнатурах
  final connectedNeurons = <int, double>{}; // neuronId -> strength
  
  // Ищем нейроны с общими словами в сигнатурах
  final neuronWords = neuron.keywords.toSet();
  double summaryStrength=0;
  for (final cluster in network.clusters.values){
    if (!cluster.isVisible || !cluster.isExpanded || cluster.neuronIds.isEmpty){continue;}

    for (final otherNeuron in network.neurons.values) {
          if (otherNeuron.id == neuron.id) continue;
          
          final otherWords = otherNeuron.keywords.toSet();
          final commonWords = neuronWords.intersection(otherWords);
          
          if (commonWords.isNotEmpty) {
            // Сила связи = количество общих слов
            double strength = (commonWords.length/neuronWords.length + commonWords.length/neuronWords.length)/2;
            connectedNeurons[otherNeuron.id] = strength;
            if (strength>summaryStrength){
              summaryStrength=(summaryStrength+strength)/2;
            }
          }
        }
  }
  
  
  // Берем топ-3 самых сильных связей
  final topConnections = connectedNeurons.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value))
    ..take(14);
  
  for (final entry in topConnections) {
    if (entry.value> summaryStrength/3*2){
      continue;
    }
    final otherNeuron = network.neurons[entry.key];
    if (otherNeuron == null) continue;
    
    // Находим позицию связанного нейрона в мировых координатах
      final otherPosition = _findNeuronPosition(otherNeuron, size);
    if (otherPosition == null) continue;
    
    // Нормализуем силу связи (0.0 - 1.0)
    final normalizedStrength = min(entry.value / 40.0, 1.0);
    
    // Простой цвет от фиолетового к голубому в зависимости от силы связи
    final color = Color.lerp(
      Colors.purple,
      Colors.cyan,
      normalizedStrength,
    )!.withOpacity(0.1);
    
    final paint = Paint()
      ..color = color
      ..strokeWidth = 0.5 + normalizedStrength * 1.0 // Толщина от силы связи
      ..style = PaintingStyle.stroke;
    
    // Простая слегка изогнутая линия
    final path = Path();
    path.moveTo(neuronPosition.dx, neuronPosition.dy);
    
    final midX = (neuronPosition.dx + otherPosition.dx) / 2;
    final midY = (neuronPosition.dy + otherPosition.dy) / 2;
    
    // Небольшой изгиб
    final controlX = midX + (otherPosition.dy - neuronPosition.dy) * 0.1;
    final controlY = midY - (otherPosition.dx - neuronPosition.dx) * 0.1;
    
    path.quadraticBezierTo(
      controlX, controlY,
      otherPosition.dx, otherPosition.dy,
    );
    
    canvas.drawPath(path, paint);
  }
}

// Вспомогательная функция для поиска позиции нейрона
Offset? _findNeuronPosition(Neuron neuron, Size size) {
  // Получаем размеры канваса из контекста
  final centerX = size.width / 2 - cameraX;
  final centerY = size.height / 2 - cameraY;
  
  // Ищем нейрон в развернутых кластерах
  for (final cluster in network.clusters.values) {
    if (cluster.isExpanded && cluster.isVisible && cluster.neuronIds.contains(neuron.id) ) {
      final clusterScreenPos = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
      final neuronIndex = cluster.neuronIds.indexOf(neuron.id);
      if (neuronIndex != -1) {
        final neuronX = clusterScreenPos.dx + 35* cameraScale  - cluster.neuronIds.length.clamp(1,5)*31/2 + (31 * (neuronIndex%5)) * cameraScale ;
        final neuronY = clusterScreenPos.dy - 10* cameraScale  - (cluster.neuronIds.length*11/(cluster.neuronIds.length/5) + neuronIndex~/5 * 11.0) * cameraScale;
        return Offset(neuronX, neuronY);
      }
    }
  }
  
  // Если не нашли в развернутых кластерах, используем позицию кластера
  for (final cluster in network.clusters.values) {
    if (cluster.neuronIds.contains(neuron.id)) {
      return _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
    }
  }
  
  return null;
}
  void _drawConnectionLine(Canvas canvas, NeuronCluster parent, NeuronCluster child, 
                        double centerX, double centerY) {
  final parentCenter = _projectToScreen(parent.x, parent.y, parent.z, centerX, centerY);
  final childCenter = _projectToScreen(child.x, child.y, child.z, centerX, centerY);
  
  // Рассчитываем размеры кластеров
  final parentSize = 40.0 * cameraScale * parent.size;
  final childSize = 40.0 * cameraScale * child.size;
  
  // Находим точки на границах кластеров
  final start = _getExitPoint(parentCenter, childCenter, parentSize);
  final end = _getEntryPoint(childCenter, parentCenter, childSize);
  
  final weight = connectionWeights[child.id] ?? 1.0;
  final strokeWidth = 2.0 * weight * cameraScale;
  
  final path = Path();
  path.moveTo(start.dx, start.dy);
  
  final dx = end.dx - start.dx;
  final dy = end.dy - start.dy;
  final distance = sqrt(dx * dx + dy * dy);
  
  // Высоты для различных фаз кривой
  final totalHeight = (start.dy - end.dy).abs();
  final phase1Height = totalHeight * 0.3; // 30% - начальный подъем
  final phase2Height = totalHeight * 0.5; // 50% - основное движение
  final phase3Height = totalHeight * 0.2; // 20% - финальный подход
  
  if (distance > 50) {
    // Точки контроля для кубической кривой Безье
    final control1 = Offset(
      start.dx + dx * 0.1,
      start.dy - phase1Height,
    );
    
    final control2 = Offset(
      start.dx + dx * 0.4,
      start.dy - phase1Height - phase2Height * 0.3,
    );
    
    final control3 = Offset(
      start.dx + dx * 0.6,
      end.dy + phase3Height + phase2Height * 0.3,
    );
    
    final control4 = Offset(
      start.dx + dx * 0.9,
      end.dy + phase3Height,
    );
    
    // Создаем плавную кривую через несколько контрольных точек
    path.cubicTo(
      control1.dx, control1.dy,
      control2.dx, control2.dy,
      (control2.dx + control3.dx) / 2, (control2.dy + control3.dy) / 2
    );
    
    path.cubicTo(
      control3.dx, control3.dy,
      control4.dx, control4.dy,
      end.dx, end.dy
    );
    
  } else {
    // Для близких кластеров - прямая линия
    path.lineTo(end.dx, end.dy);
  }
  
  // Градиент от родителя к ребенку
  final gradientColors = [
    Colors.blue.withOpacity(0.8),
    Colors.purple.withOpacity(0.6),
  ];
  
  final gradient = LinearGradient(colors: gradientColors);
  final rect = Rect.fromPoints(start, end);
  final paint = Paint()
    ..shader = gradient.createShader(rect)
    ..strokeWidth = strokeWidth
    ..style = PaintingStyle.stroke
    ..strokeCap = StrokeCap.round;
  
  canvas.drawPath(path, paint);
  
  _drawConnectionArrow(canvas, path, paint, weight);
}
 void _drawConnectionArrow(Canvas canvas, Path path, Paint paint, double weight) {
  try {
    final metrics = path.computeMetrics();
    final metric = metrics.first;
    
    // Находим точку на 95% пути для стрелки (близко к концу, но не в самой конечной точке)
    final arrowOffset = max(metric.length * 0.95, 5.0);
    final tangent = metric.getTangentForOffset(arrowOffset);
    
    if (tangent != null) {
      final arrowPoint = tangent.position;
      final angle = tangent.angle;
      
      final arrowSize = 8.0 * weight * cameraScale;
      
      final arrowPath = Path();
      arrowPath.moveTo(
        arrowPoint.dx - arrowSize * cos(angle - pi / 6),
        arrowPoint.dy - arrowSize * sin(angle - pi / 6),
      );
      arrowPath.lineTo(arrowPoint.dx, arrowPoint.dy);
      arrowPath.lineTo(
        arrowPoint.dx - arrowSize * cos(angle + pi / 6),
        arrowPoint.dy - arrowSize * sin(angle + pi / 6),
      );
      arrowPath.close();
      
      final arrowPaint = Paint()
        ..color = Colors.red.withOpacity(0.8)
        ..style = PaintingStyle.fill;
      
      canvas.drawPath(arrowPath, arrowPaint);
    }
  } catch (e) {
    // Игнорируем ошибки отрисовки стрелки
  }
}
  Offset _getExitPoint(Offset fromCenter, Offset toCenter, double fromSize) {
  final angle = atan2(toCenter.dy - fromCenter.dy, toCenter.dx - fromCenter.dx);
  
  // Вычисляем точку на границе круга в направлении цели
  return Offset(
    fromCenter.dx + cos(angle) * fromSize,
    fromCenter.dy + sin(angle) * fromSize,
  );
}

Offset _getEntryPoint(Offset toCenter, Offset fromCenter, double toSize) {
  final angle = atan2(toCenter.dy - fromCenter.dy, toCenter.dx - fromCenter.dx);
  
  // Вычисляем точку на границе круга с противоположной стороны
  return Offset(
    toCenter.dx - cos(angle) * toSize,
    toCenter.dy - sin(angle) * toSize,
  );
}
   void _drawClusters(Canvas canvas, Size size, double centerX, double centerY) {
    final sortedClusters = network.clusters.values.toList()
      ..sort((a, b) => a.depth.compareTo(b.depth));
    
    // Временный список для отладки коллизий
    final List<Rect> debugRects = [];
    
    for (final cluster in sortedClusters) {
      if (!cluster.isVisible) continue;
      
      final projected = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
      final baseSize = 40.0 * cameraScale * cluster.size;
      
      // Сохраняем для отладки
      debugRects.add(Rect.fromCircle(center: projected, radius: baseSize));
      
      _drawSingleCluster(canvas, cluster, centerX, centerY);
    }
    
    // Опционально: отладка - отрисовка зон коллизий
    //_drawDebugCollisionZones(canvas, debugRects);
  }

  void _drawSingleCluster(Canvas canvas, NeuronCluster cluster, double centerX, double centerY) {
  final projected = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
  final center = Offset(projected.dx, projected.dy);
  final baseSize = 40.0 * cameraScale * cluster.size;
  
  final isHovered = cluster.id == hoveredClusterId;
  final isDragged = cluster.id == draggedClusterId;
  final isExpanded = cluster.isExpanded;
  final isNeuronCluster = cluster.neuronIds.length > 0;
  
  // Свечение
  final glowIntensity = _getClusterGlowIntensity(cluster.id);
  if (glowIntensity > 0.0) {
    final glowPaint = Paint()
      ..color = isNeuronCluster? Colors.purple.withOpacity(glowIntensity*0.7) : Colors.yellow.withOpacity(glowIntensity * 0.5)
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, 10 * cameraScale);
    
    canvas.drawCircle(center, baseSize * (1.0 + glowIntensity), glowPaint);
  }
  
  // Градиент для заливки
  final gradientColors = [
    isNeuronCluster ? Colors.purple.withOpacity(isExpanded ? 1.0 : 0.75) : 
                     Colors.blue.withOpacity(isExpanded ? 0.53 : 0.22),
    isNeuronCluster ? Colors.green.withOpacity(isExpanded ? 1.0 : 0.75) : 
                     Colors.purple.withOpacity(isExpanded ? 0.53 : 0.22),
  ];
  
  // Создаем градиент для размера круга
  final gradientRect = Rect.fromCircle(center: center, radius: baseSize);
  final gradient = LinearGradient(colors: gradientColors);
  
  // Заливка круга
  final fillPaint = Paint()
    ..shader = gradient.createShader(gradientRect)
    ..style = PaintingStyle.fill; // Исправлено: fill вместо stroke
  
  canvas.drawCircle(center, baseSize, fillPaint);
  
  // Граница
  final borderColor = isExpanded ? Colors.greenAccent : 
                     isHovered ? Colors.yellow : Colors.white;
  
  final borderPaint = Paint()
    ..color = isNeuronCluster ? Colors.purple : borderColor
    ..strokeWidth = isExpanded ? 3.0 : (isHovered ? 2.5 : 2.0)
    ..style = PaintingStyle.stroke;
  
  canvas.drawCircle(center, baseSize, borderPaint);
  
  // Текст
  _drawClusterText(canvas, cluster, center, baseSize);
}
  
  double _getClusterGlowIntensity(String clusterId) {
    if (clusterId == hoveredClusterId) return 0.2;
    if (clusterId == draggedClusterId) return 0.8;
    return 0.0;
  }
  
  void _drawClusterText(Canvas canvas, NeuronCluster cluster, Offset center, double baseSize) {
    final text = _getClusterDisplayText(cluster);
    final textStyle = ui.TextStyle(
      color: Colors.white,
      fontSize: 10 * cameraScale * cluster.size,
      fontWeight: FontWeight.bold,
    );
    
    final textBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
      textDirection: ui.TextDirection.ltr,
      textAlign: TextAlign.center,
    ))
      ..pushStyle(textStyle)
      ..addText(text);
    
    final textParagraph = textBuilder.build();
    textParagraph.layout(ui.ParagraphConstraints(width: baseSize * 3));
    
    canvas.drawParagraph(
      textParagraph, 
      Offset(center.dx - textParagraph.width / 2, center.dy - textParagraph.height / 2)
    );
  }



Map<int, double> getFastTopConnectionsByKeywords(){
  final Map<int,double> topConnections = {};
  final List<int> keywordList = [];
  
  for (final neuronId in selectedNeuronIds){
    keywordList.addAll(network.neurons[neuronId]?.keywords ?? []);
  }
  
  // Получаем уникальные ключевые слова и сортируем по allRating (чем ниже - тем важнее)
  final List<int> neuronWords = keywordList.toSet().toList();
  
  // Сортируем слова по allRating (по возрастанию - чем меньше рейтинг, тем важнее)
  neuronWords.sort((a, b) {
    final ratingA = network.words[a]?.allRating ?? double.infinity;
    final ratingB = network.words[b]?.allRating ?? double.infinity;
    return ratingA.compareTo(ratingB); // Сортировка по возрастанию
  });
  
  final Map<int,double> myWordRatings = {};
  
  for (final keyword in neuronWords){
    final dictionary = network.words[keyword]?.ratings ?? {};
    // Дополнительная логика обработки рейтингов...
  }
  
  double summaryStrength = 0;
  final Map<int, double> connectedNeurons = {};
  
  // Получаем текущий нейрон (предполагая, что есть доступ к neuron.id)
  // Если нужно обработать несколько выбранных нейронов, измените логику
  final currentNeuron = network.neurons[selectedNeuronIds.first];
  if (currentNeuron == null) return {};
  
  for (final otherNeuron in network.neurons.values) {
    if (selectedNeuronIds.contains(otherNeuron.id)) continue;
    
    final otherWords = otherNeuron.keywords.toSet();
    final commonWords = neuronWords.toSet().intersection(otherWords);
    
    if (commonWords.isNotEmpty) {
      // Учитываем важность слов: слова с меньшим allRating имеют больший вес
      double strength = 0;
      for (final word in commonWords) {
        final wordRating = network.words[word]?.allRating ?? 1.0;
        // Инвертируем рейтинг: чем меньше allRating, тем больше вес
        final wordWeight = 1.0 / (wordRating + 1); // +1 чтобы избежать деления на 0
        strength += wordWeight;
      }
      
      strength /= neuronWords.length; // Нормализуем
      connectedNeurons[otherNeuron.id] = strength;
      summaryStrength += strength;
    }
  }
  
  // Берем топ-15 самых сильных связей
  final topConnectionsList = connectedNeurons.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value))
    ..take(15);
  
  return Map.fromEntries(topConnectionsList.take(15));
}




  double max_similairty_top_neurons = 0;
    double min_similairty_top_neurons = 0;
  Map<int, double> _topNeuronIds = {};
  List<int> _presetSelectedNeurons = [];


  void _drawNeurons(Canvas canvas, Size size, double centerX, double centerY) {
      Map<int, double> topNeurons = {};

      if (_areSetsEqual(_presetSelectedNeurons.toSet(),selectedNeuronIds.toSet())==false){
        _presetSelectedNeurons=selectedNeuronIds.toList();
        topNeurons = getFastTopConnectionsByKeywords();
        _topNeuronIds=topNeurons;
      }
      
        // Находим максимальное значение
        // Находим максимальное значение
    max_similairty_top_neurons = _topNeuronIds!.isEmpty ? 0 : _topNeuronIds!.entries.reduce(
      (a, b) => a.value > b.value ? a : b
    ).value;

    // Находим минимальное значение  
    min_similairty_top_neurons = _topNeuronIds!.isEmpty ? 0 : _topNeuronIds!.entries.reduce(
      (a, b) => a.value < b.value ? a : b
    ).value;
    for (final cluster in network.clusters.values) {
      if (!cluster.isExpanded || !cluster.isVisible || cluster.childClusterIds.isNotEmpty) continue;
      
      final clusterScreenPos = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
      final startX = clusterScreenPos.dx + 35 * cameraScale - cluster.neuronIds.length.clamp(1,5)*31/2* cameraScale ;
      final startY = clusterScreenPos.dy - 10* cameraScale  - (cluster.neuronIds.length*11/(cluster.neuronIds.length~/5)) * cameraScale;
      //        final neuronX = clusterScreenPos.dx + (20 + 30 * (neuronIndex%5)) * cameraScale ;
//        final neuronY = clusterScreenPos.dy - (cluster.neuronIds.length*11/5 + neuronIndex%5 * 11.0) * cameraScale;
      for (int i = 0; i < cluster.neuronIds.length; i++) {
        final neuronId = cluster.neuronIds[i];
        final neuron = network.neurons[neuronId];
        if (neuron == null) continue;
        
        // Сохраняем экранные координаты в нейрон
        neuron.screenX = startX + 31 * (i%5) * cameraScale;
        neuron.screenY = startY + (i~/5*11) * cameraScale;
        
        _drawSingleNeuron(canvas, neuron, neuron.screenX, neuron.screenY,size);
        
        // Рисуем связи для выделенных нейронов, передавая size
        if (selectedNeuronIds.contains(neuron.id)) {
          _drawNeuronConnections(canvas, neuron, Offset(neuron.screenX, neuron.screenY), size);
        }
   
      // Рисуем усиленные желтые связи к топ нейронам
      if (topNeurons.containsKey(neuron.id)) {
        final similarityScore = topNeurons[neuron.id]!;
        _drawEnhancedConnection(
          canvas,
          neuron,
          similarityScore,
          size
        );
      }
    }
  }
}
(String, int, int, String Function(int))? _findNumericDifference(String startUrl, String endUrl) {
  if (startUrl == endUrl) return null;
  
  // Находим позицию первого отличающегося символа
  int diffIndex = 0;
  final minLength = min(startUrl.length, endUrl.length);
  
  while (diffIndex < minLength && startUrl.codeUnitAt(diffIndex) == endUrl.codeUnitAt(diffIndex)) {
    diffIndex++;
  }
  
  if (diffIndex >= minLength) return null;
  
  // Ищем числовые последовательности вокруг позиции различия
  final startNum = _findNumberAtPosition(startUrl, diffIndex);
  final endNum = _findNumberAtPosition(endUrl, diffIndex);
  
  if (startNum == null || endNum == null || startNum.value == endNum.value) {
    return null;
  }
  
  // Создаем базовый URL
  final beforeDiff = startUrl.substring(0, startNum.start);
  final afterDiff = startUrl.substring(startNum.end);
  final baseUrl = '$beforeDiff{NUM}$afterDiff';
  
  // Функция форматирования с сохранением стиля
  String formatNumber(int num) {
    final original = startNum.match;
    
    // Сохраняем ведущие нули
    if (original.startsWith('0')) {
      final targetLength = original.length;
      return num.toString().padLeft(targetLength, '0');
    }
    
    return num.toString();
  }
  
  return (baseUrl, startNum.value, endNum.value, formatNumber);
}

NumberMatch? _findNumberAtPosition(String text, int position) {
  // Ищем начало числа
  int start = position;
  while (start > 0 && _isDigit(text.codeUnitAt(start - 1))) {
    start--;
  }
  
  // Ищем конец числа
  int end = position;
  while (end < text.length && _isDigit(text.codeUnitAt(end))) {
    end++;
  }
  
  if (start >= end) return null;
  
  final numberStr = text.substring(start, end);
  final number = int.tryParse(numberStr);
  
  if (number == null) return null;
  
  return NumberMatch(
    value: number,
    match: numberStr,
    start: start,
    end: end,
  );
}

bool _isDigit(int codeUnit) {
  return codeUnit >= 48 && codeUnit <= 57; // '0' - '9'
}

Map<String, Map<int, double>> _getTopAndBottomSignatureWords() {
  if (selectedNeuronIds.isEmpty) return {'top': {}, 'bottom': {}};

  final Map<int, double> neuronSignatures = {};
  
  // Суммируем сигнатуры
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron != null) {
      for (final entry in selectedNeuron.signatureRatings.entries) {
        final wordId = entry.key;
        final value = entry.value.toDouble();
        neuronSignatures[wordId] = (neuronSignatures[wordId] ?? 0) + value;
      }
    }
  }

  if (neuronSignatures.isEmpty) return {'top': {}, 'bottom': {}};

  // Сортируем по значению
  final sortedEntries = neuronSignatures.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));

  // Берем топ 30 и bottom 20 с сохранением значений
  final topWords = Map.fromEntries(sortedEntries.take(30));
  final bottomWords = Map.fromEntries(sortedEntries.reversed.take(20));

  return {
    'top': topWords,
    'bottom': bottomWords,
  };
}


Map<int,double> _calculateTopNeuronsByCombinedSimilarity() {
  final Map<int, double> combinedScores = {};
  
  if (selectedNeuronIds.isEmpty) return combinedScores;
  final Map<String, Map<int,double>> wordsForUse = _getTopAndBottomSignatureWords();

  final Map<int,double> top = wordsForUse['top'] ?? {};
  final Map<int,double> bottom = wordsForUse['bottom'] ?? {};
  
  // 1. Собираем neuronRatings similarity (35%)
  final Map<int, double> neuronSimilarities = {};
  double averageSimilarity = 0;
  int similarityCount = 0;
  
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron != null) {
      for (final entry in selectedNeuron.neuronRatings.entries) {
        final neuronId = entry.key;
        final similarity = entry.value.toDouble();
        neuronSimilarities[neuronId] = (neuronSimilarities[neuronId] ?? 0.25 + similarity)/2; 
        averageSimilarity += similarity;
        similarityCount++;
      }
    }
  }
  
  // Calculate average similarity
  if (similarityCount > 0) {
    averageSimilarity /= similarityCount;
  }
  
  final Map<int, double> finalSimilarity = {};
  final Map<int, double> comparedVector = {};
  
  for (final entry in neuronSimilarities.entries) {
    if (entry.value > averageSimilarity / 3 * 2) {
      continue;
    }
    
    final key = entry.key;
    final neuron = network.neurons[key];
   
    if (neuron == null) continue;
    
    final signature_allRating = neuron.signature_allRating;
    int counter = 0;
    
    for (final neuronKeyword in neuron.keywords) {
      if (!top.containsKey(neuronKeyword) && !bottom.containsKey(neuronKeyword)) continue;

      double multiplier = bottom.containsKey(neuronKeyword) ? 1.08 : 1.0;
      final neuronSignatureElement = neuron.signatureRatings[neuronKeyword] ?? 0.0;
      
      if (signature_allRating > 0 && neuronSignatureElement / signature_allRating < 0.15) continue;
      
      comparedVector[key] = (comparedVector[key] ?? 0.0) + neuronSignatureElement * multiplier; 
      counter++;
    }
    
    if (counter > 0) {
      comparedVector[key] = (comparedVector[key] ?? 0.0) / counter;
    }
    
    if (counter > 5) {
      finalSimilarity[key] = comparedVector[key] ?? 0.0;
    }
  }
  
  return finalSimilarity;
}
Map<int, double> _calculateTopNeuronsByCombinedSimilarityDD() {
  final Map<int, double> combinedScores = {};
  
  if (selectedNeuronIds.isEmpty || network.neurons.isEmpty) {
    return combinedScores;
  }

  // 1. Neuron ratings similarity (35%)
  final Map<int, double> neuronSimilarities = {};
  
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron != null && selectedNeuron.neuronRatings.isNotEmpty) {
      for (final entry in selectedNeuron.neuronRatings.entries) {
      
        // Пропускаем выбранные нейроны
        if (selectedNeuronIds.contains(entry.key)) continue;

        neuronSimilarities[entry.key]=entry.value.toDouble();
      }
    }
  }
  
  // 2. Keywords similarity (65%)
  final Map<int, double> keywordSimilarities = {};
  final Map<int, int> keywordFrequency = {};
  final Map<int,double> similarityAll = {};
  // Считаем частоту keywords
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron != null && selectedNeuron.keywords.isNotEmpty) {
      for (final keywordId in selectedNeuron.keywords) {
        keywordFrequency[selectedId] = keywordFrequency[selectedId] ?? 0 +1; 
      }
    }
  }
  
  // Keyword similarity для каждого нейрона
  for (final neuron in network.neurons.values) {
    if (selectedNeuronIds.contains(neuron.id)) continue;
    
    double keywordScore = 0.0;
    if (neuron.keywords.isNotEmpty) {
      for (final keywordId in neuron.keywords) {
        final frequency = neuron.signatureRatings[keywordId] ?? 0;
        keywordScore += frequency.toDouble()/(neuron.signature_allRating);
      }
    }
    if (keywordScore > 0) {
      keywordSimilarities[neuron.id] = keywordScore;
      similarityAll[neuron.id] = similarityAll[neuron.id]??0 + keywordScore;
    }
  }
  
  // 3. Комбинируем scores с проверками на пустоту
  final allNeuronIds = {...neuronSimilarities.keys, ...keywordSimilarities.keys};
  
  if (allNeuronIds.isEmpty) return combinedScores;


  for (final neuronId in allNeuronIds) {
    final neuronRatingScore = (neuronSimilarities[neuronId] ?? 0.001 )/(network.neurons[neuronId]!.allRating+0.001);
    final keywordScore = ( keywordSimilarities[neuronId]! ?? 0.001 )/(similarityAll[neuronId]!+0.001);
    
    final combinedScore = (neuronRatingScore * 0.35) + (keywordScore * 0.65);
    combinedScores[neuronId] = combinedScore;
  }
  
  // Топ 50 нейронов
  return Map.fromEntries(
    combinedScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value))
      ..take(50)
  );
}



void _drawEnhancedConnection(
  Canvas canvas,
  Neuron neuron,
  double similarityScore,
  Size size
) {
  final neuronPosition = Offset(neuron.screenX, neuron.screenY);
  
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron == null) continue;
    
    final hasConnection = _hasConnectionBetween(neuron, selectedNeuron);
    
    if (hasConnection>0.15) {
      final selectedPosition = _findNeuronPosition(selectedNeuron, size);
      if (selectedPosition == null) continue;
      
      final intensity = similarityScore.clamp(0.0, 1.0);
      final color = Color.lerp(
        Colors.yellow.withOpacity(0.1),
        Colors.orange.withOpacity(0.2),
        intensity,
      )!;
      
      final strokeWidth = 0.7 + (intensity * 1.0);
      
      final paint = Paint()
        ..color = color
        ..strokeWidth = strokeWidth
        ..style = PaintingStyle.stroke;
      
      // Точная копия алгоритма из _drawNeuronConnections
      _drawCurvedLine(
        canvas,
        selectedPosition,
        neuronPosition,
        paint,
      );
      
      // Свечение для сильных связей
      if (intensity > 0.7) {
        final glowPaint = Paint()
          ..color = Colors.orange.withOpacity(0.2)
          ..strokeWidth = strokeWidth * 1.2
          ..style = PaintingStyle.stroke
          ..maskFilter = MaskFilter.blur(BlurStyle.normal, 3);
        
        _drawCurvedLine(
          canvas,
          selectedPosition,
          neuronPosition,
          glowPaint,
        );
      }
    }
  }
}

// Вынесенная функция для рисования кривой линии (как в оригинале)
void _drawCurvedLine(Canvas canvas, Offset start, Offset end, Paint paint) {
  final path = Path();
  path.moveTo(start.dx, start.dy);
  
  final midX = (start.dx + end.dx) / 2;
  final midY = (start.dy + end.dy) / 2;
  
  // Тот же алгоритм расчета контрольных точек
  final controlX = midX + (end.dy - start.dy) * 0.1;
  final controlY = midY - (end.dx - start.dx) * 0.1;
  
  path.quadraticBezierTo(
    controlX, controlY,
    end.dx, end.dy,
  );
  
  canvas.drawPath(path, paint);
}

double _hasConnectionBetween(Neuron neuron1, Neuron neuron2) {
  // Проверяем связь по neuronRatings
  if (neuron1.neuronRatings.containsKey(neuron2.id) || 
      neuron2.neuronRatings.containsKey(neuron1.id)) {
    return neuron2.neuronRatings[neuron1.id]!/neuron2.allRating;
  }
  
  // Проверяем связь по общим keywords
  final keywords1 = neuron1.keywords.toSet();
  final keywords2 = neuron2.keywords.toSet();
  final commonKeywords = keywords1.intersection(keywords2);
  
  return commonKeywords.length/((keywords1.length+keywords2.length+0.1)/2);
}

  void _drawSingleNeuron(Canvas canvas, Neuron neuron, double screenX, double screenY, Size size) {
  final position = Offset(screenX, screenY);
  final isSelected = selectedNeuronIds.contains(neuron.id);
  
  _drawNeuronCardCached(canvas, neuron, position, isSelected);
  
  // Рисуем связи только для выделенных нейронов или по настройке
  if (selectedNeuronIds.contains(neuron.id)) {
    _drawNeuronConnections(canvas, neuron, position, size);
  }
}
  
  void _drawNeuronCardCached(Canvas canvas, Neuron neuron, Offset position, bool isSelected) {
    final cacheKey = _getNeuronCacheKey(neuron, isSelected);
    
    if (_neuronCardCache.containsKey(cacheKey) && _lastCameraScale == cameraScale) {
      final cachedPicture = _neuronCardCache[cacheKey]!;
      canvas.save();
      canvas.translate(position.dx, position.dy);
      canvas.drawPicture(cachedPicture);
      canvas.restore();
      return;
    }
    
    // Создаем новую картинку и кэшируем
    final recorder = ui.PictureRecorder();
    final cardCanvas = Canvas(recorder);
    
    _drawNeuronCardContent(cardCanvas, neuron, isSelected);
    
    final picture = recorder.endRecording();
    _neuronCardCache[cacheKey] = picture;
    
    if (_neuronCardCache.length > 50) {
      _neuronCardCache.remove(_neuronCardCache.keys.first);
    }
    
    canvas.save();
    canvas.translate(position.dx, position.dy);
    canvas.drawPicture(picture);
    canvas.restore();
  }
  
  void _drawNeuronCardContent(Canvas canvas, Neuron neuron, bool isSelected) {
    // Компактные размеры 120x50
    final cardWidth = 30.0 * cameraScale;
    final cardHeight = 10.0 * cameraScale;
   final bool isTopNeuron = _topNeuronIds.containsKey(neuron.id);
    final double neuronTopConnectionStr = _topNeuronIds[neuron.id]?? 0;
    final double difference =max_similairty_top_neurons-min_similairty_top_neurons;
    final double max_d = max_similairty_top_neurons-difference;
    final double min_d = max_similairty_top_neurons-difference;
    final double my_d = neuronTopConnectionStr-difference;
    final double percent_similairty = my_d/max_d;
    final double percent_more_than_min = my_d/min_d;
    final bool isSomethingSelected = !selectedNeuronIds.isEmpty;
    //  double max_similairty_top_neurons = 0;
    //double min_similairty_top_neurons = 0;
    final cardRect = Rect.fromCenter(
      center: Offset.zero,
      width: cardWidth,
      height: cardHeight
    );

    // Фон карточки
    final gradient = LinearGradient(
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
      colors: [
        isSelected ? Colors.orange.withOpacity(0.9) :isTopNeuron? Colors.green.withOpacity(0.6*percent_similairty): isSomethingSelected? Colors.grey.withOpacity(0.25) : Colors.blue.withOpacity(0.5),
        isSelected ? Colors.pink.withOpacity(0.7) : isTopNeuron? Colors.cyan.withOpacity(0.5*percent_similairty):isSomethingSelected? Colors.brown.withOpacity(0.20): Colors.purple.withOpacity(0.5),
      ],
    );
    
    final backgroundPaint = Paint()
      ..shader = gradient.createShader(cardRect)
      ..style = PaintingStyle.fill;
    
    // Тень
    final shadowPaint = Paint()
      ..color = Colors.black.withOpacity(0.3)
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, 4 * cameraScale);
    
    canvas.drawRRect(
      RRect.fromRectAndRadius(cardRect.shift(Offset(2, 2)), Radius.circular(6 * cameraScale)),
      shadowPaint
    );
    
    // Основная карточка
    canvas.drawRRect(
      RRect.fromRectAndRadius(cardRect, Radius.circular(6 * cameraScale)),
      backgroundPaint
    );
    if (isSelected || isTopNeuron) {
      final myColor = isTopNeuron ? Colors.green.withOpacity(0.5) : Colors.yellow.withOpacity(0.6);
      final borderPaint = Paint()
        ..color = myColor
        ..strokeWidth = 1 * cameraScale
        ..style = PaintingStyle.stroke;
      
      canvas.drawRRect(
        RRect.fromRectAndRadius(cardRect, Radius.circular(6 * cameraScale)),
        borderPaint
      );
    }
    final title = neuron.pageTitle ?? 'Neuron #${neuron.id}';
    final shortenedTitle = _shortenText(title, 35); // Ограничиваем длину заголовка
    
    // Заголовок (верхняя строка)
    _drawText(
      canvas,
      shortenedTitle,
      TextStyle(
        color: Colors.white,
        fontSize: 1.1 * cameraScale, // Уменьшенный шрифт
        fontWeight: FontWeight.bold,
      ),
      Offset(-cardWidth/2 + 1 * cameraScale, -cardHeight/2 + 2 * cameraScale),
      cardWidth - 2 * cameraScale,
    );
    
    // URL (средняя строка)
    if (neuron.sourceUrl != null) {
      final displayUrl = _shortenUrl(neuron.sourceUrl!);
      _drawText(
        canvas,
        displayUrl,
        TextStyle(
          color: Colors.white70,
          fontSize: 0.7 * cameraScale, // Уменьшенный шрифт
        ),
        Offset(-cardWidth/2 + 1 * cameraScale, -cardHeight/2 + 6 * cameraScale),
        cardWidth - 2 * cameraScale,
      );
    }
    
    // Ключевые слова (нижняя строка)
    final keywords = _getTopKeywords(neuron).take(6).join(', '); // Берем только 2 ключевых слова
    if (keywords.isNotEmpty) {
      final shortKeywords = _shortenText(keywords, 25);
      _drawText(
        canvas,
        shortKeywords,
        TextStyle(
          color: Colors.white.withOpacity(0.7),
          fontSize: 0.6 * cameraScale, // Уменьшенный шрифт
        ),
        Offset(-cardWidth/2 + 1 * cameraScale, -cardHeight/2 + 7 * cameraScale),
        cardWidth - 1 * cameraScale,
      );
    }
    
    // ID нейрона в правом нижнем углу
    _drawText(
      canvas,
      '#${neuron.id}',
      TextStyle(
        color: Colors.white.withOpacity(0.5),
        fontSize: 5 * cameraScale, // Уменьшенный шрифт
      ),
      Offset(cardWidth/2 - 15 * cameraScale, cardHeight/2 - 9 * cameraScale),
      5 * cameraScale,
      align: TextAlign.right,
    );
  }

  String _shortenText(String text, int maxLength) {
    if (text.length <= maxLength) return text;
    return '${text.substring(0, maxLength - 3)}...';
  }
  void _drawText(
    Canvas canvas, 
    String text, 
    TextStyle style, 
    Offset position, 
    double maxWidth, {
    TextAlign align = TextAlign.left,
  }) {
    final paragraphBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
      textDirection: ui.TextDirection.ltr,
      textAlign: align,
    ))
      ..pushStyle(style.getTextStyle())
      ..addText(text);
    
    final paragraph = paragraphBuilder.build();
    paragraph.layout(ui.ParagraphConstraints(width: maxWidth));
    
    canvas.drawParagraph(paragraph, position);
  }
  
  String _getNeuronCacheKey(Neuron neuron, bool isSelected) {
    final contentHash = _getNeuronContentHash(neuron);
    return 'neuron_${neuron.id}_${isSelected}_${cameraScale.toStringAsFixed(2)}_$contentHash';
  }
  
  String _getNeuronContentHash(Neuron neuron) {
    // Создаем хэш на основе содержимого, которое влияет на отображение
    final content = '${neuron.pageTitle}_${neuron.sourceUrl}_${_getTopKeywords(neuron).join(",")}';
    return content.hashCode.toString();
  }
  

List<String> _getTopKeywords(Neuron neuron) {
  final wordScores = <int, double>{};
  
  // Сначала вычисляем scores для слов из signatureRatings нейрона
   for (final wordId in neuron.keywords) {
    final word = network.words[wordId];
    if (word != null) {
      double score = neuron.signatureRatings[wordId]!.toDouble();
      for (final otherWordId in neuron.keywords) {
        final otherWord = network.words[otherWordId];
        if (otherWord != word) {
          final connection = network.words[otherWordId]!.ratings[wordId] ?? 0;
          score += connection * 0.1;
        }
      }
      wordScores[wordId] = score;
    }
  }
  
  
  final sortedWords = wordScores.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));
  
  // Топ-15 с самым высоким рейтингом
  final topKeywords = sortedWords
      .take(4)
      .map((entry) => network.wordLibrary[entry.key] ?? 'unknown')
      .where((word) => word.length > 2)
      .toList();
  
  // Для нижних 5 используем рейтинг из network.words
  final bottomWords = <MapEntry<int, double>>[];
  
  for (final wordId in neuron.signatureRatings.keys) {
    final word = network.words[wordId];
    if (word != null) {
      // Используем allRating из network.words как основной рейтинг
      final globalScore = word.allRating.toDouble();
      bottomWords.add(MapEntry(wordId, globalScore));
    }
  }
  
  // Сортируем по возрастанию рейтинга из network.words
  bottomWords.sort((a, b) => a.value.compareTo(b.value));
  
  final bottomKeywords = bottomWords
      .take(2)
      .map((entry) => network.wordLibrary[entry.key] ?? 'unknown')
      .where((word) => word.length > 2)
      .toList();
  
  return [...topKeywords, ...bottomKeywords];
}

  void clearCache() {
    _neuronCardCache.clear();
  }

  Color _getClusterColor(NeuronCluster cluster) {
    final hue = (cluster.id.hashCode % 360).toDouble();
    
    switch (cluster.type) {
      case 'domain':
        return HSLColor.fromAHSL(1.0, hue, 0.8, 0.6).toColor();
      case 'keyword':
        return HSLColor.fromAHSL(1.0, hue, 0.9, 0.4).toColor();
      case 'root':
        return Colors.deepPurple;
      default:
        return HSLColor.fromAHSL(1.0, hue, 0.6, 0.5).toColor();
    }
  }
  
  String _getClusterDisplayText(NeuronCluster cluster) {
    String text = cluster.title;
    
    if (cluster.neuronIds.isNotEmpty) {
      text += '\n${cluster.neuronIds.length}';
    }
    
    if (text.length > 15) {
      text = text.substring(0, 12) + '...';
    }
    
    return text;
  }
    String _shortenUrl(String url) {
    try {
      final uri = Uri.parse(url);
      final host = uri.host;
      final path = uri.path;
      if (path.length > 20) {
        return '$host${path.substring(0, 20)}...';
      }
      return '$host$path';
    } catch (e) {
      return url.length > 30 ? '${url.substring(0, 30)}...' : url;
    }
  }
  
  Offset _projectToScreen(double x, double y, double z, double centerX, double centerY) {
    // Простая проекция 3D в 2D
    final screenX = centerX + (x * cameraScale);
    final screenY = centerY + (y * cameraScale);
    
    return Offset(screenX, screenY);
  }
  
    @override
  bool shouldRepaint(_AdvancedNeuron3DPainter oldDelegate) {
    return oldDelegate.cameraX != cameraX ||
        oldDelegate.cameraY != cameraY ||
        oldDelegate.cameraScale != cameraScale ||
        oldDelegate.rotationX != rotationX ||
        oldDelegate.rotationY != rotationY ||
        !_areSetsEqual(oldDelegate.selectedNeuronIds, selectedNeuronIds) ||
        oldDelegate.hoveredClusterId != hoveredClusterId ||
        oldDelegate.draggedClusterId != draggedClusterId;
  }
  
    bool _areSetsEqual<T>(Set<T> set1, Set<T> set2) {
    if (set1.length != set2.length) return false;
    for (final item in set1) {
      if (!set2.contains(item)) return false;
    }
    return true;
  }
}
class HitResult {
  final String? clusterId;
  final int? neuronId;
  
  HitResult({this.clusterId, this.neuronId});
}
/// Улучшенная стратегия с учетом баланса allRating
class _EnhancedStrategy {
  final String description;
  final double similarityWeight;
  final double entropyWeight;
  final double allRatingWeight;
  final bool preferHighRating;
  final bool preferLowRating;
  
  const _EnhancedStrategy({
    required this.description,
    required this.similarityWeight,
    required this.entropyWeight,
    required this.allRatingWeight,
    required this.preferHighRating,
    required this.preferLowRating,
  });
  
  double calculateScore({
    required double similarityScore,
    required double entropyChange,
    required double allRatingScore,
    required int currentStep,
  }) {
    // Динамические веса в зависимости от шага
    final stepFactor = currentStep / 25.0;
    final dynamicSimilarityWeight = similarityWeight * (1.0 - stepFactor * 0.3);
    final dynamicEntropyWeight = entropyWeight * (1.0 + stepFactor * 0.5);
    
    return similarityScore * dynamicSimilarityWeight +
           entropyChange * dynamicEntropyWeight +
           allRatingScore * allRatingWeight;
  }
}

_determineEnhancedStrategy(
  double entropy, 
  _VectorStats stats, 
  double balance,
  int step
) {


    if (entropy > 2.5) {
    return _EnhancedStrategy(
      description: "ENTROPY: Focus content",
      similarityWeight: 0.6,
      entropyWeight: 0.3,
      allRatingWeight: 0.1,
      preferHighRating: false,
      preferLowRating: true,
    );
  }
  
  // Ранние шаги: фокус на сходстве
  if (step < 5) {
    return _EnhancedStrategy(
      description: "EARLY: Focus similarity",
      similarityWeight: 0.7,
      entropyWeight: 0.2,
      allRatingWeight: 0.1,
      preferHighRating: true,
      preferLowRating: false,
    );
  }
  
  // Балансировка allRating
  if (balance < 0.3) {
    return _EnhancedStrategy(
      description: "BALANCE: Correct rating imbalance",
      similarityWeight: 0.4,
      entropyWeight: 0.3,
      allRatingWeight: 0.3,
      preferHighRating: stats.mean < 0.3,
      preferLowRating: stats.mean > 0.7,
    );
  }
  
  // Управление энтропией
  if (entropy < 1.5) {
    return _EnhancedStrategy(
      description: "ENTROPY: Increase diversity",
      similarityWeight: 0.3,
      entropyWeight: 0.6,
      allRatingWeight: 0.1,
      preferHighRating: false,
      preferLowRating: true,
    );
  }
  

  // Стандартная стратегия
  return _EnhancedStrategy(
    description: "STANDARD: Balanced approach",
    similarityWeight: 0.5,
    entropyWeight: 0.3,
    allRatingWeight: 0.2,
    preferHighRating: true,
    preferLowRating: false,
  );
}
/// Анализ характеристик вектора
class _VectorStats {
  final OptimizedNeuralNetwork network;
  final double minValue;
  final double maxValue;
  final double valueRange;
  final double mean;
  final double standardDeviation;

  _VectorStats({
    required this.network,
    required this.minValue,
    required this.maxValue,
    required this.valueRange,
    required this.mean,
    required this.standardDeviation,
  });
}

/// Класс для хранения оценок кандидатов
class _EnhancedCandidateScore {
  final int wordId;
  final double similarityScore;
  final double entropyChange;
  final double allRatingScore;
  final double combinedScore;
  final int wordAllRating;

  _EnhancedCandidateScore({
    required this.wordId,
    required this.similarityScore,
    required this.entropyChange,
    required this.allRatingScore,
    required this.combinedScore,
    required this.wordAllRating,
  });
}

/// Расчет энтропии Шеннона для нормализованного вектора
double _calculateShannonEntropy(Map<int, double> vector) {
  if (vector.isEmpty) return 0.0;

  final values = vector.values.toList();
  final total = values.fold(0.0, (a, b) => a + b);
  
  if (total <= 0 || total.isInfinite || total.isNaN) return 0.0;

  double entropy = 0.0;
  for (final value in values) {
    if (value <= 0) continue;
    final probability = value / total;
    if (probability > 0 && !probability.isInfinite && !probability.isNaN) {
      entropy -= probability * log(probability);
    }
  }

  // Защита от некорректных значений
  return entropy.isNaN || entropy.isInfinite ? 0.0 : entropy;
}
/// Вспомогательный класс для хранения оценок кандидатов
class _Line7CandidateScore {
  final int wordId;
  final double intersectionScore;
  final double entropyChange;
  final double predictedEntropy;
  final double combinedScore;

  _Line7CandidateScore({
    required this.wordId,
    required this.intersectionScore,
    required this.entropyChange,
    required this.predictedEntropy,
    required this.combinedScore,
  });
}
class Fragment3DVisualization extends StatefulWidget {
  final OptimizedNeuralNetwork network;
  final Set<int> selectedFragmentIds;
  final Function(int, bool) onFragmentSelected;
  final Set<int>? neuronIds;
  
  const Fragment3DVisualization({
    Key? key,
    required this.network,
    required this.selectedFragmentIds,
    required this.onFragmentSelected,
    this.neuronIds,
  }) : super(key: key);
  
  @override
  _Fragment3DVisualizationState createState() => _Fragment3DVisualizationState();
}

class _Fragment3DVisualizationState extends State<Fragment3DVisualization> {
  double _rotationX = 0.0;
  double _rotationY = 0.0;
  double _scale = 1.0;
  Offset _offset = Offset.zero;
  Offset? _lastLeftPanPosition;
  Offset? _lastRightPanPosition;
  bool _isRightMouseDown = false;
  bool _shiftPressed = false;
  int? _primaryButtonPointer;
  int? _secondaryButtonPointer;

  @override
  void initState() {
    super.initState();
    RawKeyboard.instance.addListener(_handleKeyEvent);
  }

  @override
  void dispose() {
    RawKeyboard.instance.removeListener(_handleKeyEvent);
    super.dispose();
  }

  void _handleKeyEvent(RawKeyEvent event) {
    if (event.logicalKey == LogicalKeyboardKey.shiftLeft || 
        event.logicalKey == LogicalKeyboardKey.shiftRight) {
      setState(() {
        _shiftPressed = event is RawKeyDownEvent;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerSignal: (pointerSignal) {
        if (pointerSignal is PointerScrollEvent) {
          setState(() {
            _scale = (_scale * (1.0 + pointerSignal.scrollDelta.dy * -0.001))
                .clamp(0.1, 3.0);
          });
        }
      },
      onPointerDown: (event) {
        _handlePointerDown(event);
      },
      onPointerMove: (event) {
        _handlePointerMove(event);
      },
      onPointerUp: (event) {
        _handlePointerUp(event);
      },
      onPointerCancel: (event) {
        _handlePointerCancel(event);
      },
      child: MouseRegion(
        onHover: (event) {
          if (event.kind == PointerDeviceKind.mouse) {
            if ((event.buttons & kPrimaryButton) != 0 && !_isRightMouseDown) {
            }
          }
        },
        child: GestureDetector(
          onScaleUpdate: (details) {
            if (!_isRightMouseDown) {
              setState(() {
                _scale = (_scale * details.scale).clamp(0.1, 3.0);
              });
            }
          },
          onTapDown: (details) {
            _handleTap(details.localPosition, _shiftPressed);
          },
          child: CustomPaint(
            size: Size.infinite,
            painter: Fragment3DPainter(
              network: widget.network,
              neuronIds: widget.neuronIds,
              rotationX: _rotationX,
              rotationY: _rotationY,
              scale: _scale,
              offset: _offset,
              selectedFragmentIds: widget.selectedFragmentIds,
            ),
          ),
        ),
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (event.kind == PointerDeviceKind.mouse) {
      if (event.buttons == kPrimaryButton) {
        _primaryButtonPointer = event.pointer;
        _lastLeftPanPosition = event.position;
      } else if (event.buttons == kSecondaryButton) {
        _secondaryButtonPointer = event.pointer;
        _lastRightPanPosition = event.position;
        _isRightMouseDown = true;
      }
    } else {
      _primaryButtonPointer = event.pointer;
      _lastLeftPanPosition = event.position;
    }
  }

  void _handlePointerMove(PointerMoveEvent event) {
    if (event.kind == PointerDeviceKind.mouse) {
      if (_primaryButtonPointer == event.pointer && _lastLeftPanPosition != null) {
        setState(() {
          final delta = event.position - _lastLeftPanPosition!;
          _rotationY += delta.dx * 0.01;
          _rotationX += delta.dy * 0.01;
          _lastLeftPanPosition = event.position;
        });
      } else if (_secondaryButtonPointer == event.pointer && _lastRightPanPosition != null) {
        setState(() {
          final delta = event.position - _lastRightPanPosition!;
          _offset += Offset(delta.dx, delta.dy);
          _lastRightPanPosition = event.position;
        });
      }
    } else if (_primaryButtonPointer == event.pointer && _lastLeftPanPosition != null) {
      setState(() {
        final delta = event.position - _lastLeftPanPosition!;
        _rotationY += delta.dx * 0.01;
        _rotationX += delta.dy * 0.01;
        _lastLeftPanPosition = event.position;
      });
    }
  }

  void _handlePointerUp(PointerUpEvent event) {
    _resetPointer(event.pointer);
  }

  void _handlePointerCancel(PointerCancelEvent event) {
    _resetPointer(event.pointer);
  }

  void _resetPointer(int pointerId) {
    if (_primaryButtonPointer == pointerId) {
      _primaryButtonPointer = null;
      _lastLeftPanPosition = null;
    }
    if (_secondaryButtonPointer == pointerId) {
      _secondaryButtonPointer = null;
      _lastRightPanPosition = null;
      _isRightMouseDown = false;
    }
  }

  void _handleTap(Offset position, bool shiftPressed) {
    final RenderBox box = context.findRenderObject() as RenderBox;
    final size = box.size;
    final centerX = size.width / 2 + _offset.dx;
    final centerY = size.height / 2 + _offset.dy;
    
    final fragments = _getFragmentsToDisplay();
    final projectedFragments = <_ProjectedFragment>[];
    
    for (int i = 0; i < fragments.length; i++) {
      final fragment = fragments[i];
      final pos = _project3DTo2D(
        fragment.x - 500, fragment.y - 500, fragment.z - 500,
        centerX, centerY,
      );
      
      projectedFragments.add(_ProjectedFragment(
        fragment: fragment,
        screenX: pos.dx,
        screenY: pos.dy,
        depth: pos.depth,
        index: i,
      ));
    }
    
    for (final projFragment in projectedFragments) {
      final distance = sqrt(
        pow(projFragment.screenX - position.dx, 2) + 
        pow(projFragment.screenY - position.dy, 2)
      );
      
      if (distance < 60.0) {
        widget.onFragmentSelected(projFragment.fragment.id, shiftPressed);
        return;
      }
    }
  }

  List<Fragment> _getFragmentsToDisplay() {
    if (widget.neuronIds != null && widget.neuronIds!.isNotEmpty) {
      final allFragments = <Fragment>[];
      for (final neuronId in widget.neuronIds!) {
        final neuron = widget.network.neurons[neuronId];
        if (neuron != null) {
          for (final fragmentId in neuron.fragmentLinks) {
            final fragment = widget.network.fragments[fragmentId];
            if (fragment != null) {
              allFragments.add(fragment);
            }
          }
        }
      }
      return allFragments;
    } else {
      return widget.network.fragments.values.toList();
    }
  }
  
  Projected3D _project3DTo2D(double x, double y, double z, double centerX, double centerY) {
    final cosY = cos(_rotationY);
    final sinY = sin(_rotationY);
    final cosX = cos(_rotationX);
    final sinX = sin(_rotationX);
    
    var x1 = x * cosY - z * sinY;
    var z1 = x * sinY + z * cosY;
    var y1 = y;
    
    final y2 = y1 * cosX - z1 * sinX;
    final z2 = y1 * sinX + z1 * cosX;
    
    final perspective = 1000 / (1000 + z2);
    final screenX = centerX + x1 * _scale * perspective;
    final screenY = centerY + y2 * _scale * perspective;
    
    return Projected3D(dx: screenX, dy: screenY, depth: z2);
  }
}

class Fragment3DPainter extends CustomPainter {
  final OptimizedNeuralNetwork network;
  final Set<int>? neuronIds;
  final double rotationX;
  final double rotationY;
  final double scale;
  final Offset offset;
  final Set<int> selectedFragmentIds;
  
  Fragment3DPainter({
    required this.network,
    required this.neuronIds,
    required this.rotationX,
    required this.rotationY,
    required this.scale,
    required this.offset,
    required this.selectedFragmentIds,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final centerX = size.width / 2 + offset.dx;
    final centerY = size.height / 2 + offset.dy;
    
    final fragments = _getFragmentsToDisplay();
    final projectedFragments = <_ProjectedFragment>[];
    
    _positionFragmentsByNeurons(fragments);
    
    for (int i = 0; i < fragments.length; i++) {
      final fragment = fragments[i];
      final pos = _project3DTo2D(
        fragment.x - 500, fragment.y - 500, fragment.z - 500,
        centerX, centerY,
      );
      
      projectedFragments.add(_ProjectedFragment(
        fragment: fragment,
        screenX: pos.dx,
        screenY: pos.dy,
        depth: pos.depth,
        index: i,
      ));
    }
    
    projectedFragments.sort((a, b) => a.depth.compareTo(b.depth));
    
    for (final projFragment in projectedFragments) {
      _drawFragmentCard(canvas, projFragment);
    }
  }

  void _positionFragmentsByNeurons(List<Fragment> fragments) {
    if (fragments.isEmpty) return;
    
    final neuronFragments = <int, List<Fragment>>{};
    
    for (final fragment in fragments) {
      for (final neuron in network.neurons.values) {
        if (neuron.fragmentLinks.contains(fragment.id)) {
          if (!neuronFragments.containsKey(neuron.id)) {
            neuronFragments[neuron.id] = [];
          }
          neuronFragments[neuron.id]!.add(fragment);
          break;
        }
      }
    }
    
    if (neuronFragments.isEmpty) {
      _positionFragmentsBySemantics(fragments);
      return;
    }
    
    final neuronEntries = neuronFragments.entries.toList();
    final neuronCount = neuronEntries.length;
    
    for (int neuronIndex = 0; neuronIndex < neuronCount; neuronIndex++) {
      final entry = neuronEntries[neuronIndex];
      final neuronFrags = entry.value;
      
      final planeX = 100.0 + (neuronIndex % 3) * 600.0;
      final planeY = 100.0 + (neuronIndex ~/ 3) * 400.0;
      final planeZ = (neuronIndex % 2) * 200.0;
      
      for (int fragIndex = 0; fragIndex < neuronFrags.length; fragIndex++) {
        final fragment = neuronFrags[fragIndex];
        final row = fragIndex ~/ 4;
        final col = fragIndex % 4;
        
        fragment.x = planeX + col * 280.0;
        fragment.y = planeY + row * 120.0;
        fragment.z = planeZ;
      }
    }
    
    for (final fragment in fragments) {
      if (fragment.x == 0.0 && fragment.y == 0.0 && fragment.z == 0.0) {
        fragment.x = network.random.nextDouble() * 800 + 100;
        fragment.y = network.random.nextDouble() * 800 + 100;
        fragment.z = network.random.nextDouble() * 800 + 100;
      }
    }
  }

  List<List<Fragment>> _clusterFragmentsBySemantics(List<Fragment> fragments) {
    final clusters = <List<Fragment>>[];
    final visited = <int>{};
    
    for (final fragment in fragments) {
      if (visited.contains(fragment.id)) continue;
      
      final cluster = <Fragment>[fragment];
      visited.add(fragment.id);
      
      for (final other in fragments) {
        if (visited.contains(other.id)) continue;
        
        final similarity = _calculateFragmentSimilarity(fragment, other);
        if (similarity > 0.3) {
          cluster.add(other);
          visited.add(other.id);
        }
      }
      
      if (cluster.isNotEmpty) {
        clusters.add(cluster);
      }
    }
    
    return clusters;
  }
  
  double _calculateFragmentSimilarity(Fragment frag1, Fragment frag2) {
    final set1 = frag1.wordIds.toSet();
    final set2 = frag2.wordIds.toSet();
    final intersection = set1.intersection(set2).length;
    final union = set1.union(set2).length;
    
    double lexicalSimilarity = union > 0 ? intersection / union : 0.0;
    
    double semanticBonus = frag1.semanticType == frag2.semanticType ? 0.2 : 0.0;
    
    final lengthFactor = min(frag1.text.length, frag2.text.length) / 1000.0;
    
    return (lexicalSimilarity * 0.6 + semanticBonus * 0.2 + lengthFactor * 0.2).clamp(0.0, 1.0);
  }

  void _positionFragmentsBySemantics(List<Fragment> fragments) {
    final clusters = _clusterFragmentsBySemantics(fragments);
    final clusterCount = clusters.length;
    
    for (int i = 0; i < clusterCount; i++) {
      final cluster = clusters[i];
      final phi = acos(-1.0 + 2.0 * i / clusterCount);
      final theta = sqrt(clusterCount * pi) * phi;
      
      final centerX = 500.0 + 300.0 * sin(phi) * cos(theta);
      final centerY = 500.0 + 300.0 * sin(phi) * sin(theta);
      final centerZ = 500.0 + 300.0 * cos(phi);
      
      for (int j = 0; j < cluster.length; j++) {
        final fragment = cluster[j];
        final angle = 2 * pi * j / cluster.length;
        final radius = 80.0;
        
        fragment.x = centerX + radius * cos(angle);
        fragment.y = centerY + radius * sin(angle);
        fragment.z = centerZ;
      }
    }
  }

  void _drawFragmentCard(Canvas canvas, _ProjectedFragment projFragment) {
    final fragment = projFragment.fragment;
    final isSelected = selectedFragmentIds.contains(fragment.id);
    
    final center = Offset(projFragment.screenX, projFragment.screenY);
    const double maxWidth = 250.0;
    final double width = maxWidth * scale;
    final double height = 80.0 * scale;
    
    final cardRect = Rect.fromCenter(
      center: center,
      width: width,
      height: height
    );
    
    final backgroundPaint = Paint()
      ..color = Color(0xFF2D2D2D).withOpacity(0.9)
      ..style = PaintingStyle.fill;
    
    canvas.drawRRect(
      RRect.fromRectAndRadius(cardRect, Radius.circular(8 * scale)),
      backgroundPaint
    );
    
    if (isSelected) {
      final borderPaint = Paint()
        ..color = Colors.amber.withOpacity(0.8)
        ..strokeWidth = 2.5
        ..style = PaintingStyle.stroke;
      
      canvas.drawRRect(
        RRect.fromRectAndRadius(cardRect, Radius.circular(8 * scale)),
        borderPaint
      );
    }
    
    final textPainter = _createTextPainter(fragment.text, width - 3, 9 * scale);
    
    final textOffset = Offset(
      center.dx - textPainter.width / 2,
      center.dy - textPainter.height / 2
    );
    
    textPainter.paint(canvas, textOffset);
    
    final infoText = '#${fragment.id} • ${fragment.semanticType} • ${fragment.wordIds.length} слов';
    final infoPainter = _createTextPainter(infoText, width - 16, 8 * scale, color: Colors.white70);
    
    final infoOffset = Offset(
      center.dx - infoPainter.width / 2,
      center.dy + height / 2 - infoPainter.height - 4
    );
    
    infoPainter.paint(canvas, infoOffset);
  }

  TextPainter _createTextPainter(String text, double maxWidth, double fontSize, {Color color = Colors.white}) {
    final textStyle = TextStyle(
      color: color,
      fontSize: fontSize,
      height: 1.2,
    );
    
    final textSpan = TextSpan(
      text: text,
      style: textStyle,
    );
    
    final textPainter = TextPainter(
      text: textSpan,
      textDirection: ui.TextDirection.ltr,
      maxLines: 5,
      ellipsis: '...',
    );
    
    textPainter.layout(maxWidth: maxWidth);
    return textPainter;
  }

  void _positionFragmentsInGrid(List<Fragment> fragments) {
    const double maxWidth = 1008.0;
    const double cardWidth = 250.0;
    const double cardHeight = 80.0;
    const double horizontalSpacing = 2.0;
    const double verticalSpacing = 2.0;
    
    double currentX = 0;
    double currentY = 0;
    double currentZ = 0.0;
    int rowFragmentCount = 0;
    
    for (final fragment in fragments) {
      if (currentX + cardWidth > maxWidth) {
        currentX = 0;
        currentY += cardHeight + verticalSpacing;
        rowFragmentCount = 0;
      }
      
      fragment.x = currentX;
      fragment.y = currentY;
      fragment.z = currentZ;
      
      currentX += cardWidth + horizontalSpacing;
      rowFragmentCount++;
      
      currentZ += 5.0;
    }
  }

  List<Fragment> _getFragmentsToDisplay() {
    List<Fragment> fragments;
    
    if (neuronIds != null && neuronIds!.isNotEmpty) {
      final allFragments = <Fragment>[];
      for (final neuronId in neuronIds!) {
        final neuron = network.neurons[neuronId];
        if (neuron != null) {
          for (final fragmentId in neuron.fragmentLinks) {
            final fragment = network.fragments[fragmentId];
            if (fragment != null) {
              allFragments.add(fragment);
            }
          }
        }
      }
      fragments = allFragments;
    } else {
      fragments = network.fragments.values.take(100).toList();
    }
    
    _positionFragmentsInGrid(fragments);
    return fragments;
  }
  
  _Projected3D _project3DTo2D(double x, double y, double z, double centerX, double centerY) {
    final cosY = cos(rotationY);
    final sinY = sin(rotationY);
    final cosX = cos(rotationX);
    final sinX = sin(rotationX);
    
    var x1 = x * cosY - z * sinY;
    var z1 = x * sinY + z * cosY;
    var y1 = y;
    
    final y2 = y1 * cosX - z1 * sinX;
    final z2 = y1 * sinX + z1 * cosX;
    
    final perspective = 1000 / (1000 + z2);
    final screenX = centerX + x1 * scale * perspective;
    final screenY = centerY + y2 * scale * perspective;
    
    return _Projected3D(dx: screenX, dy: screenY, depth: z2);
  }
  
  @override
  bool shouldRepaint(Fragment3DPainter oldDelegate) {
    return oldDelegate.rotationX != rotationX ||
        oldDelegate.rotationY != rotationY ||
        oldDelegate.scale != scale ||
        oldDelegate.offset != offset ||
        oldDelegate.selectedFragmentIds.length != selectedFragmentIds.length;
  }
}

class _ProjectedFragment {
  final Fragment fragment;
  final double screenX;
  final double screenY;
  final double depth;
  final int index;
  
  _ProjectedFragment({
    required this.fragment,
    required this.screenX,
    required this.screenY,
    required this.depth,
    required this.index,
  });
}

// Расширение для добавления координат фрагментам
extension Fragment3DExtension on Fragment {
  static final Map<int, double> _xCoords = {};
  static final Map<int, double> _yCoords = {};
  static final Map<int, double> _zCoords = {};
  
  double get x => _xCoords[id] ?? 0.0;
  set x(double value) => _xCoords[id] = value;
  
  double get y => _yCoords[id] ?? 0.0;
  set y(double value) => _yCoords[id] = value;
  
  double get z => _zCoords[id] ?? 0.0;
  set z(double value) => _zCoords[id] = value;
}



extension TextStyleExtension on TextStyle {
  ui.TextStyle getTextStyle() {
    return ui.TextStyle(
      color: color,
      fontSize: fontSize,
      fontWeight: fontWeight,
      fontStyle: fontStyle,
      letterSpacing: letterSpacing,
      wordSpacing: wordSpacing,
      height: height,
      decoration: decoration,
      decorationColor: decorationColor,
      decorationStyle: decorationStyle,
      decorationThickness: decorationThickness,
      background: background,
      shadows: shadows,
      fontFeatures: fontFeatures,
    );
  }
}




























class DigitalCreationSystem {
  final OptimizedNeuralNetwork network;
  final Map<String, List<Citation>> _citations = {};
  final Map<String, Set<String>> _keywordSources = {};
  
  DigitalCreationSystem(this.network);
  
  /// Создание цифрового создания с цитированием
  Future<DigitalCreation> createDigitalCreation(
    List<String> keywords, 
    String context
  ) async {
    final creation = DigitalCreation(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      keywords: keywords,
      context: context,
      createdAt: DateTime.now(),
    );
    
    // Поиск релевантного контента
    final relevantContent = await _findRelevantContent(keywords);
    
    // Генерация с привязкой к источникам
    final generated = await _generateWithCitations(keywords, relevantContent);
    
    creation.content = generated.content;
    creation.citations = generated.citations;
    
    return creation;
  }
  
  /// Поиск релевантного контента с источниками
  Future<List<RelevantContent>> _findRelevantContent(List<String> keywords) async {
    final relevant = <RelevantContent>[];
    
    for (final keyword in keywords) {
      // Поиск в нейронах
      final neurons = network.searchNeuronsByKeywords(keyword);
      for (final neuron in neurons.take(5)) {
        relevant.add(RelevantContent(
          content: neuron.pageTitle ?? neuron.sourceUrl ?? '',
          source: ContentSource(
            type: 'neuron',
            id: neuron.id.toString(),
            url: neuron.sourceUrl,
            title: neuron.pageTitle,
          ),
          relevance: 0.8,
          keywords: [keyword],
        ));
      }
      
      // Поиск во фрагментах
      final fragments = network.searchFragments(keyword);
      for (final fragment in fragments.take(10)) {
        relevant.add(RelevantContent(
          content: fragment.text,
          source: ContentSource(
            type: 'fragment', 
            id: fragment.id.toString(),
            semanticType: fragment.semanticType,
          ),
          relevance: 0.6,
          keywords: [keyword],
        ));
      }
    }
    
    return relevant;
  }
  
  /// Генерация с цитированием конкретных утверждений
  Future<GeneratedContent> _generateWithCitations(
    List<String> keywords, 
    List<RelevantContent> sources
  ) async {
    final citations = <Citation>[];
    final contentBuffer = StringBuffer();
    
    // Группируем источники по темам
    final groupedSources = _groupSourcesByTheme(sources);
    
    for (final theme in groupedSources.entries) {
      contentBuffer.writeln('## ${theme.key}');
      
      for (final source in theme.value.take(3)) {
        final claim = _extractKeyClaim(source.content);
        contentBuffer.writeln('• $claim');
        
        citations.add(Citation(
          claim: claim,
          source: source.source,
          confidence: source.relevance,
          supportingEvidence: _findSupportingEvidence(claim, sources),
        ));
      }
      contentBuffer.writeln();
    }
    
    return GeneratedContent(
      content: contentBuffer.toString(),
      citations: citations,
      sources: sources.map((s) => s.source).toSet().toList(),
    );
  }
  
  /// Извлечение ключевого утверждения из контента
  String _extractKeyClaim(String content) {
    // Используем семантический анализ для извлечения фактов
    final analysis = SemanticAnalyzer1.analyze(content);
    
    if (analysis.isFactual) {
      return content.split('.').firstWhere(
        (s) => s.length > 20,
        orElse: () => content.substring(0, min(100, content.length))
      );
    }
    
    return content.length > 100 ? '${content.substring(0, 100)}...' : content;
  }
  
  /// Поиск подтверждающих доказательств
  List<String> _findSupportingEvidence(String claim, List<RelevantContent> sources) {
    final evidence = <String>[];
    final claimKeywords = network._extractWords(claim);
    
    for (final source in sources) {
      final sourceKeywords = network._extractWords(source.content);
      final commonKeywords = claimKeywords.toSet().intersection(sourceKeywords.toSet());
      
      if (commonKeywords.length >= claimKeywords.length ~/ 2) {
        evidence.add(source.content);
        if (evidence.length >= 3) break;
      }
    }
    
    return evidence;
  }
}

/// Модели данных для цифрового создания
class DigitalCreation {
  final String id;
  final List<String> keywords;
  final String context;
  final DateTime createdAt;
  String content;
  List<Citation> citations;
  double confidence;
  
  DigitalCreation({
    required this.id,
    required this.keywords,
    required this.context,
    required this.createdAt,
    this.content = '',
    this.citations = const [],
    this.confidence = 0.0,
  });
}

class Citation {
  final String claim;
  final ContentSource source;
  final double confidence;
  final List<String> supportingEvidence;
  final DateTime citedAt;
  
  Citation({
    required this.claim,
    required this.source,
    required this.confidence,
    required this.supportingEvidence,
  }) : citedAt = DateTime.now();
}

class ContentSource {
  final String type; // 'neuron', 'fragment', 'external'
  final String id;
  final String? url;
  final String? title;
  final String? semanticType;
  
  ContentSource({
    required this.type,
    required this.id,
    this.url,
    this.title,
    this.semanticType,
  });
}

class RelevantContent {
  final String content;
  final ContentSource source;
  final double relevance;
  final List<String> keywords;
  
  RelevantContent({
    required this.content,
    required this.source,
    required this.relevance,
    required this.keywords,
  });
}

class GeneratedContent {
  final String content;
  final List<Citation> citations;
  final List<ContentSource> sources;
  
  GeneratedContent({
    required this.content,
    required this.citations,
    required this.sources,
  });
}



