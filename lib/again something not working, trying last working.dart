// main.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io' show File, Directory;
import 'dart:math';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/services.dart';
import 'package:window_manager/window_manager.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:http/http.dart' as http;
import 'package:url_launcher/url_launcher.dart';
import 'package:archive/archive.dart';
import 'package:path/path.dart' as path;
import 'package:screen_retriever/screen_retriever.dart';
import 'package:desktop_drop/desktop_drop.dart';
import 'audio_checker.dart';
import 'package:file_icon/file_icon.dart';
import 'package:file_picker/file_picker.dart';
import 'package:system_theme/system_theme.dart';
import 'native_blur.dart'; // –ü—É—Ç—å –∫ –≤–∞—à–µ–º—É —Ñ–∞–π–ª—É
import 'package:flutter/foundation.dart';
import 'clipboard_monitor.dart';
import 'package:clipboard/clipboard.dart';
import 'file_drag_drop_service.dart';
import 'package:flutter/painting.dart';
import 'dart:isolate';
import 'dart:collection'; // –î–æ–±–∞–≤–ª—è–µ–º —ç—Ç–æ—Ç –∏–º–ø–æ—Ä—Ç
import 'package:html/parser.dart' as html_parser;
import 'package:charset_converter/charset_converter.dart';
import 'package:flutter/rendering.dart';

import 'package:cross_file/cross_file.dart';

// Add this import for DateFormat
import 'package:intl/intl.dart';
import 'package:image/image.dart' as img;

import 'package:flutter_colorpicker/flutter_colorpicker.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:speech_to_text/speech_to_text.dart' as stt;
import 'hotkey_service.dart';
// –°—Ç–æ–ø-—Å–ª–æ–≤–∞
// –°—Ç–æ–ø-—Å–ª–æ–≤–∞

import 'package:cached_network_image/cached_network_image.dart';


import 'dart:convert';

import 'native_smtc.dart';

import 'native_mouse_service.dart';



import 'package:universal_io/io.dart';

import 'package:path/path.dart' as p;


// ========== –°–¢–û–ü-–°–õ–û–í–ê ==========
final Set<String> STOP_WORDS = {
  '–∏', '–≤', '–≤–æ', '–Ω–µ', '—á—Ç–æ', '–æ–Ω', '–Ω–∞', '—è', '—Å', '—Å–æ', '–∫–∞–∫', '–∞', '—Ç–æ',
  '–≤—Å–µ', '–æ–Ω–∞', '—Ç–∞–∫', '–µ–≥–æ', '–Ω–æ', '–¥–∞', '—Ç—ã', '–∫', '—É', '–∂–µ', '–≤—ã', '–∑–∞',
  '–±—ã', '–ø–æ', '—Ç–æ–ª—å–∫–æ', '–µ–µ', '–µ—ë', '–º–Ω–µ', '–±—ã–ª–æ', '–≤–æ—Ç', '–æ—Ç', '–º–µ–Ω—è',
  '–µ—â–µ', '–µ—â—ë', '–Ω–µ—Ç', '–æ', '–∏–∑', '–µ–º—É', '—Ç–µ–ø–µ—Ä—å', '–∫–æ–≥–¥–∞', '–¥–∞–∂–µ', '–Ω—É',
  '–≤–¥—Ä—É–≥', '–ª–∏', '–µ—Å–ª–∏', '—É–∂–µ', '–∏–ª–∏', '–Ω–∏', '–±—ã—Ç—å', '–±—ã–ª', '–Ω–µ–≥–æ', '–¥–æ',
  '–≤–∞—Å', '–Ω–∏–±—É–¥—å', '–æ–ø—è—Ç—å', '—É–∂', '–≤–∞–º', '–≤–µ–¥—å', '—Ç–∞–º', '–ø–æ—Ç–æ–º', '—Å–µ–±—è',
  '–Ω–∏—á–µ–≥–æ', '–µ–π', '–º–æ–∂–µ—Ç', '–æ–Ω–∏', '—Ç—É—Ç', '–≥–¥–µ', '–µ—Å—Ç—å', '–Ω–∞–¥–æ', '–Ω–µ–π', '–¥–ª—è',
  '–º—ã', '—Ç–µ–±—è', '–∏—Ö', '—á–µ–º', '–±—ã–ª–∞', '—Å–∞–º', '—á—Ç–æ–±', '—á—Ç–æ–±—ã', '–±–µ–∑', '–±—É–¥—Ç–æ',
  '—á–µ–≥–æ', '—Ä–∞–∑', '—Ç–æ–∂–µ', '—Å–µ–±–µ', '–ø–æ–¥', '–±—É–¥–µ—Ç', '–∂', '—Ç–æ–≥–¥–∞', '–∫—Ç–æ', '—ç—Ç–æ—Ç',
  '—Ç–æ–≥–æ', '–ø–æ—Ç–æ–º—É', '—ç—Ç–æ–≥–æ', '–∫–∞–∫–æ–π', '—Ç–æ—Ç', '–∫–∞–∫–∞—è', '–∫–∞–∫–æ–µ', '–∫–∞–∫–∏–µ', '–∫–æ—Ç–æ—Ä—ã–π',
  '—Ç–∞', '—Ç–µ—Ö', '—Ç–µ–º', '—Ç–µ–º–∏', '—Ç–æ–º—É', '—Ç–µ—Ö', '—Ç–µ—Ö', '—Ç–µ—Ö', '—á–µ–π', '—á—å—è', '—á—å–µ', '—á—å–∏',
  '–≤—Å—ë', '–≤—Å–µ–≥–æ', '–≤—Å–µ–π', '–≤—Å—é', '–≤—Å–µ—é', '–≤—Å–µ–º', '–≤—Å–µ—Ö', '–≤—Å–µ–º–∏',
  '–ø–µ—Ä–µ–¥', '–ø—Ä–∏', '–æ–±', '–ø—Ä–æ', '–Ω–∞–¥', '—á–µ—Ä–µ–∑', '–ø–æ—Å–ª–µ', '–º–µ–∂–¥—É', '–∏–∑-–∑–∞', '–∏–∑–ø–æ–¥',
  '–∏–±–æ', '–ª–∏—à—å', '—Ä–∞–∑–≤–µ', '–ø—É—Å—Ç—å', '–¥–∞–≤–∞–π', '–≤–ø—Ä–æ—á–µ–º', '–∑–∞—Ç–æ', '–∏–Ω–∞—á–µ',
  '–≤–µ–¥—å', '—É–∂', '–≤–æ–Ω', '–≤—Å—é–¥—É', '–≥–¥–µ-—Ç–æ', '–∫—É–¥–∞', '–æ—Ç–∫—É–¥–∞', '—Ç—É–¥–∞', '—Å—é–¥–∞',
  '—Ç–æ–≥–¥–∞-—Ç–æ', '–≤—Å—ë-—Ç–∞–∫–∏', '—Ç–æ-—Ç–æ', '–∫–æ–µ-–∫—Ç–æ', '–∫–æ–µ-—á—Ç–æ', '–∫–æ–µ-–≥–¥–µ', '–Ω–∏–≥–¥–µ',
  '–Ω–∏–∫—É–¥–∞', '–Ω–∏–∫–æ–≥–¥–∞', '–Ω–∏—á—Ç–æ', '–Ω–∏–∫—Ç–æ', '–Ω–∏—á–µ–π', '–Ω–µ–∫—Ç–æ', '–Ω–µ—á—Ç–æ', '–Ω–µ–∫—É–¥–∞',
  '–Ω–µ–ª—å–∑—è', '–≤—Å—é–¥—É', '–∑–¥–µ—Å—å', '—Å—é–¥–∞', '–æ—Ç—Å—é–¥–∞', '—Ç—É–¥–∞', '–æ—Ç—Ç—É–¥–∞', '—Ç–∞–º', '—Ç—É—Ç',
  '—ç—Ç–∏–º', '—ç—Ç–æ–º', '—ç—Ç–∏', '—ç—Ç–∞', '—ç—Ç–æ', '—ç—Ç–∏—Ö', '—ç—Ç–∏–º–∏', '—ç—Ç–æ–º—É', '—ç—Ç–æ–π', '—ç—Ç—É',
  '–º–æ–π', '–º–æ—è', '–º–æ—ë', '–º–æ–∏', '—Ç–≤–æ–π', '—Ç–≤–æ—è', '—Ç–≤–æ—ë', '—Ç–≤–æ–∏', '–Ω–∞—à', '–Ω–∞—à–∞', '–Ω–∞—à–µ',
  '–Ω–∞—à–∏', '–≤–∞—à', '–≤–∞—à–∞', '–≤–∞—à–µ', '–≤–∞—à–∏', '–∏—Ö–Ω–∏–π', '–∏—Ö–Ω—è—è', '–∏—Ö–Ω–µ–µ', '–∏—Ö–Ω–∏–µ',
  '—Å–≤–æ–π', '—Å–≤–æ—è', '—Å–≤–æ—ë', '—Å–≤–æ–∏', '—Ç–æ—Ç-—Ç–æ', '—ç—Ç–æ—Ç-—Ç–æ', '—Ç–æ—Ç –∂–µ', '—Ç–∞ –∂–µ',
  '—Ç–æ –∂–µ', '—Ç–µ –∂–µ', '—Ç–∞–∫–æ–π', '—Ç–∞–∫–∞—è', '—Ç–∞–∫–æ–µ', '—Ç–∞–∫–∏–µ', '—Ç–∞–∫–æ–≤', '—Ç–∞–∫–æ–≤–∞',
  '—Ç–∞–∫–æ–≤—ã', '—Ç–∞–∫–æ–≤–æ–µ', '—Ç–∞–∫–æ–≤-—Ç–æ', '—Å–µ–π', '—Å–∏—è', '—Å–∏–µ', '—Å–∏–∏', '–æ–Ω –∂–µ',
  '–æ–Ω–∞ –∂–µ', '–æ–Ω–æ –∂–µ', '–æ–Ω–∏ –∂–µ', '–≤—Å—è–∫–∏–π', '–≤—Å—è–∫–∞—è', '–≤—Å—è–∫–æ–µ', '–≤—Å—è–∫–∏–µ',
  '–∫–∞–∂–¥—ã–π', '–∫–∞–∂–¥–∞—è', '–∫–∞–∂–¥–æ–µ', '–∫–∞–∂–¥—ã–µ', '—Å–∞–º—ã–π', '—Å–∞–º–∞—è', '—Å–∞–º–æ–µ', '—Å–∞–º—ã–µ',
  '–∏–Ω–æ–π', '–∏–Ω–∞—è', '–∏–Ω–æ–µ', '–∏–Ω—ã–µ', '–¥—Ä—É–≥–æ–π', '–¥—Ä—É–≥–∞—è', '–¥—Ä—É–≥–æ–µ', '–¥—Ä—É–≥–∏–µ',
  '–∫–∞–∫–æ–π-—Ç–æ', '–∫–∞–∫–∞—è-—Ç–æ', '–∫–∞–∫–æ–µ-—Ç–æ', '–∫–∞–∫–∏–µ-—Ç–æ', '—á–µ–π-—Ç–æ', '—á—å—è-—Ç–æ', '—á—å—ë-—Ç–æ', '—á—å–∏-—Ç–æ',
  '–Ω–µ–∫–æ—Ç–æ—Ä—ã–π', '–Ω–µ–∫–æ—Ç–æ—Ä–∞—è', '–Ω–µ–∫–æ—Ç–æ—Ä–æ–µ', '–Ω–µ–∫–æ—Ç–æ—Ä—ã–µ', '—ç—Ç–∞–∫', '—Ç–∞–∫-—Ç–æ', '–≤–æ—Ç-–≤–æ—Ç',
  '—Ç–∞–∫-—Ç–æ', '–¥–∞-—Å', '–∞–≥–∞', ' –ª–∞–¥–Ω–æ', '–æ–∫', '–æ–∫–µ–π', '–Ω—É-–∫–∞', '–Ω—É –∂–µ', '–∞–π', '—ç–π', '–æ–π',
  '–∞–ª–ª–æ', '–ø—Ä–æ—Å—Ç–æ', '–ø–æ—á—Ç–∏', '–≤—Ä–æ–¥–µ', '–∏–º–µ–Ω–Ω–æ', '–≤—Å–µ–≥–æ', '–ø—Ä–∏–º–µ—Ä–Ω–æ', '–æ—Å–æ–±–µ–Ω–Ω–æ',
  '–¥–∞–≤–∞–π-–∫–∞', '–≤—Å—ë –∂', '–≤—Å—ë –∂–µ', '–∂–µ', '—É–∂', '–ª–∏–±–æ', '–±—É–¥—å', '–±—É–¥–µ–º', '–±—É–¥–µ—à—å',
  '–±—É–¥—É—Ç', '–±—É–¥—É', '–µ—Å—Ç—å', '–Ω–µ—Ç—É', '–Ω–µ–∞', '–∞–≥–∞', '—ç—Ö', '–∞—Ö', '–æ–π', '—É–≤—ã', '—É–≤—ã', '–∞–≥–∞',
  '–Ω—É-–Ω—É', '–≤–æ–Ω', '–æ—Ç–Ω—é–¥—å', '–µ–¥–≤–∞', '—á—É—Ç—å', '–ø–æ—á—Ç–∏', '—Å—Ä–∞–∑—É', '–æ–ø—è—Ç—å-—Ç–∞–∫–∏', '–µ—â—ë –±—ã',
  '—Ä–∞–∑–≤–µ —á—Ç–æ', '–µ—Å–ª–∏ –±—ã', '–ª–∏–±–æ', '–Ω–∏-–Ω–∏', '–Ω–µ—É–∂–µ–ª–∏', '—á—É—Ç—å –ª–∏', '—á—É—Ç—å-—á—É—Ç—å', '–µ–¥–≤–∞ –ª–∏',
  '—Ö–æ—Ç—è', '–ø—É—Å—Ç—å', '–ø—É—Å–∫–∞–π', '—Ä–∞–∑', '–ø–æ–∫—É–¥–∞', '–ø–æ–∫–∞–º–µ—Å—Ç', '–µ–¥–≤–∞', '–ø–æ–∫–∞', '—Ç–∞–∫ –∫–∞–∫',
  '–∏–∑-–∑–∞ —Ç–æ–≥–æ —á—Ç–æ', '–Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞', '–≤—Å–ª–µ–¥—Å—Ç–≤–∏–µ', '—á—Ç–æ–±—ã –Ω–µ', '–¥–∞–±—ã', '–∏–±–æ', '–∑–∞—Ç–µ–º',
  '–≤—Å–ª–µ–¥ –∑–∞', '–Ω–∞—Ä—è–¥—É —Å', '–ø—Ä–∏ —Ç–æ–º', '–ø—Ä–∏ —ç—Ç–æ–º', '—Ç–∞–∫ –∂–µ', '–≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫', '–º–µ–∂–¥—É —Ç–µ–º',
  '—Ç–µ–º –Ω–µ –º–µ–Ω–µ–µ', '–æ–¥–Ω–∞–∫–æ', '—Ç–æ–∂–µ', '—Ç–∞–∫–∂–µ', '–ø—Ä–∏—Ç–æ–º', '–∑–∞—Ç–æ', '–≤—Å—ë —Ä–∞–≤–Ω–æ', '–≤—Å—ë-—Ç–∞–∫–∏',
  '–ø–æ—ç—Ç–æ–º—É', '—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ', '–∏—Ç–∞–∫', '—Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º', '–∑–Ω–∞—á–∏—Ç', '–Ω—É –∞', '–∞ —Ç–æ', '–∏–ª–∏ –∂–µ',
  '—Ö–æ—Ç—è –±—ã', '–ø–æ –∫—Ä–∞–π–Ω–µ–π –º–µ—Ä–µ', '–ø–æ —Å—É—Ç–∏', '–≤ –æ–±—â–µ–º', '–≤ —Ü–µ–ª–æ–º', '–ø–æ-–º–æ–µ–º—É', '–ø–æ-—Ç–≤–æ–µ–º—É',
  '–ø–æ-–Ω–∞—à–µ–º—É', '–ø–æ-–≤–∞—à–µ–º—É', '–≤–æ–∑–º–æ–∂–Ω–æ', '–Ω–∞–≤–µ—Ä–Ω–æ–µ', '–∫–∞–∂–µ—Ç—Å—è', '—è–∫–æ–±—ã', '—Å–ª–æ–≤–Ω–æ', '–±—É–¥—Ç–æ –±—ã',
  '–≤—Ä–æ–¥–µ –±—ã', '—Ç–∏–ø–∞', '–º–æ–ª', '–¥–µ—Å–∫–∞—Ç—å', '—è–∫–æ–±—ã', '—Ç–∞–∫ —Å–∫–∞–∑–∞—Ç—å', '–≤ —á–∞—Å—Ç–Ω–æ—Å—Ç–∏', '—Ç–æ –µ—Å—Ç—å',
  '–Ω–∞–ø—Ä–∏–º–µ—Ä', '—Å–∫–∞–∂–µ–º', '–≤–ø—Ä–æ—á–µ–º', '–æ–¥–Ω–∞–∂–¥—ã', '–Ω–µ–∫–æ–≥–¥–∞', '–≤—Å–µ–≥–¥–∞', '—á–∞—Å—Ç–æ', '—Ä–µ–¥–∫–æ',
  '–∏–Ω–æ–≥–¥–∞', '–Ω–∏–∫–æ–≥–¥–∞', '–≤–µ–∑–¥–µ', '–≥–¥–µ-–ª–∏–±–æ', '–∫–æ–≥–¥–∞-–ª–∏–±–æ', '–∑–∞—á–µ–º', '–æ—Ç—á–µ–≥–æ', '–ø–æ—á–µ–º—É',
  '–∑–∞—á–µ–º-—Ç–æ', '–∫—É–¥–∞-–ª–∏–±–æ', '–æ—Ç–∫—É–¥–∞-–ª–∏–±–æ', '–∫–æ–≥–¥–∞-—Ç–æ', '—Ç–æ–≥–¥–∞-—Ç–æ', '—Å–µ–π—á–∞—Å', '—Ç–µ–ø–µ—Ä—å',
  '—Ä–∞–Ω—å—à–µ', '–ø–æ–∑–∂–µ', '–≤—á–µ—Ä–∞', '—Å–µ–≥–æ–¥–Ω—è', '–∑–∞–≤—Ç—Ä–∞', '–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞', '–Ω–∏–∫–æ–≥–¥–∞', '–≤—Å–µ–≥–¥–∞',
  '–µ–¥–≤–∞ –ª–∏', '–≤–µ—Å—å', '–≤—Å—è', '–≤—Å—ë', '–≤—Å–µ', '–≤—Å–µ–≥–æ', '–≤—Å–µ–π', '–≤—Å–µ–º', '–≤—Å–µ–º–∏', '–≤—Å–µ—Ö',
  '–±—ã–≤–∞–µ—Ç', '–±—ã–ª–∏', '–±—ã–ª', '–±—É–¥–µ—Ç', '–±—É–¥—É—Ç', '–µ—Å—Ç—å', '–Ω–µ—Ç', '–Ω–µ –±—ã–ª–æ', '–Ω–µ –±—É–¥–µ—Ç',
  '–º–æ–∂–µ—Ç', '–º–æ–≥', '—Å–º–æ–≥', '—Å–º–æ–∂–µ—Ç', '–Ω–∞–¥–æ', '–Ω—É–∂–Ω–æ', '—Å–ª–µ–¥—É–µ—Ç', '–¥–æ–ª–∂–µ–Ω', '—Å–ª–µ–¥–æ–≤–∞–ª–æ',
  '–Ω–µ–ª—å–∑—è', '–º–æ–∂–Ω–æ', '–º–æ–∂–Ω–æ –ª–∏', '–Ω–µ–ª—å–∑—è –ª–∏', '–≤—Å—ë —ç—Ç–æ', '–≤—Å—ë —Ç–æ', '–∏ —Ç–∞–∫ –¥–∞–ª–µ–µ',
  '–∏ —Ç–æ–º—É –ø–æ–¥–æ–±–Ω–æ–µ'
};

// ========== –£–¢–ò–õ–ò–¢–´ ==========
T min<T extends Comparable>(T a, T b) => a.compareTo(b) < 0 ? a : b;
T max<T extends Comparable>(T a, T b) => a.compareTo(b) > 0 ? a : b;

// ========== –ù–û–†–ú–ê–õ–ò–ó–ê–¶–ò–Ø –¢–ï–ö–°–¢–ê ==========
class TextNormalizer {
  static String normalizeText(String text) {
    text = text.replaceAll(RegExp(r'\s+'), ' ').trim();
    if (!text.endsWith('.') && !text.endsWith('!') && !text.endsWith('?')) {
      text += '.';
    }
    if (text.isNotEmpty) {
      text = text[0].toUpperCase() + text.substring(1);
    }
    return text;
  }
}

// ========== –°–ï–ú–ê–ù–¢–ò–ß–ï–°–ö–ò–ô –ê–ù–ê–õ–ò–ó ==========
class SemanticAnalyzer {
  static String analyzeSemantics(String text) {
    text = text.toLowerCase();
    if (text.contains('?')) return '–≤–æ–ø—Ä–æ—Å';
    if (text.contains(RegExp(r'\b(–¥–∞|–Ω–µ—Ç|–∫–æ–Ω–µ—á–Ω–æ|—Ä–∞–∑—É–º–µ–µ—Ç—Å—è)\b'))) return '—É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ';
    if (text.contains(RegExp(r'\b(—Å–∫–∞–∑–∞–ª|–æ—Ç–≤–µ—Ç–∏–ª|—Å–ø—Ä–æ—Å–∏–ª|–ø—Ä–æ–¥–æ–ª–∂–∏–ª)\b'))) return '–¥–∏–∞–ª–æ–≥';
    if (text.contains(RegExp(r'\b(–ø–æ—Ç–æ–º—É|–ø–æ—ç—Ç–æ–º—É|—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ|—Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º)\b'))) return '–æ–±—ä—è—Å–Ω–µ–Ω–∏–µ';
    if (text.length < 50) return '–∫—Ä–∞—Ç–∫–æ–µ –≤—ã—Å–∫–∞–∑—ã–≤–∞–Ω–∏–µ';
    return '–ø–æ–≤–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ';
  }
}

// ========== –°–¢–ï–ú–ú–ò–ù–ì –°–õ–û–í ==========
class WordStemmer {
  static final Map<String, String> _stemmingRules = {
    r'—Å—è$': '', r'—Å—å$': '', r'–æ–µ$': '—ã–π', r'–∞—è$': '—ã–π', r'–∏–µ$': '–∏–π',
    r'—ã–µ$': '—ã–π', r'–æ–º—É$': '—ã–π', r'–µ–º—É$': '–∏–π', r'–∏–º–∏$': '–∏–π', r'—ã–º–∏$': '—ã–π',
  };
  
  static String getStem(String word) {
    if (word.length < 3) return word;
    String stem = word.toLowerCase();
    for (final rule in _stemmingRules.entries) {
      final regex = RegExp(rule.key);
      if (regex.hasMatch(stem)) {
        stem = stem.replaceAll(regex, rule.value);
        break;
      }
    }
    return stem;
  }
}

// ========== –û–ü–ï–†–ê–¶–ò–ò –° –í–ï–ö–¢–û–†–ê–ú–ò ==========
class VectorOperations {
  /// –ù–∞—Ö–æ–¥–∏—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –¥–≤—É—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ (—Ç–æ–ª—å–∫–æ –æ–±—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã)
  static Map<int, int> findCommonVector(Map<int, int> vec1, Map<int, int> vec2) {
    final common = <int, int>{};
    for (final entry in vec1.entries) {
      if (vec2.containsKey(entry.key)) {
        common[entry.key] = min(entry.value, vec2[entry.key]!);
      }
    }
    return common;
  }
  
  /// –°–∞–º–æ–ø—Ä–æ–µ–∫—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞: —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ—Ç –≤—Å–µ —Å–ª–æ–≤–∞ –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä–∞ –∏ –Ω–∞—Ö–æ–¥–∏—Ç –æ–±—â–µ–µ
  static Map<int, int> selfProjection(Map<int, int> vector, Map<int, Word> allWords) {
  if (vector.isEmpty) return {};
  
  final expandedVectors = <Map<int, int>>[];
  for (final wordId in vector.keys) {
    final word = allWords[wordId];
    if (word != null && word.ratings.isNotEmpty) {
      expandedVectors.add(word.ratings);
    }
  }
  
  if (expandedVectors.isEmpty) return vector;
  
  // –°—á–∏—Ç–∞–µ–º —á–∞—Å—Ç–æ—Ç—É –≤—Å—Ç—Ä–µ—á–∞–µ–º–æ—Å—Ç–∏ –∏ —Å—É–º–º—É –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞
  final indexFrequency = <int, int>{};
  final indexSum = <int, int>{};
  
  for (final vec in expandedVectors) {
    for (final entry in vec.entries) {
      final index = entry.key;
      final value = entry.value;
      
      indexFrequency[index] = (indexFrequency[index] ?? 0) + 1;
      indexSum[index] = (indexSum[index] ?? 0) + value;
    }
  }
  
  // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∏–Ω–¥–µ–∫—Å—ã, –≤—Å—Ç—Ä–µ—á–∞—é—â–∏–µ—Å—è –∫–∞–∫ –º–∏–Ω–∏–º—É–º 13 —Ä–∞–∑
  final commonVec = <int, int>{};
  for (final index in indexFrequency.keys) {
    if (indexFrequency[index]! >= 13) {
      commonVec[index] = indexSum[index]!;
    }
  }
  
  return commonVec;
}
  
  /// –ü–æ–∏—Å–∫ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —á–µ—Ä—Ç: —Å–ª–æ–≤–∞ —Å –Ω–∏–∑–∫–∏–º allRating –Ω–æ –≤—ã—Å–æ–∫–∏–º ratings[contextWordId]
  static List<int> findUniqueFeatures(
    Map<int, int> vector,
    Map<int, Word> allWords,
    int limit,
  ) {
    final scores = <int, double>{};
    
    for (final entry in vector.entries) {
      final word = allWords[entry.key];
      if (word == null) continue;
      
      final avgConnectionStrength = entry.value / (word.allRating + 1);
      final uniquenessScore = avgConnectionStrength * 1000000 / (word.allRating + 1);
      scores[entry.key] = uniquenessScore;
    }
    
    final sortedEntries = scores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedEntries.take(limit).map((e) => e.key).toList();
  }

  /// –í—ã—á–∏—Å–ª—è–µ—Ç —Ä–∞–∑–Ω–æ—Å—Ç—å –≤–µ–∫—Ç–æ—Ä–æ–≤ (–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ä–∞–∑–ª–∏—á–∏–µ)
  static double vectorQualityDifference(Map<int, int> vec1, Map<int, int> vec2) {
    double difference = 0.0;
    final allKeys = {...vec1.keys, ...vec2.keys};
    
    for (final key in allKeys) {
      final val1 = vec1[key] ?? 0;
      final val2 = vec2[key] ?? 0;
      difference += (val1 - val2).abs().toDouble();
    }
    
    return difference;
  }
  
  /// –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–≤—è–∑–µ–π –∏ –ø–µ—Ä–µ—Å—á–µ—Ç –≤–µ—Å–æ–≤
  static void optimizeNeuralConnectionsRebuildWeights(Map<int, Word> words) async {
    for (final word in words.values) {
      final projectedVector = selfProjection(word.ratings, words);
      
      for (final entry in projectedVector.entries) {
        final otherWord = words[entry.key];
        if (otherWord == null) continue;
        
        final rating1 = word.ratings[entry.key];
        final rating2 = otherWord.ratings[word.id];
        
        if (rating1 == null || rating2 == null) continue;
        
        final normalizedRating1 = word.allRating > 0 ? rating1 / word.allRating : 0;
        final normalizedRating2 = otherWord.allRating > 0 ? rating2 / otherWord.allRating : 0;
        
        final multiplier = 1.0 + ((normalizedRating1 + normalizedRating2) / 2).clamp(0.999, 1.001);
        
        word.ratings[entry.key] = (entry.value * multiplier).round();
        otherWord.ratings[word.id] = (rating2 * multiplier).round();
      }
      
      word.allRating = word.ratings.values.fold(0, (a, b) => a + b);
    }
  }
}

// ========== –ö–õ–ê–°–°–´ –î–ê–ù–ù–´–• ==========


class Word {
  final int id;
  Map<int, int> ratings;
  int allRating;
  double x, y, z;
  Set<int> sameWords;
  dynamic? embedding; // ‚Üê –ò–ó–ú–ï–ù–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£

  Word({
    required this.id,
    required this.ratings,
    required this.allRating,
    required this.x,
    required this.y,
    required this.z,
    Set<int>? sameWords,
    this.embedding, // ‚Üê –ò –î–û–ë–ê–í–ò–¢–¨ –≠–¢–û–¢ –ü–ê–†–ê–ú–ï–¢–†
  }) : sameWords = sameWords ?? <int>{};

  double get fontSize {
    if (allRating < 1000) return 12.0;
    if (allRating > 200000) return 18.0;
    return 12.0 + (allRating / 30000);
  }
  
 Map<String, dynamic> toJson() => {
    'id': id,
    'ratings': ratings.map((k, v) => MapEntry(k.toString(), v)),
    'allRating': allRating,
    'x': x,
    'y': y,
    'z': z,
    'sameWords': sameWords.toList(),
    'embedding': embedding?.toJson(), // ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
    'embeddingType': embedding is CompressedEmbedding ? 'compressed' : 'normal', // ‚Üê –ò –≠–¢–£
  };
    factory Word.fromJson(Map<String, dynamic> json) {
    dynamic embedding;
    if (json['embedding'] != null) {
      if (json['embeddingType'] == 'compressed') {
        embedding = CompressedEmbedding.fromJson(json['embedding']);
      } else {
        embedding = SemanticEmbedding.fromJson(json['embedding']);
      }
    }

    return Word(
      id: json['id'],
       ratings: (json['ratings'] as Map).map((k, v) => MapEntry(int.parse(k), v as int)),
      allRating: json['allRating'] ?? 0,
      x: (json['x'] ?? 0).toDouble(),
      y: (json['y'] ?? 0).toDouble(),
      z: (json['z'] ?? 0).toDouble(),
      sameWords: Set<int>.from(json['sameWords'] ?? []),
      embedding: embedding, // ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–û–¢ –ü–ê–†–ê–ú–ï–¢–†
    );
  }
}

class Fragment {
  final int id;
  final String text;
  List<int> wordIds;
  int? packageId;
  SemanticAnalysisResult semanticType;
  dynamic embedding; // ‚Üê –£–±—Ä–∞—Ç—å ? –ø–æ—Å–ª–µ dynamic

  Fragment({
    required this.id,
    required this.text,
    required this.wordIds,
    this.packageId,
    SemanticAnalysisResult? semanticType,
    this.embedding,
  }) : semanticType = semanticType ?? (text.length < 55 
         ? SemanticAnalyzer1.analyze(text) 
         : SemanticAnalyzer1.analyze(text.substring(0, 55)));


  
  
  
  List<int> get keywords {
    final wordCounts = <int, int>{};
    for (final wordId in wordIds) {
      wordCounts[wordId] = (wordCounts[wordId] ?? 0) + 1;
    }
    
    final sortedEntries = wordCounts.entries.toList();
    sortedEntries.sort((a, b) => b.value.compareTo(a.value));
    
    return sortedEntries
        .take(5)
        .map((e) => e.key)
        .toList();
  }
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'text': text,
    'wordIds': wordIds,
    'packageId': packageId,
    'semanticType': semanticType,
    'embedding': embedding?.toJson(), // ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
    'embeddingType': embedding is CompressedEmbedding ? 'compressed' : 'normal', // ‚Üê –ò –≠–¢–£
  };

  
  factory Fragment.fromJson(Map<String, dynamic> json) {
    dynamic embedding;
    if (json['embedding'] != null) {
      if (json['embeddingType'] == 'compressed') {
        embedding = CompressedEmbedding.fromJson(json['embedding']);
      } else {
        embedding = SemanticEmbedding.fromJson(json['embedding']);
      }
    }

    return Fragment(
      id: json['id'],
      text: json['text'],
      wordIds: List<int>.from(json['wordIds'] ?? []),
      packageId: json['packageId'],
      semanticType: json['semanticType'],
      embedding: embedding, // ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–û–¢ –ü–ê–†–ê–ú–ï–¢–†
    );
  }
}

enum PackageStatus { through, permanent, done }

class Package {
  final int id;
  List<int> signature;
 
  List<int> keywords;
  PackageStatus status;
  List<int> fragmentLinks;
  List<int> neuronLinks;
    Map<int, int> signatureRatings;
  Package({

    required this.id,
    required this.signature,
    List<int>? keywords,
    required this.status,
    List<int>? fragmentLinks,
    List<int>? neuronLinks,
      Map<int, int>? signatureRatings,
  }) : 
      signatureRatings = signatureRatings ?? {},
    keywords = keywords ?? List.from(signature),
    fragmentLinks = fragmentLinks ?? [],
    neuronLinks = neuronLinks ?? [];
  
  Map<String, dynamic> toJson() => {
    'id': id, 'signature': signature, 'keywords': keywords,
    'status': status.index, 'fragment_links': fragmentLinks, 'neuron_links': neuronLinks,
  };
  
  factory Package.fromJson(Map<String, dynamic> json) => Package(
    id: json['id'],
    signature: List<int>.from(json['signature']),
    keywords: List<int>.from(json['keywords']),
    status: PackageStatus.values[json['status']],
    fragmentLinks: List<int>.from(json['fragment_links']),
    neuronLinks: List<int>.from(json['neuron_links']),
  );
}



class Neuron {
  OptimizedNeuralNetwork network;
  final int id;
  final int personalSynapseId;
  final String? sourceUrl;
  final String? pageTitle;
  String? fullPageContent;
  List<int> fragmentLinks;
  List<int> signature;
  List<int> keywords;
  List<int> packageLinks;
  Map<int, int> neuronRatings;
  int signature_allRating;
  Map<int, int> signatureRatings;
  double x;
  double y;
  double z;
  double screenX = 0;
  int allRating;
  double screenY = 0;
  
  // –ù–æ–≤–æ–µ –ø–æ–ª–µ: —ç–º–±–µ–¥–¥–∏–Ω–≥
 dynamic embedding;
  
  Neuron({
    required this.network,
    required this.id,
    required this.personalSynapseId,
    this.sourceUrl,
    this.pageTitle,
    this.fullPageContent,
    List<int>? fragmentLinks,
    List<int>? signature,
    List<int>? keywords,
    List<int>? packageLinks,
    Map<int, int>? neuronRatings,
    Map<int, int>? signatureRatings,
    int? signature_allRating,
    double? x,
    double? y,
    int? allRating,
    double? z,
    this.embedding, // –ù–æ–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
  }) : 
    
    fragmentLinks = fragmentLinks ?? [],
    signature = signature ?? [],
    keywords = keywords ?? [],
    packageLinks = packageLinks ?? [],
    signature_allRating = signature_allRating ?? 0,
    neuronRatings = neuronRatings ?? {},
    allRating = allRating ?? 0,
    signatureRatings = signatureRatings ?? {},
    x = x ?? 0.0,
    y = y ?? 0.0,
    z = z ?? 0.0;

  
  void updateSignature(List<int> wordIds,OptimizedNeuralNetwork network) {
    final wordCounts = <int, int>{};
    for (final id in wordIds) {
      wordCounts[id] = (wordCounts[id] ?? 0) + 1;
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º signature ratings
    for (final entry in wordCounts.entries) {
      signatureRatings[entry.key] = (signatureRatings[entry.key] ?? 0) + entry.value;
      signature_allRating +=entry.value;
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º signature
    final sortedSignature = signatureRatings.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    signature = sortedSignature.take(50).map((e) => e.key).toList();
    
    // –§–æ—Ä–º–∏—Ä—É–µ–º keywords
    final top20 = sortedSignature.take(20).map((e) => e.key).toList();
    
    // –î–ª—è bottom 10 –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –∏–∑ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è 30 —Å–ª–æ–≤ (–ø–æ–∑–∏—Ü–∏–∏ 20-49)
    final remainingWords = sortedSignature.skip(20).take(30).map((e) => e.key).toList();
    final sortedByLowRating = remainingWords.toList()
      ..sort((a, b) {
        final ratingA = network.words[a]?.allRating ?? 0;
        final ratingB = network.words[b]?.allRating ?? 0;
        return ratingA.compareTo(ratingB);
      });
    
    final bottom10 = sortedByLowRating.take(10).toList();
    
    // –û–±—ä–µ–¥–∏–Ω—è–µ–º - –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –ø–æ–ª—É—á–∏–º 30 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    keywords = [...top20, ...bottom10];
  }
  
  /// Express: –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–∏–≥–Ω–∞—Ç—É—Ä—É –≤ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –Ω–µ–π—Ä–æ–Ω—ã –∏ –ø–æ–ª—É—á–∞–µ—Ç —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã
  Future<Package> express(
    
    Map<int, int>? customVector
  ) async {
    Map<int, int> expressVector;
    
    if (customVector != null) {
      final superVector = _computeSuperVector(network);
      final projectedCustom = VectorOperations.selfProjection(customVector, network.words);
      expressVector = _averageVectors(superVector, projectedCustom);
    } else {
      expressVector = _computeSuperVector(network);
    }
    
    final allFragments = <int>[];
    
    for (final synapseId in network.synapses.keys) {
      final synapse = network.synapses[synapseId];
      if (synapse == null) continue;
      
      for (final neuronId in synapse.neuronLinks) {
        if (neuronId == id) continue;
        
        final targetNeuron = network.neurons[neuronId];
        if (targetNeuron == null) continue;
        
        final similarity = _calculateSimilarity(signatureRatings, targetNeuron.signatureRatings);
        if (similarity < 0.1) continue;
        
        final relevantFragments = _getRelevantFragments(
          targetNeuron,
          expressVector,
          network,
        );
        
        allFragments.addAll(relevantFragments);
        
        neuronRatings[neuronId] = (neuronRatings[neuronId] ?? 0) + (similarity * 100).round();
        targetNeuron.neuronRatings[id] = (targetNeuron.neuronRatings[id] ?? 0) + (similarity * 100).round();
        allRating+=(similarity * 100).round();
        targetNeuron.allRating+=(similarity * 100).round();
      }
    }
    
    final sortedEntries = expressVector.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    final keywords = sortedEntries.take(10).map((e) => e.key).toList();
    
    final pkg = Package(
      id: network.nextPackageId++,
      signature: expressVector.keys.toList(),
      keywords: keywords,
      status: PackageStatus.permanent,
      fragmentLinks: allFragments,
      neuronLinks: [id],
    );
    
    network.packages[pkg.id] = pkg;
    packageLinks.add(pkg.id);
    
    return pkg;
  }
  
  Map<int, int> _computeSuperVector(OptimizedNeuralNetwork network) {
    final superVector = <int, int>{};
    for (final fragId in fragmentLinks) {
      final frag = network.fragments[fragId];
      if (frag == null) continue;
      
      for (final wordId in frag.wordIds) {
        final word = network.words[wordId];
        if (word != null) {
          for (final entry in word.ratings.entries) {
            superVector[entry.key] = (superVector[entry.key] ?? 0) + entry.value;
          }
        }
      }
    }
    return VectorOperations.selfProjection(superVector, network.words);
  }
  
  Map<int, int> _averageVectors(Map<int, int> vec1, Map<int, int> vec2) {
    final avg = <int, int>{};
    final allKeys = {...vec1.keys, ...vec2.keys};
    
    for (final key in allKeys) {
      final val1 = vec1[key] ?? 0;
      final val2 = vec2[key] ?? 0;
      avg[key] = ((val1 + val2) / 2).round();
    }
    
    return avg;
  }
  
  List<int> _getRelevantFragments(
    Neuron targetNeuron,
    Map<int, int> expressVector,
    OptimizedNeuralNetwork network,
  ) {
    final fragmentScores = <int, double>{};
    
    for (final fragId in targetNeuron.fragmentLinks) {
      final frag = network.fragments[fragId];
      if (frag == null) continue;
      
      double score = 0.0;
      for (final wordId in frag.wordIds) {
        if (expressVector.containsKey(wordId)) {
          score += expressVector[wordId]!.toDouble();
        }
      }
      
      if (score > 0) {
        fragmentScores[fragId] = score;
      }
    }
    
    return (fragmentScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value)))
      .take(20)
      .map((e) => e.key)
      .toList();
  }
  
double _calculateSimilarity(Map<int, int> sig1, Map<int, int> sig2) {
  if (sig1.isEmpty || sig2.isEmpty) return 0.0;
  
  // –ù–∞—Ö–æ–¥–∏–º –æ–±—â–∏–µ —Å–ª–æ–≤–∞
  final commonWords = sig1.keys.toSet().intersection(sig2.keys.toSet());
  if (commonWords.isEmpty) return 0.0;
  
  // –í—ã—á–∏—Å–ª—è–µ–º —Å—É–º–º—ã –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏
  final sum1 = sig1.values.reduce((a, b) => a + b).toDouble();
  final sum2 = sig2.values.reduce((a, b) => a + b).toDouble();
  
  double totalSimilarity = 0.0;
  int count = 0;
  
  for (final wordId in commonWords) {
    final value1 = sig1[wordId]!.toDouble();
    final value2 = sig2[wordId]!.toDouble();
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
    final normalized1 = value1 / sum1;
    final normalized2 = value2 / sum2;
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤
    final vectorRatio = normalized1 / ((normalized2 / ((value1 + value2) / 2)));
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∫ –æ–±—â–µ–π —Å—Ö–æ–∂–µ—Å—Ç–∏
    totalSimilarity += vectorRatio;
    count++;
  }
  
  return count > 0 ? totalSimilarity / count : 0.0;
}
  
  double calculateSimilarityTo(Neuron other, Map<int, Word> words, Map<int, String> wordLibrary) {
    if (signature.isEmpty || other.signature.isEmpty) return 0.0;
    
    final set1 = signature.toSet();
    final set2 = other.signature.toSet();
    final intersection = set1.intersection(set2).length;
    final union = set1.union(set2).length;
    
    double semanticSimilarity = union > 0 ? intersection / union : 0.0;
    
    double connectionStrength = 0.0;
    int commonWordsCount = 0;
    
    final intersectionSet = set1.intersection(set2);
    for (final wordId in intersectionSet) {
      final word = words[wordId];
      if (word != null) {
        final rating1 = word.ratings[other.id] ?? 0;
        final rating2 = word.ratings[id] ?? 0;
        connectionStrength += (rating1 + rating2) / 2.0;
        commonWordsCount++;
      }
    }
    
    if (commonWordsCount > 0) {
      connectionStrength /= commonWordsCount;
      semanticSimilarity *= (1.0 + connectionStrength / 10000.0);
    }
    
    return semanticSimilarity.clamp(0.0, 1.0);
  }
  
 
  // –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤ JSON
  Map<String, dynamic> toJson() => {
    'id': id,
    'personal_synapse_id': personalSynapseId,
    'source_url': sourceUrl,
    'page_title': pageTitle,
    'full_page_content': fullPageContent,
    'fragment_links': fragmentLinks,
    'signature': signature,
    'keywords': keywords,
    'package_links': packageLinks,
    'neuron_ratings': neuronRatings.map((k, v) => MapEntry(k.toString(), v)),
    'signature_allRating': signature_allRating,
    'signatureRatings': signatureRatings.map((k, v) => MapEntry(k.toString(), v)),
    'x': x,
    'y': y,
    'z': z,
    'allRating': allRating,
    'embedding': embedding?.toJson(),
    'embeddingType': embedding is CompressedEmbedding ? 'compressed' : 'normal',
  };
  factory Neuron.fromJson(Map<String, dynamic> json, OptimizedNeuralNetwork network) {
    dynamic embedding;
    if (json['embedding'] != null) {
      if (json['embeddingType'] == 'compressed') {
        embedding = CompressedEmbedding.fromJson(json['embedding']);
      } else {
        embedding = SemanticEmbedding.fromJson(json['embedding']);
      }
    }

    return Neuron(
      network: network,
      id: json['id'],
      personalSynapseId: json['personal_synapse_id'],
      sourceUrl: json['source_url'],
      pageTitle: json['page_title'],
      fullPageContent: json['full_page_content'],
      fragmentLinks: List<int>.from(json['fragment_links'] ?? []),
      signature: List<int>.from(json['signature'] ?? []),
      keywords: List<int>.from(json['keywords'] ?? []),
      packageLinks: List<int>.from(json['package_links'] ?? []),
      neuronRatings: (json['neuron_ratings'] as Map?)?.map((k, v) => MapEntry(int.parse(k), v as int)) ?? {},
      signature_allRating: json['signature_allRating'] ?? 0,
      signatureRatings: (json['signature_ratings'] as Map?)?.map((k, v) => MapEntry(int.parse(k), v as int)) ?? {},
      x: (json['x'] ?? 0).toDouble(),
      y: (json['y'] ?? 0).toDouble(),
      z: (json['z'] ?? 0).toDouble(),
      allRating: json['allRating'] ?? 0,
      embedding: embedding,
    );
  }
}


class Synapse {
  final int id;
  List<int> synapseLinks;
  List<int> neuronLinks;
  
  Synapse({
    required this.id,
    List<int>? synapseLinks,
    List<int>? neuronLinks,
  }) : 
    synapseLinks = synapseLinks ?? [],
    neuronLinks = neuronLinks ?? [];
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'synapse_links': synapseLinks,
    'neuron_links': neuronLinks,
  };
  
  factory Synapse.fromJson(Map<String, dynamic> json) => Synapse(
    id: json['id'],
    synapseLinks: List<int>.from(json['synapse_links'] ?? []),
    neuronLinks: List<int>.from(json['neuron_links'] ?? []),
  );
}

// ========== –ö–õ–ê–°–¢–ï–† –ù–ï–ô–†–û–ù–û–í ==========
class NeuronCluster {
  final String id;
  final String type;
  final String title;
  final String? domain;
  final String? path;
  final String? keyword;
  List<int> neuronIds;
  Map<int,int> signature;
  List<int> keywords;
  double x, y, z;
  bool isExpanded;
  bool isVisible;
  List<String> childClusterIds;
  String? parentClusterId;
  int depth;
  double size;
  DateTime lastUpdated;
  
  double animationProgress;
  double targetX, targetY, targetZ;
  double sourceX, sourceY, sourceZ;
  double glowIntensity;
  bool isDragging;
  
  NeuronCluster({
    required this.id,
    required this.type,
    required this.title,
    this.domain,
    this.path,
    this.keyword,
    List<int>? neuronIds,
    Map<int,int>? signature,
    List<int>? keywords,
    double? x,
    double? y,
    double? z,
    bool? isExpanded,
    bool? isVisible,
    List<String>? childClusterIds,
    this.parentClusterId,
    int? depth,
    double? size,
  }) : 
    neuronIds = neuronIds ?? [],
    signature = signature ?? {},
    keywords = keywords ?? [],
    x = x ?? 0.0,
    y = y ?? 0.0,
    z = z ?? 0.0,
    isExpanded = isExpanded ?? false,
    isVisible = isVisible ?? true,
    childClusterIds = childClusterIds ?? [],
    depth = depth ?? 0,
    size = size ?? 1.0,
    lastUpdated = DateTime.now(),
    animationProgress = 1.0,
    targetX = x ?? 0.0,
    targetY = y ?? 0.0,
    targetZ = z ?? 0.0,
    sourceX = x ?? 0.0,
    sourceY = y ?? 0.0,
    sourceZ = z ?? 0.0,
    glowIntensity = 0.0,
    isDragging = false;
  double hoverIntensity = 0.0;
  

  void startHover() {
    hoverIntensity = 0.2; // 20% –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
  }

  void endHover() {
    // Hover –±—É–¥–µ—Ç –ø–ª–∞–≤–Ω–æ –∏—Å—á–µ–∑–∞—Ç—å —á–µ—Ä–µ–∑ updateAnimation
  }
  void updatePosition(double newX, double newY, double newZ) {
    sourceX = x;
    sourceY = y;
    sourceZ = z;
    targetX = newX;
    targetY = newY;
    targetZ = newZ;
    animationProgress = 0.0;
  }

  void updateAnimation(double deltaTime) {
    if (animationProgress < 1.0) {
      animationProgress = (animationProgress + deltaTime * 8.0).clamp(0.0, 1.0);
      final ease = _easeOutCubic(animationProgress);
      x = sourceX + (targetX - sourceX) * ease;
      y = sourceY + (targetY - sourceY) * ease;
      z = sourceZ + (targetZ - sourceZ) * ease;
    }
    
    // –ê–Ω–∏–º–∞—Ü–∏—è glow —ç—Ñ—Ñ–µ–∫—Ç–∞
    if (glowIntensity > 0.0) {
      glowIntensity = (glowIntensity - deltaTime * 2.0).clamp(0.0, 1.0);
    }
    
    // –ê–Ω–∏–º–∞—Ü–∏—è hover —ç—Ñ—Ñ–µ–∫—Ç–∞
    if (hoverIntensity > 0.0) {
      hoverIntensity = (hoverIntensity - deltaTime * 3.0).clamp(0.0, 0.2);
    }
  }

  double _easeOutCubic(double t) {
    return 1 - pow(1 - t, 3).toDouble();
  }

  

void updateSignature( OptimizedNeuralNetwork network) {
  final wordCounts = <int, int>{};

  List<int> wordIds = [];
  if (neuronIds!.isEmpty==false){
    for (final neuronId in neuronIds){
    final neuron = network.neurons[neuronId];
    if (neuron!=null) {
    for (final wordId in neuron!.keywords){
        wordIds.add(wordId);
    }}
    }
    
  }else{
    if (childClusterIds.isEmpty!=true){
      for (final clusterId in childClusterIds){
        final cluster = network.clusters[clusterId];
        if (cluster!=null){
            final sortedSignature = cluster!.signature.entries.toList()
              ..sort((a, b) => b.value.compareTo(a.value));
            
            for (final entry in sortedSignature){
              signature[entry.key]= (signature[entry.key]??0) + entry.value.toInt();  
            }

        }
      }


    }
    return;
  }
  for (final id in wordIds) {
    wordCounts[id] = (wordCounts[id] ?? 0) + 1;
  }
  for (final neuronId in neuronIds) {
    final neuron = network.neurons[neuronId];
    if (neuron != null) {
      for (final wordId in neuron.signatureRatings.keys) {
        wordCounts[wordId] = (neuron.signatureRatings[wordId] ?? 0) + 1;
      }
    }
  }
  // –û–±–Ω–æ–≤–ª—è–µ–º signature ratings
  for (final entry in wordCounts.entries) {
    signature[entry.key] = (signature[entry.key] ?? 0) + entry.value;
  }
  
  // –°–æ—Ä—Ç–∏—Ä—É–µ–º signature –ø–æ —É–±—ã–≤–∞–Ω–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
  final sortedSignature = signature.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));
  
  // –ë–µ—Ä–µ–º 20 —Å–∞–º—ã—Ö –≤—ã—Å–æ–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Å–∏–≥–Ω–∞—Ç—É—Ä—ã
  final top20 = sortedSignature
      .take(20)
      .map((e) => e.key)
      .toList();
  
  // –î–ª—è bottom 10 –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –∏–∑ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è 30 —Å–ª–æ–≤ (–ø–æ–∑–∏—Ü–∏–∏ 20-49)
  final remainingWords = sortedSignature.skip(20).map((e) => e.key).toList();
  final sortedByLowRating = remainingWords.toList()
    ..sort((a, b) {
      final ratingA = network.words[a]?.allRating ?? 0;
      final ratingB = network.words[b]?.allRating ?? 0;
      return ratingA.compareTo(ratingB);
    });
  
  final bottom10 = sortedByLowRating.take(10).toList();
  
  // –û–±—ä–µ–¥–∏–Ω—è–µ–º - –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –ø–æ–ª—É—á–∏–º 30 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
  keywords = [...top20, ...bottom10];
}
  
  void startGlow() {
    glowIntensity = 1.0;
  }

  void startDrag() {
    isDragging = true;
    glowIntensity = 0.8;
  }

  void endDrag() {
    isDragging = false;
    glowIntensity = 0.0;
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': type,
      'title': title,
      'domain': domain,
      'path': path,
      'keyword': keyword,
      'neuronIds': neuronIds,
      'signature': signature.map((k, v) => MapEntry(k.toString(), v)),
      'keywords': keywords,
      'x': x,
      'y': y,
      'z': z,
      'isExpanded': isExpanded,
      'isVisible': isVisible,
      'childClusterIds': childClusterIds,
      'parentClusterId': parentClusterId,
      'depth': depth,
      'size': size,
      'lastUpdated': lastUpdated.toIso8601String(),
    };
  }

  factory NeuronCluster.fromJson(Map<String, dynamic> json) {
    return NeuronCluster(
      id: json['id'],
      type: json['type'],
      title: json['title'],
      domain: json['domain'],
      path: json['path'],
      keyword: json['keyword'],
      neuronIds: List<int>.from(json['neuronIds'] ?? []),
      signature:   (json['signature_ratings'] as Map?)?.map((k, v) => MapEntry(int.parse(k), v as int)) ?? {},
      keywords: List<int>.from(json['keywords'] ?? []),
      x: (json['x'] ?? 0.0).toDouble(),
      y: (json['y'] ?? 0.0).toDouble(),
      z: (json['z'] ?? 0.0).toDouble(),
      isExpanded: json['isExpanded'] ?? false,
      isVisible: json['isVisible'] ?? true,
      childClusterIds: List<String>.from(json['childClusterIds'] ?? []),
      parentClusterId: json['parentClusterId'],
      depth: json['depth'] ?? 0,
      size: (json['size'] ?? 1.0).toDouble(),
    );
  }
}

// ========== –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –ù–ï–ô–†–û–°–ï–¢–¨ ==========
class OptimizedNeuralNetwork {
  final Map<int, String> wordLibrary = {};

  final Map<String, int> wordIndex = {};
  final Map<int, Word> words = {};
  final Map<int, Fragment> fragments = {};
  final Map<int, Neuron> neurons = {};
  final Map<int, Synapse> synapses = {};
  final Map<int, Package> packages = {};
  final Map<String, NeuronCluster> clusters = {};
  
  int nextWordId = 1;
  int nextFragmentId = 1;
  int nextNeuronId = 1;
  int nextSynapseId = 1;
  int nextPackageId = 1;
  
  final Random random = Random();
  
  static const int MAX_VECTOR_SIZE = 600;
  
  Map<int, int> currentSearchVector = {};
  List<int> currentSearchWords = [];
  
  final List<NavigationStep> navigationHistory = [];
  static const int maxHistorySteps = 10;
  
  Set<int> selectedWordIds = {};
  Set<int> selectedNeuronIds = {};
  Set<int> selectedFragmentIds = {};
  Set<String> expandedClusterIds = {};
  
  VisualizationMode visualizationMode = VisualizationMode.words;
  final List<String> clusterHistory = [];
  int historyIndex = -1;
  final Set<int> searchedNeurons = {};
  int currentSearchIndex = -1;
  
  bool _isAnimating = false;
  final Map<String, List<AnimationStage>> _animationQueue = {};
  
  final String clustersDataPath = 'qwa_ai_bd/neural_clusters_data_ai.json';
  
  // –ù–æ–≤—ã–µ –ø–æ–ª—è –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π –∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ–º
  double _cameraX = 0.0;
  double _cameraY = 0.0;
  double _cameraScale = 1.0;
  String? _draggedClusterId;
  Offset? _dragStartOffset;
  Offset? _clusterStartOffset;
  bool hasVisualChanges = false;
  OptimizedNeuralNetwork() {
    _initializeRootNeuron();
    //createTestClusters();
  }
  
  void _initializeRootNeuron() {
    final rootSynapse = Synapse(id: 0);
    synapses[0] = rootSynapse;
    
    final rootNeuron = Neuron(network: this, id: 0, personalSynapseId: 0);
    neurons[0] = rootNeuron;
    
    rootSynapse.neuronLinks.add(0);
  }


  void updateAnimations(double deltaTime) {
    hasVisualChanges = false;
    
    for (final cluster in clusters.values) {
      final oldX = cluster.x;
      final oldY = cluster.y;
      final oldZ = cluster.z;
      final oldGlow = cluster.glowIntensity;
      final oldHover = cluster.hoverIntensity;
      
      cluster.updateAnimation(deltaTime);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª–∏ –ª–∏ –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
      if (cluster.x != oldX || cluster.y != oldY || cluster.z != oldZ ||
          cluster.glowIntensity != oldGlow || cluster.hoverIntensity != oldHover) {
        hasVisualChanges = true;
      }
    }}

List<Neuron> searchNeuronsByKeywords(String query) {
    final keywords = _extractWords(query);
    if (keywords.isEmpty) return [];

    final neuronScores = <Neuron, double>{};

    for (final neuron in neurons.values) {
      if (neuron.id == 0) continue;

      double score = 0.0;
      for (final keyword in keywords) {
        final wordId = wordIndex[keyword];
        if (wordId != null && neuron.signature.contains(wordId)) {
          score += 1.0;
        }
      }

      if (score > 0) {
        final signatureStrength = neuron.signature
            .where((wordId) => keywords.any((k) => wordIndex[k] == wordId))
            .map((wordId) => words[wordId]?.allRating ?? 0)
            .fold(0, (a, b) => a + b) / 1000.0;

        final totalScore = score * (1 + signatureStrength);
        neuronScores[neuron] = totalScore;
      }
    }

    final sortedEntries = neuronScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedEntries.map((e) => e.key).toList();
  }
  Future<void> createTestClusters() async {
  print('üõ†Ô∏è Creating test clusters...');
  return;
  // –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–ª–∞—Å—Ç–µ—Ä—ã
  clusters.clear();
  
  // –°–æ–∑–¥–∞–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π –∫–ª–∞—Å—Ç–µ—Ä
  clusters['root'] = NeuronCluster(
    id: 'root',
    type: 'root',
    title: 'Root',
    x: 0.0,
    y: 300.0, // –ü–æ–º–µ—â–∞–µ–º –≤–Ω–∏–∑—É
    z: 0.0,
    depth: 0,
    size: 2.0,
    isExpanded: false,
    isVisible: true,
  );

  // –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–æ—á–µ—Ä–Ω–∏—Ö –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
  final testDomains = ['example.com', 'test.org', 'demo.net'];
  for (int i = 0; i < testDomains.length; i++) {
    final domain = testDomains[i];
    final clusterId = 'domain_$domain';
    
    clusters[clusterId] = NeuronCluster(
      id: clusterId,
      type: 'domain',
      title: domain,
      domain: domain,
      x: 0.0,
      y: 300.0 - (i * 100), // –†–∞—Å–ø–æ–ª–∞–≥–∞–µ–º –≤—ã—à–µ —Ä–æ–¥–∏—Ç–µ–ª—è
      z: 0.0, // –ù–µ–º–Ω–æ–≥–æ —Ä–∞–∑–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ Z
      depth: 1,
      size: 1.5,
      isExpanded: false,
      isVisible: false, // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã—Ç—ã
    );
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ –¥–æ—á–µ—Ä–Ω–∏–µ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞
    clusters['root']!.childClusterIds.add(clusterId);
    clusters[clusterId]!.parentClusterId = 'root';
  }

  print('‚úÖ Test clusters created: ${clusters.length} clusters');
  setState(() {});
}
  /// –ü–æ–∏—Å–∫ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –ø–æ —Ç–µ–∫—Å—Ç—É
  List<Fragment> searchFragments(String query) {
    final keywords = query.toLowerCase().split(' ').where((w) => w.length > 2).toList();
    if (keywords.isEmpty) return [];

    final fragmentScores = <Fragment, int>{};

    for (final fragment in fragments.values) {
      int score = 0;
      final text = fragment.text.toLowerCase();

      for (final keyword in keywords) {
        if (text.contains(keyword)) {
          score += keyword.length;
        }
      }

      if (score > 0) {
        fragmentScores[fragment] = score;
      }
    }

    final sortedEntries = fragmentScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedEntries.map((e) => e.key).toList();
  }

  // ========== –í–´–ë–û–† –≠–õ–ï–ú–ï–ù–¢–û–í ==========
  void selectWord(int wordId, {bool withShift = false}) {
    if (withShift) {
      if (selectedWordIds.contains(wordId)) {
        selectedWordIds.remove(wordId);
      } else {
        selectedWordIds.add(wordId);
      }
    } else {
      selectedWordIds = {wordId};
    }
    selectedNeuronIds.clear();
    selectedFragmentIds.clear();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Å–ª–æ–≤
    _updateFragmentsFromSelectedWords();
    
    addNavigationStep(NavigationStep(type: 'word', id: wordId));
  }
  
  void selectNeuron(int neuronId, {bool withShift = false}) {
    if (withShift) {
      if (selectedNeuronIds.contains(neuronId)) {
        selectedNeuronIds.remove(neuronId);
      } else {
        selectedNeuronIds.add(neuronId);
      }
    } else {
      selectedNeuronIds = {neuronId};
    }
    selectedWordIds.clear();
    selectedFragmentIds.clear();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ —Å–ª–æ–≤–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –Ω–µ–π—Ä–æ–Ω–∞
    //_updateWordsFromSelectedNeuron();
    
    addNavigationStep(NavigationStep(type: 'neuron', id: neuronId));
  }
  
  void selectFragment(int fragmentId, {bool withShift = false}) {
    if (withShift) {
      if (selectedFragmentIds.contains(fragmentId)) {
        selectedFragmentIds.remove(fragmentId);
      } else {
        selectedFragmentIds.add(fragmentId);
      }
    } else {
      selectedFragmentIds = {fragmentId};
    }
    selectedWordIds.clear();
    selectedNeuronIds.clear();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ —Å–ª–æ–≤–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
    _updateWordsFromSelectedFragment();
    
    addNavigationStep(NavigationStep(type: 'fragment', id: fragmentId));
  }
  
  void clearSelection() {
    selectedWordIds.clear();
    selectedNeuronIds.clear();
    selectedFragmentIds.clear();
  }
 // ========== –ò–°–¢–û–†–ò–Ø –ù–ê–í–ò–ì–ê–¶–ò–ò ==========
  void addNavigationStep(NavigationStep step) {
    navigationHistory.add(step);
    if (navigationHistory.length > maxHistorySteps) {
      navigationHistory.removeAt(0);
    }
  }
  
  void navigateToStep(int index) {
    if (index < 0 || index >= navigationHistory.length) return;
    
    final step = navigationHistory[index];
    switch (step.type) {
      case 'word':
        selectedWordIds = {step.id!};
        selectedNeuronIds.clear();
        selectedFragmentIds.clear();
        break;
      case 'neuron':
        selectedNeuronIds = {step.id!};
        selectedWordIds.clear();
        selectedFragmentIds.clear();
        break;
      case 'fragment':
        selectedFragmentIds = {step.id!};
        selectedWordIds.clear();
        selectedNeuronIds.clear();
        break;
      case 'search':
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
        currentSearchVector = _buildSearchVector(step.query!);
        break;
    }
  }
  
  /// –ü–æ–∏—Å–∫ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –ø–æ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º —Å–ª–æ–≤–∞–º
  List<Fragment> findFragmentsWithAllWords(Set<int> wordIds) {
    final result = <Fragment>[];
    
    for (final fragment in fragments.values) {
      final fragmentWordSet = fragment.wordIds.toSet();
      if (wordIds.every((wordId) => fragmentWordSet.contains(wordId))) {
        result.add(fragment);
      }
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏ (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ö–æ–∂–¥–µ–Ω–∏–π –∏—Å–∫–æ–º—ã—Ö —Å–ª–æ–≤)
    result.sort((a, b) {
      final countA = a.wordIds.where((id) => wordIds.contains(id)).length;
      final countB = b.wordIds.where((id) => wordIds.contains(id)).length;
      return countB.compareTo(countA);
    });
    
    return result;
  }

   /// –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–º–ø–æ–∑–∏—Ç–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –¥–ª—è –Ω–∞–±–æ—Ä–∞ —Å–ª–æ–≤
  Map<int, int> getCompositeVector(Set<int> wordIds) {
    final compositeVector = <int, int>{};
    
    for (final wordId in wordIds) {
      final word = words[wordId];
      if (word != null) {
        for (final entry in word.ratings.entries) {
          compositeVector[entry.key] = (compositeVector[entry.key] ?? 0) + entry.value;
        }
      }
    }
    
    return VectorOperations.selfProjection(compositeVector, words);
  }

  /// –°–ª–∏—è–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤ –≤ –æ–¥–∏–Ω
  Future<Neuron> mergeNeurons(Set<int> neuronIds) async {
    final newNeuronId = nextNeuronId++;
    final newSynapseId = nextSynapseId++;
    
    final newSynapse = Synapse(id: newSynapseId);
    synapses[newSynapseId] = newSynapse;
    
    final allFragments = <int>[];
    final allPackages = <int>[];
    final neuronRatings = <int, int>{};
    String combinedTitle = '';
    
    for (final neuronId in neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      allFragments.addAll(neuron.fragmentLinks);
      allPackages.addAll(neuron.packageLinks);
      
      for (final entry in neuron.neuronRatings.entries) {
        neuronRatings[entry.key] = (neuronRatings[entry.key] ?? 0) + entry.value;
      }
      
      if (neuron.pageTitle != null) {
        combinedTitle += '${neuron.pageTitle} + ';
      }
    }
    
    final newNeuron = Neuron(
      network: this, 
      id: newNeuronId,
      personalSynapseId: newSynapseId,
      pageTitle: combinedTitle.isNotEmpty ? combinedTitle.substring(0, combinedTitle.length - 3) : 'Merged Neuron',
      fragmentLinks: allFragments,
      packageLinks: allPackages,
      neuronRatings: neuronRatings,
    );
    
    final allWordIds = <int>[];
    for (final fragId in allFragments) {
      final frag = fragments[fragId];
      if (frag != null) {
        allWordIds.addAll(frag.wordIds);
      }
    }
    newNeuron.updateSignature(allWordIds,this);
    
    neurons[newNeuronId] = newNeuron;
    newSynapse.neuronLinks.add(newNeuronId);
    
    for (final parentId in neuronIds) {
      newNeuron.neuronRatings[parentId] = 10000;
      final parent = neurons[parentId];
      if (parent != null) {
        parent.neuronRatings[newNeuronId] = 10000;
      }
    }
    
    return newNeuron;
  }
  
  /// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–≤—è–∑–µ–π –º–µ–∂–¥—É –≤—ã–±—Ä–∞–Ω–Ω—ã–º–∏ –Ω–µ–π—Ä–æ–Ω–∞–º–∏
  Future<void> processNeuronConnections(Set<int> neuronIds) async {
    final neuronsList = neuronIds
        .map((id) => neurons[id])
        .where((n) => n != null)
        .cast<Neuron>()
        .toList();
    
    for (int i = 0; i < neuronsList.length; i++) {
      final neuron1 = neuronsList[i];
      
      final superVec1 = <int, int>{};
      for (final fragId in neuron1.fragmentLinks) {
        final frag = fragments[fragId];
        if (frag == null) continue;
        for (final wordId in frag.wordIds) {
          final word = words[wordId];
          if (word != null) {
            for (final entry in word.ratings.entries) {
              superVec1[entry.key] = (superVec1[entry.key] ?? 0) + entry.value;
            }
          }
        }
      }
      final commonVec1 = VectorOperations.selfProjection(superVec1, words);
      
      for (int j = i + 1; j < neuronsList.length; j++) {
        final neuron2 = neuronsList[j];
        
        final superVec2 = <int, int>{};
        for (final fragId in neuron2.fragmentLinks) {
          final frag = fragments[fragId];
          if (frag == null) continue;
          for (final wordId in frag.wordIds) {
            final word = words[wordId];
            if (word != null) {
              for (final entry in word.ratings.entries) {
                superVec2[entry.key] = (superVec2[entry.key] ?? 0) + entry.value;
              }
            }
          }
        }
        final commonVec2 = VectorOperations.selfProjection(superVec2, words);
        
        final difference = VectorOperations.vectorQualityDifference(commonVec1, commonVec2);
        final similarity = 1000000 / (difference + 1);
        final rating = similarity.round();
        
        neuron1.neuronRatings[neuron2.id] = (neuron1.neuronRatings[neuron2.id] ?? 0) + rating;
        neuron2.neuronRatings[neuron1.id] = (neuron2.neuronRatings[neuron1.id] ?? 0) + rating;
      }
    }
  }
  
  /// –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
  Future<void> copyNeuronsToClipboard(Set<int> neuronIds) async {
    final allText = StringBuffer();
    
    for (final neuronId in neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      if (neuron.pageTitle != null) {
        allText.writeln('=== ${neuron.pageTitle} ===');
      }
      
      for (final fragId in neuron.fragmentLinks) {
        final frag = fragments[fragId];
        if (frag != null) {
          allText.writeln(frag.text);
        }
      }
      allText.writeln();
    }
    
    await Clipboard.setData(ClipboardData(text: allText.toString()));
  }
  
  /// –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
  Future<void> copyFragmentsToClipboard(List<int> fragmentIds) async {
    final allText = StringBuffer();
    
    for (final fragId in fragmentIds) {
      final frag = fragments[fragId];
      if (frag != null) {
        allText.writeln(frag.text);
      }
    }
    
    await Clipboard.setData(ClipboardData(text: allText.toString()));
  }
  
  /// –°–æ–∑–¥–∞–Ω–∏–µ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–ª–æ–≤ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤
  Map<int, Word> createNeuronWordsVisualization(Set<int> neuronIds) {
    final wordScores = <int, double>{};
    
    for (final neuronId in neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      for (final fragId in neuron.fragmentLinks) {
        final frag = fragments[fragId];
        if (frag == null) continue;
        
        for (final wordId in frag.wordIds) {
          final word = words[wordId];
          if (word != null) {
            wordScores[wordId] = (wordScores[wordId] ?? 0.0) + word.allRating.toDouble();
          }
        }
      }
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –ø—Ä–æ–µ–∫—Ü–∏—é —Å–ª–æ–≤
    final projectedWords = <int, Word>{};
    for (final entry in wordScores.entries) {
      final originalWord = words[entry.key];
      if (originalWord != null) {
        final projectedWord = Word(
          id: originalWord.id,
          ratings: Map.from(originalWord.ratings),
          allRating: originalWord.allRating,
          x: originalWord.x,
          y: originalWord.y,
          z: originalWord.z,
          sameWords: Set.from(originalWord.sameWords),
        );
        projectedWords[entry.key] = projectedWord;
      }
    }
    
    return projectedWords;
  }

  
  void _updateWordsFromSelectedFragment() {
    if (selectedFragmentIds.isEmpty) return;
    
    final wordSet = <int>{};
    for (final fragmentId in selectedFragmentIds) {
      final fragment = fragments[fragmentId];
      if (fragment != null) {
        wordSet.addAll(fragment.wordIds);
      }
    }
    selectedWordIds = wordSet;
  }
  
  void _updateFragmentsFromSelectedWords() {
    if (selectedWordIds.isEmpty) return;
    
    final fragmentScores = <int, int>{};
    for (final fragment in fragments.values) {
      int score = 0;
      for (final wordId in fragment.wordIds) {
        if (selectedWordIds.contains(wordId)) {
          score++;
        }
      }
      if (score > 0) {
        fragmentScores[fragment.id] = score;
      }
    }
    
    final sortedFragments = fragmentScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    selectedFragmentIds = sortedFragments.take(10).map((e) => e.key).toSet();
  }

  
  // ========== –ü–û–ò–°–ö –ò –§–ò–õ–¨–¢–†–ê–¶–ò–Ø ==========
  Map<int, int> _buildSearchVector(String query) {
    final wordTexts = _extractWords(query);
    final promptWordIds = wordTexts
        .map((w) => wordIndex[w])
        .where((id) => id != null)
        .cast<int>()
        .toList();
    
    if (promptWordIds.isEmpty) return {};
    
    final superVector = <int, int>{};
    for (final wordId in promptWordIds) {
      final word = words[wordId];
      if (word != null) {
        for (final entry in word.ratings.entries) {
          superVector[entry.key] = (superVector[entry.key] ?? 0) + entry.value;
        }
      }
    }
    
    return VectorOperations.selfProjection(superVector, words);
  }
  // ========== –û–°–ù–û–í–ù–´–ï –ú–ï–¢–û–î–´ –ö–õ–ê–°–¢–ï–†–ò–ó–ê–¶–ò–ò ==========
  Future<void> updateClusters() async {
    print('üöÄ Starting advanced cluster update with ${neurons.length} neurons');
    
    await _loadClustersFromFile();
    
    if (!clusters.containsKey('root')) {
      clusters['root'] = NeuronCluster(
        id: 'root',
        type: 'root',
        title: 'Neural Network Root',
        x: 0.0,
        y: 0.0,
        z: 0.0,
        depth: 0,
        size: 2.0,
      );
    }
    await _createIntermediateClusters();
    await _createUrlDomainClusters();
    //await _createKeywordClusters();
    
    //_positionAllClusters();
    await _saveClustersToFile();

    await AppLogger.writeLog('‚úÖ Cluster update complete: ${clusters.length} clusters');
  }


  
// –ù–û–í–´–ô –ú–ï–¢–û–î: —Å–æ–∑–¥–∞–µ–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –∫–ª–∞—Å—Ç–µ—Ä—ã
Future<void> _createIntermediateClusters() async {
  print('üèóÔ∏è Creating intermediate clusters');
  
  // –°–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–∫–ª–∞—Å—Ç–µ—Ä –∫–∞–∫ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π
  if (!clusters.containsKey('internet')) {
    final internetCluster = NeuronCluster(
      id: 'internet',
      type: 'internet',
      title: 'Internet',
      depth: 1,
      size: 1.8,
    );
    clusters['internet'] = internetCluster;
    clusters['root']!.childClusterIds.add('internet');
    internetCluster.parentClusterId = 'root';
    print('‚ûï Created internet cluster');
  }
  
  // –°–æ–∑–¥–∞–µ–º –∫–ª–∞—Å—Ç–µ—Ä –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –∫–∞–∫ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π
  if (!clusters.containsKey('keyword_clusters')) {
    final keywordCluster = NeuronCluster(
      id: 'keyword_clusters',
      type: 'keyword_root',
      title: 'Keywords',
      depth: 1,
      size: 1.8,
    );
    clusters['keyword_clusters'] = keywordCluster;
    clusters['root']!.childClusterIds.add('keyword_clusters');
    keywordCluster.parentClusterId = 'root';
    print('‚ûï Created keyword_clusters container');
  }
}

Future<void> _createUrlDomainClusters() async {
  final domainNeuronsMap = <String, List<int>>{};
  final categoryNeuronsMap = <String, Map<String, List<int>>>{}; // –∫–∞—Ç–µ–≥–æ—Ä–∏—è -> –¥–æ–º–µ–Ω -> –Ω–µ–π—Ä–æ–Ω—ã
  final pathNeuronsMap = <String, Map<String, Map<String, List<int>>>>{}; // –∫–∞—Ç–µ–≥–æ—Ä–∏—è -> –¥–æ–º–µ–Ω -> –ø—É—Ç—å -> –Ω–µ–π—Ä–æ–Ω—ã
  
  // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π (–æ—Å—Ç–∞–≤–ª—è–µ–º –≤–∞—à—É —Ñ—É–Ω–∫—Ü–∏—é –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
  String _normalizeCategory(String pathSegment) {
    final normalized = pathSegment.toLowerCase();
    
    // –§–æ—Ä—É–º–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('forum')) return 'forums';
    if (normalized.contains('chat')) return 'chats';
    if (normalized.contains('board')) return 'forums';
    if (normalized.contains('discussion')) return 'forums';
    
    // –ú–µ–¥–∏–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('audio')) return 'audio';
    if (normalized.contains('music')) return 'audio';
    if (normalized.contains('video')) return 'video';
    if (normalized.contains('movie')) return 'video';
    if (normalized.contains('podcast')) return 'audio';
    
    // –¢–µ–∫—Å—Ç–æ–≤—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('book')) return 'books';
    if (normalized.contains('wiki')) return 'wiki';
    if (normalized.contains('article')) return 'articles';
    if (normalized.contains('blog')) return 'blogs';
    if (normalized.contains('news')) return 'news';
    if (normalized.contains('story')) return 'stories';
    if (normalized.contains('song')) return 'songs';
    if (normalized.contains('poem')) return 'poems';
    
    // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('user')) return 'users';
    if (normalized.contains('profile')) return 'profiles';
    if (normalized.contains('account')) return 'accounts';
    
    // –ü—Ä–æ—á–∏–µ
    if (normalized.contains('archive')) return 'archives';
    if (normalized.contains('download')) return 'downloads';
    if (normalized.contains('file')) return 'files';
    
    return normalized;
  }
  
  // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º (–ø–∞–≥–∏–Ω–∞—Ü–∏—è –ø–æ 20 —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
  String _getRangeGroup(int number, int groupSize) {
    final lower = (number ~/ groupSize) * groupSize + 1;
    final upper = lower + groupSize - 1;
    return '$lower-$upper';
  }
  
  // –ê–Ω–∞–ª–∏–∑ URL –∏ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞
  for (final neuron in neurons.values) {
    if (neuron.id == 0 || neuron.sourceUrl == null) continue;
    
    try {
      final uri = Uri.parse(neuron.sourceUrl!);
      final domain = uri.host;
      
      // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–æ–º–µ–Ω–∞–º
      domainNeuronsMap[domain] = [...domainNeuronsMap[domain] ?? [], neuron.id];
      
      // –ê–Ω–∞–ª–∏–∑ –ø—É—Ç–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏
      if (uri.path.isNotEmpty && uri.path != '/') {
        final pathSegments = uri.path.split('/').where((s) => s.isNotEmpty).toList();
        
        if (pathSegments.isNotEmpty) {
          final firstSegment = pathSegments[0];
          final category = _normalizeCategory(firstSegment);
          
          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
          if (!categoryNeuronsMap.containsKey(category)) {
            categoryNeuronsMap[category] = {};
          }
          if (!pathNeuronsMap.containsKey(category)) {
            pathNeuronsMap[category] = {};
          }
          
          // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–æ–º–µ–Ω–∞–º –≤–Ω—É—Ç—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
          categoryNeuronsMap[category]![domain] = [
            ...categoryNeuronsMap[category]![domain] ?? [],
            neuron.id
          ];
          
          // –ê–Ω–∞–ª–∏–∑ –ø—É—Ç–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–µ—Ä–∞—Ä—Ö–∏–∏
          if (pathSegments.length >= 2) {
            final secondSegment = pathSegments[1];
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∞–∑–æ–≤—ã–π –ø—É—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, "book/1")
            final basePath = '$firstSegment/$secondSegment';
            
            if (!pathNeuronsMap[category]!.containsKey(domain)) {
              pathNeuronsMap[category]![domain] = {};
            }
            
            // –ò–∑–≤–ª–µ–∫–∞–µ–º —á–∏—Å–ª–æ–≤–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
            int? pageNumber;
            
            // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ —á–∏—Å–ª–æ–≤–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤ —Å–µ–≥–º–µ–Ω—Ç–∞—Ö –ø—É—Ç–∏
            for (int i = 2; i < pathSegments.length; i++) {
              pageNumber = int.tryParse(pathSegments[i]);
              if (pageNumber != null) break;
            }
            
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö —Å–µ–≥–º–µ–Ω—Ç–∞—Ö, –ø—Ä–æ–±—É–µ–º –≤—Ç–æ—Ä–æ–π —Å–µ–≥–º–µ–Ω—Ç
            if (pageNumber == null) {
              pageNumber = int.tryParse(secondSegment);
            }
            
            String groupKey;
            if (pageNumber != null) {
              // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º –ø–æ 20 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
              groupKey = _getRangeGroup(pageNumber, 20);
            } else {
              // –ï—Å–ª–∏ –Ω–µ—Ç —á–∏—Å–ª–æ–≤–æ–≥–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞, –≥—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é –≤—Ç–æ—Ä–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
              groupKey = secondSegment;
            }
            
            final pathKey = '$basePath/$groupKey';
            
            pathNeuronsMap[category]![domain]![pathKey] = [
              ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
              neuron.id
            ];
          } else {
            // –ï—Å–ª–∏ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Å–µ–≥–º–µ–Ω—Ç –ø—É—Ç–∏, –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ–±—â—É—é –≥—Ä—É–ø–ø—É –¥–æ–º–µ–Ω–∞
            final pathKey = '$firstSegment/general';
            if (!pathNeuronsMap[category]!.containsKey(domain)) {
              pathNeuronsMap[category]![domain] = {};
            }
            pathNeuronsMap[category]![domain]![pathKey] = [
              ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
              neuron.id
            ];
          }
        }
      }
    } catch (e) {
      print('‚ö†Ô∏è Error parsing URL for neuron ${neuron.id}: ${neuron.sourceUrl}');
    }
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ "internet"
  if (!clusters.containsKey('internet')) {
    clusters['internet'] = NeuronCluster(
      id: 'internet',
      type: 'root',
      title: 'Internet',
      neuronIds: [],
      depth: 0,
      size: 2.0,
    );
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∏–µ—Ä–∞—Ä—Ö–∏–∏: –∫–∞—Ç–µ–≥–æ—Ä–∏—è ‚Üí –¥–æ–º–µ–Ω ‚Üí –ø–∞–≥–∏–Ω–∞—Ü–∏–æ–Ω–Ω—ã–µ –∫–ª–∞—Å—Ç–µ—Ä—ã
  for (final category in categoryNeuronsMap.keys) {
    final categoryClusterId = 'category_$category';
    
    // –°–æ–∑–¥–∞–µ–º –∫–ª–∞—Å—Ç–µ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (!clusters.containsKey(categoryClusterId)) {
      clusters[categoryClusterId] = NeuronCluster(
        id: categoryClusterId,
        type: 'category',
        title: category,
        neuronIds: [],
        depth: 1,
        size: 1.8,
      );
      
      // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–æ—Ä–Ω–µ–≤–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
      clusters['internet']!.childClusterIds.add(categoryClusterId);
      clusters[categoryClusterId]!.parentClusterId = 'internet';
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–æ–º–µ–Ω—ã –≤–Ω—É—Ç—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    for (final domain in categoryNeuronsMap[category]!.keys) {
      final domainClusterId = '${category}_domain_$domain';
      
      // –°–æ–∑–¥–∞–µ–º –¥–æ–º–µ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
      if (!clusters.containsKey(domainClusterId)) {
        clusters[domainClusterId] = NeuronCluster(
          id: domainClusterId,
          type: 'domain',
          title: domain,
          domain: domain,
          neuronIds: [],
          depth: 2,
          size: 1.5,
        );
        
        // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        clusters[categoryClusterId]!.childClusterIds.add(domainClusterId);
        clusters[domainClusterId]!.parentClusterId = categoryClusterId;
      }
      
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—É—Ç–∏ –≤–Ω—É—Ç—Ä–∏ –¥–æ–º–µ–Ω–∞
      final domainPaths = pathNeuronsMap[category]?[domain] ?? {};
      
      for (final pathKey in domainPaths.keys) {
        final neuronsInPath = domainPaths[pathKey]!;
        
        if (neuronsInPath.length >= 5) {
          // –°–æ–∑–¥–∞–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏–æ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
          final pageClusterId = '${domainClusterId}_$pathKey';
          
          clusters[pageClusterId] = NeuronCluster(
            id: pageClusterId,
            type: 'page_group',
            title: '$pathKey (${neuronsInPath.length})',
            domain: domain,
            path: pathKey,
            neuronIds: neuronsInPath,
            depth: 3,
            size: 1.1,
          );
          
          // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –¥–æ–º–µ–Ω–Ω–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
          clusters[domainClusterId]!.childClusterIds.add(pageClusterId);
          clusters[pageClusterId]!.parentClusterId = domainClusterId;
        } else {
          // –ú–∞–ª–æ –Ω–µ–π—Ä–æ–Ω–æ–≤ - –¥–æ–±–∞–≤–ª—è–µ–º –Ω–∞–ø—Ä—è–º—É—é –≤ –¥–æ–º–µ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
          clusters[domainClusterId]!.neuronIds.addAll(neuronsInPath);
        }
      }
      
      // –ï—Å–ª–∏ –≤ –¥–æ–º–µ–Ω–µ –æ—Å—Ç–∞–ª–∏—Å—å –Ω–µ–π—Ä–æ–Ω—ã –±–µ–∑ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö –ø—É—Ç–µ–π, –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö
      final domainNeurons = categoryNeuronsMap[category]![domain]!;
      final assignedNeurons = domainPaths.values.expand((list) => list).toSet();
      final remainingNeurons = domainNeurons.where((id) => !assignedNeurons.contains(id)).toList();
      
      if (remainingNeurons.isNotEmpty) {
        clusters[domainClusterId]!.neuronIds.addAll(remainingNeurons);
      }
    }
  }
  
  // –¢–∞–∫–∂–µ —Å–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–µ –¥–æ–º–µ–Ω–Ω—ã–µ –∫–ª–∞—Å—Ç–µ—Ä—ã –¥–ª—è –Ω–µ–π—Ä–æ–Ω–æ–≤ –±–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
  for (final domain in domainNeuronsMap.keys) {
    final domainClusterId = 'domain_$domain';
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –±—ã–ª –ª–∏ —É–∂–µ —Å–æ–∑–¥–∞–Ω —ç—Ç–æ—Ç –¥–æ–º–µ–Ω –≤ –∫–∞–∫–æ–π-–ª–∏–±–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    final existsInCategory = clusters.values.any((cluster) => 
        cluster.id.contains('_domain_$domain') && cluster.type == 'domain');
    
    if (!existsInCategory && !clusters.containsKey(domainClusterId)) {
      clusters[domainClusterId] = NeuronCluster(
        id: domainClusterId,
        type: 'domain',
        title: domain,
        domain: domain,
        neuronIds: domainNeuronsMap[domain]!,
        depth: 1,
        size: 1.5,
      );
      
      // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–æ—Ä–Ω–µ–≤–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
      clusters['internet']!.childClusterIds.add(domainClusterId);
      clusters[domainClusterId]!.parentClusterId = 'internet';
    }
  }
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏–≥–Ω–∞—Ç—É—Ä –≤—Å–µ—Ö –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
  for (final cluster in clusters.values) {
    if (cluster.neuronIds.isNotEmpty) {
      cluster.updateSignature(this);
    }
  }
  
  print('‚úÖ Created URL hierarchy: ${clusters.length} clusters');
}
  

  Future<void> _createUrlDomainClustersDD() async {
  final domainNeuronsMap = <String, List<int>>{};
  final domainNeuronsMapChanging  = <String, List<int>>{};
  final categoryNeuronsMap = <String, Map<String, List<int>>>{}; // –∫–∞—Ç–µ–≥–æ—Ä–∏—è -> –¥–æ–º–µ–Ω -> –Ω–µ–π—Ä–æ–Ω—ã
  final pathNeuronsMap = <String, Map<String, Map<String, List<int>>>>{}; // –∫–∞—Ç–µ–≥–æ—Ä–∏—è -> –¥–æ–º–µ–Ω -> –ø—É—Ç—å -> –Ω–µ–π—Ä–æ–Ω—ã
  
  // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π (–æ—Å—Ç–∞–≤–ª—è–µ–º –≤–∞—à—É —Ñ—É–Ω–∫—Ü–∏—é –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
  String _normalizeCategory(String pathSegment) {
    final normalized = pathSegment.toLowerCase();
    
    // –§–æ—Ä—É–º–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('forum')) return 'forums';
    if (normalized.contains('chat')) return 'chats';
    if (normalized.contains('board')) return 'forums';
    if (normalized.contains('discussion')) return 'forums';
    
    // –ú–µ–¥–∏–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('audio')) return 'audio';
    if (normalized.contains('music')) return 'audio';
    if (normalized.contains('video')) return 'video';
    if (normalized.contains('movie')) return 'video';
    if (normalized.contains('podcast')) return 'audio';
    
    // –¢–µ–∫—Å—Ç–æ–≤—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('book')) return 'books';
    if (normalized.contains('wiki')) return 'wiki';
    if (normalized.contains('article')) return 'articles';
    if (normalized.contains('blog')) return 'blogs';
    if (normalized.contains('news')) return 'news';
    if (normalized.contains('story')) return 'stories';
    if (normalized.contains('song')) return 'songs';
    if (normalized.contains('poem')) return 'poems';
    
    // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('user')) return 'users';
    if (normalized.contains('profile')) return 'profiles';
    if (normalized.contains('account')) return 'accounts';
    
    // –ü—Ä–æ—á–∏–µ
    if (normalized.contains('archive')) return 'archives';
    if (normalized.contains('download')) return 'downloads';
    if (normalized.contains('file')) return 'files';
    
    return "generic";
  }
  
  // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º (–ø–∞–≥–∏–Ω–∞—Ü–∏—è –ø–æ 20 —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
  String _getRangeGroup(int number, int groupSize) {
    final lower = (number ~/ groupSize) * groupSize + 1;
    final upper = lower + groupSize - 1;
    return '$lower-$upper';
  }
  
          final regex = RegExp(r'\d+');
         
  // –ê–Ω–∞–ª–∏–∑ URL –∏ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞
  for (final neuron in neurons.values) {
    if (neuron.id == 0 || neuron.sourceUrl == null) continue;
    
    try {
      final uri = Uri.parse(neuron.sourceUrl!);
      final domain = uri.host;
      
      // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–æ–º–µ–Ω–∞–º
      domainNeuronsMap[domain] = [...domainNeuronsMap[domain] ?? [], neuron.id];
      
      // –ê–Ω–∞–ª–∏–∑ –ø—É—Ç–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏
      if (uri.path.isNotEmpty && uri.path != '/') {
        final pathSegments = uri.path.split('/').where((s) => s.isNotEmpty).toList();
          final firstSegment = pathSegments[0];
            final secondSegment = pathSegments[1];
            
        if (pathSegments.isNotEmpty) {
      String category = "generic";
          int indexCat = 0;
          for (final path in pathSegments) {
              category = _normalizeCategory(path);
              indexCat= pathSegments.indexOf(path);
              if (category != "generic") break;
          }
          

          
          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
          if (!categoryNeuronsMap.containsKey(category)) {
            categoryNeuronsMap[category] = {};
          }
          if (!pathNeuronsMap.containsKey(category)) {
            pathNeuronsMap[category] = {};
          }
          
          // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–æ–º–µ–Ω–∞–º –≤–Ω—É—Ç—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
          categoryNeuronsMap[category]![domain] = [
            ...categoryNeuronsMap[category]![domain] ?? [],
            neuron.id
          ];
          
          // –ê–Ω–∞–ª–∏–∑ –ø—É—Ç–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–µ—Ä–∞—Ä—Ö–∏–∏
          if (pathSegments.length >= 2) {
          
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∞–∑–æ–≤—ã–π –ø—É—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, "book/1")
            final basePath = '$firstSegment/$secondSegment';
            
            if (!pathNeuronsMap[category]!.containsKey(domain)) {
              pathNeuronsMap[category]![domain] = {};
            }
            
            // –ò–∑–≤–ª–µ–∫–∞–µ–º —á–∏—Å–ª–æ–≤–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
            int? pageNumber;
            
            // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ —á–∏—Å–ª–æ–≤–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤ —Å–µ–≥–º–µ–Ω—Ç–∞—Ö –ø—É—Ç–∏
            for (int i = 2; i < pathSegments.length; i++) {
              if (i==indexCat) continue;
              final matches = regex.allMatches(pathSegments[i]);
              for (final match in matches) {
                final number = int.tryParse(match.group(0)!);
                if (number != null) {
                  pageNumber = number;
                }
              }
              if (pageNumber != null) break;
            }
            
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö —Å–µ–≥–º–µ–Ω—Ç–∞—Ö, –ø—Ä–æ–±—É–µ–º –≤—Ç–æ—Ä–æ–π —Å–µ–≥–º–µ–Ω—Ç
            if (pageNumber == null) {
              final matches = regex.allMatches(secondSegment);
              for (final match in matches) {
                final number = int.tryParse(match.group(0)!);
                if (number != null) {
                  pageNumber = number;
                }
              }
              if (pageNumber != null) break;
            }
            
            String groupKey;
            if (pageNumber != null) {
              // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º –ø–æ 20 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
              groupKey = _getRangeGroup(pageNumber, 20);
            } else {
              // –ï—Å–ª–∏ –Ω–µ—Ç —á–∏—Å–ª–æ–≤–æ–≥–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞, –≥—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é –≤—Ç–æ—Ä–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
              groupKey = secondSegment;
            }
            
            final pathKey = '$basePath/$groupKey';
            
            pathNeuronsMap[category]![domain]![pathKey] = [
              ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
              neuron.id
            ];
          } else {
            // –ï—Å–ª–∏ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Å–µ–≥–º–µ–Ω—Ç –ø—É—Ç–∏, –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ–±—â—É—é –≥—Ä—É–ø–ø—É –¥–æ–º–µ–Ω–∞
            final pathKey = '$firstSegment/general';
            if (!pathNeuronsMap[category]!.containsKey(domain)) {
              pathNeuronsMap[category]![domain] = {};
            }
            pathNeuronsMap[category]![domain]![pathKey] = [
              ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
              neuron.id
            ];
          }
        }
      }
    } catch (e) {
      print('‚ö†Ô∏è Error parsing URL for neuron ${neuron.id}: ${neuron.sourceUrl}');
    }
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ "internet"
  if (!clusters.containsKey('internet')) {
    clusters['internet'] = NeuronCluster(
      id: 'internet',
      type: 'root',
      title: 'Internet',
      neuronIds: [],
      depth: 0,
      size: 2.0,
    );
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∏–µ—Ä–∞—Ä—Ö–∏–∏: –∫–∞—Ç–µ–≥–æ—Ä–∏—è ‚Üí –¥–æ–º–µ–Ω ‚Üí –ø–∞–≥–∏–Ω–∞—Ü–∏–æ–Ω–Ω—ã–µ –∫–ª–∞—Å—Ç–µ—Ä—ã
  for (final category in categoryNeuronsMap.keys) {
    final categoryClusterId = 'category_$category';
    
    // –°–æ–∑–¥–∞–µ–º –∫–ª–∞—Å—Ç–µ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (!clusters.containsKey(categoryClusterId)) {
      clusters[categoryClusterId] = NeuronCluster(
        id: categoryClusterId,
        type: 'category',
        title: category,
        neuronIds: [],
        depth: 1,
        size: 1.8,
      );
      
      // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–æ—Ä–Ω–µ–≤–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
      clusters['internet']!.childClusterIds.add(categoryClusterId);
      clusters[categoryClusterId]!.parentClusterId = 'internet';
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–æ–º–µ–Ω—ã –≤–Ω—É—Ç—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    for (final domain in categoryNeuronsMap[category]!.keys) {
      final domainClusterId = '${category}_domain_$domain';
      
      // –°–æ–∑–¥–∞–µ–º –¥–æ–º–µ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
      if (!clusters.containsKey(domainClusterId)) {
        clusters[domainClusterId] = NeuronCluster(
          id: domainClusterId,
          type: 'domain',
          title: domain,
          domain: domain,
          neuronIds: [],
          depth: 2,
          size: 1.5,
        );
        
        // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        clusters[categoryClusterId]!.childClusterIds.add(domainClusterId);
        clusters[domainClusterId]!.parentClusterId = categoryClusterId;
      }
      
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—É—Ç–∏ –≤–Ω—É—Ç—Ä–∏ –¥–æ–º–µ–Ω–∞
      final domainPaths = pathNeuronsMap[category]?[domain] ?? {};
      
      for (final pathKey in domainPaths.keys) {
        final neuronsInPath = domainPaths[pathKey]!;
        
        if (neuronsInPath.length >= 5) {
          // –°–æ–∑–¥–∞–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏–æ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
          final pageClusterId = '${domainClusterId}_$pathKey';
          
          clusters[pageClusterId] = NeuronCluster(
            id: pageClusterId,
            type: 'page_group',
            title: '$pathKey (${neuronsInPath.length})',
            domain: domain,
            path: pathKey,
            neuronIds: neuronsInPath,
            depth: 3,
            size: 1.1,
          );
          
          // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –¥–æ–º–µ–Ω–Ω–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
          clusters[domainClusterId]!.childClusterIds.add(pageClusterId);
          clusters[pageClusterId]!.parentClusterId = domainClusterId;
        } else {
          // –ú–∞–ª–æ –Ω–µ–π—Ä–æ–Ω–æ–≤ - –¥–æ–±–∞–≤–ª—è–µ–º –Ω–∞–ø—Ä—è–º—É—é –≤ –¥–æ–º–µ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
          clusters[domainClusterId]!.neuronIds.addAll(neuronsInPath);
        }
      }
      
      // –ï—Å–ª–∏ –≤ –¥–æ–º–µ–Ω–µ –æ—Å—Ç–∞–ª–∏—Å—å –Ω–µ–π—Ä–æ–Ω—ã –±–µ–∑ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö –ø—É—Ç–µ–π, –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö
      final domainNeurons = categoryNeuronsMap[category]![domain]!;
      final assignedNeurons = domainPaths.values.expand((list) => list).toSet();
      final remainingNeurons = domainNeurons.where((id) => !assignedNeurons.contains(id)).toList();
      
      if (remainingNeurons.isNotEmpty) {
        clusters[domainClusterId]!.neuronIds.addAll(remainingNeurons);
      }
    }
  }
  
  // –¢–∞–∫–∂–µ —Å–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–µ –¥–æ–º–µ–Ω–Ω—ã–µ –∫–ª–∞—Å—Ç–µ—Ä—ã –¥–ª—è –Ω–µ–π—Ä–æ–Ω–æ–≤ –±–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
  for (final domain in domainNeuronsMap.keys) {
    final domainClusterId = 'domain_$domain';
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –±—ã–ª –ª–∏ —É–∂–µ —Å–æ–∑–¥–∞–Ω —ç—Ç–æ—Ç –¥–æ–º–µ–Ω –≤ –∫–∞–∫–æ–π-–ª–∏–±–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    final existsInCategory = clusters.values.any((cluster) => 
        cluster.id.contains('_domain_$domain') && cluster.type == 'domain');
    
    if (!existsInCategory && !clusters.containsKey(domainClusterId)) {
      clusters[domainClusterId] = NeuronCluster(
        id: domainClusterId,
        type: 'domain',
        title: domain,
        domain: domain,
        neuronIds: domainNeuronsMap[domain]!,
        depth: 1,
        size: 1.5,
      );
      
      // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–æ—Ä–Ω–µ–≤–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
      clusters['internet']!.childClusterIds.add(domainClusterId);
      clusters[domainClusterId]!.parentClusterId = 'internet';
    }
  }
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏–≥–Ω–∞—Ç—É—Ä –≤—Å–µ—Ö –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
  for (final cluster in clusters.values) {
    if (cluster.neuronIds.isNotEmpty) {
      cluster.updateSignature(this);
    }
  }
  
  print('‚úÖ Created URL hierarchy: ${clusters.length} clusters');
}



Future<void> _createUrlDomainClustersShouldRework() async {
  final domainNeuronsMap = <String, List<int>>{};
  final categoryNeuronsMap = <String, Map<String, List<int>>>{};
  final pathNeuronsMap = <String, Map<String, Map<String, List<int>>>>{};
  final keywordNeuronsMap = <String, Map<String, List<int>>>{}; // keyword -> domain -> neurons
  final numericPatternsMap = <String, Map<String, List<int>>>{}; // pattern -> domain -> neurons

  // –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
  String _normalizeCategory(String pathSegment) {
    final normalized = pathSegment.toLowerCase();
    
    // –§–æ—Ä—É–º–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('forum')) return 'forums';
    if (normalized.contains('chat')) return 'chats';
    if (normalized.contains('board')) return 'forums';
    if (normalized.contains('discussion')) return 'forums';
    if (normalized.contains('thread')) return 'threads';
    if (normalized.contains('topic')) return 'topics';
    
    // –ú–µ–¥–∏–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('audio')) return 'audio';
    if (normalized.contains('music')) return 'audio';
    if (normalized.contains('video')) return 'video';
    if (normalized.contains('movie')) return 'video';
    if (normalized.contains('film')) return 'video';
    if (normalized.contains('podcast')) return 'audio';
    if (normalized.contains('stream')) return 'streams';
    if (normalized.contains('live')) return 'live';
    
    // –¢–µ–∫—Å—Ç–æ–≤—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('book')) return 'books';
    if (normalized.contains('wiki')) return 'wiki';
    if (normalized.contains('article')) return 'articles';
    if (normalized.contains('blog')) return 'blogs';
    if (normalized.contains('news')) return 'news';
    if (normalized.contains('story')) return 'stories';
    if (normalized.contains('song')) return 'songs';
    if (normalized.contains('poem')) return 'poems';
    if (normalized.contains('text')) return 'texts';
    if (normalized.contains('doc')) return 'documents';
    if (normalized.contains('document')) return 'documents';
    
    // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('user')) return 'users';
    if (normalized.contains('profile')) return 'profiles';
    if (normalized.contains('account')) return 'accounts';
    if (normalized.contains('member')) return 'members';
    
    // –ü–æ–∏—Å–∫ –∏ —Ç–µ–≥–∏
    if (normalized.contains('search')) return 'search';
    if (normalized.contains('query')) return 'search';
    if (normalized.contains('tag')) return 'tags';
    if (normalized.contains('category')) return 'categories';
    if (normalized.contains('label')) return 'labels';
    
    // –ü—Ä–æ—á–∏–µ –≤–∞–∂–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (normalized.contains('archive')) return 'archives';
    if (normalized.contains('download')) return 'downloads';
    if (normalized.contains('file')) return 'files';
    if (normalized.contains('image')) return 'images';
    if (normalized.contains('photo')) return 'photos';
    if (normalized.contains('picture')) return 'images';
    if (normalized.contains('gallery')) return 'galleries';
    if (normalized.contains('product')) return 'products';
    if (normalized.contains('item')) return 'items';
    if (normalized.contains('shop')) return 'shop';
    if (normalized.contains('store')) return 'store';
    
    return normalized;
  }

  // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä —á–∏—Å–ª–æ–≤—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
  Map<String, dynamic> _parseNumericPattern(List<String> pathSegments) {
    final numbers = <int>[];
    final patterns = <String>[];
    
    for (final segment in pathSegments) {
      // –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å —á–∏—Å—Ç–æ —á–∏—Å–ª–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
      final number = int.tryParse(segment);
      if (number != null) {
        numbers.add(number);
        continue;
      }
      
      // –ò—â–µ–º —á–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤ —Å–º–µ—à–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫–∞—Ö
      final regex = RegExp(r'(\d+)');
      final matches = regex.allMatches(segment);
      
      for (final match in matches) {
        final numericValue = int.tryParse(match.group(0)!);
        if (numericValue != null) {
          numbers.add(numericValue);
        }
      }
      
      // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Ç–∏–ø–∞: page1, item_123, v2.0 –∏ —Ç.–¥.
      if (segment.contains(RegExp(r'[a-zA-Z]+\d+'))) {
        patterns.add(segment);
      }
    }
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —á–∏—Å–ª–æ–≤–æ–≥–æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
    String patternType = 'unknown';
    if (numbers.isNotEmpty) {
      numbers.sort();
      final range = numbers.last - numbers.first;
      final count = numbers.length;
      
      if (count >= 3 && range <= 100) {
        patternType = 'sequential';
      } else if (count >= 2 && numbers.every((n) => n % 10 == 0)) {
        patternType = 'pagination';
      } else if (numbers.any((n) => n > 1000000)) {
        patternType = 'id_large';
      } else if (numbers.any((n) => n > 1000)) {
        patternType = 'id_medium';
      } else {
        patternType = 'id_small';
      }
    }
    
    return {
      'numbers': numbers,
      'patterns': patterns,
      'pattern_type': patternType,
      'primary_number': numbers.isNotEmpty ? numbers.first : null,
    };
  }

  // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –∏–∑ query –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ —Ö—ç—à—Ç–µ–≥–æ–≤
  List<String> _extractKeywords(Uri uri) {
    final keywords = <String>{};
    
    // –ò–∑ query –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    if (uri.hasQuery) {
      final queryParams = uri.queryParameters;
      for (final key in ['q', 'query', 'search', 'tag', 'keyword']) {
        final value = queryParams[key];
        if (value != null && value.isNotEmpty) {
          keywords.addAll(value.split(RegExp(r'[+\s,]')).where((word) => 
              word.length > 2).map((word) => word.toLowerCase()));
        }
      }
    }
    
    // –ò–∑ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ (—Ö—ç—à—Ç–µ–≥–∏)
    if (uri.fragment.isNotEmpty) {
      final fragment = uri.fragment;
      if (fragment.contains('#')) {
        keywords.addAll(fragment.split('#').where((tag) => 
            tag.length > 2).map((tag) => tag.toLowerCase()));
      }
    }
    
    return keywords.toSet().toList();
  }

  // –ê–Ω–∞–ª–∏–∑ URL –∏ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞
  for (final neuron in neurons.values) {
    if (neuron.id == 0 || neuron.sourceUrl == null) continue;
    
    try {
      final uri = Uri.parse(neuron.sourceUrl!);
      final domain = uri.host;
      
      // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–æ–º–µ–Ω–∞–º
      domainNeuronsMap[domain] = [...domainNeuronsMap[domain] ?? [], neuron.id];
      
      // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
      final keywords = _extractKeywords(uri);
      for (final keyword in keywords) {
        if (!keywordNeuronsMap.containsKey(keyword)) {
          keywordNeuronsMap[keyword] = {};
        }
        keywordNeuronsMap[keyword]![domain] = [
          ...keywordNeuronsMap[keyword]![domain] ?? [],
          neuron.id
        ];
      }
      
      // –ê–Ω–∞–ª–∏–∑ –ø—É—Ç–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏
      if (uri.path.isNotEmpty && uri.path != '/') {
        final pathSegments = uri.path.split('/').where((s) => s.isNotEmpty).toList();
        
        if (pathSegments.isNotEmpty) {
          // –ê–Ω–∞–ª–∏–∑ —á–∏—Å–ª–æ–≤—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
          final numericAnalysis = _parseNumericPattern(pathSegments);
          final numbers = numericAnalysis['numbers'] as List<int>;
          final patternType = numericAnalysis['pattern_type'] as String;
          
          if (numbers.isNotEmpty) {
            final patternKey = '${patternType}_${numbers.length}';
            if (!numericPatternsMap.containsKey(patternKey)) {
              numericPatternsMap[patternKey] = {};
            }
            numericPatternsMap[patternKey]![domain] = [
              ...numericPatternsMap[patternKey]![domain] ?? [],
              neuron.id
            ];
          }
          
          // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–≤–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
          final firstSegment = pathSegments[0];
          final category = _normalizeCategory(firstSegment);
          
          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
          if (!categoryNeuronsMap.containsKey(category)) {
            categoryNeuronsMap[category] = {};
          }
          if (!pathNeuronsMap.containsKey(category)) {
            pathNeuronsMap[category] = {};
          }
          
          // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–æ–º–µ–Ω–∞–º –≤–Ω—É—Ç—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
          categoryNeuronsMap[category]![domain] = [
            ...categoryNeuronsMap[category]![domain] ?? [],
            neuron.id
          ];
          
          // –°–æ–∑–¥–∞–Ω–∏–µ –∏–µ—Ä–∞—Ä—Ö–∏–∏ –ø—É—Ç–∏
          String pathKey = firstSegment;
          
          if (pathSegments.length >= 2) {
            final secondSegment = pathSegments[1];
            final secondCategory = _normalizeCategory(secondSegment);
            
            // –ï—Å–ª–∏ –≤—Ç–æ—Ä–æ–π —Å–µ–≥–º–µ–Ω—Ç —Ç–æ–∂–µ —è–≤–ª—è–µ—Ç—Å—è –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–º–±–∏–Ω–∞—Ü–∏—é
            if (secondCategory != secondSegment.toLowerCase()) {
              pathKey = '$firstSegment/$secondCategory';
            } else {
              pathKey = '$firstSegment/$secondSegment';
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º —á–∏—Å–ª–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å
            if (numbers.isNotEmpty) {
              final primaryNumber = numericAnalysis['primary_number'] as int?;
              if (primaryNumber != null) {
                pathKey = '$pathKey/$primaryNumber';
              }
            }
          }
          
          if (!pathNeuronsMap[category]!.containsKey(domain)) {
            pathNeuronsMap[category]![domain] = {};
          }
          
          pathNeuronsMap[category]![domain]![pathKey] = [
            ...pathNeuronsMap[category]![domain]![pathKey] ?? [],
            neuron.id
          ];
        }
      }
    } catch (e) {
      print('‚ö†Ô∏è Error parsing URL for neuron ${neuron.id}: ${neuron.sourceUrl}');
    }
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ "internet"
  if (!clusters.containsKey('internet')) {
    clusters['internet'] = NeuronCluster(
      id: 'internet',
      type: 'root',
      title: 'Internet',
      neuronIds: [],
      depth: 0,
      size: 2.0,
    );
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞—Å—Ç–µ—Ä–∞ –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
  if (!clusters.containsKey('keywords') && keywordNeuronsMap.isNotEmpty) {
    clusters['keywords'] = NeuronCluster(
      id: 'keywords',
      type: 'keyword_root',
      title: 'Keywords',
      neuronIds: [],
      depth: 1,
      size: 1.8,
    );
    clusters['internet']!.childClusterIds.add('keywords');
    clusters['keywords']!.parentClusterId = 'internet';
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
  for (final keyword in keywordNeuronsMap.keys) {
    final keywordClusterId = 'keyword_${keyword.replaceAll(RegExp(r'[^a-zA-Z0-9]'), '_')}';
    
    clusters[keywordClusterId] = NeuronCluster(
      id: keywordClusterId,
      type: 'keyword',
      title: 'Keyword: $keyword',
      neuronIds: [],
      depth: 2,
      size: 1.3,
    );
    
    // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–æ—Ä–Ω—é –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
    clusters['keywords']!.childClusterIds.add(keywordClusterId);
    clusters[keywordClusterId]!.parentClusterId = 'keywords';
    
    // –°–æ–∑–¥–∞–µ–º –ø–æ–¥–∫–ª–∞—Å—Ç–µ—Ä—ã –ø–æ –¥–æ–º–µ–Ω–∞–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞
    for (final domain in keywordNeuronsMap[keyword]!.keys) {
      final domainKeywordClusterId = '${keywordClusterId}_$domain';
      final neurons = keywordNeuronsMap[keyword]![domain]!;
      
      clusters[domainKeywordClusterId] = NeuronCluster(
        id: domainKeywordClusterId,
        type: 'keyword_domain',
        title: '$domain: $keyword',
        domain: domain,
        neuronIds: neurons,
        depth: 3,
        size: 1.1,
      );
      
      clusters[keywordClusterId]!.childClusterIds.add(domainKeywordClusterId);
      clusters[domainKeywordClusterId]!.parentClusterId = keywordClusterId;
    }
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞—Å—Ç–µ—Ä–∞ –¥–ª—è —á–∏—Å–ª–æ–≤—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
  if (!clusters.containsKey('numeric_patterns') && numericPatternsMap.isNotEmpty) {
    clusters['numeric_patterns'] = NeuronCluster(
      id: 'numeric_patterns',
      type: 'numeric_root',
      title: 'Numeric Patterns',
      neuronIds: [],
      depth: 1,
      size: 1.8,
    );
    clusters['internet']!.childClusterIds.add('numeric_patterns');
    clusters['numeric_patterns']!.parentClusterId = 'internet';
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ –¥–ª—è —á–∏—Å–ª–æ–≤—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
  for (final pattern in numericPatternsMap.keys) {
    final patternClusterId = 'pattern_${pattern.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_')}';
    
    clusters[patternClusterId] = NeuronCluster(
      id: patternClusterId,
      type: 'numeric_pattern',
      title: 'Pattern: $pattern',
      neuronIds: [],
      depth: 2,
      size: 1.4,
    );
    
    clusters['numeric_patterns']!.childClusterIds.add(patternClusterId);
    clusters[patternClusterId]!.parentClusterId = 'numeric_patterns';
    
    for (final domain in numericPatternsMap[pattern]!.keys) {
      final domainPatternClusterId = '${patternClusterId}_$domain';
      final neurons = numericPatternsMap[pattern]![domain]!;
      
      clusters[domainPatternClusterId] = NeuronCluster(
        id: domainPatternClusterId,
        type: 'pattern_domain',
        title: '$domain: $pattern',
        domain: domain,
        neuronIds: neurons,
        depth: 3,
        size: 1.1,
      );
      
      clusters[patternClusterId]!.childClusterIds.add(domainPatternClusterId);
      clusters[domainPatternClusterId]!.parentClusterId = patternClusterId;
    }
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∏–µ—Ä–∞—Ä—Ö–∏–∏: –∫–∞—Ç–µ–≥–æ—Ä–∏—è ‚Üí –¥–æ–º–µ–Ω ‚Üí –ø–∞–≥–∏–Ω–∞—Ü–∏–æ–Ω–Ω—ã–µ –∫–ª–∞—Å—Ç–µ—Ä—ã
  for (final category in categoryNeuronsMap.keys) {
    final categoryClusterId = 'category_$category';
    
    // –°–æ–∑–¥–∞–µ–º –∫–ª–∞—Å—Ç–µ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (!clusters.containsKey(categoryClusterId)) {
      clusters[categoryClusterId] = NeuronCluster(
        id: categoryClusterId,
        type: 'category',
        title: category,
        neuronIds: [],
        depth: 1,
        size: 1.8,
      );
      
      // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–æ—Ä–Ω–µ–≤–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
      clusters['internet']!.childClusterIds.add(categoryClusterId);
      clusters[categoryClusterId]!.parentClusterId = 'internet';
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–æ–º–µ–Ω—ã –≤–Ω—É—Ç—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    for (final domain in categoryNeuronsMap[category]!.keys) {
      final domainClusterId = '${category}_domain_$domain';
      
      // –°–æ–∑–¥–∞–µ–º –¥–æ–º–µ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
      if (!clusters.containsKey(domainClusterId)) {
        clusters[domainClusterId] = NeuronCluster(
          id: domainClusterId,
          type: 'domain',
          title: domain,
          domain: domain,
          neuronIds: [],
          depth: 2,
          size: 1.5,
        );
        
        // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        clusters[categoryClusterId]!.childClusterIds.add(domainClusterId);
        clusters[domainClusterId]!.parentClusterId = categoryClusterId;
      }
      
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—É—Ç–∏ –≤–Ω—É—Ç—Ä–∏ –¥–æ–º–µ–Ω–∞
      final domainPaths = pathNeuronsMap[category]?[domain] ?? {};
      
      for (final pathKey in domainPaths.keys) {
        final neuronsInPath = domainPaths[pathKey]!;
        
        if (neuronsInPath.length >= 3) { // –£–º–µ–Ω—å—à–∏–ª –ø–æ—Ä–æ–≥ –¥–ª—è –ª—É—á—à–µ–≥–æ –ø–æ–∫—Ä—ã—Ç–∏—è
          // –°–æ–∑–¥–∞–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏–æ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
          final pageClusterId = '${domainClusterId}_${pathKey.replaceAll(RegExp(r'[^a-zA-Z0-9]'), '_')}';
          
          clusters[pageClusterId] = NeuronCluster(
            id: pageClusterId,
            type: 'page_group',
            title: '$pathKey (${neuronsInPath.length})',
            domain: domain,
            path: pathKey,
            neuronIds: neuronsInPath,
            depth: 3,
            size: 1.1,
          );
          
          // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –¥–æ–º–µ–Ω–Ω–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
          clusters[domainClusterId]!.childClusterIds.add(pageClusterId);
          clusters[pageClusterId]!.parentClusterId = domainClusterId;
        } else {
          // –ú–∞–ª–æ –Ω–µ–π—Ä–æ–Ω–æ–≤ - –¥–æ–±–∞–≤–ª—è–µ–º –Ω–∞–ø—Ä—è–º—É—é –≤ –¥–æ–º–µ–Ω–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä
          clusters[domainClusterId]!.neuronIds.addAll(neuronsInPath);
        }
      }
      
      // –ï—Å–ª–∏ –≤ –¥–æ–º–µ–Ω–µ –æ—Å—Ç–∞–ª–∏—Å—å –Ω–µ–π—Ä–æ–Ω—ã –±–µ–∑ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö –ø—É—Ç–µ–π, –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö
      final domainNeurons = categoryNeuronsMap[category]![domain]!;
      final assignedNeurons = domainPaths.values.expand((list) => list).toSet();
      final remainingNeurons = domainNeurons.where((id) => !assignedNeurons.contains(id)).toList();
      
      if (remainingNeurons.isNotEmpty) {
        clusters[domainClusterId]!.neuronIds.addAll(remainingNeurons);
      }
    }
  }
  
  // –¢–∞–∫–∂–µ —Å–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–µ –¥–æ–º–µ–Ω–Ω—ã–µ –∫–ª–∞—Å—Ç–µ—Ä—ã –¥–ª—è –Ω–µ–π—Ä–æ–Ω–æ–≤ –±–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
  for (final domain in domainNeuronsMap.keys) {
    final domainClusterId = 'domain_$domain';
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –±—ã–ª –ª–∏ —É–∂–µ —Å–æ–∑–¥–∞–Ω —ç—Ç–æ—Ç –¥–æ–º–µ–Ω –≤ –∫–∞–∫–æ–π-–ª–∏–±–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    final existsInCategory = clusters.values.any((cluster) => 
        cluster.id.contains('_domain_$domain') && cluster.type == 'domain');
    
    if (!existsInCategory && !clusters.containsKey(domainClusterId)) {
      clusters[domainClusterId] = NeuronCluster(
        id: domainClusterId,
        type: 'domain',
        title: domain,
        domain: domain,
        neuronIds: domainNeuronsMap[domain]!,
        depth: 1,
        size: 1.5,
      );
      
      // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –∫–æ—Ä–Ω–µ–≤–æ–º—É –∫–ª–∞—Å—Ç–µ—Ä—É
      clusters['internet']!.childClusterIds.add(domainClusterId);
      clusters[domainClusterId]!.parentClusterId = 'internet';
    }
  }
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏–≥–Ω–∞—Ç—É—Ä –≤—Å–µ—Ö –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
  for (final cluster in clusters.values) {
    if (cluster.neuronIds.isNotEmpty) {
      cluster.updateSignature(this);
    }
  }
  
  print('‚úÖ Created URL hierarchy: ${clusters.length} clusters');
  print('   - Categories: ${categoryNeuronsMap.length}');
  print('   - Keywords: ${keywordNeuronsMap.length}');
  print('   - Numeric patterns: ${numericPatternsMap.length}');
  print('   - Domains: ${domainNeuronsMap.length}');
}

void _buildClusterHierarchy(Map<String, Map<String, dynamic>> structuredClusters) {
  if (!clusters.containsKey('internet')) {
    clusters['internet'] = NeuronCluster(
      id: 'internet', type: 'root', title: 'Internet', neuronIds: [], depth: 0, size: 2.0,
    );
  }
  
  for (final category in structuredClusters.keys) {
    final categoryClusterId = 'category_$category';
    clusters[categoryClusterId] = NeuronCluster(
      id: categoryClusterId, type: 'category', 
      title: '${category[0].toUpperCase()}${category.substring(1)}',
      neuronIds: [], depth: 1, size: 1.8,
    );
    
    clusters['internet']!.childClusterIds.add(categoryClusterId);
    clusters[categoryClusterId]!.parentClusterId = 'internet';
    
    final categoryData = structuredClusters[category]!;
    
    for (final domain in categoryData['domains'].keys) {
      final domainData = categoryData['domains'][domain];
      final domainClusterId = '${category}_$domain';
      
      clusters[domainClusterId] = NeuronCluster(
        id: domainClusterId, type: 'domain', title: domain, domain: domain,
        neuronIds: [], depth: 2, size: 1.5,
      );
      
      clusters[categoryClusterId]!.childClusterIds.add(domainClusterId);
      clusters[domainClusterId]!.parentClusterId = categoryClusterId;
      
      // –ö–ª–∞—Å—Ç–µ—Ä—ã –¥–ª—è –∫–Ω–∏–≥
      for (final bookId in domainData['books'].keys) {
        final bookNeurons = domainData['books'][bookId];
        final bookClusterId = '${domainClusterId}_book_$bookId';
        clusters[bookClusterId] = NeuronCluster(
          id: bookClusterId, type: 'book', title: 'Book $bookId (${bookNeurons.length})',
          neuronIds: bookNeurons, depth: 3, size: 1.3,
        );
        clusters[domainClusterId]!.childClusterIds.add(bookClusterId);
        clusters[bookClusterId]!.parentClusterId = domainClusterId;
      }
      
      // –ö–ª–∞—Å—Ç–µ—Ä—ã –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü
      for (final pageRange in domainData['pages'].keys) {
        final pageNeurons = domainData['pages'][pageRange];
        if (pageNeurons.length >= 3) {
          final pageClusterId = '${domainClusterId}_pages_$pageRange';
          clusters[pageClusterId] = NeuronCluster(
            id: pageClusterId, type: 'page_range', title: 'Pages $pageRange (${pageNeurons.length})',
            neuronIds: pageNeurons, depth: 3, size: 1.1,
          );
          clusters[domainClusterId]!.childClusterIds.add(pageClusterId);
          clusters[pageClusterId]!.parentClusterId = domainClusterId;
        } else {
          clusters[domainClusterId]!.neuronIds.addAll(pageNeurons);
        }
      }
      
      // –û—Å—Ç–∞–≤—à–∏–µ—Å—è –Ω–µ–π—Ä–æ–Ω—ã
      final assignedNeurons = [
        ...domainData['books'].values.expand((list) => list),
        ...domainData['pages'].values.expand((list) => list),
        ...domainData['chapters'].values.expand((list) => list),
      ].toSet();
      
      final remainingNeurons = domainData['neurons']
          .where((id) => !assignedNeurons.contains(id)).toList();
      
      clusters[domainClusterId]!.neuronIds.addAll(remainingNeurons);
    }
  }
}

  
  Future<void> _createKeywordClusters() async {
    final keywordNeuronsMap = <String, List<int>>{};
    final keywordScores = <String, double>{};
    
    for (final neuron in neurons.values) {
      if (neuron.id == 0) continue;
      
      final topKeywords = _getTopKeywordsForNeuron(neuron, 10);
      for (final keyword in topKeywords) {
        if (!keywordNeuronsMap.containsKey(keyword)) {
          keywordNeuronsMap[keyword] = [];
        }
        keywordNeuronsMap[keyword]!.add(neuron.id);
        
        final wordEntry = wordIndex[keyword];

        double allRatingWordEntry = (words[wordEntry]!.allRating ?? 0).toDouble();
        double neuronAllRating = (neuron.allRating ?? 0).toDouble();
    keywordScores[keyword] = keywordScores[keyword] ?? 0.0 + allRatingWordEntry +neuronAllRating;
      }
    }
    
    final sortedKeywords = keywordScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    for (final entry in sortedKeywords) {
      final keyword = entry.key;
      final neuronIds = keywordNeuronsMap[keyword]!;
      
      if (neuronIds.length >= 5) {
        await _createKeywordClusterHierarchy(keyword, neuronIds);
      }
    }
  }
  
  Future<void> _createKeywordClusterHierarchy(String keyword, List<int> neuronIds) async {
    const maxNeuronsPerCluster = 100;
    int clusterIndex = 0;
    
    for (int i = 0; i < neuronIds.length; i += maxNeuronsPerCluster) {
      final endIndex = min(i + maxNeuronsPerCluster, neuronIds.length);
      final clusterNeuronIds = neuronIds.sublist(i, endIndex);
      
      final clusterId = 'keyword_${keyword.hashCode}_$clusterIndex';
      clusterIndex++;
      
      if (!clusters.containsKey(clusterId)) {
        final cluster = NeuronCluster(
          id: clusterId,
          type: 'keyword',
          title: '$keyword [${clusterIndex + 1}]',
          keyword: keyword,
          neuronIds: clusterNeuronIds,
          depth: 1,
          size: 1.0,
        );
        
        clusters[clusterId] = cluster;
        clusters['root']!.childClusterIds.add(clusterId);
        cluster.parentClusterId = 'root';
      } else {
        clusters[clusterId]!.neuronIds = clusterNeuronIds;
        clusters[clusterId]!.updateSignature( this);
      }
    }
  }
  
  List<String> _getTopKeywordsForNeuron(Neuron neuron, int limit) {

  final wordScores = <int, double>{};
  
  // –°–Ω–∞—á–∞–ª–∞ –≤—ã—á–∏—Å–ª—è–µ–º scores –¥–ª—è —Å–ª–æ–≤ –∏–∑ signatureRatings –Ω–µ–π—Ä–æ–Ω–∞
   for (final wordId in neuron.signatureRatings.keys) {
    final word = network.words[wordId];
    if (word != null) {
      double score = neuron.signatureRatings[wordId]!.toDouble();
      for (final otherWordId in network.words.keys) {
        final otherWord = network.words[otherWordId];
        if (otherWord != word) {
          final connection = network.words[otherWordId]!.ratings[wordId] ?? 0;
          score += connection * 0.1;
        }
      }
      wordScores[wordId] = score;
    }
  }
  
  
  final sortedWords = wordScores.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));
  
  // –¢–æ–ø-15 —Å —Å–∞–º—ã–º –≤—ã—Å–æ–∫–∏–º —Ä–µ–π—Ç–∏–Ω–≥–æ–º
  final topKeywords = sortedWords
      .take(15)
      .map((entry) => network.wordLibrary[entry.key] ?? 'unknown')
      .where((word) => word.length > 2)
      .toList();
  
  // –î–ª—è –Ω–∏–∂–Ω–∏—Ö 5 –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–π—Ç–∏–Ω–≥ –∏–∑ network.words
  final bottomWords = <MapEntry<int, double>>[];
  
  for (final wordId in neuron.signatureRatings.keys) {
    final word = network.words[wordId];
    if (word != null) {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º allRating –∏–∑ network.words –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–µ–π—Ç–∏–Ω–≥
      final globalScore = word.allRating.toDouble();
      bottomWords.add(MapEntry(wordId, globalScore));
    }
  }
  
  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é —Ä–µ–π—Ç–∏–Ω–≥–∞ –∏–∑ network.words
  bottomWords.sort((a, b) => a.value.compareTo(b.value));
  
  final bottomKeywords = bottomWords
      .take(5)
      .map((entry) => network.wordLibrary[entry.key] ?? 'unknown')
      .where((word) => word.length > 2)
      .toList();
  
  return [...topKeywords, ...bottomKeywords];
}


  // ========== –ü–û–ó–ò–¶–ò–û–ù–ò–†–û–í–ê–ù–ò–ï –ö–õ–ê–°–¢–ï–†–û–í ==========
  void _positionAllClusters() {
    print('üìç Positioning ${clusters.length} clusters');
    
    clusters['root']?.updatePosition(0.0, 0.0, 0.0);
    //3_positionChildClusters('root', 0.0, 0.0, 0);
    
    for (final cluster in clusters.values) {
      cluster.updateSignature(  this);
    }
  }
  
  void _positionChildClusters(String parentId, double parentX, double parentY, int depth) {
    final parent = clusters[parentId];
    if (parent == null) return;
    
    final children = parent.childClusterIds
        .map((id) => clusters[id])
        .whereType<NeuronCluster>()
        .toList();
    
    if (children.isEmpty) return;
    
    final angleStep = (2 * pi) / children.length;
    final radius = 250.0 + (depth * 50.0);
    
    for (int i = 0; i < children.length; i++) {
      final child = children[i];
      final angle = i * angleStep;
      
      double childX, childY, childZ;
      
      // –ß–µ—Ä–µ–¥—É–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è: —á–µ—Ç–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ - –≤–≤–µ—Ä—Ö, –Ω–µ—á–µ—Ç–Ω–∞—è - –≤–ø—Ä–∞–≤–æ
      if (depth % 2 == 0) {
        // –í–≤–µ—Ä—Ö
        childX = parentX + radius * cos(angle) * 0.3;
        childY = parentY - radius * 0.8;
        childZ = radius * sin(angle) * 0.5;
      } else {
        // –í–ø—Ä–∞–≤–æ
        childX = parentX + radius * 0.8;
        childY = parentY + radius * sin(angle) * 0.3;
        childZ = radius * cos(angle) * 0.5;
      }
      
      //child?.updatePosition(childX, childY, childZ);
      child?.depth = depth + 1;
      child?.size = 1.0 / (depth * 0.3 + 1);
      
      // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –¥–µ—Ç–µ–π, –Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–ª–∞—Å—Ç–µ—Ä —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç
      if (child?.isExpanded == true) {
        _positionChildClusters(child!.id, childX, childY, depth + 1);
      }
    }
  }
  
  // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î - —É–±–∏—Ä–∞–µ–º —Ä–µ–∫—É—Ä—Å–∏—é
  int _countExpandedChildren(String clusterId) {
    final cluster = clusters[clusterId];
    if (cluster == null) return 0;
    
    int count = 0;
    final queue = Queue<String>();
    queue.addAll(cluster.childClusterIds);
    
    while (queue.isNotEmpty) {
      final currentId = queue.removeFirst();
      final current = clusters[currentId];
      if (current == null) continue;
      
      if (current.isExpanded) {
        count++;
        queue.addAll(current.childClusterIds);
        
        // –ï—Å–ª–∏ —ç—Ç–æ –ª–∏—Å—Ç–æ–≤–æ–π –∫–ª–∞—Å—Ç–µ—Ä, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–µ–π—Ä–æ–Ω—ã
        if (current.childClusterIds.isEmpty) {
          count += current.neuronIds.length.toInt();
        }
      }
    }
    
    return count;
  }

  // ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–õ–ê–°–¢–ï–†–ê–ú–ò –ò –ê–ù–ò–ú–ê–¶–ò–Ø ==========
  Future<void> toggleClusterExpansion(String clusterId) async {
    final cluster = clusters[clusterId];
    if (cluster == null || _isAnimating) return;
    
    _isAnimating = true;
    
    clusterHistory.add(clusterId);
    historyIndex = clusterHistory.length - 1;
    
    if (cluster.isExpanded) {
      await _collapseCluster(cluster);
    } else {
      await _expandCluster(cluster);
    }
    
    _isAnimating = false;
    await _saveClustersToFile();
  }
  
  Future<void> _expandCluster(NeuronCluster cluster) async {
    cluster.isExpanded = true;
    expandedClusterIds.add(cluster.id);
    
    for (final childId in cluster.childClusterIds) {
      final child = clusters[childId];
      if (child != null) {
        child.isVisible = true;
        child.updatePosition(child.targetX, child.targetY, child.targetZ);
      }
    }
    
    if (cluster.childClusterIds.isEmpty) {
      _positionNeuronsInCluster(cluster);
    }
    
    await _animateClusterExpansion(cluster);
    _adjustCameraToFitClusters();
  }
  
  Future<void> _collapseCluster(NeuronCluster cluster) async {
    cluster.isExpanded = false;
    expandedClusterIds.remove(cluster.id);
    
    _hideAllChildren(cluster.id);
    _resetNeuronsToCluster(cluster);
    
    await _animateClusterCollapse(cluster);
    _adjustCameraToFitClusters();
  }
  
  void _hideAllChildren(String clusterId) {
    final cluster = clusters[clusterId];
    if (cluster == null) return;
    
    for (final childId in cluster.childClusterIds) {
      final child = clusters[childId];
      if (child != null) {
        child.isVisible = false;
        child.isExpanded = false;
        expandedClusterIds.remove(childId);
        _hideAllChildren(childId);
      }
    }
  }

  Future<void> _animateClusterExpansion(NeuronCluster cluster) async {
    final stages = <AnimationStage>[];
    final childCount = cluster.childClusterIds.length;
    
    stages.add(AnimationStage(
      duration: 0.1,
      action: () {
        cluster.size = 1.2;
        cluster.startGlow();
      },
    ));
    
    for (int i = 0; i < cluster.childClusterIds.length; i++) {
      final childId = cluster.childClusterIds[i];
      final child = clusters[childId];
      if (child != null) {
        final duration = 0.15 - (i * 0.01);
        stages.add(AnimationStage(
          duration: duration.clamp(0.05, 0.15),
          action: () {
            child.isVisible = true;
            child.animationProgress = 0.0;
            child.sourceX = cluster.x;
            child.sourceY = cluster.y;
            child.sourceZ = cluster.z;
            child.startGlow();
          },
        ));
      }
    }
    
    stages.add(AnimationStage(
      duration: 0.05,
      action: () {
        cluster.size = 1.0;
      },
    ));
    
    await _executeAnimationStages(stages);
  }
  
  Future<void> _animateClusterCollapse(NeuronCluster cluster) async {
    final stages = <AnimationStage>[];
    
    stages.add(AnimationStage(
      duration: 0.1,
      action: () {
        cluster.size = 0.9;
        cluster.startGlow();
      },
    ));
    
    stages.add(AnimationStage(
      duration: 0.1,
      action: () {
        cluster.size = 1.0;
      },
    ));
    
    await _executeAnimationStages(stages);
  }
  
  Future<void> _executeAnimationStages(List<AnimationStage> stages) async {
    for (final stage in stages) {
      stage.action();
      await Future.delayed(Duration(milliseconds: (stage.duration * 1000).round()));
    }
  }
  
  void _positionNeuronsInCluster(NeuronCluster cluster) {
    final clusterNeurons = cluster.neuronIds
        .map((id) => neurons[id])
        .whereType<Neuron>()
        .toList();
    
    final angleStep = pi / (clusterNeurons.length + 1);
    
    for (int i = 0; i < clusterNeurons.length; i++) {
      final neuron = clusterNeurons[i];
      final angle = (i + 1) * angleStep;
      final radius = 150.0;
      
      neuron.x = cluster.x + radius * cos(angle - pi/2);
      neuron.y = cluster.y + radius * sin(angle - pi/2);
      neuron.z = cluster.z;
    }
  }
  
  void _resetNeuronsToCluster(NeuronCluster cluster) {
    final random = Random(cluster.id.hashCode);
    
    for (final neuronId in cluster.neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      neuron.x = cluster.x + random.nextDouble() * 40 - 20;
      neuron.y = cluster.y + random.nextDouble() * 40 - 20;
      neuron.z = cluster.z;
    }
  }

  // ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–ï–†–ï–¢–ê–°–ö–ò–í–ê–ù–ò–ï–ú ==========
  void startClusterDrag(String clusterId, Offset startOffset) {
    final cluster = clusters[clusterId];
    if (cluster == null) return;
    
    _draggedClusterId = clusterId;
    _dragStartOffset = startOffset;
    _clusterStartOffset = Offset(cluster.x, cluster.y);
    cluster.startDrag();
  }
  
  void updateClusterDrag(Offset currentOffset) {
    if (_draggedClusterId == null || _dragStartOffset == null || _clusterStartOffset == null) return;
    
    final cluster = clusters[_draggedClusterId!];
    if (cluster == null) return;
    
    final delta = currentOffset - _dragStartOffset!;
    final newX = _clusterStartOffset!.dx + delta.dx / _cameraScale;
    final newY = _clusterStartOffset!.dy + delta.dy / _cameraScale;
    
    cluster.updatePosition(newX, newY, cluster.z);
    
    if (cluster.isExpanded) {
      _moveNeuronsWithCluster(cluster, newX, newY);
    }
  }
  
  void endClusterDrag() {
    if (_draggedClusterId != null) {
      final cluster = clusters[_draggedClusterId!];
      cluster?.endDrag();
    }
    
    _draggedClusterId = null;
    _dragStartOffset = null;
    _clusterStartOffset = null;
  }
  
  void _moveNeuronsWithCluster(NeuronCluster cluster, double newX, double newY) {
    final deltaX = newX - cluster.x;
    final deltaY = newY - cluster.y;
    
    for (final neuronId in cluster.neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron != null) {
        neuron.x += deltaX;
        neuron.y += deltaY;
      }
    }
  }

  // ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–ê–ú–ï–†–û–ô ==========
  void _adjustCameraToFitClusters() {
    if (clusters.isEmpty) return;
    
    double minX = double.infinity;
    double maxX = double.negativeInfinity;
    double minY = double.infinity;
    double maxY = double.negativeInfinity;
    
    for (final cluster in clusters.values) {
      if (!cluster.isVisible) continue;
      
      minX = min(minX, cluster.x);
      maxX = max(maxX, cluster.x);
      minY = min(minY, cluster.y);
      maxY = max(maxY, cluster.y);
    }
    
    final centerX = (minX + maxX) / 2;
    final centerY = (minY + maxY) / 2;
    final width = maxX - minX;
    final height = maxY - minY;
    final maxDimension = max(width, height);
    
    _cameraX = -centerX;
    _cameraY = -centerY;
    _cameraScale = maxDimension > 0 ? 800 / maxDimension : 1.0;
  }
  
  void moveCameraToNeuron(int neuronId) {
    final neuron = neurons[neuronId];
    if (neuron == null) return;
    
    _cameraX = -neuron.x;
    _cameraY = -neuron.y;
    _cameraScale = 2.0;
  }

  // ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–°–¢–û–†–ò–ï–ô –ò –ü–û–ò–°–ö–û–ú ==========
  void undo() {
    if (historyIndex > 0) {
      historyIndex--;
      final clusterId = clusterHistory[historyIndex];
      final cluster = clusters[clusterId];
      if (cluster != null && cluster.isExpanded) {
        toggleClusterExpansion(clusterId);
      }
    }
  }
  
  void redo() {
    if (historyIndex < clusterHistory.length - 1) {
      historyIndex++;
      final clusterId = clusterHistory[historyIndex];
      final cluster = clusters[clusterId];
      if (cluster != null && !cluster.isExpanded) {
        toggleClusterExpansion(clusterId);
      }
    }
  }
  
  void setSearchedNeurons(Set<int> neuronIds) {
    searchedNeurons.clear();
    searchedNeurons.addAll(neuronIds);
    currentSearchIndex = searchedNeurons.isNotEmpty ? 0 : -1;
    
    _expandClustersToNeurons(neuronIds);
    if (neuronIds.isNotEmpty) {
      moveCameraToNeuron(neuronIds.first);
    }
  }
  
  void _expandClustersToNeurons(Set<int> neuronIds) {
    final clustersToExpand = <String>{};
    
    for (final neuronId in neuronIds) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      for (final cluster in clusters.values) {
        if (cluster.neuronIds.contains(neuronId)) {
          _addClusterAndAncestorsToSet(cluster.id, clustersToExpand);
        }
      }
    }
    
    for (final clusterId in clustersToExpand) {
      final cluster = clusters[clusterId];
      if (cluster != null && !cluster.isExpanded) {
        toggleClusterExpansion(clusterId);
      }
    }
  }
  
  void _addClusterAndAncestorsToSet(String clusterId, Set<String> clusterSet) {
    if (clusterSet.contains(clusterId)) return;
    
    clusterSet.add(clusterId);
    
    final cluster = clusters[clusterId];
    if (cluster?.parentClusterId != null) {
      _addClusterAndAncestorsToSet(cluster!.parentClusterId!, clusterSet);
    }
  }
  
  void navigateToNextSearchedNeuron() {
    if (searchedNeurons.isEmpty) return;
    
    currentSearchIndex = (currentSearchIndex + 1) % searchedNeurons.length;
    _focusOnNeuron(searchedNeurons.elementAt(currentSearchIndex));
  }
  
  void navigateToPreviousSearchedNeuron() {
    if (searchedNeurons.isEmpty) return;
    
    currentSearchIndex = (currentSearchIndex - 1) % searchedNeurons.length;
    if (currentSearchIndex < 0) currentSearchIndex = searchedNeurons.length - 1;
    
    _focusOnNeuron(searchedNeurons.elementAt(currentSearchIndex));
  }
  
  void _focusOnNeuron(int neuronId) {
    moveCameraToNeuron(neuronId);
  }

  // ========== –°–û–•–†–ê–ù–ï–ù–ò–ï –ò –ó–ê–ì–†–£–ó–ö–ê ==========
  Future<void> _saveClustersToFile() async {
    try {
      final clustersJson = {
        'clusters': clusters.values.map((cluster) => cluster.toJson()).toList(),
        'lastUpdated': DateTime.now().toIso8601String(),
      };
      
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/$clustersDataPath');
      await file.create(recursive: true);
      await file.writeAsString(jsonEncode(clustersJson));
      
      print('üíæ Clusters saved to: $clustersDataPath');
    } catch (e) {
      print('‚ùå Error saving clusters: $e');
    }
  }
  
  Future<void> _loadClustersFromFile() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/$clustersDataPath');
      
      if (await file.exists()) {
        final data = await file.readAsString();
        final jsonData = jsonDecode(data);
        clusters.clear();
        
        for (final clusterJson in jsonData['clusters']) {
          final cluster = NeuronCluster.fromJson(clusterJson);
          clusters[cluster.id] = cluster;
        }
        
        print('üìÇ Loaded ${clusters.length} clusters from file');
      }
    } catch (e) {
      print('‚ùå Error loading clusters: $e');
      clusters.clear();
    }
  }



  // ========== –û–°–¢–ê–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ ==========
  void setState(VoidCallback fn) {
    fn();
  }

  List<String> _extractWords(String text) {
    return text
        .toLowerCase()
        .split(RegExp(r'[^\w–∞-—è–ê-–Ø—ë–Å]+', unicode: true))
        .where((w) => w.length > 2)
        .toList();
  }



  Future<void> trainTest(Function(String) onProgress) async {
    onProgress('–ù–∞—á–∞–ª–æ –æ–±—É—á–µ–Ω–∏—è...');
    
    for (int chapter = 1; chapter <= 121; chapter++) {
      final url = 'https://hpmor.ru/book/1/$chapter/';
      
      onProgress('–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–ª–∞–≤—ã $chapter/121...');
      
      try {
        await processWebsite(url, onProgress);
        
        final fragmentCount = fragments.length;
        final wordCount = words.length;
        onProgress('–ì–ª–∞–≤–∞ $chapter: $wordCount —Å–ª–æ–≤, $fragmentCount —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤');
        
        final recentFragments = fragments.values
            .where((f) => f.id > max(0, fragmentCount - 50))
            .take(10)
            .toList();
        
        for (final fragment in recentFragments) {
          final shortText = fragment.text.length > 60 
              ? fragment.text.substring(0, 60) + "..." 
              : fragment.text;
        }
        
        final topWords = getTopWords(10);
        final topWordsText = topWords
            .map((w) => '${wordLibrary[w.id]}:${w.allRating}')
            .join(', ');
        onProgress('  –¢–æ–ø —Å–ª–æ–≤–∞: $topWordsText');
        
        if (chapter % 10 == 0) {
          await saveToFile();
          onProgress('–ß–µ–∫–ø–æ–∏–Ω—Ç –≥–ª–∞–≤—ã $chapter —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
        }
      } catch (e) {
        onProgress('–û—à–∏–±–∫–∞ –≥–ª–∞–≤—ã $chapter: $e');
      }
      
      await Future.delayed(Duration(milliseconds: 100));
    }
    
    await saveToFile();
    onProgress('–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! ${words.length} —Å–ª–æ–≤, ${fragments.length} —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤');
  }


  Future<void> trainTest2(Function(String) onProgress) async {
    onProgress('–ù–∞—á–∞–ª–æ –æ–±—É—á–µ–Ω–∏—è...');
    
    for (int chapter = 1; chapter <= 98; chapter++) {
      final url = 'https://strugacki.ru/book_25/${1002+chapter}.html';
      
      onProgress('–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–ª–∞–≤—ã $chapter/93...');
      
      try {
        await processWebsite(url, onProgress);
        
        final fragmentCount = fragments.length;
        final wordCount = words.length;
        onProgress('–ì–ª–∞–≤–∞ $chapter: $wordCount —Å–ª–æ–≤, $fragmentCount —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤');
        
        final recentFragments = fragments.values
            .where((f) => f.id > max(0, fragmentCount - 50))
            .take(10)
            .toList();
        
        for (final fragment in recentFragments) {
          final shortText = fragment.text.length > 60 
              ? fragment.text.substring(0, 60) + "..." 
              : fragment.text;
        }
        
        final topWords = getTopWords(10);
        final topWordsText = topWords
            .map((w) => '${wordLibrary[w.id]}:${w.allRating}')
            .join(', ');
        onProgress('  –¢–æ–ø —Å–ª–æ–≤–∞: $topWordsText');
        
        if (chapter % 10 == 0) {
          await saveToFile();
          onProgress('–ß–µ–∫–ø–æ–∏–Ω—Ç –≥–ª–∞–≤—ã $chapter —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
        }
      } catch (e) {
        onProgress('–û—à–∏–±–∫–∞ –≥–ª–∞–≤—ã $chapter: $e');
      }
      
      await Future.delayed(Duration(milliseconds: 1000));
    }
    
    await saveToFile();
    onProgress('–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! ${words.length} —Å–ª–æ–≤, ${fragments.length} —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤');
  }
  
  List<int> _removeDuplicateFragments(List<int> fragmentIds) {
    final seenTexts = <String>{};
    final uniqueIds = <int>[];
    
    for (final id in fragmentIds) {
      final fragment = fragments[id];
      if (fragment != null && !seenTexts.contains(fragment.text)) {
        seenTexts.add(fragment.text);
        uniqueIds.add(id);
      }
    }
    return uniqueIds;
  }
  
  Future<List<int>> _generateLine2WithPossibilityVector(List<int> line1Words, List<int> promptWordIds) async {
    final possibilityVector = <int, int>{};
    
    for (final wordId in line1Words) {
      for (final fragment in fragments.values) {
        final wordIds = fragment.wordIds;
        for (int i = 0; i < wordIds.length - 1; i++) {
          if (wordIds[i] == wordId) {
            final nextWordId = wordIds[i + 1];
            if (!STOP_WORDS.contains(wordLibrary[nextWordId])) {
              possibilityVector[nextWordId] = (possibilityVector[nextWordId] ?? 0) + 1;
            }
          }
        }
      }
    }
    
    if (possibilityVector.isEmpty) {
      final line2SuperVector = <int, int>{};
      for (final wordId in line1Words) {
        final word = words[wordId];
        if (word != null) {
          for (final entry in word.ratings.entries) {
            line2SuperVector[entry.key] = 
                (line2SuperVector[entry.key] ?? 0) + entry.value;
          }
        }
      }
      
      return (line2SuperVector.entries.toList()
        ..sort((a, b) => b.value.compareTo(a.value)))
          .take(50)
          .map((e) => e.key)
          .toList();
    }
    
    final totalOccurrences = possibilityVector.values.fold(0, (a, b) => a + b);
    final weightVector = <int, double>{};
    for (final entry in possibilityVector.entries) {
      weightVector[entry.key] = entry.value / totalOccurrences;
    }
    
    final scoredWords = <int, double>{};
    for (final wordId in weightVector.keys) {
      final word = words[wordId];
      if (word != null) {
        final wordVectorSum = word.ratings.values.fold(0, (a, b) => a + b);
        final contextScore = wordVectorSum > 0 ? word.allRating / wordVectorSum : 0.0;
        scoredWords[wordId] = weightVector[wordId]! * contextScore;
      }
    }
    
    return (scoredWords.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value)))
        .take(50)
        .map((e) => e.key)
        .toList();
  }

/// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—è—Ç–æ–π –ª–∏–Ω–∏–∏ - –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º allRating
Future<List<int>> makeLine5ForAPrompt(List<int> promptWordIds) async {
  if (promptWordIds.isEmpty) {
    
    await AppLogger.writeLog("makeLine5 no prompt");
    return [];}
  
  // –°—Ç—Ä–æ–∏–º —Å—É–ø–µ—Ä–≤–µ–∫—Ç–æ—Ä –∏–∑ –ø—Ä–æ–º–ø—Ç–∞
  final promptSuperVector = <int, int>{};
  for (final wordId in promptWordIds) {
    final word = words[wordId];
    if (word != null) {
      for (final entry in word.ratings.entries) {
        promptSuperVector[entry.key] = (promptSuperVector[entry.key] ?? 0) + entry.value;
      }
    }
  }
  
  // –°–∞–º–æ–ø—Ä–æ–µ–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞
  final promptVector = VectorOperations.selfProjection(promptSuperVector, words);
  if (promptVector.isEmpty) return [];
  
  // –ù–∞—Ö–æ–¥–∏–º —Å–ª–æ–≤–∞ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ–º –∏ –≤—ã—Å–æ–∫–∏–º allRating
  final wordScores = <int, _WordScore>{};
  
  for (final wordId in promptVector.keys) {
    final word = words[wordId];
    if (word == null) continue;
    
    // –í—ã—á–∏—Å–ª—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤ (—Å—Ö–æ–∂–µ—Å—Ç—å)
    double vectorIntersection = 0.0;
    for (final entry in word.ratings.entries) {
      if (promptVector.containsKey(entry.key)) {
        vectorIntersection += min(entry.value, promptVector[entry.key]!).toDouble();
      }
    }
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ
    final maxPossibleIntersection = word.ratings.values.fold(0, (a, b) => a + b);
    final normalizedIntersection = maxPossibleIntersection > 0 ? 
        vectorIntersection / maxPossibleIntersection : 0.0;
    
    // –£—á–∏—Ç—ã–≤–∞–µ–º allRating
    final allRatingScore = word.allRating / 1000000.0; // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º
    
    // –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π score: 70% –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ, 30% allRating
    final combinedScore = (normalizedIntersection * 0.7) + (allRatingScore * 0.3);
    
    wordScores[wordId] = _WordScore(
      wordId: wordId,
      intersectionScore: normalizedIntersection,
      allRatingScore: allRatingScore,
      combinedScore: combinedScore,
    );
  }
  
  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–º—É score
  final sortedScores = wordScores.values.toList()
    ..sort((a, b) => b.combinedScore.compareTo(a.combinedScore));
  await AppLogger.writeLog("makeLine5 finished with ${sortedScores.length} output");
  // –ë–µ—Ä–µ–º —Ç–æ–ø 50 —Å–ª–æ–≤
  return sortedScores.take(50).map((score) => score.wordId).toList();
}



/// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞ –ø–æ —Ñ–æ—Ä–º—É–ª–µ: (rating1/allRating1 + rating2/allRating2) / 2
Map<int, double> _normalizeVectorWithMutualProbability(Map<int, int> vector) {
  final normalized = <int, double>{};
  final wordIds = vector.keys.toList();
  
  // –î–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã —Å–ª–æ–≤ –≤ –≤–µ–∫—Ç–æ—Ä–µ –≤—ã—á–∏—Å–ª—è–µ–º –≤–∑–∞–∏–º–Ω—É—é –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å
  for (int i = 0; i < wordIds.length; i++) {
    final word1Id = wordIds[i];
    final word1 = network.words[word1Id];
    if (word1 == null) continue;
    
    for (int j = 0; j < wordIds.length; j++) {
      if (i == j) continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ —Å–ª–æ–≤–∞
      
      final word2Id = wordIds[j];
      final word2 = network.words[word2Id];
      if (word2 == null) continue;
      
      // –í—ã—á–∏—Å–ª—è–µ–º –≤–∑–∞–∏–º–Ω—ã–µ —Ä–µ–π—Ç–∏–Ω–≥–∏
      final rating1to2 = word1.ratings[word2Id] ?? 0;
      final rating2to1 = word2.ratings[word1Id] ?? 0;
      
      // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–æ—Ä–º—É–ª—É: (rating1/allRating1 + rating2/allRating2) / 2
      final prob1 = word1.allRating > 0 ? rating1to2 / word1.allRating : 0;
      final prob2 = word2.allRating > 0 ? rating2to1 / word2.allRating : 0;
      
      final mutualProbability = (prob1 + prob2) / 2;
      
      // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –º–µ–∂–¥—É –æ–±–æ–∏–º–∏ —Å–ª–æ–≤–∞–º–∏
      normalized[word1Id] = (normalized[word1Id] ?? 0) + mutualProbability;
      normalized[word2Id] = (normalized[word2Id] ?? 0) + mutualProbability;
    }
  }
  
  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —á—Ç–æ–±—ã —Å—É–º–º–∞ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π = 1
  final total = normalized.values.fold(0.0, (a, b) => a + b);
  if (total > 0) {
    for (final key in normalized.keys) {
      normalized[key] = normalized[key]! / total;
    }
  }
  
  return normalized;
}
_VectorStats _analyzeVector(Map<int, int> vector) {
  if (vector.isEmpty) {
    return _VectorStats(
      network: network,
      minValue: 0.0,
      maxValue: 0.0,
      valueRange: 0.0,
      mean: 0.0,
      standardDeviation: 0.0,
    );
  }

  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–µ–∫—Ç–æ—Ä –ø–æ —Ñ–æ—Ä–º—É–ª–µ –≤–∑–∞–∏–º–Ω—ã—Ö –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π
  final normalizedVector = _normalizeVectorWithMutualProbability(vector);
  
  final values = normalizedVector.values.toList();
  final minValue = values.reduce((a, b) => a < b ? a : b);
  final maxValue = values.reduce((a, b) => a > b ? a : b);
  final valueRange = maxValue - minValue;
  
  final mean = values.fold(0.0, (a, b) => a + b) / values.length;
  final variance = values.map((v) => pow(v - mean, 2)).fold(0.0, (a, b) => a + b) / values.length;
  final standardDeviation = sqrt(variance);

  return _VectorStats(
    network: network,
    minValue: minValue,
    maxValue: maxValue,
    valueRange: valueRange,
    mean: mean,
    standardDeviation: standardDeviation,
  );
}




/// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ ‚Äî ¬´line8¬ª ‚Äî –æ—Å–º—ã—Å–ª–µ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç (string)
Future<String> makeLine8ForAPrompt(List<int> promptWordIds) async {
  if (promptWordIds.isEmpty) {
    await AppLogger.writeLog("makeLine8 no prompt");
    return '';
  }

  // –ü–æ–ª—É—á–∞–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –∏–∑ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
  final results = await Future.wait([
   makeLine6ForAPrompt(promptWordIds),
    makeLine5ForAPrompt(promptWordIds),
  ]);

  final candidates7 = results[0]; // –≤–µ—Ä–æ—è—Ç–Ω–æ –±–æ–ª–µ–µ ¬´—Å–ª–æ–∂–Ω—ã–µ¬ª –∫–∞–Ω–¥–∏–¥–∞—Ç—ã
  final candidates5 = results[1]; // –±–æ–ª–µ–µ —á–∞—Å—Ç–æ—Ç–Ω—ã–µ / –≥–ª–æ–±–∞–ª—å–Ω—ã–µ

  // –°–æ–±–∏—Ä–∞–µ–º –∏ –≤–∑–≤–µ—à–∏–≤–∞–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
  final scoreMap = <int, double>{};
  int pos = 0;
  for (final id in candidates7) {
    // –¥–∞—ë–º –±–æ–ª—å—à–∏–π –≤–µ—Å —Ç–µ–º —á—Ç–æ –∏–∑ makeLine7 (—Ä–∞–Ω–≥ + allRating)
    final w = words[id];
    final base = (w?.allRating ?? 1).toDouble();
    scoreMap[id] = (scoreMap[id] ?? 0.0) + base * (1.0 + (100.0 / (1 + pos)));
    pos++;
  }
  pos = 0;
  for (final id in candidates5) {
    final w = words[id];
    final base = (w?.allRating ?? 1).toDouble();
    scoreMap[id] = (scoreMap[id] ?? 0.0) + base * (0.6 + (50.0 / (1 + pos)));
    pos++;
  }

  if (scoreMap.isEmpty) {
    await AppLogger.writeLog("makeLine8 no candidates");
    return '';
  }

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –ø–æ —Å–∫–æ—Ä—É
  final sorted = scoreMap.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));

  // –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã, —Å—Ç–æ–ø-—Å–ª–æ–≤–∞ –∏ —Å–æ–±–∏—Ä–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫
  final used = <int>{};
  final finalIds = <int>[];
  final rng = Random();

  // –°–ø–∏—Å–æ–∫ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–æ–≤ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
  final connectors = ['–∏', '–Ω–æ', '–∞', '—Ç–∞–∫–∂–µ', '–∑–∞—Ç–µ–º', '–æ–¥–Ω–∞–∫–æ'];

  // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–æ–ø-—Å–ª–æ–≤ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π STOP_WORDS set)
  bool isStopWordId(int id) {
    final wname = wordLibrary[id];
    if (wname == null) return true;
    return STOP_WORDS.contains(wname.toLowerCase());
  }

  // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –≤–∑—è—Ç—å –ø–µ—Ä–≤—ã–π –∑–Ω–∞—á–∏–º—ã–π (–Ω–µ-—Å—Ç–æ–ø) –∫–∞–∫ –Ω–∞—á–∞–ª–æ
  for (final e in sorted) {
    final id = e.key;
    if (used.contains(id)) continue;
    if (isStopWordId(id)) continue;
    finalIds.add(id);
    used.add(id);
    break;
  }

  // –ó–∞—Ç–µ–º –¥–æ–±–∞–≤–ª—è–µ–º –µ—â—ë —Å–ª–æ–≤ –¥–æ –¥–ª–∏–Ω—ã –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è (6..12)
  final targetLen = min(12, max(6, 6 + rng.nextInt(7))); // 6..12
  for (final e in sorted) {
    if (finalIds.length >= targetLen) break;
    final id = e.key;
    if (used.contains(id)) continue;
    finalIds.add(id);
    used.add(id);
  }

  // –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–æ—Å—å –º–∞–ª–æ —Å–ª–æ–≤ ‚Äî –¥–æ–±–∞–≤–∏–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–ø-—Å–ª–æ–≤ –ø–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
  if (finalIds.length < 4) {
    for (final e in sorted) {
      if (finalIds.length >= 4) break;
      final id = e.key;
      if (used.contains(id)) continue;
      finalIds.add(id);
      used.add(id);
    }
  }

  // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ —Å –ø—Ä–æ—Å—Ç—ã–º–∏ —Å–≤—è–∑–∫–∞–º–∏: –≤—Å—Ç–∞–≤–ª—è–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä
  final wordsOut = <String>[];
  for (int i = 0; i < finalIds.length; i++) {
    final id = finalIds[i];
    final token = wordLibrary[id] ?? '';
    if (token.isEmpty) continue;

    // –ò–Ω–æ–≥–¥–∞ –≤—Å—Ç–∞–≤–ª—è–µ–º —Å–≤—è–∑–∫—É –ø–µ—Ä–µ–¥ —Å–ª–æ–≤–æ–º –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
    if (i > 1 && rng.nextDouble() < 0.18) {
      wordsOut.add(connectors[rng.nextInt(connectors.length)]);
    }

    wordsOut.add(token);
  }

  if (wordsOut.isEmpty) return '';

  // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ –≤–∞–ª–∏–¥–Ω—É—é —Ñ—Ä–∞–∑—É: –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –ø—É–Ω–∫—Ç—É–∞—Ü–∏–∏, –∑–∞–≥–ª–∞–≤–Ω–∞—è –±—É–∫–≤–∞
  String sentence = wordsOut.join(' ');

  // –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –ø–µ—Ä–µ–¥ –∑–∞–ø—è—Ç—ã–º–∏/—Ç–æ—á–∫–∞–º–∏ (–µ—Å–ª–∏ —Ç–∞–∫–∏–µ –≤–æ–∑–Ω–∏–∫–Ω—É—Ç)
  sentence = sentence.replaceAll(RegExp(r'\s+,'), ',');
  sentence = sentence.replaceAll(RegExp(r'\s+\.'), '.');

  // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª–∏–Ω—ã —Å–∏–º–≤–æ–ª–æ–≤ (–±–µ–∑ —Ä–∞–∑—Ä—ã–≤–∞ —Å–ª–æ–≤)
  if (sentence.length > 240) {
    sentence = sentence.substring(0, 240);
    // –û–±—Ä–µ–∑–∞–µ–º –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø—Ä–æ–±–µ–ª–∞ —á—Ç–æ–±—ã –Ω–µ —Ä–µ–∑–∞—Ç—å —Å–ª–æ–≤–æ
    final lastSpace = sentence.lastIndexOf(' ');
    if (lastSpace > 0) sentence = sentence.substring(0, lastSpace);
    sentence = sentence.trim();
    sentence = sentence + '...';
  }

  // –ó–∞–≥–ª–∞–≤–Ω–∞—è –ø–µ—Ä–≤–∞—è –±—É–∫–≤–∞
  sentence = sentence.trim();
  if (sentence.isNotEmpty) {
    sentence = sentence[0].toUpperCase() + sentence.substring(1);
  }

  // –ó–∞–≤–µ—Ä—à–∞—é—â–∏–π –∑–Ω–∞–∫
  if (!RegExp(r'[.!?]$').hasMatch(sentence)) {
    sentence = '$sentence.';
  }

  await AppLogger.writeLog("makeLine8 finished: $sentence");
  return sentence;
}


Future<List<int>> makeLine7ForAPrompt(List<int> promptWordIds) async {
  if (promptWordIds.isEmpty) {
    await AppLogger.writeLog("makeLine7 no prompt");
    return [];
  }
  return [];

  // –ö—ç—à–∏—Ä—É–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã —Å–ª–æ–≤ —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞—Ç—å –∫–∞–∂–¥—ã–π —Ä–∞–∑
  final normalizedWordCache = <int, Map<int, double>>{};
  
  // –°—Ç—Ä–æ–∏–º —Å—É–ø–µ—Ä–≤–µ–∫—Ç–æ—Ä –∏–∑ –ø—Ä–æ–º–ø—Ç–∞ –∏ —Å–∞–º–æ–ø—Ä–æ–µ–∫—Ü–∏—è
  final promptSuperVector = <int, int>{};
  for (final wordId in promptWordIds) {
    final word = words[wordId];
    if (word != null) {
      for (final entry in word.ratings.entries) {
        promptSuperVector[entry.key] = (promptSuperVector[entry.key] ?? 0) + entry.value;
      }
    }
  }
  
  final originalPromptVector = VectorOperations.selfProjection(promptSuperVector, words);
  if (originalPromptVector.isEmpty) return [];

  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –ø–æ –Ω–æ–≤–æ–π —Ñ–æ—Ä–º—É–ª–µ
  final normalizedPromptVector = _normalizeVectorWithFormula(originalPromptVector);
  
  final resultWords = <int>[];
  Map<int, double> currentVector = Map<int, double>.from(normalizedPromptVector);
  final usedWordIds = Set<int>.from(promptWordIds);
  
  // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ allRating –¥–ª—è –±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∏
  int highRatingCount = 0;
  int mediumRatingCount = 0;
  int lowRatingCount = 0;

  // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –≤—ã—á–∏—Å–ª—è–µ–º —Ç–µ–Ω–∑–æ—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–º–ø—Ç–∞
  Map<int, double> processedVector = _applyTensorOperations(currentVector);
  double currentEntropy = _calculateShannonEntropy(processedVector);
  _VectorStats vectorStats = _analyzeEnhancedVector(processedVector);

  // –ü–æ—à–∞–≥–æ–≤–æ –¥–æ–±–∞–≤–ª—è–µ–º 11 —Å–ª–æ–≤ —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π
  for (int step = 0; step < 9; step++) {
    final allRatingBalance = _calculateAllRatingBalance(highRatingCount, mediumRatingCount, lowRatingCount);
    
    final strategy = _determineEnhancedStrategy(
      currentEntropy, 
      vectorStats, 
      allRatingBalance,
      step
    );

    await AppLogger.writeLog(
      "Step $step: entropy=${currentEntropy.toStringAsFixed(3)}, "
      "balance=[H:$highRatingCount M:$mediumRatingCount L:$lowRatingCount]"
    );

    final candidateScores = <int, _EnhancedCandidateScore>{};

    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∏—Å–∫ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ —Ç–æ–ª—å–∫–æ —Ç–æ–ø-N —Å–ª–æ–≤ –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞
    final candidateWordIds = _getTopCandidateWords(processedVector, 100); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ 100 –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤

    for (final wordId in candidateWordIds) {
      if (usedWordIds.contains(wordId)) continue;
      
      final word = words[wordId];
      if (word == null) continue;

      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ —Å–ª–æ–≤–∞
      final wordNormalized = normalizedWordCache[wordId] ?? _normalizeWordVector(word);
      normalizedWordCache[wordId] = wordNormalized;

      // –ë—ã—Å—Ç—Ä–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ö–æ–¥—Å—Ç–≤–∞ –±–µ–∑ –ø–æ–ª–Ω–æ–≥–æ –ø–µ—Ä–µ–±–æ—Ä–∞
      final similarityScore = _calculateFastSimilarity(processedVector, wordNormalized);
      
      // –ë—ã—Å—Ç—Ä–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ (–ø—Ä–æ—Å—Ç–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ)
      final predictedVector = _fastVectorAddition(processedVector, wordNormalized);
      
      // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–Ω–∑–æ—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∫ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–º—É –≤–µ–∫—Ç–æ—Ä—É
      final predictedProcessedVector = _applyTensorOperations(predictedVector);
      final predictedEntropy = _calculateShannonEntropy(predictedProcessedVector);
      final entropyChange = predictedEntropy - currentEntropy;

      // –û—Ü–µ–Ω–∫–∞ –±–∞–ª–∞–Ω—Å–∞ allRating
      final wordAllRating = word.allRating;
      final allRatingScore = _evaluateAllRatingContribution(
        wordAllRating, 
        strategy, 
        highRatingCount, 
        mediumRatingCount, 
        lowRatingCount
      );

      final combinedScore = strategy.calculateScore(
        similarityScore: similarityScore,
        entropyChange: entropyChange,
        allRatingScore: allRatingScore,
        currentStep: step,
      );

      candidateScores[wordId] = _EnhancedCandidateScore(
        wordId: wordId,
        similarityScore: similarityScore,
        entropyChange: entropyChange,
        allRatingScore: allRatingScore,
        combinedScore: combinedScore,
        wordAllRating: wordAllRating,
      );
    }

    if (candidateScores.isEmpty) break;

    // –í—ã–±–∏—Ä–∞–µ–º –ª—É—á—à–µ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
    final bestCandidate = _getBestCandidate(candidateScores);
    final bestWordId = bestCandidate.wordId;
    final bestWord = words[bestWordId];

    // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–≤–æ –∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    resultWords.add(bestWordId);
    usedWordIds.add(bestWordId);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫–∏ allRating
    if (bestWord != null) {
      if (bestWord.allRating > 500000) highRatingCount++;
      else if (bestWord.allRating > 100000) mediumRatingCount++;
      else lowRatingCount++;
    }

    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ë—ã—Å—Ç—Ä–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞
    final bestWordNormalized = normalizedWordCache[bestWordId] ?? _normalizeWordVector(bestWord!);
    currentVector = _fastVectorAddition(currentVector, bestWordNormalized!);
    
    // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –û–±–Ω–æ–≤–ª—è–µ–º processedVector –∏ —ç–Ω—Ç—Ä–æ–ø–∏—é –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω–æ
    processedVector = _applyTensorOperations(currentVector);
    currentEntropy = _calculateShannonEntropy(processedVector);
    vectorStats = _analyzeEnhancedVector(processedVector);

    // –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏–µ —Å –ø—Ä–æ–º–ø—Ç–æ–º
    _fastReconcileWithPrompt(currentVector, normalizedPromptVector, step / 11.0);
  }
final line7 = resultWords.map((id)=>wordLibrary[id]??'').join(' ');
  await AppLogger.writeLog("makeLine7 finished with ${resultWords.length} words: ${resultWords} line7: ${line7}");
  

  return resultWords;
}

/// –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò

/// –ë—ã—Å—Ç—Ä–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤
Map<int, double> _fastVectorAddition(Map<int, double> vector1, Map<int, double> vector2) {
  final result = Map<int, double>.from(vector1);
  for (final entry in vector2.entries) {
    result[entry.key] = (result[entry.key] ?? 0) + entry.value;
  }
  return result;
}

/// –ë—ã—Å—Ç—Ä–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ö–æ–¥—Å—Ç–≤–∞
double _calculateFastSimilarity(Map<int, double> vector, Map<int, double> wordVector) {
  double similarity = 0.0;
  int commonCount = 0;
  
  // –ò—Ç–µ—Ä–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø–æ –º–µ–Ω—å—à–µ–º—É –≤–µ–∫—Ç–æ—Ä—É –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
  final searchVector = wordVector.length < vector.length ? wordVector : vector;
  final targetVector = wordVector.length < vector.length ? vector : wordVector;
  
  for (final entry in searchVector.entries) {
    if (targetVector.containsKey(entry.key)) {
      similarity += min(entry.value, targetVector[entry.key]!);
      commonCount++;
    }
  }
  
  return commonCount > 0 ? similarity / commonCount : 0.0;
}

/// –í—ã–±–æ—Ä —Ç–æ–ø-N –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞
List<int> _getTopCandidateWords(Map<int, double> vector, int limit) {
  final entries = vector.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));
  
  final topWords = entries.take(limit).map((e) => e.key).toList();
  final bottomWords = entries.reversed.take(15).map((e) => e.key).toList();
  
  return [...topWords, ...bottomWords];
}

/// –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
_EnhancedCandidateScore _getBestCandidate(Map<int, _EnhancedCandidateScore> candidates) {
  _EnhancedCandidateScore? bestCandidate;
  double bestScore = -double.infinity;
  
  for (final candidate in candidates.values) {
    if (candidate.combinedScore > bestScore) {
      bestScore = candidate.combinedScore;
      bestCandidate = candidate;
    }
  }
  
  return bestCandidate!;
}

/// –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏–µ —Å –ø—Ä–æ–º–ø—Ç–æ–º
void _fastReconcileWithPrompt(
  Map<int, double> currentVector, 
  Map<int, double> promptVector, 
  double progress
) {
  final promptWeight = 0.3 * (1.0 - progress);
  
  for (final entry in promptVector.entries) {
    currentVector[entry.key] = (currentVector[entry.key] ?? 0) * (1 - promptWeight) + 
                              entry.value * promptWeight;
  }
}
 
double _calculateShannonEntropy(Map<int, double> vector) {
  if (vector.isEmpty) return 0.0;

  final values = vector.values.toList();
  final total = values.fold(0.0, (a, b) => a + b);
  
  if (total <= 0 || total.isInfinite || total.isNaN) return 0.0;

  double entropy = 0.0;
  for (final value in values) {
    if (value <= 0) continue;
    final probability = value / total;
    if (probability > 0 && !probability.isInfinite && !probability.isNaN) {
      entropy -= probability * log(probability);
    }
  }

  // –ó–∞—â–∏—Ç–∞ –æ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
  return entropy.isNaN || entropy.isInfinite ? 0.0 : entropy;
}
/// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞ –ø–æ —Ñ–æ—Ä–º—É–ª–µ: (rating1/allRating1 + rating2/allRating2) / 2
Map<int, double> _normalizeVectorWithFormula(Map<int, int> vector) {
  final normalized = <int, double>{};
  final wordIds = vector.keys.toList();
  
  for (int i = 0; i < wordIds.length; i++) {
    for (int j = i + 1; j < wordIds.length; j++) {
      final word1Id = wordIds[i];
      final word2Id = wordIds[j];
      
      final word1 = words[word1Id];
      final word2 = words[word2Id];
      
      if (word1 == null || word2 == null) continue;
      
      final rating1to2 = word1.ratings[word2Id] ?? 0;
      final rating2to1 = word2.ratings[word1Id] ?? 0;
      
      final prob1 = word1.allRating > 0 ? rating1to2 / word1.allRating : 0;
      final prob2 = word2.allRating > 0 ? rating2to1 / word2.allRating : 0;
      
      final mutualWeight = (prob1 + prob2) / 2;
      
      // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–µ—Å –º–µ–∂–¥—É –æ–±–æ–∏–º–∏ —Å–ª–æ–≤–∞–º–∏
      normalized[word1Id] = (normalized[word1Id] ?? 0) + mutualWeight;
      normalized[word2Id] = (normalized[word2Id] ?? 0) + mutualWeight;
    }
  }
  
  return normalized;
}

/// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Å–ª–æ–≤–∞
Map<int, double> _normalizeWordVector(Word word) {
  final normalized = <int, double>{};
  
  for (final entry in word.ratings.entries) {
    final otherWord = words[entry.key];
    if (otherWord != null) {
      final rating1to2 = entry.value;
      final rating2to1 = otherWord.ratings[word.id] ?? 0;
      
      final prob1 = word.allRating > 0 ? rating1to2 / word.allRating : 0;
      final prob2 = otherWord.allRating > 0 ? rating2to1 / otherWord.allRating : 0;
      
      final mutualWeight = (prob1 + prob2) / 2;
      
      normalized[entry.key] = mutualWeight;
    }
  }
  
  return normalized;
}

/// –¢–µ–Ω–∑–æ—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–µ–∫—Ç–æ—Ä–∞
Map<int, double> _applyTensorOperations(Map<int, double> vector) {
  if (vector.isEmpty) return vector;
  
  final processed = Map<int, double>.from(vector);
  
  // 1. –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è L2 —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
  final l2Norm = sqrt(vector.values.map((v) => v * v).fold(0.0, (a, b) => a + b));
  if (l2Norm > 1e-10) { // –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º –º–∞–ª—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
    for (final key in processed.keys) {
      processed[key] = processed[key]! / l2Norm;
    }
  }
  
  // 2. –ù–µ–ª–∏–Ω–µ–π–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º
  for (final key in processed.keys) {
    processed[key] = max(0.0, min(1.0, processed[key]! * 1.5 - 0.2)); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω
  }
  
  // 3. Softmax —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è
  final maxVal = processed.values.fold(-double.infinity, (a, b) => max(a, b));
  final expValues = processed.values.map((v) => exp(v - maxVal)).toList(); // –°—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏—è
  final sumExp = expValues.fold(0.0, (a, b) => a + b);
  
  if (sumExp > 1e-10) {
    final keys = processed.keys.toList();
    for (int i = 0; i < keys.length; i++) {
      processed[keys[i]] = expValues[i] / sumExp;
    }
  }
  
  return processed;
}
/// –†–∞—Å—á–µ—Ç –±–∞–ª–∞–Ω—Å–∞ allRating
double _calculateAllRatingBalance(int high, int medium, int low) {
  final total = high + medium + low;
  if (total == 0) return 0.5;
  
  final highRatio = high / total;
  final lowRatio = low / total;
  
  // –ò–¥–µ–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å: 40% high, 30% medium, 30% low
  const idealHigh = 0.4;
  const idealLow = 0.3;
  
  final highDeviation = (highRatio - idealHigh).abs();
  final lowDeviation = (lowRatio - idealLow).abs();
  
  return 1.0 - (highDeviation + lowDeviation) / 2;
}



/// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —à–µ—Å—Ç–æ–π –ª–∏–Ω–∏–∏ - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π allRating, –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–≤—è–∑—å
Future<List<int>> makeLine6ForAPrompt(List<int> promptWordIds) async {
    if (promptWordIds.isEmpty) {
    
    await AppLogger.writeLog("makeLine6 no prompt");
    return [];}
  
  // –°—Ç—Ä–æ–∏–º —Å—É–ø–µ—Ä–≤–µ–∫—Ç–æ—Ä –∏–∑ –ø—Ä–æ–º–ø—Ç–∞
  final promptSuperVector = <int, int>{};
  for (final wordId in promptWordIds) {
    final word = words[wordId];
    if (word != null) {
      for (final entry in word.ratings.entries) {
        promptSuperVector[entry.key] = (promptSuperVector[entry.key] ?? 0) + entry.value;
      }
    }
  }
  
  final promptVector = VectorOperations.selfProjection(promptSuperVector, words);
  if (promptVector.isEmpty) return [];
  
  final wordScores = <int, _WordScore>{};
  
  for (final wordId in promptVector.keys) {
    final word = words[wordId];
    if (word == null) continue;
    
    // –í—ã—á–∏—Å–ª—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤
    double vectorIntersection = 0.0;
    for (final entry in word.ratings.entries) {
      if (promptVector.containsKey(entry.key)) {
        vectorIntersection += min(entry.value, promptVector[entry.key]!).toDouble();
      }
    }
    
    final maxPossibleIntersection = word.ratings.values.fold(0, (a, b) => a + b);
    final normalizedIntersection = maxPossibleIntersection > 0 ? 
        vectorIntersection / maxPossibleIntersection : 0.0;
    
    // –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º allRating (—á–µ–º –º–µ–Ω—å—à–µ - —Ç–µ–º –ª—É—á—à–µ)
    final invertedAllRating = 1.0 / (word.allRating + 1); // +1 —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥–µ–ª–µ–Ω–∏—è –Ω–∞ 0
    
    // –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π score: 80% –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ, 20% –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π allRating
    final combinedScore = (normalizedIntersection * 0.8) + (invertedAllRating * 0.2);
    
    wordScores[wordId] = _WordScore(
      wordId: wordId,
      intersectionScore: normalizedIntersection,
      allRatingScore: invertedAllRating,
      combinedScore: combinedScore,
    );
  }
  
  final sortedScores = wordScores.values.toList()
    ..sort((a, b) => b.combinedScore.compareTo(a.combinedScore));
  await AppLogger.writeLog("makeLine6 finished with ${sortedScores.length} output");
  return sortedScores.take(50).map((score) => score.wordId).toList();
}

  // ========== –û–ë–†–ê–ë–û–¢–ö–ê –ó–ê–ü–†–û–°–û–í ==========

/// –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
Future<Map<String, dynamic>> processQueryAdvanced(String query) async {
  final wordTexts = _extractWords(query);
  final promptWordIds = wordTexts
      .map((w) => wordIndex[w])
      .where((id) => id != null)
      .cast<int>()
      .toList();
  
  if (promptWordIds.isEmpty) {
    return {'line1': '', 'line2': '', 'line3': '', 'line5': '', 'line6': '','line7':'', 'fragments': []};
  }
  
  currentSearchWords = promptWordIds;
  //selectedWordIds = promptWordIds.toSet();
  final querySemantics = SemanticAnalyzer.analyzeSemantics(query);
  
  final superVector = <int, int>{};
  for (final wordId in promptWordIds) {
    final word = words[wordId];
    if (word != null) {
      for (final entry in word.ratings.entries) {
        superVector[entry.key] = (superVector[entry.key] ?? 0) + entry.value;
      }
    }
  }
  
  final promptVector = VectorOperations.selfProjection(superVector, words);
  currentSearchVector = promptVector;
  
  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –ª–∏–Ω–∏–π
  final line1Words = promptWordIds.take(10).toList();
  final line1 = line1Words.map((id) => wordLibrary[id] ?? '').join(' ');
  
  final line2Words = await _generateLine2WithPossibilityVector(line1Words, promptWordIds);
  final line2 = TextNormalizer.normalizeText(
      line2Words.map((id) => wordLibrary[id] ?? '').join(' '));
  
  final line3Fragments = await _findFragmentsWithMaxCoverage(promptVector, promptWordIds, querySemantics);
  final uniqueFragments = _removeDuplicateFragments(line3Fragments);
  final line3 = uniqueFragments
      .take(10)
      .map((id) => fragments[id]?.text ?? '')
      .join(' ... ');
  
  // –ù–æ–≤—ã–µ –ª–∏–Ω–∏–∏ 5 –∏ 6
  final line5Words = await makeLine5ForAPrompt(promptWordIds);
  final line5 = line5Words.take(20).map((id) => wordLibrary[id] ?? '').join(' ');
  
  final line6Words = await makeLine6ForAPrompt(promptWordIds);
  final line6 = line6Words.take(20).map((id) => wordLibrary[id] ?? '').join(' ');
  

  final line7Words = await makeLine7ForAPrompt(promptWordIds);
  final line7 = line7Words.map((id)=>wordLibrary[id]??'').join(' ');
  await AppLogger.writeLog("generated line7: ${line7}");
 
 final pkg = Package(
    id: nextPackageId++,
    signature: promptWordIds,
    keywords: promptWordIds,
    status: PackageStatus.through,
    fragmentLinks: List.from(uniqueFragments),
  );
  await AppLogger.writeLog("generated line7: ${line7}");
    AppLogger.writeLog("package made");
  packages[pkg.id] = pkg;
  
  await _routePackage(pkg, 0, <int>{});
   await AppLogger.writeLog("package sent and returned");
  final uniqueResultFragments = _removeDuplicateFragments(pkg.fragmentLinks)
      .take(100)
      .map((id) => fragments[id]?.text ?? '')
      .where((t) => t.isNotEmpty)
      .toList();
  
  return {
    'line1': line1,
    'line2': line2,
    'line3': line3,
    'line5': line5,
    'line6': line6,
    'line7': line7,
    'fragments': uniqueResultFragments,
    'package_status': pkg.status.toString(),
    'semantics': querySemantics,
  };
}


  OptimizedNeuralNetwork get self => this;
  
  // –∏–ª–∏
  OptimizedNeuralNetwork get network => this;
/// –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –≤–µ–∫—Ç–æ—Ä–∞ —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
/// –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –≤–µ–∫—Ç–æ—Ä–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π double
_VectorStats _analyzeEnhancedVector(Map<int, double> vector) {
  if (vector.isEmpty) {
    return _VectorStats(
      network: network,
      minValue: 0.0,
      maxValue: 0.0,
      valueRange: 0.0,
      mean: 0.0,
      standardDeviation: 0.0,
    );
  }

  final values = vector.values.toList();
  final minValue = values.reduce((a, b) => a < b ? a : b);
  final maxValue = values.reduce((a, b) => a > b ? a : b);
  final valueRange = maxValue - minValue;
  
  final mean = values.fold(0.0, (a, b) => a + b) / values.length;
  final variance = values.map((v) => pow(v - mean, 2)).fold(0.0, (a, b) => a + b) / values.length;
  final standardDeviation = sqrt(variance);

  return _VectorStats(
    network: network,
    minValue: minValue,
    maxValue: maxValue,
    valueRange: valueRange,
    mean: mean,
    standardDeviation: standardDeviation,
  );
}
/// –†–∞—Å—á–µ—Ç —Å—Ö–æ–¥—Å—Ç–≤–∞ –º–µ–∂–¥—É –≤–µ–∫—Ç–æ—Ä–æ–º –∏ —Å–ª–æ–≤–æ–º
double _calculateVectorSimilarity(Map<int, double> vector, Word word) {
  double similarity = 0.0;
  int commonWords = 0;
  
  for (final entry in word.ratings.entries) {
    if (vector.containsKey(entry.key)) {
      final wordObj = words[entry.key];
      if (wordObj != null) {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –≤–µ—Å–∞
        final rating1to2 = entry.value;
        final rating2to1 = wordObj.ratings[word.id] ?? 0;
        
        final prob1 = word.allRating > 0 ? rating1to2 / word.allRating : 0;
        final prob2 = wordObj.allRating > 0 ? rating2to1 / wordObj.allRating : 0;
        
        final mutualWeight = (prob1 + prob2) / 2;
        final vectorWeight = vector[entry.key] ?? 0;
        
        similarity += min(mutualWeight, vectorWeight);
        commonWords++;
      }
    }
  }
  
  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –æ–±—â–∏—Ö —Å–ª–æ–≤
  return commonWords > 0 ? similarity / commonWords : 0.0;
}

/// –û—Ü–µ–Ω–∫–∞ –≤–∫–ª–∞–¥–∞ allRating –≤ –±–∞–ª–∞–Ω—Å
double _evaluateAllRatingContribution(
  int wordAllRating, 
  _EnhancedStrategy strategy,
  int highCount, 
  int mediumCount, 
  int lowCount
) {
  final total = highCount + mediumCount + lowCount;
  if (total == 0) return 1.0;
  
  final highRatio = highCount / total;
  final lowRatio = lowCount / total;
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ–≤–∞
  final bool isHighRating = wordAllRating > 500000;
  final bool isLowRating = wordAllRating < 100000;
  
  // –û—Ü–µ–Ω–∏–≤–∞–µ–º –Ω—É–∂–Ω–æ—Å—Ç—å —ç—Ç–æ–≥–æ —Å–ª–æ–≤–∞ –¥–ª—è –±–∞–ª–∞–Ω—Å–∞
  if (strategy.preferHighRating && isHighRating) {
    // –ù–∞–≥—Ä–∞–∂–¥–∞–µ–º –≤—ã—Å–æ–∫–æ—Ä–µ–π—Ç–∏–Ω–≥–æ–≤—ã–µ —Å–ª–æ–≤–∞ –µ—Å–ª–∏ –∏—Ö –º–∞–ª–æ
    return highRatio < 0.4 ? 1.5 : 0.8;
  }
  
  if (strategy.preferLowRating && isLowRating) {
    // –ù–∞–≥—Ä–∞–∂–¥–∞–µ–º –Ω–∏–∑–∫–æ—Ä–µ–π—Ç–∏–Ω–≥–æ–≤—ã–µ —Å–ª–æ–≤–∞ –µ—Å–ª–∏ –∏—Ö –º–∞–ª–æ
    return lowRatio < 0.3 ? 1.5 : 0.8;
  }
  
  if (!strategy.preferHighRating && isHighRating) {
    // –®—Ç—Ä–∞—Ñ—É–µ–º –≤—ã—Å–æ–∫–æ—Ä–µ–π—Ç–∏–Ω–≥–æ–≤—ã–µ —Å–ª–æ–≤–∞ –µ—Å–ª–∏ –∏—Ö –º–Ω–æ–≥–æ
    return highRatio > 0.5 ? 0.3 : 0.7;
  }
  
  if (!strategy.preferLowRating && isLowRating) {
    // –®—Ç—Ä–∞—Ñ—É–µ–º –Ω–∏–∑–∫–æ—Ä–µ–π—Ç–∏–Ω–≥–æ–≤—ã–µ —Å–ª–æ–≤–∞ –µ—Å–ª–∏ –∏—Ö –º–Ω–æ–≥–æ
    return lowRatio > 0.4 ? 0.3 : 0.7;
  }
  
  // –°—Ä–µ–¥–Ω–µ—Ä–µ–π—Ç–∏–Ω–≥–æ–≤—ã–µ —Å–ª–æ–≤–∞ –≤—Å–µ–≥–¥–∞ —Ö–æ—Ä–æ—à–∏ –¥–ª—è –±–∞–ª–∞–Ω—Å–∞
  return 1.0;
}

/// –°–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ —Å –ø—Ä–æ–º–ø—Ç–æ–º
void _reconcileWithPromptVector(
  Map<int, double> currentVector, 
  Map<int, double> promptVector, 
  double progress
) {
  // –í–µ—Å –ø—Ä–æ–º–ø—Ç–∞ —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è –ø–æ –º–µ—Ä–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
  final promptWeight = 0.5 * (1.0 - progress);
  final currentWeight = 1.0 - promptWeight;
  
  // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä –∫–ª—é—á–µ–π
  final allKeys = {...currentVector.keys, ...promptVector.keys};
  
  for (final key in allKeys) {
    final currentValue = currentVector[key] ?? 0;
    final promptValue = promptVector[key] ?? 0;
    
    // –í–∑–≤–µ—à–µ–Ω–Ω–æ–µ —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ
    currentVector[key] = (currentValue * currentWeight) + (promptValue * promptWeight);
  }
  
  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  final maxValue = currentVector.values.fold(0.0, (a, b) => max(a, b));
  if (maxValue > 0) {
    for (final key in currentVector.keys) {
      currentVector[key] = currentVector[key]! / maxValue;
    }
  }
}
  Future<void> _routePackage(Package pkg, int synapseId, Set<int> visited) async {
    if (pkg.status == PackageStatus.done) return;
    if (pkg.fragmentLinks.length >= 100) {
      pkg.status = PackageStatus.done;
      pkg.neuronLinks.add(0);
      return;
    }
    
    if (visited.contains(synapseId)) return;
    visited.add(synapseId);
    
    final synapse = synapses[synapseId];
    if (synapse == null) return;
    
    // –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –ø–∞–∫–µ—Ç–∞
    final pkgKeywords = _getPackageKeywords(pkg);
    final minKeywordMatch = (pkgKeywords.length * 0.15).ceil(); // 15% –æ—Ç –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
    
    for (final neuronId in synapse.neuronLinks) {
      final neuron = neurons[neuronId];
      if (neuron == null) continue;
      
      final similarity = _calculateSimilarity(pkg.signatureRatings, neuron.signatureRatings);
      
      if (similarity >= 0.7) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –ø–∞–∫–µ—Ç—ã –Ω–µ–π—Ä–æ–Ω–∞
        for (final packageId in neuron.packageLinks) {
          final permPkg = packages[packageId];
          if (permPkg != null && (permPkg.status == PackageStatus.permanent || permPkg.status == PackageStatus.done)) {
            // –§–∏–ª—å—Ç—Ä—É–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
            final filteredFragments = _filterFragmentsByKeywords(
              permPkg.fragmentLinks, 
              pkgKeywords, 
              minKeywordMatch
            );
            pkg.fragmentLinks.addAll(filteredFragments);
          }
        }
        
        // –§–∏–ª—å—Ç—Ä—É–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –Ω–µ–π—Ä–æ–Ω–∞ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
        final filteredNeuronFragments = _filterFragmentsByKeywords(
          neuron.fragmentLinks, 
          pkgKeywords, 
          minKeywordMatch
        );
        pkg.fragmentLinks.addAll(filteredNeuronFragments);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ —Å–≤—è–∑–µ–π –º–µ–∂–¥—É –Ω–µ–π—Ä–æ–Ω–∞–º–∏
        for (final linkedNeuronId in pkg.neuronLinks) {
          final linkedNeuron = neurons[linkedNeuronId];
          if (linkedNeuron != null && linkedNeuronId != neuronId) {
            linkedNeuron.neuronRatings[neuronId] = 
                (linkedNeuron.neuronRatings[neuronId] ?? 0) + (similarity * 100).round().toInt();
            neuron.neuronRatings[linkedNeuronId] = 
                (neuron.neuronRatings[linkedNeuronId] ?? 0) + (similarity * 100).round().toInt();
          }
        }
        
        if (pkg.fragmentLinks.length >= 100) {
          pkg.status = PackageStatus.done;
          pkg.neuronLinks.add(neuronId);
          neurons[neuronId]!.packageLinks.add(pkg.id);
          return;
        }
      }
    }
    
    for (final linkedSynapseId in synapse.synapseLinks) {
      if (linkedSynapseId != synapseId && !visited.contains(linkedSynapseId)) {
        await _routePackage(pkg, linkedSynapseId, visited);
        if (pkg.status == PackageStatus.done) return;
      }
    }
  }

  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã

  /// –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ –ø–∞–∫–µ—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ signatureRatings
  List<int> _getPackageKeywords(Package pkg) {
    final keywordScores = <int, double>{};
    
    for (final entry in pkg.signatureRatings.entries) {
      final wordId = entry.key;
      final score = entry.value;

      keywordScores[wordId] = score.toDouble();
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é —Ä–µ–π—Ç–∏–Ω–≥–∞ –∏ –±–µ—Ä–µ–º —Ç–æ–ø-20
    final sortedKeywords = keywordScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedKeywords
        .take(40)
        .map((entry) => entry.key)
        .toList();
  }

  /// –§–∏–ª—å—Ç—Ä—É–µ—Ç —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
  List<int> _filterFragmentsByKeywords(
    List<int> fragmentIds, 
    List<int> keywords, 
    int minKeywordMatch
  ) {
    if (keywords.isEmpty || minKeywordMatch == 0) {
      return fragmentIds; // –ï—Å–ª–∏ –Ω–µ—Ç –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã
    }
    
    final filteredFragments = <int>[];
    
    for (final fragmentId in fragmentIds) {
      final fragment = fragments[fragmentId];
      if (fragment == null) continue;

      // –°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
      int matchCount = 0;
      for (final keyword in keywords) {
 
        if (fragment.wordIds.contains(keyword)) {
          matchCount++;
          if (matchCount >= minKeywordMatch) {
            break; // –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
          }
        }
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç –µ—Å–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
      if (matchCount >= minKeywordMatch) {
        filteredFragments.add(fragmentId);
      }
    }
    
    return filteredFragments;
  }

  /// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º signature —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤
  List<int> _filterFragmentsBySignature(
    List<int> fragmentIds, 
    List<int> pkgKeywords, 
    int minKeywordMatch
  ) {
    if (pkgKeywords.isEmpty || minKeywordMatch == 0) {
      return fragmentIds;
    }
    
    final filteredFragments = <int>[];
    
    for (final fragmentId in fragmentIds) {
      final fragment = fragments[fragmentId];
      if (fragment == null) continue;
      
      // –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ –∏–∑ –µ–≥–æ signature
      final fragmentKeywords = _getFragmentKeywords(fragment);
      
      // –°—á–∏—Ç–∞–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
      final intersection = pkgKeywords.toSet().intersection(
        fragmentKeywords.toSet()
      );
      
      // –î–æ–±–∞–≤–ª—è–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç –µ—Å–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
      if (intersection.length >= minKeywordMatch) {
        filteredFragments.add(fragmentId);
      }
    }
    
    return filteredFragments;
  }

  /// –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ signature
  List<int> _getFragmentKeywords(Fragment fragment) {
    final keywords = <int>[];
    
    for (final wordId in fragment.wordIds) {
      keywords.add(wordId);
    }
    
    return keywords;
  }
double _calculateSimilarity(Map<int, int> sig1, Map<int, int> sig2) {
  if (sig1.isEmpty || sig2.isEmpty) return 0.0;
  
  // –ù–∞—Ö–æ–¥–∏–º –æ–±—â–∏–µ —Å–ª–æ–≤–∞
  final commonWords = sig1.keys.toSet().intersection(sig2.keys.toSet());
  if (commonWords.isEmpty) return 0.0;
  
  // –í—ã—á–∏—Å–ª—è–µ–º —Å—É–º–º—ã –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏
  final sum1 = sig1.values.reduce((a, b) => a + b).toDouble();
  final sum2 = sig2.values.reduce((a, b) => a + b).toDouble();
  
  double totalSimilarity = 0.0;
  int count = 0;
  
  for (final wordId in commonWords) {
    final value1 = sig1[wordId]!.toDouble();
    final value2 = sig2[wordId]!.toDouble();
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
    final normalized1 = value1 / sum1;
    final normalized2 = value2 / sum2;
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤
    final vectorRatio = normalized1 / ((normalized2 / ((value1 + value2) / 2)));
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∫ –æ–±—â–µ–π —Å—Ö–æ–∂–µ—Å—Ç–∏
    totalSimilarity += vectorRatio;
    count++;
  }
  
  return count > 0 ? totalSimilarity / count : 0.0;
}
Future<void> processWebsite(String url, Function(String) onProgress) async {
    try {
      final client = http.Client();
      final response = await client.get(Uri.parse(url));
      client.close();
      
      if (response.statusCode != 200) {
        onProgress('  –û—à–∏–±–∫–∞ HTTP: ${response.statusCode}');
        return;
      }

      // –£–ª—É—á—à–µ–Ω–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏
      String html;
      final contentType = response.headers['content-type'];
      
      if (contentType?.contains('windows-1251') == true) {
        html = await _decodeWindows1251(response.bodyBytes);
        onProgress('  –î–µ–∫–æ–¥–∏—Ä—É–µ–º windows-1251');
      } else {
        // –ü—Ä–æ–±—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–¥–∏—Ä–æ–≤–∫—É –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É
        html = await _autoDetectEncoding(response.bodyBytes);
        onProgress('  –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏');
      }

      final document = html_parser.parse(html);
      
      String? pageTitle;
      final titleElement = document.querySelector('title');
      if (titleElement != null) {
        pageTitle = titleElement.text.trim();
        onProgress('  –ó–∞–≥–æ–ª–æ–≤–æ–∫: $pageTitle');
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∞
        if (_containsGibberish(pageTitle)) {
          onProgress('  ‚ö†Ô∏è –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã - –ø—Ä–æ–±–ª–µ–º–∞ —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π');
        }
      }

      final texts = <String>[];
      String fullContent = '';
      
      // –¶–µ–ª–µ–≤—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è —ç—Ç–æ–≥–æ —Å–∞–π—Ç–∞
   
        onProgress('  –ü—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã...');
        final alternativeSelectors = ['p', '.text', 'div', 'span','p.text','div.cont p', '.text p'];
        for (final selector in alternativeSelectors) {
          final elements = document.querySelectorAll(selector);
          onProgress('  –°–µ–ª–µ–∫—Ç–æ—Ä $selector: ${elements.length} —ç–ª–µ–º–µ–Ω—Ç–æ–≤');
          for (final element in elements) {
            final text = element.text.trim();
            if (text.length > 30 && 
                !_containsGibberish(text) &&
                !_isNavigation(text)) {
              texts.add(text);
              fullContent += text + ' ';
              
            }
          }
        
        }
   

      // –ï—Å–ª–∏ –≤—Å–µ –µ—â–µ –ø—É—Å—Ç–æ, –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –≤–µ—Å—å —Ç–µ–∫—Å—Ç –∏–∑ body
      if (texts.isEmpty) {
        onProgress('  –ü—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –≤–µ—Å—å —Ç–µ–∫—Å—Ç –∏–∑ body...');
        final bodyText = document.body?.text ?? '';
        if (bodyText.length > 100 && !_containsGibberish(bodyText)) {
          // –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
          final sentences = bodyText.split(RegExp(r'[.!?]+'));
          for (final sentence in sentences) {
            final trimmed = sentence.trim();
            if (trimmed.length > 20 && !_isNavigation(trimmed)) {
              texts.add(trimmed);
              fullContent += trimmed + ' ';
            }
          }
        }
      }

      onProgress('  –ò—Ç–æ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –±–ª–æ–∫–æ–≤: ${texts.length}');
      onProgress('  –û–±—â–∏–π –æ–±—ä–µ–º —Ç–µ–∫—Å—Ç–∞: ${fullContent.length} —Å–∏–º–≤–æ–ª–æ–≤');
      
      if (texts.isEmpty) {
        onProgress('  –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ');
        
        // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏ –≤—ã–≤–µ–¥–µ–º –ø–µ—Ä–≤—ã–µ 500 —Å–∏–º–≤–æ–ª–æ–≤ —Å—ã—Ä–æ–≥–æ HTML
        final rawPreview = html.length > 500 ? html.substring(0, 500) + '...' : html;
        onProgress('  –°—ã—Ä–æ–π HTML (–ø–µ—Ä–≤—ã–µ 500 —Å–∏–º–≤–æ–ª–æ–≤): $rawPreview');
        return;
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –∏–∑–≤–ª–µ—á–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
      if (_containsGibberish(fullContent)) {
        onProgress('  ‚ö†Ô∏è –ò–∑–≤–ª–µ—á–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã');
      }
      
      final neuronId = nextNeuronId++;
      final synapseId = nextSynapseId++;
      
      onProgress('  –°–æ–∑–¥–∞–µ–º –Ω–µ–π—Ä–æ–Ω #$neuronId...');
      
      final synapse = Synapse(id: synapseId);
      synapses[synapseId] = synapse;
      
      final neuron = Neuron(
        network: this, 
        id: neuronId,
        personalSynapseId: synapseId,
        sourceUrl: url,
        pageTitle: pageTitle,
        fullPageContent: fullContent.trim(),
      );
      neurons[neuronId] = neuron;
      
      synapse.neuronLinks.add(neuronId);
      
      if (neurons.length > 1) {
        final rootSynapse = synapses[0]!;
        rootSynapse.synapseLinks.add(synapseId);
        synapse.synapseLinks.add(0);
      }
      
      final allWordIds = <int>[];
      onProgress('  –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç—ã...');
      
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç—ã —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
      for (int i = 0; i < texts.length; i++) {
        onProgress('  –¢–µ–∫—Å—Ç ${i + 1}/${texts.length}...');
        await _processText(texts[i], neuron, allWordIds);
      }
      
      if (allWordIds.isNotEmpty) {
        neuron.updateSignature(allWordIds,network);
        onProgress('  –°–∏–≥–Ω–∞—Ç—É—Ä–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞: ${allWordIds.length} —Å–ª–æ–≤');
      }
      
      onProgress('  –°–æ–∑–¥–∞–µ–º –ø–∞–∫–µ—Ç—ã –¥–ª—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤...');
      for (final fragmentId in neuron.fragmentLinks) {
        final fragment = fragments[fragmentId];
        if (fragment != null && fragment.wordIds.isNotEmpty) {
          await _createPackageForFragment(fragment, neuron);
        }
      }
      
      await _checkNeuronSimilarity(neuron, onProgress);
      //await neuron.express(this);
      onProgress('  Express —Å–æ–∑–¥–∞–Ω –¥–ª—è –Ω–µ–π—Ä–æ–Ω–∞ #$neuronId');
      
      //await updateClusters();
      onProgress('  ‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
      
    } catch (e) {
      onProgress('  ‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ: $e');
    }
  }

Future<String> _decodeWindows1251(List<int> bytes) async {
  try {
    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º List<int> –≤ Uint8List
    final uint8List = Uint8List.fromList(bytes);
    final result = await CharsetConverter.decode('windows-1251', uint8List);
    return result ?? utf8.decode(bytes, allowMalformed: true);
  } catch (e) {
    return utf8.decode(bytes, allowMalformed: true);
  }
}
String _manualEncodingFix(String text) {
  final replacements = {
    '√ê': '–ù', '√ë': '–û', '√í': '–ü', '√ì': '–†', '√î': '–°', '√ï': '–¢', '√ñ': '–£',
    '√ó': '–§', '√ò': '–•', '√ô': '–¶', '√ö': '–ß', '√õ': '–®', '√ú': '–©', '√ù': '–™',
    '√û': '–´', '√ü': '–¨', '√†': '–≠', '√°': '–Æ', '√¢': '–Ø',
    '√£': '–∞', '√§': '–±', '√•': '–≤', '√¶': '–≥', '√ß': '–¥', '√®': '–µ', '√©': '–∂',
    '√™': '–∑', '√´': '–∏', '√¨': '–π', '√≠': '–∫', '√Æ': '–ª', '√Ø': '–º', '√∞': '–Ω',
    '√±': '–æ', '√≤': '–ø', '√≥': '—Ä', '√¥': '—Å', '√µ': '—Ç', '√∂': '—É', '√∑': '—Ñ',
    '√∏': '—Ö', '√π': '—Ü', '√∫': '—á', '√ª': '—à', '√º': '—â', '√Ω': '—ä', '√æ': '—ã',
    '√ø': '—å',
    '√Ç': '–ê', '√É': '–ë', '√Ñ': '–í', '√Ö': '–ì', '√Ü': '–î', '√á': '–ï', '√à': '–ñ',
    '√â': '–ó', '√ä': '–ò', '√ã': '–ô', '√å': '–ö', '√ç': '–õ', '√é': '–ú', '√è': '–ù',
  };
  
  String result = text;
  replacements.forEach((wrong, correct) {
    result = result.replaceAll(wrong, correct);
  });
  
  return result;
}

/// –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏
Future<String> _autoDetectEncoding(List<int> bytes) async {
  // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º UTF-8
  try {
    final utf8Text = utf8.decode(bytes, allowMalformed: false);
    if (!_containsGibberish(utf8Text)) {
      return utf8Text;
    }
  } catch (e) {}
  
  // –ü—Ä–æ–±—É–µ–º windows-1251
  try {
    final win1251Text = await _decodeWindows1251(bytes);
    if (!_containsGibberish(win1251Text)) {
      return win1251Text;
    }
  } catch (e) {}
  
  // –ü—Ä–æ–±—É–µ–º latin1
  try {
    final latin1Text = latin1.decode(bytes);
    final convertedText = _latin1ToCyrillic(latin1Text);
    if (!_containsGibberish(convertedText)) {
      return convertedText;
    }
  } catch (e) {}
  
  // –ü–æ—Å–ª–µ–¥–Ω–∏–π –≤–∞—Ä–∏–∞–Ω—Ç
  return utf8.decode(bytes, allowMalformed: true);
}

/// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ "–∞–±—Ä–∞–∫–∞–¥–∞–±—Ä—É" (–Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã)
bool _containsGibberish(String text) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π —Å–∏–º–≤–æ–ª–æ–≤
  final gibberishPattern = RegExp(r'[√Ç√ê√¢√∞¬Ç¬Ä¬Ç¬Ä¬Ç¬Ä]'); // –¢–∏–ø–∏—á–Ω—ã–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–∏
  final cyrillicPattern = RegExp(r'[–∞-—è–ê-–Ø—ë–Å]');
  
  // –ï—Å–ª–∏ –µ—Å—Ç—å –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –ò –º–∞–ª–æ –∫–∏—Ä–∏–ª–ª–∏—Ü—ã - –≤–µ—Ä–æ—è—Ç–Ω–æ –ø—Ä–æ–±–ª–µ–º–∞ —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π
  final hasGibberish = gibberishPattern.hasMatch(text);
  final hasCyrillic = cyrillicPattern.hasMatch(text);
  final cyrillicRatio = text.split('').where((c) => cyrillicPattern.hasMatch(c)).length / text.length;
  
  return hasGibberish || (text.isNotEmpty && cyrillicRatio < 0.1);
}

/// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è latin1 –≤ –∫–∏—Ä–∏–ª–ª–∏—Ü—É (–ø—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞)
String _latin1ToCyrillic(String text) {
  final Map<String, String> replacements = {
    '√Ç': '–ê', '√¢': '–∞', '√ê': '–î', '√∞': '–¥',
    '': '–ï', '¬Ç': '–í', '¬Ä': '–†'
  };
  
  String result = text;
  replacements.forEach((from, to) {
    result = result.replaceAll(from, to);
  });
  
  return result;
}


  bool _isNavigation(String text) {
    final navigationPatterns = [
      '–≥–ª–∞–≤–Ω–∞—è', '–±–∏–æ–≥—Ä–∞—Ñ–∏—è', '–æ—Ç–∑—ã–≤', '—Å–ª–µ–¥—É—é—â–∞—è', '–ø—Ä–µ–¥—ã–¥—É—â–∞—è', 
      '–æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ', '—Å—Ç—Ä–∞–Ω–∏—Ü–∞', '–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏', '¬©', '—è–Ω–¥–µ–∫—Å.–º–µ—Ç—Ä–∏–∫–∞',
      '1, 2, 3,', '4, 5, 6,'
    ];
    return navigationPatterns.any((pattern) => text.toLowerCase().contains(pattern));
  }

 

  bool _containsCyrillic(String text) {
    return RegExp(r'[–∞-—è–ê-–Ø—ë–Å]').hasMatch(text);
  }

  Future<void> _processText(String text, Neuron neuron, List<int> allWordIds) async {
    final sentences = _splitIntoSentences(text);
    
    for (final sentence in sentences) {
      if (sentence.trim().length < 3) continue;
      
      final wordTexts = _extractWords(sentence);
      if (wordTexts.isEmpty) continue;
      
      final fragment = Fragment(
        id: nextFragmentId++,
        text: sentence,
        wordIds: [],
      );
      
      fragments[fragment.id] = fragment;
      neuron.fragmentLinks.add(fragment.id);
      
      final sentenceWordIds = <int>[];
      for (final wordText in wordTexts) {
        final wordId = _getOrCreateWordId(wordText);
        if (wordId > 0) {
          sentenceWordIds.add(wordId);
          allWordIds.add(wordId);
        }
      }
      
      for (final wordId in sentenceWordIds) {
        final wordText = wordLibrary[wordId]!;
        if (!STOP_WORDS.contains(wordText)) {
          fragment.wordIds.add(wordId);
        }
      }
      
      _computeRatingsForSentence(sentenceWordIds);
    }
  }

  List<String> _splitIntoSentences(String text) {
    return text
        .split(RegExp(r'[.!?]+'))
        .map((s) => s.trim())
        .where((s) => s.length > 3)
        .toList();
  }

  int _getOrCreateWordId(String wordText) {
    final normalizedWord = wordText.toLowerCase().trim();
    
    if (normalizedWord.isEmpty || normalizedWord.length < 2) return -1;
    if (!RegExp(r'[–∞-—è–ê-–Ø—ë–Åa-zA-Z]').hasMatch(normalizedWord)) return -1;
    
    int? wordId = wordIndex[normalizedWord];
    
    if (wordId == null) {
      wordId = nextWordId++;
      wordLibrary[wordId] = normalizedWord;
      wordIndex[normalizedWord] = wordId;
      
      words[wordId] = Word(
        id: wordId,
        ratings: {},
        allRating: 0,
        x: random.nextDouble() * 1000,
        y: random.nextDouble() * 1000,
        z: random.nextDouble() * 1000,
      );

    }
    
    return wordId;
  }

  void _computeRatingsForSentence(List<int> wordIds) {
    for (int i = 0; i < wordIds.length; i++) {
      final wordId = wordIds[i];
      final wordText = wordLibrary[wordId]!;
      if (STOP_WORDS.contains(wordText)) continue;

      double leftBonus = 1.0;
      for (int left = i - 1; left >= 0 && left >= i - 1; left--) {
        final leftWordText = wordLibrary[wordIds[left]]!;
        if (STOP_WORDS.contains(leftWordText)) {
          leftBonus += 0.1;
        } else {
          break;
        }
      }

      for (int j = max(0, i - 10); j <= min(wordIds.length - 1, i + 10); j++) {
        if (i == j) continue;
        final otherWordId = wordIds[j];
        final otherWordText = wordLibrary[otherWordId]!;
        if (STOP_WORDS.contains(otherWordText)) continue;

        final distance = (i - j).abs();
        double betweenBonus = 1.0;

        int stopWordsBetween = 0;
        for (int k = min(i, j) + 1; k < max(i, j); k++) {
          final betweenWordText = wordLibrary[wordIds[k]]!;
          if (STOP_WORDS.contains(betweenWordText)) stopWordsBetween++;
        }

        betweenBonus += stopWordsBetween * 0.05;
        final totalBonus = leftBonus * betweenBonus;
        final rating = ((5.0 / distance) * totalBonus * 100).round();

        _updateWordRating(wordId, otherWordId, rating);
      }
    }
  }

  void _updateWordRating(int wordId, int otherId, int rating) {
    final word = words[wordId];
    if (word == null) return;
    
    word.ratings[otherId] = (word.ratings[otherId] ?? 0) + rating;
    
    if (word.ratings.length > MAX_VECTOR_SIZE) {
      final sorted = word.ratings.entries.toList()
        ..sort((a, b) => b.value.compareTo(a.value));
      
      word.ratings.clear();
      for (int i = 0; i < MAX_VECTOR_SIZE; i++) {
        word.ratings[sorted[i].key] = sorted[i].value;
      }
    }
    
    word.allRating = word.ratings.values.fold(0, (a, b) => a + b);
    
    final otherWord = words[otherId];
    if (otherWord != null) {
      otherWord.ratings[wordId] = (otherWord.ratings[wordId] ?? 0) + (rating ~/ 2);
      if (otherWord.ratings.length > MAX_VECTOR_SIZE) {
        final sorted = otherWord.ratings.entries.toList()
          ..sort((a, b) => b.value.compareTo(a.value));
        otherWord.ratings.clear();
        for (int i = 0; i < MAX_VECTOR_SIZE; i++) {
          otherWord.ratings[sorted[i].key] = sorted[i].value;
        }
      }
      otherWord.allRating = otherWord.ratings.values.fold(0, (a, b) => a + b);
    }
  }

  Future<void> _createPackageForFragment(Fragment fragment, Neuron neuron) async {
    if (fragment.wordIds.isEmpty) return;
    
    final pkg = Package(
      id: nextPackageId++,
      signature: List.from(fragment.wordIds),
      keywords: fragment.wordIds.take(10).toList(),
      status: PackageStatus.permanent,
      fragmentLinks: [fragment.id],
      neuronLinks: [neuron.id],
    );
    
    packages[pkg.id] = pkg;
    fragment.packageId = pkg.id;
    neuron.packageLinks.add(pkg.id);
  }

  Future<List<int>> _findFragmentsWithMaxCoverage(
    Map<int, int> superVector, 
    List<int> promptWordIds, 
    String querySemantics
  ) async {
    final fragmentScores = <int, double>{};
    final usedWords = Set<int>.from(promptWordIds);
    
    for (final fragment in fragments.values) {
      if (fragment.semanticType != querySemantics && querySemantics != '–ø–æ–≤–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ') {
        continue;
      }
      
      final fragmentWordSet = fragment.wordIds.toSet();
      final relevantWords = fragmentWordSet.difference(usedWords);
      if (relevantWords.isEmpty) continue;
      
      double coverageScore = 0.0;
      int coveredCount = 0;
      
      for (final wordId in relevantWords) {
        if (superVector.containsKey(wordId)) {
          coverageScore += superVector[wordId]!;
          coveredCount++;
        }
      }
      
      final coverageRatio = coveredCount / relevantWords.length;
      final lengthBonus = fragment.wordIds.length > 10 ? 1.0 : 0.5;
      
      final normalizedScore = coverageScore * coverageRatio * lengthBonus;
      fragmentScores[fragment.id] = normalizedScore;
    }
    
    final sortedFragments = fragmentScores.entries
        .toList()
        ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedFragments
        .where((entry) => entry.value > 0)
        .take(20)
        .map((e) => e.key)
        .toList();
  }
  Future<void> _checkNeuronSimilarity(Neuron newNeuron, Function(String) onProgress) async {
    for (final existingNeuron in neurons.values) {
      if (existingNeuron.id == newNeuron.id || existingNeuron.id == 0) continue;
      
      final similarity = _calculateSimilarity(
        newNeuron.signatureRatings,
        existingNeuron.signatureRatings,
      );
      
      if (similarity > 0.3) {
        newNeuron.neuronRatings[existingNeuron.id] = (similarity * 1000).round();
        existingNeuron.neuronRatings[newNeuron.id] = (similarity * 1000).round();
        
        onProgress('  –°–≤—è–∑—å —Å –Ω–µ–π—Ä–æ–Ω–æ–º #${existingNeuron.id}: ${(similarity * 100).toStringAsFixed(1)}%');
      }
    }
  }


  // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
  void optimizeWordPositions() {
    for (int i = 0; i < 20; i++) {
      Future.delayed(Duration(milliseconds: 1100), () {
        optimizeWordPositions1();
      });
    }
  }

  void optimizeWordPositions1() {
    final topWords = getTopWords(150);
    if (topWords.length < 2) return;
    
    _initializeStemBasedPositions(topWords);
    _applyStrongWordRepulsion(topWords);
    _applyStrongWordAttraction(topWords);
    _applyClusterAttraction(topWords);
    _applyFinalStabilization(topWords);
  }

  void _initializeStemBasedPositions(List<Word> topWords) {
    final stemGroups = <String, List<Word>>{};
    
    for (final word in topWords) {
      final wordText = wordLibrary[word.id] ?? '';
      final stem = WordStemmer.getStem(wordText);
      
      if (!stemGroups.containsKey(stem)) {
        stemGroups[stem] = [];
      }
      stemGroups[stem]!.add(word);
    }
    
    final groups = stemGroups.values.toList();
    final groupCount = groups.length;
    
    for (int i = 0; i < groupCount; i++) {
      final group = groups[i];
      if (group.length == 1) continue;
      
      final phi = acos(-1.0 + 2.0 * i / groupCount);
      final theta = sqrt(groupCount * pi) * phi;
      
      final centerX = 500.0 + 300.0 * sin(phi) * cos(theta);
      final centerY = 500.0 + 300.0 * sin(phi) * sin(theta);
      final centerZ = 500.0 + 300.0 * cos(phi);
      
      for (int j = 0; j < group.length; j++) {
        final word = group[j];
        final angle = 2 * pi * j / group.length;
        final radius = 20.0 + (word.allRating / 1550000).clamp(0.0, 50.0);
        
        word.x = centerX + radius * cos(angle);
        word.y = centerY + radius * sin(angle);
        word.z = centerZ + (j % 2 == 0 ? radius * 0.5 : -radius * 0.5);
      }
    }
    
    for (final word in topWords) {
      if (word.x == 0.0 && word.y == 0.0 && word.z == 0.0) {
        word.x = random.nextDouble() * 800 + 100;
        word.y = random.nextDouble() * 800 + 100;
        word.z = random.nextDouble() * 800 + 100;
      }
    }
  }

  void _applyStrongWordRepulsion(List<Word> topWords) {
    final strongWords = topWords.where((w) => w.allRating > 1550000).toList();
    
    for (int i = 0; i < strongWords.length; i++) {
      final word1 = strongWords[i];
      
      for (int j = i + 1; j < strongWords.length; j++) {
        final word2 = strongWords[j];
        
        final dx = word1.x - word2.x;
        final dy = word1.y - word2.y;
        final dz = word1.z - word2.z;
        final distance = sqrt(dx * dx + dy * dy + dz * dz);
        
        final minDistance = 150.0 + (word1.allRating + word2.allRating) / 150000.0;
        
        if (distance < minDistance) {
          final force = (minDistance - distance) / distance * 0.5;
          
          word1.x += dx * force * (word1.allRating / (word1.allRating + word2.allRating));
          word1.y += dy * force * (word1.allRating / (word1.allRating + word2.allRating));
          word1.z += dz * force * (word1.allRating / (word1.allRating + word2.allRating));
          
          word2.x -= dx * force * (word2.allRating / (word1.allRating + word2.allRating));
          word2.y -= dy * force * (word2.allRating / (word1.allRating + word2.allRating));
          word2.z -= dz * force * (word2.allRating / (word1.allRating + word2.allRating));
        }
      }
    }
  }

  void _applyStrongWordAttraction(List<Word> topWords) {
    final strongWords = topWords.where((w) => w.allRating > 1550000).toList();
    
    for (final strongWord in strongWords) {
      final attractionStrength = (strongWord.allRating / 1550000.0).clamp(0.1, 2.0);
      
      final strongConnections = strongWord.ratings.entries
          .toList()
          ..sort((a, b) => b.value.compareTo(a.value));
      
      final connectionsToProcess = strongConnections.take(30).toList();
      
      for (final connection in connectionsToProcess) {
        final otherWord = words[connection.key];
        if (otherWord == null || otherWord == strongWord) continue;
        
        final connectionStrength = connection.value / strongWord.allRating;
        
        final dx = strongWord.x - otherWord.x;
        final dy = strongWord.y - otherWord.y;
        final dz = strongWord.z - otherWord.z;
        final distance = sqrt(dx * dx + dy * dy + dz * dz);
        
        final targetDistance = 50.0 + (1.0 - connectionStrength) * 200.0;
        
        if (distance > targetDistance) {
          final force = (distance - targetDistance) / distance * 
                       connectionStrength * 
                       attractionStrength * 0.3;
          
          otherWord.x += dx * force;
          otherWord.y += dy * force;
          otherWord.z += dz * force;
        }
      }
    }
  }

  void _applyClusterAttraction(List<Word> topWords) {
    final clusterCenters = <Word>[];
    
    for (final word in topWords) {
      if (word.allRating > 20000 && word.ratings.length > 10) {
        clusterCenters.add(word);
      }
    }
    
    final clusterPositions = <Word, List<double>>{};
    
    for (final center in clusterCenters) {
      double sumX = center.x;
      double sumY = center.y;
      double sumZ = center.z;
      int count = 1;
      
      final strongConnections = center.ratings.entries
          .where((e) => e.value > center.allRating * 0.1)
          .take(20)
          .toList();
      
      for (final connection in strongConnections) {
        final otherWord = words[connection.key];
        if (otherWord != null) {
          sumX += otherWord.x;
          sumY += otherWord.y;
          sumZ += otherWord.z;
          count++;
        }
      }
      
      clusterPositions[center] = [sumX / count, sumY / count, sumZ / count];
    }
    
    final clusters = clusterPositions.entries.toList();
    
    for (int i = 0; i < clusters.length; i++) {
      final cluster1 = clusters[i];
      
      for (int j = i + 1; j < clusters.length; j++) {
        final cluster2 = clusters[j];
        
        final commonConnections = _findCommonStrongConnections(
          cluster1.key, 
          cluster2.key
        );
        
        if (commonConnections > 3) {
          final dx = cluster1.value[0] - cluster2.value[0];
          final dy = cluster1.value[1] - cluster2.value[1];
          final dz = cluster1.value[2] - cluster2.value[2];
          final distance = sqrt(dx * dx + dy * dy + dz * dz);
          
          final targetDistance = 100.0 + commonConnections * 20.0;
          
          if (distance > targetDistance) {
            final force = (distance - targetDistance) / distance * 0.1;
            
            _moveClusterTowards(cluster1.key, cluster2.value, force * 0.5);
            _moveClusterTowards(cluster2.key, cluster1.value, force * 0.5);
          }
        }
      }
    }
  }

  void _moveClusterTowards(Word center, List<double> target, double force) {
    final dx = target[0] - center.x;
    final dy = target[1] - center.y;
    final dz = target[2] - center.z;
    
    center.x += dx * force;
    center.y += dy * force;
    center.z += dz * force;
    
    final strongConnections = center.ratings.entries
        .where((e) => e.value > center.allRating * 0.1)
        .take(15)
        .toList();
    
    for (final connection in strongConnections) {
      final otherWord = words[connection.key];
      if (otherWord != null) {
        otherWord.x += dx * force * 0.3;
        otherWord.y += dy * force * 0.3;
        otherWord.z += dz * force * 0.3;
      }
    }
  }

  int _findCommonStrongConnections(Word word1, Word word2) {
    int commonCount = 0;
    
    final threshold1 = word1.allRating * 0.05;
    final threshold2 = word2.allRating * 0.05;
    
    for (final entry in word1.ratings.entries) {
      if (entry.value > threshold1) {
        final otherRating = word2.ratings[entry.key];
        if (otherRating != null && otherRating > threshold2) {
          commonCount++;
        }
      }
    }
    
    return commonCount;
  }

  void _applyFinalStabilization(List<Word> topWords) {
    for (final word in topWords) {
      word.x = word.x.clamp(50.0, 950.0);
      word.y = word.y.clamp(50.0, 950.0);
      word.z = word.z.clamp(50.0, 950.0);
    }
    
    for (final word in topWords) {
      if (word.allRating < 5000) {
        word.x += (random.nextDouble() - 0.5) * 10.0;
        word.y += (random.nextDouble() - 0.5) * 10.0;
        word.z += (random.nextDouble() - 0.5) * 10.0;
      }
    }
  }

  List<Word> getTopWords(int limit) {
     final sorted = words.values.toList()
    ..sort((a, b) => b.allRating.compareTo(a.allRating));
  
  final filtered = sorted.where((word) => 
    !STOP_WORDS.contains(wordLibrary[word.id]!.toLowerCase())
  ).toList();
  
  final topWords = filtered.take(limit).toList();
  final bottomWords = filtered.reversed.take(15).toList();
  
  return [...topWords, ...bottomWords];
}


  Future<void> saveToFile() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/neural_network_v2.json');
      
      final data = {
        'word_library': wordLibrary.map((k, v) => MapEntry(k.toString(), v)),
        'words': words.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'fragments': fragments.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'neurons': neurons.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'synapses': synapses.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'packages': packages.map((k, v) => MapEntry(k.toString(), v.toJson())),
        'next_word_id': nextWordId,
        'next_fragment_id': nextFragmentId,
        'next_neuron_id': nextNeuronId,
        'next_synapse_id': nextSynapseId,
        'next_package_id': nextPackageId,
      };
      
      await file.writeAsString(jsonEncode(data));
    } catch (e) {
      print('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: $e');
    }
  }

  Future<void> loadFromFile() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/neural_network_v2.json');
      
      if (!await file.exists()) return;
      
      final content = await file.readAsString();
      final data = jsonDecode(content);
      
      wordLibrary.clear();
      wordIndex.clear();
      (data['word_library'] as Map).forEach((k, v) {
        final id = int.parse(k);
        wordLibrary[id] = v;
        wordIndex[v] = id;
      });
      
      words.clear();
      (data['words'] as Map).forEach((k, v) {
        words[int.parse(k)] = Word.fromJson(v);
      });
      
      fragments.clear();
      (data['fragments'] as Map).forEach((k, v) {
        fragments[int.parse(k)] = Fragment.fromJson(v);
      });
      
      neurons.clear();
      if (data['neurons'] != null) {
        (data['neurons'] as Map).forEach((k, v) {
          neurons[int.parse(k)] = Neuron.fromJson(v,this);
        });
      }
      
      synapses.clear();
      if (data['synapses'] != null) {
        (data['synapses'] as Map).forEach((k, v) {
          synapses[int.parse(k)] = Synapse.fromJson(v);
        });
      }
      
      packages.clear();
      if (data['packages'] != null) {
        (data['packages'] as Map).forEach((k, v) {
          packages[int.parse(k)] = Package.fromJson(v);
        });
      }
      
      nextWordId = data['next_word_id'] ?? 1;
      nextFragmentId = data['next_fragment_id'] ?? 1;
      nextNeuronId = data['next_neuron_id'] ?? 1;
      nextSynapseId = data['next_synapse_id'] ?? 1;
      nextPackageId = data['next_package_id'] ?? 1;
      
      optimizeWordPositions();
      
      print('–ó–∞–≥—Ä—É–∂–µ–Ω–æ: ${words.length} —Å–ª–æ–≤, ${fragments.length} —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤, ${neurons.length} –Ω–µ–π—Ä–æ–Ω–æ–≤');
    } catch (e) {
      print('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: $e');
    }
  }
}

// ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ö–õ–ê–°–°–´ ==========
class NavigationStep {
  final String type;
  final int? id;
  final String? query;
  final DateTime timestamp;
  
  NavigationStep({
    required this.type,
    this.id,
    this.query,
  }) : timestamp = DateTime.now();
  
  String get displayText {
    switch (type) {
      case 'word':
        return '–°–ª–æ–≤–æ #$id';
      case 'neuron':
        return '–ù–µ–π—Ä–æ–Ω #$id';
      case 'fragment':
        return '–§—Ä–∞–≥–º–µ–Ω—Ç #$id';
      case 'search':
        return '–ü–æ–∏—Å–∫: $query';
      default:
        return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —à–∞–≥';
    }
  }
}

enum VisualizationMode {
  words,
  neurons,
  fragments
}
class _WordScore {
  final int wordId;
  final double intersectionScore;
  final double allRatingScore;
  final double combinedScore;
  
  _WordScore({
    required this.wordId,
    required this.intersectionScore,
    required this.allRatingScore,
    required this.combinedScore,
  });
}
class AnimationStage {
  final double duration;
  final VoidCallback action;
  
  AnimationStage({required this.duration, required this.action});
}

class Projected3D {
  final double dx;
  final double dy;
  final double depth;
  
  Projected3D({required this.dx, required this.dy, required this.depth});
}

// ========== –í–ò–ó–£–ê–õ–ò–ó–ê–¢–û–†–´ ==========
class InteractiveWordVisualization3D extends StatefulWidget {
  final OptimizedNeuralNetwork network;
  final Set<int> selectedWordIds;
  final Function(int, bool) onWordSelected;
  
  const InteractiveWordVisualization3D({
    Key? key,
    required this.network,
    required this.selectedWordIds,
    required this.onWordSelected,
  }) : super(key: key);
  
  @override
  _InteractiveWordVisualization3DState createState() => _InteractiveWordVisualization3DState();
}

class _InteractiveWordVisualization3DState extends State<InteractiveWordVisualization3D> {
  double _rotationX = 0.0;
  double _rotationY = 0.0;
  double _scale = 1.0;
  Offset _offset = Offset.zero;
  Offset? _lastLeftPanPosition;
  Offset? _lastRightPanPosition;
  bool _isRightMouseDown = false;
  int? _primaryButtonPointer;
  int? _secondaryButtonPointer;
  bool _shiftPressed = false;

  @override
  void initState() {
    super.initState();
    RawKeyboard.instance.addListener(_handleKeyEvent);
  }

  @override
  void dispose() {
    RawKeyboard.instance.removeListener(_handleKeyEvent);
    super.dispose();
  }

  void _handleKeyEvent(RawKeyEvent event) {
    if (event.logicalKey == LogicalKeyboardKey.shiftLeft || 
        event.logicalKey == LogicalKeyboardKey.shiftRight) {
      setState(() {
        _shiftPressed = event is RawKeyDownEvent;
      });
    } 
    
  }

  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerSignal: (pointerSignal) {
        if (pointerSignal is PointerScrollEvent) {
          setState(() {
            _scale = (_scale * (1.0 + pointerSignal.scrollDelta.dy * -0.001))
                .clamp(0.1, 3.0);
          });
        }
      },
      onPointerDown: (event) {
        if (event.kind == PointerDeviceKind.mouse) {
          if (event.buttons == kPrimaryButton) {
            _primaryButtonPointer = event.pointer;
            _lastLeftPanPosition = event.position;
          } else if (event.buttons == kSecondaryButton) {
            _secondaryButtonPointer = event.pointer;
            _lastRightPanPosition = event.position;
            _isRightMouseDown = true;
          }
        } else {
          _primaryButtonPointer = event.pointer;
          _lastLeftPanPosition = event.position;
        }
      },
      onPointerMove: (event) {
        if (event.kind == PointerDeviceKind.mouse) {
          if (_primaryButtonPointer == event.pointer && _lastLeftPanPosition != null) {
            setState(() {
              final delta = event.position - _lastLeftPanPosition!;
              _rotationY += delta.dx * 0.01;
              _rotationX += delta.dy * 0.01;
              _lastLeftPanPosition = event.position;
            });
          } else if (_secondaryButtonPointer == event.pointer && _lastRightPanPosition != null) {
            setState(() {
              final delta = event.position - _lastRightPanPosition!;
              _offset += Offset(delta.dx, delta.dy);
              _lastRightPanPosition = event.position;
            });
          }
        } else if (_primaryButtonPointer == event.pointer && _lastLeftPanPosition != null) {
          setState(() {
            final delta = event.position - _lastLeftPanPosition!;
            _rotationY += delta.dx * 0.01;
            _rotationX += delta.dy * 0.01;
            _lastLeftPanPosition = event.position;
          });
        }
      },
      onPointerUp: (event) {
        if (_primaryButtonPointer == event.pointer) {
          _primaryButtonPointer = null;
          _lastLeftPanPosition = null;
        }
        if (_secondaryButtonPointer == event.pointer) {
          _secondaryButtonPointer = null;
          _lastRightPanPosition = null;
          _isRightMouseDown = false;
        }
      },
      onPointerCancel: (event) {
        if (_primaryButtonPointer == event.pointer) {
          _primaryButtonPointer = null;
          _lastLeftPanPosition = null;
        }
        if (_secondaryButtonPointer == event.pointer) {
          _secondaryButtonPointer = null;
          _lastRightPanPosition = null;
          _isRightMouseDown = false;
        }
      },
      child: MouseRegion(
        onHover: (event) {
          if (event.kind == PointerDeviceKind.mouse) {
            if (event.buttons == kPrimaryButton && _primaryButtonPointer == null) {
              _primaryButtonPointer = -1;
              _lastLeftPanPosition = event.position;
            } else if (event.buttons == kSecondaryButton && _secondaryButtonPointer == null) {
              _secondaryButtonPointer = -1;
              _lastRightPanPosition = event.position;
              _isRightMouseDown = true;
            }
          }
        },
        child: GestureDetector(
          onScaleUpdate: (details) {
            if (!_isRightMouseDown) {
              setState(() {
                _scale = (_scale * details.scale).clamp(0.1, 3.0);
              });
            }
          },
          onTapDown: (details) {
            final shiftPressed = _isShiftKeyPressed();
            _handleTap(details.localPosition, shiftPressed);
          },
          child: CustomPaint(
            size: Size.infinite,
            painter: Word3DPainter(
              words: widget.network.getTopWords(150),
              wordLibrary: widget.network.wordLibrary,
              allWords: widget.network.words,
              rotationX: _rotationX,
              rotationY: _rotationY,
              scale: _scale,
              offset: _offset,
              selectedWordIds: widget.selectedWordIds,
              searchVector: widget.network.currentSearchVector,
              searchWords: widget.network.currentSearchWords,
            ),
          ),
        ),
      ),
    );
  }

  bool _isShiftKeyPressed() {
    return _shiftPressed;
  }

  void _handleTap(Offset position, bool shiftPressed) {
    final RenderBox box = context.findRenderObject() as RenderBox;
    final size = box.size;
    final words = widget.network.getTopWords(150);
    final centerX = size.width / 2 + _offset.dx;
    final centerY = size.height / 2 + _offset.dy;
    
    int? clickedWordId;
    double minDistance = 30.0;
    
    for (final word in words) {
      final projected = _project3DTo2D(
        word.x - 500, word.y - 500, word.z - 500,
        centerX, centerY, _rotationX, _rotationY, _scale,
      );
      
      final distance = sqrt(
        pow(projected.dx - position.dx, 2) + 
        pow(projected.dy - position.dy, 2)
      );
      
      if (distance < minDistance) {
        minDistance = distance;
        clickedWordId = word.id;
      }
    }
    
    if (clickedWordId != null) {
      widget.onWordSelected(clickedWordId, shiftPressed);
    }
  }
  
  Offset _project3DTo2D(double x, double y, double z, double centerX, double centerY, 
                        double rotationX, double rotationY, double scale) {
    final cosY = cos(rotationY);
    final sinY = sin(rotationY);
    final cosX = cos(rotationX);
    final sinX = sin(rotationX);
    
    var x1 = x * cosY - z * sinY;
    var z1 = x * sinY + z * cosY;
    var y1 = y;
    
    final y2 = y1 * cosX - z1 * sinX;
    final z2 = y1 * sinX + z1 * cosX;
    
    final perspective = 1000 / (1000 + z2);
    final screenX = centerX + x1 * scale * perspective;
    final screenY = centerY + y2 * scale * perspective;
    
    return Offset(screenX, screenY);
  }
}

class Word3DPainter extends CustomPainter {
  final List<Word> words;
  final Map<int, String> wordLibrary;
  final Map<int, Word> allWords;
  final double rotationX;
  final double rotationY;
  final double scale;
  final Offset offset;
  final Set<int> selectedWordIds;
  final Map<int, int> searchVector;
  final List<int> searchWords;
  
  Word3DPainter({
    required this.words,
    required this.wordLibrary,
    required this.allWords,
    required this.rotationX,
    required this.rotationY,
    required this.scale,
    required this.offset,
    required this.selectedWordIds,
    required this.searchVector,
    required this.searchWords,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    if (words.isEmpty) return;
    
    final centerX = size.width / 2 + offset.dx;
    final centerY = size.height / 2 + offset.dy;
    
    final projectedWords = <_ProjectedWord>[];
    
    for (final word in words) {
      final pos = _project3DTo2D(
        word.x - 500, word.y - 500, word.z - 500,
        centerX, centerY,
      );
      
      projectedWords.add(_ProjectedWord(
        word: word,
        screenX: pos.dx,
        screenY: pos.dy,
        depth: pos.depth,
      ));
    }
    
    projectedWords.sort((a, b) => a.depth.compareTo(b.depth));
    
    final selectedWords = selectedWordIds.map((id) => allWords[id]).whereType<Word>().toList();
    final connectedWordIds = <int>{};
    
    for (final selectedWord in selectedWords) {
      connectedWordIds.addAll(selectedWord.ratings.keys);
    }
    
    final searchVectorWords = searchVector.keys.toSet();
    final commonSearchWords = <int>{};
    
    if (searchWords.isNotEmpty) {
      for (final wordId in searchVectorWords) {
        if (searchWords.contains(wordId)) {
          commonSearchWords.add(wordId);
        }
      }
    }
    
    for (final projWord in projectedWords) {
      if (selectedWordIds.contains(projWord.word.id)) {
        _drawConnections(canvas, projWord, projectedWords, true, Colors.amber);
      }
    }
    
    for (final projWord in projectedWords) {
      if (searchWords.contains(projWord.word.id) && !selectedWordIds.contains(projWord.word.id)) {
        _drawConnections(canvas, projWord, projectedWords, false, Colors.green);
      }
    }
    
    for (final projWord in projectedWords) {
      final isSelected = selectedWordIds.contains(projWord.word.id);
      final isConnected = connectedWordIds.contains(projWord.word.id);
      final isInSearch = searchVectorWords.contains(projWord.word.id);
      final isCommonSearch = commonSearchWords.contains(projWord.word.id);
       _drawConnections(canvas, projWord, projectedWords, false, Colors.purple.withOpacity(0.69));
      double opacity = 1.0;
      if (selectedWordIds.isNotEmpty && !isSelected && !isConnected) {
        opacity = 0.3;
      }
      
      if (searchVectorWords.isNotEmpty && !isInSearch && selectedWordIds.isEmpty) {
        opacity = 0.2;
      }
      
      Color textColor;
      if (isSelected) {
        textColor = Color(0xFFFFD700);
      } else if (isCommonSearch) {
        textColor = Color(0xFF00FF7F);
      } else if (isInSearch) {
        textColor = Colors.lightGreen;
      } else if (isConnected && selectedWords.isNotEmpty) {
        double maxConnectionStrength = 0.0;
        for (final selectedWord in selectedWords) {
          final rating = selectedWord.ratings[projWord.word.id] ?? 0;
          if (rating > 0) {
            final maxRating = selectedWord.ratings.values.reduce((a, b) => a > b ? a : b);
            final strength = rating / maxRating.toDouble();
            maxConnectionStrength = max(maxConnectionStrength, strength);
          }
        }
        
        final baseColor = _getColorFromText(wordLibrary[projWord.word.id] ?? '');
        textColor = Color.lerp(baseColor, Colors.white, maxConnectionStrength * 0.7)!;
      } else {
        textColor = _getColorFromText(wordLibrary[projWord.word.id] ?? '');
      }
      
      _drawWord(canvas, projWord, opacity, textColor);
    }
  }
  
  void _drawConnections(Canvas canvas, _ProjectedWord projWord, List<_ProjectedWord> allProjected, bool isSelected, Color baseColor) {
    final word = projWord.word;
    if (word.ratings.isEmpty) return;
    bool isUsualConnect = (baseColor ==  Colors.purple.withOpacity(0.69));
    final sortedConnections = word.ratings.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    final connectionsToProcess = sortedConnections.take(isSelected ? 10 : 5).toList();
    
    for (final entry in connectionsToProcess) {
      final otherWord = allWords[entry.key];
      if (otherWord == null) continue;
      
      final otherProj = allProjected.firstWhere(
        (p) => p.word.id == entry.key,
        orElse: () => _ProjectedWord(word: otherWord, screenX: projWord.screenX, screenY: projWord.screenY, depth: 0),
      );
      
      final maxRating = word.ratings.values.reduce((a, b) => a > b ? a : b);
      final normalizedRating = entry.value / maxRating.toDouble();
      
      double opacity = isSelected ? (normalizedRating * 0.8).clamp(0.3, 0.9) : 0.2;
      double strokeWidth = isSelected ? (normalizedRating * 4 + 1.0).clamp(1.0, 3.0) : 1.0;
      
      final connectionColor = isSelected ? 
          Color.lerp(baseColor.withOpacity(0.5), baseColor, normalizedRating)! :
          baseColor.withOpacity(opacity);
      
      final paint = Paint()
        ..color = connectionColor
        ..strokeWidth = strokeWidth
        ..style = PaintingStyle.stroke;
      
      canvas.drawLine(
        Offset(projWord.screenX, projWord.screenY),
        Offset(otherProj.screenX, otherProj.screenY),
        paint,
      );
      
      if (isSelected && normalizedRating > 0.3) {
        final dotPaint = Paint()
          ..color = baseColor.withOpacity(normalizedRating * 0.8)
          ..style = PaintingStyle.fill;
        
        canvas.drawCircle(
          Offset(otherProj.screenX, otherProj.screenY),
          1 * strokeWidth,
          dotPaint,
        );
      }
    }
  }
  
  void _drawWord(Canvas canvas, _ProjectedWord projWord, double opacity, Color color) {
    final wordText = wordLibrary[projWord.word.id] ?? 'unknown';
    final scaleFactor = projWord.word.allRating / (words.isNotEmpty ? words[0].allRating : 1);
    final baseSize = 12.0 * scale;
    final fontSize = baseSize + scaleFactor * 6 * scale;
    
    final backgroundPaint = Paint()
      ..color = Colors.black.withOpacity(opacity * 0.7)
      ..style = PaintingStyle.fill;
    
    final textSpan = TextSpan(
      text: wordText,
      style: TextStyle(
        color: color.withOpacity(opacity),
        fontSize: fontSize,
        fontWeight: FontWeight.bold,
        shadows: [
          Shadow(
            blurRadius: 3.0,
            color: Colors.black.withOpacity(opacity * 0.8),
            offset: Offset(1.0, 1.0),
          ),
        ],
      ),
    );
    
    final textPainter = TextPainter(
      text: textSpan,
      textDirection: ui.TextDirection.ltr,
    );
    
    textPainter.layout();
    
    final textOffset = Offset(
      projWord.screenX - textPainter.width / 2,
      projWord.screenY - textPainter.height / 2,
    );
    
    final backgroundRect = Rect.fromCenter(
      center: Offset(projWord.screenX, projWord.screenY),
      width: textPainter.width + 8,
      height: textPainter.height + 4,
    );
    
    canvas.drawRect(backgroundRect, backgroundPaint);
    
    textPainter.paint(canvas, textOffset);
    
    if (selectedWordIds.contains(projWord.word.id)) {
      final highlightPaint = Paint()
        ..color = Colors.yellow.withOpacity(0.3)
        ..strokeWidth = 2
        ..style = PaintingStyle.stroke;
      
      canvas.drawCircle(
        Offset(projWord.screenX, projWord.screenY),
        textPainter.width / 2 + 6,
        highlightPaint,
      );
    }
  }
  
  _Projected3D _project3DTo2D(double x, double y, double z, double centerX, double centerY) {
    final cosY = cos(rotationY);
    final sinY = sin(rotationY);
    final cosX = cos(rotationX);
    final sinX = sin(rotationX);
    
    var x1 = x * cosY - z * sinY;
    var z1 = x * sinY + z * cosY;
    var y1 = y;
    
    final y2 = y1 * cosX - z1 * sinX;
    final z2 = y1 * sinX + z1 * cosX;
    
    final perspective = 1000 / (1000 + z2);
    final screenX = centerX + x1 * scale * perspective;
    final screenY = centerY + y2 * scale * perspective;
    
    return _Projected3D(dx: screenX, dy: screenY, depth: z2);
  }
  
  Color _getColorFromText(String text) {
    int hash = 0;
    for (int i = 0; i < text.length; i++) {
      hash = text.codeUnitAt(i) + ((hash << 5) - hash);
    }
    
    int r = ((hash & 0xFF0000) >> 16);
    int g = ((hash & 0x00FF00) >> 8);
    int b = (hash & 0x0000FF);
    
    r = (r * 1.4).toInt().clamp(0, 255);
    g = (g * 1.4).toInt().clamp(0, 255);
    b = (b * 1.4).toInt().clamp(0, 255);
    
    return Color.fromRGBO(r, g, b, 1.0);
  }
  
  @override
  bool shouldRepaint(Word3DPainter oldDelegate) {
    return oldDelegate.rotationX != rotationX ||
        oldDelegate.rotationY != rotationY ||
        oldDelegate.scale != scale ||
        oldDelegate.offset != offset ||
        oldDelegate.selectedWordIds.length != selectedWordIds.length ||
        oldDelegate.searchVector.length != searchVector.length;
  }
}

class _ProjectedWord {
  final Word word;
  final double screenX;
  final double screenY;
  final double depth;
  
  _ProjectedWord({required this.word, required this.screenX, required this.screenY, required this.depth});
}

class _Projected3D {
  final double dx;
  final double dy;
  final double depth;
  
  _Projected3D({required this.dx, required this.dy, required this.depth});
}

// ========== –û–°–ù–û–í–ù–û–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–ï ==========
class NeuralNetworkApp extends StatefulWidget {
  @override
  _NeuralNetworkAppState createState() => _NeuralNetworkAppState();
}

class _NeuralNetworkAppState extends State<NeuralNetworkApp> {
  final OptimizedNeuralNetwork network = OptimizedNeuralNetwork();
  final TextEditingController _chatController = TextEditingController();
  final TextEditingController _searchController = TextEditingController();
  final List<ChatMessage1> _messages = [];
  bool _isProcessing = false;
  bool _shiftPressed = false;
  bool _ctrlPressed = false;
  
  @override
  void initState() {
    super.initState();
    _loadNetwork();
    RawKeyboard.instance.addListener(_handleKeyEvent);
    
    
  }
  
  @override
  void dispose() {
    RawKeyboard.instance.removeListener(_handleKeyEvent);
    super.dispose();
  }
  
  void _handleKeyEvent(RawKeyEvent event) {
    if (event.logicalKey == LogicalKeyboardKey.shiftLeft || 
        event.logicalKey == LogicalKeyboardKey.shiftRight) {
      setState(() {
        _shiftPressed = event is RawKeyDownEvent;
      });
    } else if (event.logicalKey == LogicalKeyboardKey.controlLeft ||
               event.logicalKey == LogicalKeyboardKey.controlRight) {
      setState(() {
        _ctrlPressed = event is RawKeyDownEvent;
      });
    }
    
    if (event is RawKeyDownEvent) {
      if (_ctrlPressed) {
        if (event.logicalKey == LogicalKeyboardKey.keyZ) {
          if (_shiftPressed) {
            network.redo();
          } else {
            network.undo();
          }
          setState(() {});
        } else if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
          network.navigateToNextSearchedNeuron();
          setState(() {});
        } else if (event.logicalKey == LogicalKeyboardKey.arrowLeft) {
          network.navigateToPreviousSearchedNeuron();
          setState(() {});
        }
      }
    }
  }

  Future<void> _loadNetwork() async {
    await network.loadFromFile();
    await network.updateClusters();
    _addMessage('–°–∏—Å—Ç–µ–º–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞: ${network.words.length} —Å–ª–æ–≤, ${network.neurons.length} –Ω–µ–π—Ä–æ–Ω–æ–≤', isSystem: true);
  }
  
  void _addMessage(String text, {bool isSystem = false}) {
    setState(() {
      _messages.add(ChatMessage1(
        text: text,
        isSystem: isSystem,
        timestamp: DateTime.now(),
      ));
    });
  }
 Future<void> _trainFromRange(String command) async {
  try {
    final parts = command.split(' ');
    if (parts.length < 5 || parts[0] != '--train' || parts[1] != 'from' || parts[3] != 'to') {
      _addMessage('Invalid command format. Use: --train from START_URL to END_URL', isSystem: true);
      return;
    }
    
    final startUrl = parts[2];
    final endUrl = parts[4];
    
    // –ù–∞—Ö–æ–¥–∏–º —á–∏—Å–ª–æ–≤—É—é —Ä–∞–∑–Ω–∏—Ü—É –º–µ–∂–¥—É URL
    final result = _findNumericDifference(startUrl, endUrl);
    
    if (result == null) {
      _addMessage('Could not find numeric difference between URLs', isSystem: true);
      return;
    }
    
    final (baseUrl, startNumber, endNumber, formatNumber) = result;
    
    if (startNumber >= endNumber) {
      _addMessage('Start number must be less than end number', isSystem: true);
      return;
    }
    
    final total = endNumber - startNumber + 1;
    _addMessage('Training: from $startNumber to $endNumber ($total URLs)', isSystem: true);
    
    int processed = 0;
    
    for (int i = startNumber; i <= endNumber; i++) {
      final formattedNumber = formatNumber(i);
      final currentUrl = baseUrl.replaceFirst('{NUM}', formattedNumber.toString());
      
      _addMessage('[$processed/$total] Processing: $currentUrl', isSystem: true);
      
      try {
        await network.processWebsite(currentUrl, (progress) {
          _addMessage('  $progress', isSystem: true);
        });
        processed++;
        
        await Future.delayed(Duration(milliseconds: 500));
        
      } catch (e) {
        _addMessage('  Failed: $e', isSystem: true);
      }
    }
    
    _addMessage('Completed! Processed $processed/$total URLs', isSystem: true);
    setState(() {});
    
  } catch (e) {
    _addMessage('Error: $e', isSystem: true);
  }
}

(String, int, int, String Function(int))? _findNumericDifference(String startUrl, String endUrl) {
  // –ò—â–µ–º –≤—Å–µ —á–∏—Å–ª–æ–≤—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤ URL
  final startNumbers = _extractAllNumbers(startUrl);
  final endNumbers = _extractAllNumbers(endUrl);
  
  if (startNumbers.isEmpty || endNumbers.isEmpty) {
    return null;
  }
  
  // –ò—â–µ–º –ø–µ—Ä–≤—É—é –ø–∞—Ä—É —á–∏—Å–µ–ª, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è
  for (int i = 0; i < min(startNumbers.length, endNumbers.length); i++) {
    final startNum = startNumbers[i];
    final endNum = endNumbers[i];
    
    if (startNum.value != endNum.value) {
      // –ù–∞—à–ª–∏ —Ä–∞–∑–ª–∏—á–∞—é—â–∏–µ—Å—è —á–∏—Å–ª–∞
      final startNumber = startNum.value;
      final endNumber = endNum.value;
      
      // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π URL —Å –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–º
      final baseUrl = startUrl.replaceFirst(startNum.match, '{NUM}');
      
      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —á–∏—Å–ª–∞ (—Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤–µ–¥—É—â–∏–µ –Ω—É–ª–∏ –µ—Å–ª–∏ –µ—Å—Ç—å)
      String formatNumber(int num) {
        if (startNum.match.length > endNum.match.length) {
          // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–∑ startUrl
          return num.toString().padLeft(startNum.match.length, '0');
        } else if (endNum.match.length > startNum.match.length) {
          // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–∑ endUrl
          return num.toString().padLeft(endNum.match.length, '0');
        }
        return num.toString();
      }
      
      return (baseUrl, startNumber, endNumber, formatNumber);
    }
  }
  
  return null;
}

List<NumberMatch> _extractAllNumbers(String url) {
  final matches = <NumberMatch>[];
  final regex = RegExp(r'\d+');
  final allMatches = regex.allMatches(url);
  
  for (final match in allMatches) {
    final number = int.tryParse(match.group(0)!);
    if (number != null) {
      matches.add(NumberMatch(
        value: number,
        match: match.group(0)!,
        start: match.start,
        end: match.end,
      ));
    }
  }
  
  return matches;
}


int? _extractNumberFromUrl(String url) {
  // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ü–∏—Ñ—Ä –≤ URL
  final regex = RegExp(r'/(\d+)(?:\?|$|/)');
  final match = regex.firstMatch(url);
  
  if (match != null) {
    return int.tryParse(match.group(1)!);
  }
  
  return null;
}

String _replaceNumberInUrl(String url, int newNumber) {
  // –ó–∞–º–µ–Ω—è–µ–º —á–∏—Å–ª–æ –≤ URL –Ω–∞ –Ω–æ–≤–æ–µ
  return url.replaceAllMapped(
    RegExp(r'/(\d+)(?:\?|$|/)'),
    (match) => '/$newNumber${match.group(2) ?? ''}'
  );
}
  Future<void> _handleMessage(String text) async {
    if (text.isEmpty) return;
    
    _addMessage(text);
    _chatController.clear();
    setState(() => _isProcessing = true);
    
    try {
      if (text.startsWith("--train ")){
        await _trainFromRange(text);
      
      }
      if (text.startsWith("http://") || text.startsWith("https://")) {
        await network.processWebsite(text, (progress) {
          _addMessage(progress, isSystem: true);
        });
        setState(() {});
      } else if (text == '/train') {
        await network.trainTest((progress) {
          _addMessage(progress, isSystem: true);
        });
        setState(() {});
      } else if (text == '/train2') {
        await network.trainTest2((progress) {
          _addMessage(progress, isSystem: true);
        });
        setState(() {});
      }else if (text == '/optimize') {
        network.optimizeWordPositions();
        _addMessage('–ü–æ–∑–∏—Ü–∏–∏ —Å–ª–æ–≤ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã', isSystem: true);
        setState(() {});
      } else if (text == '/optimizeNeuralConnectionsRebuildWeights') {
        VectorOperations.optimizeNeuralConnectionsRebuildWeights(network.words);
        _addMessage('–ù–µ–π—Ä–æ–Ω–Ω—ã–µ —Å–≤—è–∑–∏ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã', isSystem: true);
        setState(() {});
      } else {
        final result = await network.processQueryAdvanced(text);
        
        if (result['line1'].toString().isNotEmpty) {
          _addMessage('–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞: ${result['line1']}', isSystem: true);
        }
        
        if (result['line2'].toString().isNotEmpty) {
          _addMessage('–ö–æ–Ω—Ç–µ–∫—Å—Ç: ${result['line2']}', isSystem: true);
        }
        if (result['line3'].toString().isNotEmpty) {
          _addMessage('–ö–æ–Ω—Ç–µ–∫—Å—Ç: ${result['line3']}', isSystem: true);
        }
      
        if (result['line5'].toString().isNotEmpty) {
          _addMessage('Entropy Increase: ${result['line5']}', isSystem: true);
         
        }
         if (result['line6'].toString().isNotEmpty) {
          _addMessage('Entropy descrease: ${result['line6']}', isSystem: true);
        }
         if (result['line7'].toString().isNotEmpty) {
          _addMessage('Entropy descrease: ${result['line7']}', isSystem: true);
        }
        final fragments = result['fragments'] as List<String>;
        if (fragments.isNotEmpty) {
          _addMessage('–ù–∞–π–¥–µ–Ω–æ ${fragments.length} —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤', isSystem: true);
          for (int i = 0; i < min(5, fragments.length); i++) {
            _addMessage(fragments[i]);
          }
        }
        
        setState(() {});
      }
    } catch (e) {
      _addMessage('–û—à–∏–±–∫–∞: $e', isSystem: true);
    }
    
    setState(() => _isProcessing = false);
  }
  
  void _handleSearchUpdate(String text) {
    if (text.isEmpty) {
      setState(() {
        network.currentSearchVector.clear();
        network.currentSearchWords.clear();
      });
      return;
    }
    
    switch (network.visualizationMode) {
      case VisualizationMode.words:
        _handleWordSearch(text);
        break;
      case VisualizationMode.neurons:
        _handleNeuronSearch(text);
        break;
      case VisualizationMode.fragments:
        _handleFragmentSearch(text);
        break;
    }
  }
  
  void _handleWordSearch(String text) {
    final wordTexts = network._extractWords(text);
    final promptWordIds = wordTexts
        .map((w) => network.wordIndex[w])
        .where((id) => id != null)
        .cast<int>()
        .toList();
    
    if (promptWordIds.isEmpty) return;
    
    final superVector = <int, int>{};
    for (final wordId in promptWordIds) {
      final word = network.words[wordId];
      if (word != null) {
        for (final entry in word.ratings.entries) {
          superVector[entry.key] = (superVector[entry.key] ?? 0) + entry.value;
        }
      }
    }
    
    final projectedVector = VectorOperations.selfProjection(superVector, network.words);
    
    setState(() {
      network.currentSearchVector = projectedVector;
      network.currentSearchWords = promptWordIds;
    });
  }
  
  void _handleNeuronSearch(String text) {
    final foundNeurons = network.searchNeuronsByKeywords(text);
    setState(() {
      network.selectedNeuronIds = foundNeurons.take(10).map((n) => n.id).toSet();
    });
  }
  
  void _handleFragmentSearch(String text) {
    final foundFragments = network.searchFragments(text);
    setState(() {
      network.selectedFragmentIds = foundFragments.take(10).map((f) => f.id).toSet();
    });
  }
  
  void _handleWordSelected(int wordId, bool withShift) {
    setState(() {
      network.selectWord(wordId, withShift: withShift || _shiftPressed);
    });
  }
  
  void _handleNeuronSelected(int neuronId, bool withShift) {
    setState(() {
      network.selectNeuron(neuronId, withShift: withShift || _shiftPressed);
    });
  }

  void _handleFragmentSelected(int fragmentId, bool withShift) {
    setState(() {
      network.selectFragment(fragmentId, withShift: withShift || _shiftPressed);
      
      if (network.selectedFragmentIds.isNotEmpty) {
        final allFragmentWordIds = <int>{};
        for (final selectedFragmentId in network.selectedFragmentIds) {
          final fragment = network.fragments[selectedFragmentId];
          if (fragment != null) {
            allFragmentWordIds.addAll(fragment.wordIds);
          }
        }
        network.selectedWordIds = allFragmentWordIds;
      }
    });
  }

  void _handleClusterTapped(String clusterId) {
    network.toggleClusterExpansion(clusterId);
    setState(() {});
  }

  void _changeVisualizationMode(VisualizationMode mode) {
    setState(() {
      network.visualizationMode = mode;
      _searchController.clear();
      network.currentSearchVector.clear();
      network.currentSearchWords.clear();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Advanced Neural Network System'),
        backgroundColor: Colors.deepPurple,
        actions: [
          IconButton(
            icon: Icon(Icons.save),
            onPressed: () => network.saveToFile(),
            tooltip: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å',
          ),
          IconButton(
            icon: Icon(Icons.auto_awesome),
            onPressed: () {
              network.optimizeWordPositions();
              _addMessage('–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞', isSystem: true);
              setState(() {});
            },
            tooltip: '–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å',
          ),
        ],
      ),
      body: Row(
        children: [
          Expanded(flex: 3, child: _buildChatPanel()),
          Expanded(flex: 2, child: _buildVisualizationPanel()),
          if (network.selectedWordIds.isNotEmpty || 
              network.selectedNeuronIds.isNotEmpty || 
              network.selectedFragmentIds.isNotEmpty)
            Container(
              width: MediaQuery.of(context).size.width * 0.3,
              child: _buildDetailsPanel(),
            ),
        ],
      ),
    );
  }
  
  Widget _buildChatPanel() {
    return Container(
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.deepPurple.withOpacity(0.1),
              borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
            ),
            child: Row(
              children: [
                Icon(Icons.chat, color: Colors.deepPurple),
                SizedBox(width: 8),
                Text('–ù–µ–π—Ä–æ-—á–∞—Ç', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                Spacer(),
                if (_isProcessing)
                  Row(
                    children: [
                      SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2)),
                      SizedBox(width: 8),
                      Text('${network.words.length} —Å–ª–æ–≤', style: TextStyle(fontSize: 12, color: Colors.grey)),
                    ],
                  ),
              ],
            ),
          ),
          Expanded(
            child: ListView.builder(
              reverse: true,
              itemCount: _messages.length,
              itemBuilder: (context, index) {
                final message = _messages[_messages.length - 1 - index];
                return ChatBubble(
                  message: message,
                  onWordTap: (word) {
                    _searchController.text = word;
                    _handleSearchUpdate(word);
                  },
                );
              },
            ),
          ),
          Container(
            padding: EdgeInsets.all(8),
            decoration: BoxDecoration(
              border: Border(top: BorderSide(color: Colors.grey)),
            ),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _chatController,
                    decoration: InputDecoration(
                      hintText: 'URL, /neurons, /optimize –∏–ª–∏ –∑–∞–ø—Ä–æ—Å...',
                      border: OutlineInputBorder(),
                    ),
                    onSubmitted: _handleMessage,
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.send),
                  onPressed: () => _handleMessage(_chatController.text),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildVisualizationPanel() {
    return Container(
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.blue.withOpacity(0.1),
              borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
            ),
            child: Column(
              children: [
                Row(
                  children: [
                    Icon(Icons.auto_awesome, color: Colors.blue),
                    SizedBox(width: 8),
                    Text(
                      _getVisualizationTitle(),
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                  ],
                ),
                SizedBox(height: 8),
                TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: _getSearchHint(),
                    prefixIcon: Icon(Icons.search),
                    border: OutlineInputBorder(),
                    contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  ),
                  onChanged: _handleSearchUpdate,
                ),
                if (network.navigationHistory.isNotEmpty) ...[
                  SizedBox(height: 8),
                  Container(
                    height: 30,
                    child: ListView.builder(
                      scrollDirection: Axis.horizontal,
                      itemCount: network.navigationHistory.length,
                      itemBuilder: (context, index) {
                        final step = network.navigationHistory[index];
                        return Padding(
                          padding: EdgeInsets.only(right: 8),
                          child: ActionChip(
                            label: Text(
                              step.displayText,
                              style: TextStyle(fontSize: 9),
                            ),
                            onPressed: () => network.navigateToStep(index),
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ],
            ),
          ),
          Expanded(
            child: OverflowBox(
              maxWidth: MediaQuery.of(context).size.width * 0.7,
              maxHeight: MediaQuery.of(context).size.height * 0.7,
              child: ClipRect(
                child: _buildVisualization(),
              ),
            ),
          ),
          Container(
            padding: EdgeInsets.all(12),
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(color: Colors.grey, width: 1.0),
              ),
              color: Colors.grey.withOpacity(0.1),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildVisualizationButton('–°–ª–æ–≤–∞', Icons.text_fields, VisualizationMode.words),
                _buildVisualizationButton('–ù–µ–π—Ä–æ–Ω—ã', Icons.hub, VisualizationMode.neurons),
                _buildVisualizationButton('–§—Ä–∞–≥–º–µ–Ω—Ç—ã', Icons.article, VisualizationMode.fragments),
                _buildStatItem('–°–ª–æ–≤–∞', network.words.length.toString()),
                _buildStatItem('–§—Ä–∞–≥–º–µ–Ω—Ç—ã', network.fragments.length.toString()),
                _buildStatItem('–ù–µ–π—Ä–æ–Ω—ã', network.neurons.length.toString()),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildVisualization() {
    switch (network.visualizationMode) {
      case VisualizationMode.words:
        return InteractiveWordVisualization3D(
          network: network,
          selectedWordIds: network.selectedWordIds,
          onWordSelected: _handleWordSelected,
        );
      case VisualizationMode.neurons:
        return AdvancedNeuron3DVisualization(
          network: network,
          selectedNeuronIds: network.selectedNeuronIds,
          onNeuronSelected: _handleNeuronSelected,
          onClusterTapped: _handleClusterTapped,
          sendMessage: _addMessage,
        );
      case VisualizationMode.fragments:
        return Fragment3DVisualization(
          network: network,
          selectedFragmentIds: network.selectedFragmentIds,
          onFragmentSelected: _handleFragmentSelected,
          neuronIds: network.selectedNeuronIds.isNotEmpty ? 
              network.selectedNeuronIds : null,
        );
    }
  }
  
  Widget _buildVisualizationButton(String label, IconData icon, VisualizationMode mode) {
    return GestureDetector(
      onTap: () => _changeVisualizationMode(mode),
      child: Container(
        padding: EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: network.visualizationMode == mode ? Colors.blue : Colors.grey,
          borderRadius: BorderRadius.circular(20),
        ),
        child: Row(
          children: [
            Icon(icon, size: 16, color: Colors.white),
            SizedBox(width: 4),
            Text(label, style: TextStyle(fontSize: 12, color: Colors.white)),
          ],
        ),
      ),
    );
  }
  
  Widget _buildDetailsPanel() {
    if (network.selectedWordIds.isNotEmpty) {
      return _buildWordDetailsPanel();
    } else if (network.selectedNeuronIds.isNotEmpty) {
      return _buildNeuronDetailsPanel();
    } else if (network.selectedFragmentIds.isNotEmpty) {
      return _buildFragmentDetailsPanel();
    }
    return SizedBox.shrink();
  }

  Widget _buildWordDetailsPanel() {
    final wordId = network.selectedWordIds.isNotEmpty ? network.selectedWordIds.first : null;
    if (wordId == null) return SizedBox.shrink();
    
    final word = network.words[wordId];
    if (word == null) return SizedBox.shrink();
    
    final wordText = network.wordLibrary[wordId] ?? 'Unknown';
    
    return Container(
      width: MediaQuery.of(context).size.width * 0.3,
      height: MediaQuery.of(context).size.height,
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.orange),
        borderRadius: BorderRadius.circular(8),
        color: Colors.black.withOpacity(0.9),
      ),
      child: DefaultTabController(
        length: 3,
        child: Column(
          children: [
            Container(
              decoration: BoxDecoration(
                color: Colors.orange.withOpacity(0.3),
                borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
              ),
              child: Column(
                children: [
                  Padding(
                    padding: EdgeInsets.all(12),
                    child: Row(
                      children: [
                        Icon(Icons.label, color: Colors.orange, size: 20),
                        SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            wordText,
                            style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.white),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        IconButton(
                          icon: Icon(Icons.close, color: Colors.white, size: 20),
                          onPressed: () => network.clearSelection(),
                        ),
                      ],
                    ),
                  ),
                  TabBar(
                    labelColor: Colors.orange,
                    unselectedLabelColor: Colors.white70,
                    indicatorColor: Colors.orange,
                    tabs: [
                      Tab(text: 'Connections'),
                      Tab(text: 'Fragments'),
                      Tab(text: 'Composite'),
                    ],
                  ),
                ],
              ),
            ),
            Expanded(
              child: TabBarView(
                children: [
                  _buildConnectionsTab(word),
                  _buildFragmentsTab(word),
                  _buildCompositeTab(word),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildConnectionsTab(Word word) {
      final connections = word.ratings.entries.toList();
      connections.sort((a, b) => b.value.compareTo(a.value));

      final topWords = connections.take(40).map((e) => e.key).toList();
      final bottomWords = connections.reversed.take(20).map((e) => e.key).toList();
      final listToShow = [...topWords, ...bottomWords];

    //votsuda 
    return ListView.builder(
      padding: EdgeInsets.all(12),
      itemCount: min(listToShow.length, 50),
      itemBuilder: (context, index) {
        final conn = connections[index];
        final connWord = network.wordLibrary[conn.key] ?? 'Unknown';
        
        return Card(
          color: Colors.grey[850],
          child: ListTile(
            leading: CircleAvatar(
              backgroundColor: Colors.orange,
              child: Text('${index + 1}', style: TextStyle(fontSize: 10)),
            ),
            title: Text(connWord, style: TextStyle(color: Colors.white)),
            trailing: Chip(
              label: Text('${conn.value}'),
              backgroundColor: Colors.orange,
            ),
            onTap: () => _handleWordSelected(conn.key, _shiftPressed),
          ),
        );
      },
    );
  }

  Widget _buildFragmentsTab(Word word) {
    final allFragments = network.fragments.values
        .where((f) => f.wordIds.contains(word.id))
        .toList();
    
    return ListView.builder(
      padding: EdgeInsets.all(12),
      itemCount: allFragments.length,
      itemBuilder: (context, index) {
        final frag = allFragments[index];
        
        return Card(
          color: Colors.grey[850],
          margin: EdgeInsets.only(bottom: 8),
          child: Padding(
            padding: EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  frag.text,
                  style: TextStyle(color: Colors.white70, fontSize: 12),
                ),
                SizedBox(height: 8),
                Chip(
                  label: Text(frag.semanticType.semanticType.displayName),
                  backgroundColor: Colors.blue,
                  labelStyle: TextStyle(fontSize: 10, color: Colors.white),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildCompositeTab(Word word) {
    return StatefulBuilder(
      builder: (context, setState) {
        return Column(
          children: [
            Padding(
              padding: EdgeInsets.all(12),
              child: Row(
                children: [
                  Text('–í—ã–¥–µ–ª–µ–Ω–Ω—ã–µ —Å–ª–æ–≤–∞: ${network.selectedWordIds.length}', 
                      style: TextStyle(color: Colors.white)),
                  Spacer(),
                  if (network.selectedWordIds.length > 1)
                    ElevatedButton.icon(
                      icon: Icon(Icons.search, size: 16),
                      label: Text('–ü–æ–∏—Å–∫ –ø–æ —Å–ª–æ–≤–∞–º'),
                      onPressed: _searchWithSelectedWords,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.blue,
                        padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      ),
                    ),
                ],
              ),
            ),
            Expanded(
              child: _buildCompositeSearchResults(),
            ),
          ],
        );
      },
    );
  }

  Widget _buildCompositeSearchResults() {
    if (network.selectedWordIds.length < 2) {
      return Center(
        child: Text('–í—ã–¥–µ–ª–∏—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ª–æ–≤ (Shift+Click)', 
            style: TextStyle(color: Colors.white70)),
      );
    }
    
    final fragments = network.findFragmentsWithAllWords(network.selectedWordIds);
    final compositeVector = network.getCompositeVector(network.selectedWordIds);
    
    final uniqueFragments = _removeDuplicateFragments(fragments);
    
    return Column(
      children: [
        Padding(
          padding: EdgeInsets.all(8),
          child: Text('–ö–æ–º–ø–æ–∑–∏—Ç–Ω—ã–π –≤–µ–∫—Ç–æ—Ä: ${compositeVector.length} —Å–≤—è–∑–µ–π\n'
                      '–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤: ${uniqueFragments.length}',
              style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        ),
        Expanded(
          child: ListView.builder(
            itemCount: uniqueFragments.length,
            itemBuilder: (context, index) {
              final fragment = uniqueFragments[index];
              final isSelected = network.selectedFragmentIds.contains(fragment.id);
              
              return Card(
                color: isSelected ? Colors.blue.withOpacity(0.3) : Colors.grey[850],
                margin: EdgeInsets.all(4),
                child: ListTile(
                  title: Text(
                    fragment.text,
                    style: TextStyle(color: Colors.white, fontSize: 12),
                  ),
                  trailing: isSelected ? Icon(Icons.check_circle, color: Colors.blue) : null,
                  onTap: () {
                    setState(() {
                      if (_shiftPressed) {
                        if (isSelected) {
                          network.selectedFragmentIds.remove(fragment.id);
                        } else {
                          network.selectedFragmentIds.add(fragment.id);
                        }
                      } else {
                        network.selectedFragmentIds = {fragment.id};
                      }
                      
                      _highlightWordsInFragment(fragment);
                    });
                  },
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  List<Fragment> _removeDuplicateFragments(List<Fragment> fragments) {
    final seenTexts = <String>{};
    final uniqueFragments = <Fragment>[];
    
    for (final fragment in fragments) {
      final normalizedText = fragment.text.trim().toLowerCase();
      if (!seenTexts.contains(normalizedText)) {
        seenTexts.add(normalizedText);
        uniqueFragments.add(fragment);
      }
    }
    
    return uniqueFragments;
  }

  void _highlightWordsInFragment(Fragment fragment) {
    final fragmentWordIds = fragment.wordIds.toSet();
    setState(() {
      network.selectedWordIds = fragmentWordIds;
    });
  }

  void _searchWithSelectedWords() {
    if (network.selectedWordIds.length < 2) return;
    
    final compositeVector = network.getCompositeVector(network.selectedWordIds);
    final fragments = network.findFragmentsWithAllWords(network.selectedWordIds);
    
    setState(() {
      network.currentSearchVector = compositeVector;
    });
    
    _addMessage('–ù–∞–π–¥–µ–Ω–æ ${fragments.length} —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ —Å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏', isSystem: true);
  }

  Widget _buildNeuronDetailsPanel() {
    return Container(
      width: MediaQuery.of(context).size.width * 0.3,
      height: MediaQuery.of(context).size.height,
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.purple),
        borderRadius: BorderRadius.circular(8),
        color: Colors.black.withOpacity(0.9),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.purple.withOpacity(0.3),
              borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
            ),
            child: Row(
              children: [
                Icon(Icons.hub, color: Colors.purple),
                SizedBox(width: 8),
                Expanded(
                  child: Text(
                    '${network.selectedNeuronIds.length} –Ω–µ–π—Ä–æ–Ω–æ–≤ –≤—ã–±—Ä–∞–Ω–æ',
                    style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.close, color: Colors.white),
                  onPressed: () => network.clearSelection(),
                ),
              ],
            ),
          ),
          
          if (network.selectedNeuronIds.isNotEmpty) ...[
            Padding(
              padding: EdgeInsets.all(8),
              child: Wrap(
                spacing: 8,
                runSpacing: 8,
                children: [
                  if (network.selectedNeuronIds.length >= 2) ...[
                    ElevatedButton.icon(
                      icon: Icon(Icons.merge),
                      label: Text('New Neuron'),
                      onPressed: _mergeSelectedNeurons,
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
                    ),
                    ElevatedButton.icon(
                      icon: Icon(Icons.link),
                      label: Text('Process'),
                      onPressed: _processSelectedNeurons,
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),
                    ),
                  ],
                  ElevatedButton.icon(
                    icon: Icon(Icons.article),
                    label: Text('Show Fragments'),
                    onPressed: _createFragmentVisualizationFromNeurons,
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),
                  ),
                  ElevatedButton.icon(
                    icon: Icon(Icons.content_copy),
                    label: Text('Copy'),
                    onPressed: _copySelectedNeuronsToClipboard,
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.orange),
                  ),
                  ElevatedButton.icon(
                    icon: Icon(Icons.auto_awesome),
                    label: Text('Show Words'),
                    onPressed: _createWordsVisualizationFromNeurons,
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.purple),
                  ),
                ],
              ),
            ),
          ],
          
          Expanded(
            child: _buildNeuronFragmentsList(),
          ),
        ],
      ),
    );
  }

  void _createFragmentVisualizationFromNeurons() {
    if (network.selectedNeuronIds.isEmpty) return;
    
    setState(() {
      network.visualizationMode = VisualizationMode.fragments;
    });
    
    _addMessage('–°–æ–∑–¥–∞–Ω–∞ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –¥–ª—è ${network.selectedNeuronIds.length} –Ω–µ–π—Ä–æ–Ω–æ–≤', isSystem: true);
  }

  Future<void> _mergeSelectedNeurons() async {
    if (network.selectedNeuronIds.length < 2) return;
    
    final newNeuron = await network.mergeNeurons(network.selectedNeuronIds);
    _addMessage('–°–æ–∑–¥–∞–Ω –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–π –Ω–µ–π—Ä–æ–Ω #${newNeuron.id} –∏–∑ ${network.selectedNeuronIds.length} –Ω–µ–π—Ä–æ–Ω–æ–≤', isSystem: true);
    
    setState(() {
      network.selectedNeuronIds = {newNeuron.id};
    });
  }

  Future<void> _processSelectedNeurons() async {
    if (network.selectedNeuronIds.length < 2) return;
    
    await network.processNeuronConnections(network.selectedNeuronIds);
    _addMessage('–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${network.selectedNeuronIds.length} –Ω–µ–π—Ä–æ–Ω–æ–≤, —Å–≤—è–∑–∏ —É—Å–∏–ª–µ–Ω—ã', isSystem: true);
    setState(() {});
  }

  Future<void> _copySelectedNeuronsToClipboard() async {
    if (network.selectedNeuronIds.isEmpty) return;
    
    await network.copyNeuronsToClipboard(network.selectedNeuronIds);
    _addMessage('–¢–µ–∫—Å—Ç ${network.selectedNeuronIds.length} –Ω–µ–π—Ä–æ–Ω–æ–≤ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä', isSystem: true);
  }

  Future<void> _copySelectedFragmentsToClipboard() async {
    if (network.selectedFragmentIds.isEmpty) return;
    
    await network.copyFragmentsToClipboard(network.selectedFragmentIds.toList());
    _addMessage('–¢–µ–∫—Å—Ç ${network.selectedFragmentIds.length} —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä', isSystem: true);
  }

  Widget _buildNeuronFragmentsList() {
    final selectedNeuronId = network.selectedNeuronIds.isNotEmpty ? network.selectedNeuronIds.first : null;
    if (selectedNeuronId == null) return Center(child: Text('–í—ã–±–µ—Ä–∏—Ç–µ –Ω–µ–π—Ä–æ–Ω', style: TextStyle(color: Colors.white)));
    
    final neuron = network.neurons[selectedNeuronId];
    if (neuron == null) return Center(child: Text('–ù–µ–π—Ä–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω', style: TextStyle(color: Colors.white)));
    
    final fragmentIds = neuron.fragmentLinks;
    
    return StatefulBuilder(
      builder: (context, setState) {
        return Column(
          children: [
            Padding(
              padding: EdgeInsets.all(8),
              child: Row(
                children: [
                  Text('–§—Ä–∞–≥–º–µ–Ω—Ç—ã: ${fragmentIds.length}', 
                      style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                  Spacer(),
                  if (network.selectedFragmentIds.isNotEmpty)
                    ElevatedButton.icon(
                      icon: Icon(Icons.content_copy, size: 16),
                      label: Text('–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ'),
                      onPressed: _copySelectedFragmentsToClipboard,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.green,
                        padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      ),
                    ),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: fragmentIds.length,
                itemBuilder: (context, index) {
                  final fragmentId = fragmentIds[index];
                  final fragment = network.fragments[fragmentId];
                  if (fragment == null) return SizedBox.shrink();
                  
                  final isSelected = network.selectedFragmentIds.contains(fragmentId);
                  
                  return Card(
                    color: isSelected ? Colors.green.withOpacity(0.3) : Colors.grey[850],
                    margin: EdgeInsets.all(4),
                    child: ListTile(
                      title: Text(
                        fragment.text.length > 100 
                            ? fragment.text.substring(0, 100) + "..." 
                            : fragment.text,
                        style: TextStyle(color: Colors.white, fontSize: 12),
                      ),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          SizedBox(height: 4),
                          Wrap(
                            spacing: 4,
                            children: fragment.keywords.take(3).map((wordId) {
                              final wordText = network.wordLibrary[wordId] ?? '';
                              return GestureDetector(
                                onTap: () => _handleWordTap(wordText),
                                child: Chip(
                                  label: Text(wordText, style: TextStyle(fontSize: 8)),
                                  backgroundColor: Colors.purple.withOpacity(0.5),
                                ),
                              );
                            }).toList(),
                          ),
                        ],
                      ),
                      trailing: isSelected ? Icon(Icons.check_circle, color: Colors.green) : null,
                      onTap: () {
                        setState(() {
                          if (_shiftPressed) {
                            if (isSelected) {
                              network.selectedFragmentIds.remove(fragmentId);
                            } else {
                              network.selectedFragmentIds.add(fragmentId);
                            }
                          } else {
                            network.selectedFragmentIds = {fragmentId};
                          }
                        });
                      },
                      onLongPress: () {
                        _showFragmentDetail(fragment);
                      },
                    ),
                  );
                },
              ),
            ),
          ],
        );
      },
    );
  }

  void _showFragmentDetail(Fragment fragment) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: Colors.black,
        surfaceTintColor: Colors.transparent,
        title: Row(
          children: [
            Icon(Icons.article, color: Colors.green),
            SizedBox(width: 8),
            Text('–§—Ä–∞–≥–º–µ–Ω—Ç #${fragment.id}', style: TextStyle(color: Colors.white)),
          ],
        ),
        content: Container(
          width: MediaQuery.of(context).size.width * 0.8,
          height: MediaQuery.of(context).size.height * 0.8,
          child: _buildFragmentDetailContent(fragment),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('–ó–∞–∫—Ä—ã—Ç—å', style: TextStyle(color: Colors.white)),
          ),
          ElevatedButton(
            onPressed: () {
              Clipboard.setData(ClipboardData(text: fragment.text));
              Navigator.of(context).pop();
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('–¢–µ–∫—Å—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä')),
              );
            },
            child: Text('–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç'),
          ),
        ],
      ),
    );
  }

  Widget _buildFragmentDetailContent(Fragment fragment) {
    final containingNeurons = network.neurons.values
        .where((neuron) => neuron.fragmentLinks.contains(fragment.id))
        .toList();
    
    final allFragments = network.fragments.values.toList();
    final currentIndex = allFragments.indexWhere((f) => f.id == fragment.id);
    final previousFragment = currentIndex > 0 ? allFragments[currentIndex - 1] : null;
    final nextFragment = currentIndex < allFragments.length - 1 ? allFragments[currentIndex + 1] : null;
    
    return DefaultTabController(
      length: 3,
      child: Column(
        children: [
          TabBar(
            labelColor: Colors.green,
            unselectedLabelColor: Colors.white70,
            indicatorColor: Colors.green,
            tabs: [
              Tab(text: '–¢–µ–∫—Å—Ç'),
              Tab(text: '–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞'),
              Tab(text: '–ö–æ–Ω—Ç–µ–∫—Å—Ç'),
            ],
          ),
          Expanded(
            child: TabBarView(
              children: [
                SingleChildScrollView(
                  padding: EdgeInsets.all(16),
                  child: SelectableText(
                    fragment.text,
                    style: TextStyle(color: Colors.white, fontSize: 14),
                  ),
                ),
                
                _buildKeywordsTab(fragment),
                
                _buildContextTab(fragment, containingNeurons, previousFragment, nextFragment),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildKeywordsTab(Fragment fragment) {
    return Padding(
      padding: EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞:', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: fragment.keywords.map((wordId) {
              final wordText = network.wordLibrary[wordId] ?? '';
              return GestureDetector(
                onTap: () {
                  Navigator.of(context).pop();
                  network.selectWord(wordId);
                  setState(() {});
                },
                child: Chip(
                  label: Text(wordText),
                  backgroundColor: Colors.green.withOpacity(0.3),
                ),
              );
            }).toList(),
          ),
          SizedBox(height: 16),
          Text('–°–∏–≥–Ω–∞—Ç—É—Ä–∞:', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          SizedBox(height: 8),
          Text(
            fragment.semanticType.semanticType.displayName,
            style: TextStyle(color: Colors.white70),
          ),
        ],
      ),
    );
  }

  Widget _buildContextTab(Fragment fragment, List<Neuron> containingNeurons, Fragment? previousFragment, Fragment? nextFragment) {
    return Padding(
      padding: EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('–ü—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –Ω–µ–π—Ä–æ–Ω–∞–º:', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          SizedBox(height: 8),
          if (containingNeurons.isEmpty)
            Text('–ù–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –Ω–∏ –æ–¥–Ω–æ–º—É –Ω–µ–π—Ä–æ–Ω—É', style: TextStyle(color: Colors.white70)),
          ...containingNeurons.map((neuron) => ListTile(
            leading: Icon(Icons.hub, color: Colors.purple),
            title: Text(neuron.pageTitle ?? 'Neuron #${neuron.id}', style: TextStyle(color: Colors.white)),
            onTap: () {
              Navigator.of(context).pop();
              network.selectNeuron(neuron.id);
              setState(() {});
            },
          )).toList(),
          
          SizedBox(height: 16),
          Text('–°–æ—Å–µ–¥–Ω–∏–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã:', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          SizedBox(height: 8),
          if (previousFragment != null) 
            _buildNeighborFragmentTile(previousFragment, '–ü—Ä–µ–¥—ã–¥—É—â–∏–π'),
          if (nextFragment != null)
            _buildNeighborFragmentTile(nextFragment, '–°–ª–µ–¥—É—é—â–∏–π'),
        ],
      ),
    );
  }

  Widget _buildNeighborFragmentTile(Fragment fragment, String label) {
    return Card(
      color: Colors.grey[850],
      child: ListTile(
        leading: Icon(Icons.article, color: Colors.blue),
        title: Text(label, style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        subtitle: Text(
          fragment.text.length > 100 ? fragment.text.substring(0, 100) + "..." : fragment.text,
          style: TextStyle(color: Colors.white70),
        ),
        onTap: () {
          Navigator.of(context).pop();
          _showFragmentDetail(fragment);
        },
      ),
    );
  }

  void _createWordsVisualizationFromNeurons() {
    if (network.selectedNeuronIds.isEmpty) return;
    
    final projectedWords = network.createNeuronWordsVisualization(network.selectedNeuronIds);
    
    setState(() {
      network.visualizationMode = VisualizationMode.words;
    });
    
    _addMessage('–°–æ–∑–¥–∞–Ω–∞ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ–≤ –¥–ª—è ${network.selectedNeuronIds.length} –Ω–µ–π—Ä–æ–Ω–æ–≤', isSystem: true);
  }

  void _handleWordTap(String wordText) {
    _searchController.text = wordText;
    _handleSearchUpdate(wordText);
  }

  Widget _buildFragmentDetailsPanel() {
    return Container(
      height: MediaQuery.of(context).size.height,
      margin: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.green),
        borderRadius: BorderRadius.circular(8),
        color: Colors.black.withOpacity(0.9),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.green.withOpacity(0.3),
              borderRadius: BorderRadius.vertical(top: Radius.circular(8)),
            ),
            child: Row(
              children: [
                Icon(Icons.article, color: Colors.green),
                SizedBox(width: 8),
                Expanded(
                  child: Text(
                    '${network.selectedFragmentIds.length} —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –≤—ã–±—Ä–∞–Ω–æ',
                    style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.close, color: Colors.white),
                  onPressed: () => network.clearSelection(),
                ),
              ],
            ),
          ),
          if (network.selectedFragmentIds.isNotEmpty) ...[
            Padding(
              padding: EdgeInsets.all(8),
              child: ElevatedButton.icon(
                icon: Icon(Icons.content_copy),
                label: Text('–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä'),
                onPressed: _copySelectedFragmentsToClipboard,
                style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
              ),
            ),
          ],
          Expanded(
            child: ListView.builder(
              itemCount: network.selectedFragmentIds.length,
              itemBuilder: (context, index) {
                final fragmentId = network.selectedFragmentIds.elementAt(index);
                final fragment = network.fragments[fragmentId];
                if (fragment == null) return SizedBox.shrink();
                
                return Card(
                  color: Colors.grey[850],
                  margin: EdgeInsets.all(8),
                  child: Padding(
                    padding: EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          fragment.text,
                          style: TextStyle(color: Colors.white, fontSize: 12),
                        ),
                        SizedBox(height: 8),
                        Wrap(
                          spacing: 4,
                          children: fragment.keywords.map((wordId) {
                            final wordText = network.wordLibrary[wordId] ?? '';
                            return Chip(
                              label: Text(wordText, style: TextStyle(fontSize: 8)),
                              backgroundColor: Colors.green.withOpacity(0.5),
                            );
                          }).toList(),
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Column(
      children: [
        Text(value, style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.deepPurple)),
        Text(label, style: TextStyle(fontSize: 12, color: Colors.grey)),
      ],
    );
  }

  String _getVisualizationTitle() {
    switch (network.visualizationMode) {
      case VisualizationMode.words:
        return '3D –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ–≤';
      case VisualizationMode.neurons:
        return '3D –ì—Ä–∞—Ñ –Ω–µ–π—Ä–æ–Ω–æ–≤';
      case VisualizationMode.fragments:
        return '3D –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤';
    }
  }

  String _getSearchHint() {
    switch (network.visualizationMode) {
      case VisualizationMode.words:
        return '–ü–æ–∏—Å–∫ —Å–ª–æ–≤...';
      case VisualizationMode.neurons:
        return '–ü–æ–∏—Å–∫ –Ω–µ–π—Ä–æ–Ω–æ–≤...';
      case VisualizationMode.fragments:
        return '–ü–æ–∏—Å–∫ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤...';
    }
  }
}


class NumberMatch {
  final int value;
  final String match;
  final int start;
  final int end;
  
  NumberMatch({
    required this.value,
    required this.match,
    required this.start,
    required this.end,
  });
}

class ChatMessage1 {
  final String text;
  final bool isSystem;
  final DateTime timestamp;
  
  ChatMessage1({required this.text, required this.isSystem, required this.timestamp});
}

class ChatBubble extends StatelessWidget {
  final ChatMessage1 message;
  final Function(String)? onWordTap;
  
  const ChatBubble({Key? key, required this.message, this.onWordTap}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Container(
      margin: EdgeInsets.symmetric(vertical: 4, horizontal: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            message.isSystem ? Icons.settings : Icons.person,
            size: 16,
            color: message.isSystem ? Colors.grey : Colors.blue,
          ),
          SizedBox(width: 8),
          Expanded(
            child: Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: message.isSystem ? Colors.grey.withOpacity(0.1) : Colors.blue.withOpacity(0.1),
                borderRadius: BorderRadius.circular(12),
              ),
              child: _buildClickableText(message.text),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildClickableText(String text) {
    final words = text.split(' ');
    return Wrap(
      children: words.map((word) {
        return GestureDetector(
          onTap: () => onWordTap?.call(word),
          child: Container(
            margin: EdgeInsets.only(right: 4),
            child: Text(
              '$word ',
              style: TextStyle(
                fontSize: 14,
                color: _isClickableWord(word) ? Colors.blue : null,
                decoration: _isClickableWord(word) ? TextDecoration.underline : TextDecoration.none,
              ),
            ),
          ),
        );
      }).toList(),
    );
  }
  
  bool _isClickableWord(String word) {
    return word.length > 3 && 
           RegExp(r'^[a-zA-Z–∞-—è–ê-–Ø—ë–Å]+$').hasMatch(word) &&
           !STOP_WORDS.contains(word.toLowerCase());
  }
}
class AdvancedNeuron3DVisualization extends StatefulWidget {
  final OptimizedNeuralNetwork network;
  final Set<int> selectedNeuronIds;
  final Function(int, bool) onNeuronSelected;
  final Function(String) onClusterTapped;
  final Function(String, {bool isSystem}) sendMessage; // –ò–∑–º–µ–Ω–∏—Ç–µ –∑–¥–µ—Å—å
  
  const AdvancedNeuron3DVisualization({
    Key? key,
    required this.network,
    required this.selectedNeuronIds,
    required this.onNeuronSelected,
    required this.onClusterTapped,
    required this.sendMessage,
  }) : super(key: key);
  
  @override
  _AdvancedNeuron3DVisualizationState createState() => _AdvancedNeuron3DVisualizationState();
}

class _AdvancedNeuron3DVisualizationState extends State<AdvancedNeuron3DVisualization> 
    with SingleTickerProviderStateMixin {
  // –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç - –∫–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ —Å—Ü–µ–Ω—É
  double _cameraX = 0.0;
  double _cameraY = 0.0;
  double _cameraZ = 1000.0; // –ö–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç —Å–≤–µ—Ä—Ö—É
  double _cameraScale = 1.0;
  
  // –í—Ä–∞—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
  double _rotationX = 0.0;
  double _rotationY = 0.0;
  
  // –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
  Offset? _lastPanOffset;
  bool _isPanning = false;
  String? _hoveredClusterId;
  String? _draggedClusterId;
  Offset? _dragStartOffset;
  Offset? _clusterStartOffset;
  
  // –ê–Ω–∏–º–∞—Ü–∏—è
  late AnimationController _animationController;
  final Map<String, double> _clusterGlowIntensities = {};
  final Map<String, double> _connectionWeights = {};
    bool _isAnimating = false;
  String? _expandingClusterId;
  @override
  void initState() {
    super.initState();
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–∑–∏—Ü–∏–∏ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –∫–ª–∞—Å—Ç–µ—Ä–∞ –≤–Ω–∏–∑—É —Å—Ü–µ–Ω—ã
    _initializeRootClusterPosition();
    
        _animationController = AnimationController(
      vsync: this,
      duration: Duration(milliseconds: 16),
    )..addListener(_onAnimationTick);
    
    
    _animationController.repeat();
    _initializeConnectionWeights();
  }
   
  void _onAnimationTick() {
    if (!mounted) return;
    
    widget.network.updateAnimations(1/60);
    _updateConnectionWeights();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è
    if (widget.network.hasVisualChanges) {
      setState(() {});
    }
  }
  void _initializeRootClusterPosition() {
    final rootCluster = widget.network.clusters['root'];
    if (rootCluster != null) {
      // –ü–æ–º–µ—â–∞–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π –∫–ª–∞—Å—Ç–µ—Ä –≤–Ω–∏–∑—É —Å—Ü–µ–Ω—ã
      rootCluster.updatePosition(0.0, 300.0, 0.0);
      
      // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ –∫–ª–∞—Å—Ç–µ—Ä—ã –≤–æ–∫—Ä—É–≥ –Ω–µ–≥–æ –≤–≤–µ—Ä—Ö
      _positionChildClusters('root', 0.0, 300.0, 0);
    }
  }
  
  void _positionChildClusters(String parentId, double parentX, double parentY, int depth) {
    final parent = widget.network.clusters[parentId];
    if (parent == null) return;
    
    final children = parent.childClusterIds
        .map((id) => widget.network.clusters[id])
        .whereType<NeuronCluster>()
        .toList();
    
    if (children.isEmpty) return;
    
    final angleStep = (2 * pi) / children.length;
    final radius = 150.0 + (depth * 50.0);
    
    for (int i = 0; i < children.length; i++) {
      final child = children[i];
      final angle = i * angleStep;
      
      double childX, childY, childZ;
      
      // –ß–µ—Ä–µ–¥—É–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è: —á–µ—Ç–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ - –≤–≤–µ—Ä—Ö, –Ω–µ—á–µ—Ç–Ω–∞—è - –≤–ø—Ä–∞–≤–æ
      if (depth % 2 == 0) {
        // –í–≤–µ—Ä—Ö
        childX = parentX - (children.length*200)/2+i*200;
        childY = parentY - 300;
        
      } else {
        // –í–ø—Ä–∞–≤–æ
        childX = parentX + radius * 0.8;
        childY = parentY + radius * sin(angle) * 0.3;
        
      }
      
      child?.updatePosition(childX, childY, 0);
      child?.depth = depth + 1;
      child?.size = 1.0 / (depth * 0.3 + 1);
      
      // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –¥–µ—Ç–µ–π, –Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–ª–∞—Å—Ç–µ—Ä —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç
     if (child?.childClusterIds.isNotEmpty ?? false) {
      _positionChildClusters(child!.id, childX, childY, depth + 1);
    }
    }
  }
  
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  
  void _initializeConnectionWeights() {
    for (final cluster in widget.network.clusters.values) {
      if (cluster.parentClusterId != null) {
        final weight = _calculateConnectionWeight(cluster.id);
        _connectionWeights[cluster.id] = weight;
      }
    }
  }
  
  void _updateConnectionWeights() {
    for (final cluster in widget.network.clusters.values) {
      if (cluster.parentClusterId != null) {
        final weight = _calculateConnectionWeight(cluster.id);
        _connectionWeights[cluster.id] = weight;
      }
    }
  }
  
  double _calculateConnectionWeight(String clusterId) {
    final cluster = widget.network.clusters[clusterId];
    if (cluster == null || cluster.parentClusterId == null) return 1.0;
    
    double weight = 1.0;
    int expandedCount = _countExpandedChildren(clusterId);
    weight += expandedCount * 0.05;
    
    final depth = cluster.depth;
    weight += depth * 0.02;
    
    return weight.clamp(1.0, 3.0);
  }
  
  
  // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î - —É–±–∏—Ä–∞–µ–º —Ä–µ–∫—É—Ä—Å–∏—é
  int _countExpandedChildren(String clusterId) {
    final cluster = widget.network.clusters[clusterId];
    if (cluster == null) return 0;
    
    int count = 0;
    final queue = Queue<String>();
    queue.addAll(cluster.childClusterIds);
    
    while (queue.isNotEmpty) {
      final currentId = queue.removeFirst();
      final current = widget.network.clusters[currentId];
      if (current == null) continue;
      
      if (current.isExpanded) {
        count++;
        queue.addAll(current.childClusterIds);
        
        // –ï—Å–ª–∏ —ç—Ç–æ –ª–∏—Å—Ç–æ–≤–æ–π –∫–ª–∞—Å—Ç–µ—Ä, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–µ–π—Ä–æ–Ω—ã
        if (current.childClusterIds.isEmpty) {
          count += current.neuronIds.length;
        }
      }
    }
    
    return count;
  }

  // –ü–ï–†–ï–ò–ú–ï–ù–û–í–ê–õ –≤ _toggleClusterExpansion
Future<void> _toggleClusterExpansion(String clusterId) async {
  if (_isAnimating) return;
  
  _isAnimating = true;
  _expandingClusterId = clusterId;
  
  final cluster = widget.network.clusters[clusterId];
  if (cluster == null) {
    _isAnimating = false;
    _expandingClusterId = null;
    return;
  }
  
  // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  final wasExpanded = cluster.isExpanded;
  cluster.isExpanded = !wasExpanded;
  
  widget.sendMessage('üéØ Toggling cluster ${cluster.id} from $wasExpanded to ${cluster.isExpanded}. ${cluster.childClusterIds.length} ${cluster.neuronIds.length}');
  
  if (cluster.isExpanded) {
    // –†–ê–ó–í–û–†–ê–ß–ò–í–ê–ï–ú - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–µ–π
    await _showChildClusters(clusterId);
  } else {
    // –°–í–û–†–ê–ß–ò–í–ê–ï–ú - —Å–∫—Ä—ã–≤–∞–µ–º –¥–µ—Ç–µ–π
    await _hideChildClusters(clusterId);
  }
  
  // –û–ë–ù–û–í–õ–Ø–ï–ú –ü–û–ó–ò–¶–ò–ò –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
  //_updateClusterPositions();
  
  // –§–û–†–°–ò–†–£–ï–ú –û–ë–ù–û–í–õ–ï–ù–ò–ï UI
  if (mounted) {
          setState(() {});
        }
  
  _isAnimating = false;
  _expandingClusterId = null;
}
  
 Future<void> _showChildClusters(String parentId) async {
    final parent = widget.network.clusters[parentId];
    if (parent == null) return;
    List<String> myReports = [];
    for (final childId in parent.childClusterIds) {
      final child = widget.network.clusters[childId];
      if (child != null) {
        child.isVisible = true;

        // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
        final index = parent.childClusterIds.indexOf(childId);
        //await Future.delayed(Duration(milliseconds: 150 - (10 * index).clamp(50, 150)));
        final newX = parent.x+(35-(parent.childClusterIds.length*90)/2+90*index)*_cameraScale;
        final newY = parent.y-60*_cameraScale;
        if (child.neuronIds.isEmpty!=true){
            myReports.add("opening parent cluster ${parent.id}, ${parent.x}, ${parent.y}, ${newX}, ${newY}, ${parent.childClusterIds.length}, ${index}");
        }
        
        child.x=newX;
        child.y=newY;
        
      }
    }

    for (final report in myReports){
      await AppLogger.writeLog(report);
    }

  }
  
  Future<void> _hideChildClusters(String parentId) async {
    final parent = widget.network.clusters[parentId];
    if (parent == null) return;
    
    // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ
    final allChildren = _getAllChildren(parentId);
    for (final childId in allChildren) {
      final child = widget.network.clusters[childId];
      if (child != null) {
        child.isVisible = false;
        child.isExpanded = false; // –°–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Ç–æ–∂–µ
      }
    }
    
   
  }
  
  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –¥–µ—Ç–µ–π (–≤–∫–ª—é—á–∞—è –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö)
  List<String> _getAllChildren(String parentId) {
    final result = <String>[];
    final queue = Queue<String>();
    queue.addAll(widget.network.clusters[parentId]?.childClusterIds ?? []);
    
    while (queue.isNotEmpty) {
      final currentId = queue.removeFirst();
      result.add(currentId);
      queue.addAll(widget.network.clusters[currentId]?.childClusterIds ?? []);
    }
    
    return result;
  }
  
  void _updateClusterPositions() {
    final rootCluster = widget.network.clusters['root'];
    if (rootCluster != null) {
      _positionChildClusters('root', rootCluster.x, rootCluster.y, 0);
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onScaleStart: (details) {
        _lastPanOffset = details.focalPoint;
        _isPanning = true;
      },
      onScaleUpdate: (details) {
        if (_isPanning && _lastPanOffset != null) {
          final delta = details.focalPoint - _lastPanOffset!;
          setState(() {
            // –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            _cameraX -= delta.dx / _cameraScale;
            _cameraY -= delta.dy / _cameraScale;
          });
          _lastPanOffset = details.focalPoint;
        }
        
        // –ó—É–º
        if (details.scale != 1.0) {
          setState(() {
            _cameraScale = (_cameraScale * details.scale).clamp(0.1, 5.0);
          });
        }
      },
      onScaleEnd: (details) {
        _isPanning = false;
        _lastPanOffset = null;
      },
      onTapDown: (details) {
        _handleTap(details.localPosition);
      },
      child: MouseRegion(
        onHover: (event) {
          _handleHover(event.localPosition);
        },
        onExit: (event) {
          setState(() {
            _hoveredClusterId = null;
          });
        },
        child: Listener(
          onPointerSignal: (pointerSignal) {
            if (pointerSignal is PointerScrollEvent) {
              setState(() {
                _cameraScale = (_cameraScale * (1.0 + pointerSignal.scrollDelta.dy * -0.001))
                    .clamp(0.05, 2.0);
              });
            }
          },
          onPointerDown: (event) {
            _handlePointerDown(event.position);
          },
          onPointerMove: (event) {
            _handlePointerMove(event.position);
          },
          onPointerUp: (event) {
            _handlePointerUp();
          },
          child: CustomPaint(
            size: Size.infinite,
            painter: _AdvancedNeuron3DPainter(
              network: widget.network,
              cameraX: _cameraX,
              cameraY: _cameraY,
              cameraZ: _cameraZ,
              cameraScale: _cameraScale,
              rotationX: _rotationX,
              rotationY: _rotationY,
              selectedNeuronIds: widget.selectedNeuronIds,
              hoveredClusterId: _hoveredClusterId,
              draggedClusterId: _draggedClusterId,
              connectionWeights: _connectionWeights,
            ),
          ),
        ),
      ),
    );
  }
  
  void _handleHover(Offset position) {
    final hitResult = _findHitObject(position);
    setState(() {
      _hoveredClusterId = hitResult.clusterId;
      
      if (hitResult.clusterId != null) {
        _clusterGlowIntensities[hitResult.clusterId!] = 0.2;
      }
    });
  }
  void _startClusterGlowAnimation(String clusterId) {
  final cluster = widget.network.clusters[clusterId];
  if (cluster == null) return;

  // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —Å–≤–µ—á–µ–Ω–∏—è
  cluster.glowIntensity = 1.0;
  setState(() {});

  // –ü–ª–∞–≤–Ω–æ —É–º–µ–Ω—å—à–∞–µ–º —Å–≤–µ—á–µ–Ω–∏–µ –≤ —Ç–µ—á–µ–Ω–∏–µ 500 –º—Å
  const totalDuration = 500;
  const steps = 10;
  const stepDuration = totalDuration ~/ steps;
  
  for (int i = 1; i <= steps; i++) {
    Future.delayed(Duration(milliseconds: stepDuration * i), () {
      if (mounted && widget.network.clusters.containsKey(clusterId)) {
        final currentCluster = widget.network.clusters[clusterId];
        if (currentCluster != null) {
          currentCluster.glowIntensity = 1.0 - (i / steps);
          setState(() {});
        }
      }
    });
  }
}
  void _handleTap(Offset position) {
    final hitResult = _findHitObject(position);
    
    if (hitResult.clusterId != null) {
            _startClusterGlowAnimation(hitResult.clusterId!);
      _toggleClusterExpansion(hitResult.clusterId!);
      //widget.onClusterTapped(hitResult.clusterId!);
    } else if (hitResult.neuronId != null) {
      widget.onNeuronSelected(hitResult.neuronId!, false);
    }
  }
  
  void _handlePointerDown(Offset position) {
    final hitResult = _findHitObject(position);
    
    if (hitResult.clusterId != null) {
      _draggedClusterId = hitResult.clusterId;
      _dragStartOffset = position;
      final cluster = widget.network.clusters[hitResult.clusterId]!;
      _clusterStartOffset = Offset(cluster.x, cluster.y);
      
      _clusterGlowIntensities[hitResult.clusterId!] = 0.8;
    }
  }
  
  void _handlePointerMove(Offset position) {
    if (_draggedClusterId != null && _dragStartOffset != null && _clusterStartOffset != null) {
      final cluster = widget.network.clusters[_draggedClusterId!];
      if (cluster != null) {
        final delta = (position - _dragStartOffset!) / _cameraScale;
        final newX = _clusterStartOffset!.dx + delta.dx;
        final newY = _clusterStartOffset!.dy + delta.dy;
        
        cluster.updatePosition(newX, newY, cluster.z);
        
        if (cluster.isExpanded && cluster.childClusterIds.isEmpty) {
          _moveNeuronsWithCluster(cluster, newX, newY);
        }
        
        setState(() {});
      }
    }
  }
  
  void _handlePointerUp() {
    if (_draggedClusterId != null) {
      _clusterGlowIntensities[_draggedClusterId!] = 0.0;
    }
    _draggedClusterId = null;
    _dragStartOffset = null;
    _clusterStartOffset = null;
  }
  
  void _moveNeuronsWithCluster(NeuronCluster cluster, double newX, double newY) {
    final deltaX = newX - cluster.x;
    final deltaY = newY - cluster.y;
    
    for (final neuronId in cluster.neuronIds) {
      final neuron = widget.network.neurons[neuronId];
      if (neuron != null) {
        neuron.x += deltaX;
        neuron.y += deltaY;
      }
    }
  }
  
  void _startClusterExpansionAnimation(String clusterId) {
    final cluster = widget.network.clusters[clusterId];
    if (cluster == null) return;
    
    _clusterGlowIntensities[clusterId] = 1.0;
    
    Future.delayed(Duration(milliseconds: 300), () {
      if (mounted) {
        setState(() {
          _clusterGlowIntensities[clusterId] = 0.0;
        });
      }
    });
  }
  HitResult _findHitObject(Offset position) {
  final box = context.findRenderObject() as RenderBox;
  final size = box.size;
  
  final centerX = size.width / 2 - _cameraX;
  final centerY = size.height / 2 - _cameraY;
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∞—Å—Ç–µ—Ä—ã
  for (final cluster in widget.network.clusters.values) {
    if (!cluster.isVisible) continue;
    
    final projected = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
    final clusterSize = 40.0 * _cameraScale * cluster.size;
    final distance = (Offset(projected.dx, projected.dy) - position).distance;
    
    if (distance < clusterSize) {
      return HitResult(clusterId: cluster.id);
    }
  }
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–π—Ä–æ–Ω—ã –≤ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã—Ö –∫–ª–∞—Å—Ç–µ—Ä–∞—Ö
  for (final cluster in widget.network.clusters.values) {
    if (!cluster.isExpanded || !cluster.isVisible || cluster.childClusterIds.isNotEmpty) continue;
    
    final clusterScreenPos = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
    final startX = clusterScreenPos.dx + 80.0 * _cameraScale;
    final startY = clusterScreenPos.dy - (cluster.neuronIds.length * 60.0) * _cameraScale;
    
    for (int i = 0; i < cluster.neuronIds.length; i++) {
      final neuronId = cluster.neuronIds[i];
      final neuron = widget.network.neurons[neuronId];
      if (neuron == null) continue;
      
      // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Ç–∞–∫ –∂–µ –∫–∞–∫ –ø—Ä–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–µ
      final neuronX = startX;
      final neuronY = startY + (i * 60.0) * _cameraScale;
      
      final neuronRect = Rect.fromCenter(
        center: Offset(neuronX, neuronY),
        width: 110.0 * _cameraScale,
        height: 50.0 * _cameraScale,
      );
      
      if (neuronRect.contains(position)) {
        return HitResult(neuronId: neuronId);
      }
    }
  }
  
  return HitResult();
}
  
  Offset _projectToScreen(double x, double y, double z, double centerX, double centerY) {
    // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø—Ä–æ–µ–∫—Ü–∏—è 3D –≤ 2D —Å —É—á–µ—Ç–æ–º –∫–∞–º–µ—Ä—ã
    final screenX = centerX + (x * _cameraScale);
    final screenY = centerY + (y * _cameraScale);
    
    return Offset(screenX, screenY);
  }
}



class _AdvancedNeuron3DPainter extends CustomPainter {
  final OptimizedNeuralNetwork network;
  final double cameraX;
  final double cameraY;
  final double cameraZ;
  final double cameraScale;
  final double rotationX;
  final double rotationY;
  final Set<int> selectedNeuronIds;
  final String? hoveredClusterId;
  final String? draggedClusterId;
  final Map<String, double> connectionWeights;
  
  _AdvancedNeuron3DPainter({
    required this.network,
    required this.cameraX,
    required this.cameraY,
    required this.cameraZ,
    required this.cameraScale,
    required this.rotationX,
    required this.rotationY,
    required this.selectedNeuronIds,
    required this.hoveredClusterId,
    required this.draggedClusterId,
    required this.connectionWeights,
  });
    final Map<String, ui.Picture> _neuronCardCache = {};
  double _lastCameraScale = 1.0;
  
  
  @override
  void paint(Canvas canvas, Size size) {
    final centerX = size.width / 2 - cameraX;
    final centerY = size.height / 2 - cameraY;
    
    // –°–Ω–∞—á–∞–ª–∞ –≤—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –≤—Å–µ—Ö –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ —Å —É—á–µ—Ç–æ–º –∫–æ–ª–ª–∏–∑–∏–π
    //_resolveClusterCollisions(size, centerX, centerY);
    
    _drawConnections(canvas, size, centerX, centerY);
    _drawClusters(canvas, size, centerX, centerY);
    _drawNeurons(canvas, size, centerX, centerY);
    _lastCameraScale = cameraScale;
  }

  void _resolveClusterCollisions(Size size, double centerX, double centerY) {
    final clusters = network.clusters.values.where((c) => c.isVisible).toList();
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≥–ª—É–±–∏–Ω–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç –¥–∞–ª—å–Ω–∏—Ö –∫ –±–ª–∏–∂–Ω–∏–º
    clusters.sort((a, b) => a.depth.compareTo(b.depth));
    
    for (int i = 0; i < clusters.length; i++) {
      final clusterA = clusters[i];
      final posA = _projectToScreen(clusterA.x, clusterA.y, clusterA.z, centerX, centerY);
      final baseSizeA = 40.0 * cameraScale * clusterA.size;
      final rectA = Rect.fromCircle(center: posA, radius: baseSizeA);
      
      // –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Å —É—á–µ—Ç–æ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö –æ—Ç—Å—Ç—É–ø–æ–≤
      final expandedRectA = Rect.fromLTRB(
        rectA.left - 50 * cameraScale,
        rectA.top - 75 * cameraScale,  
        rectA.right + 50 * cameraScale,
        rectA.bottom + 75 * cameraScale,
      );
      
      for (int j = i + 1; j < clusters.length; j++) {
        final clusterB = clusters[j];
        final posB = _projectToScreen(clusterB.x, clusterB.y, clusterB.z, centerX, centerY);
        final baseSizeB = 40.0 * cameraScale * clusterB.size;
        final rectB = Rect.fromCircle(center: posB, radius: baseSizeB);
        
        final expandedRectB = Rect.fromLTRB(
          rectB.left - 50 * cameraScale,
          rectB.top - 75 * cameraScale,
          rectB.right + 50 * cameraScale,
          rectB.bottom + 75 * cameraScale,
        );
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã—Ö –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤
        if (expandedRectA.overlaps(expandedRectB)) {
          _resolveCollision(clusterA, clusterB, posA, posB, expandedRectA, expandedRectB, centerX, centerY);
        }
      }
    }
  }

  void _resolveCollision(
    NeuronCluster clusterA, 
    NeuronCluster clusterB, 
    Offset posA, 
    Offset posB,
    Rect rectA,
    Rect rectB,
    double centerX,
    double centerY,
  ) {
    final intersection = rectA.intersect(rectB);
    
    if (intersection.width > 0 && intersection.height > 0) {
      // –í—ã—á–∏—Å–ª—è–µ–º –≤–µ–∫—Ç–æ—Ä –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è
      final centerA = rectA.center;
      final centerB = rectB.center;
      
      final dx = centerB.dx - centerA.dx;
      final dy = centerB.dy - centerA.dy;
      final distance = sqrt(dx * dx + dy * dy);
      
      if (distance > 0) {
        // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ü–µ–Ω—Ç—Ä–∞–º–∏ —Å —É—á–µ—Ç–æ–º –æ—Ç—Å—Ç—É–ø–æ–≤
        final minDistance = (rectA.width / 2) + (rectB.width / 2);
        final overlap = minDistance - distance;
        
        if (overlap > 0) {
          // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
          final nx = dx / distance;
          final ny = dy / distance;
          
          // –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–ª–ª–∏–∑–∏–∏
          final offsetX = nx * overlap * 0.5;
          final offsetY = ny * overlap * 0.5;
          
          // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ –∫ –æ–±–æ–∏–º –∫–ª–∞—Å—Ç–µ—Ä–∞–º
          // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–ª–∞—Å—Ç–µ—Ä–∞ B
          final newScreenX = posB.dx + offsetX;
          final newScreenY = posB.dy + offsetY;
          
          // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
          final newWorldX = (newScreenX - centerX) / cameraScale;
          final newWorldY = (newScreenY - centerY) / cameraScale;
          
          // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–ª–∞—Å—Ç–µ—Ä–∞ B
          clusterB.x = newWorldX;
          clusterB.y = newWorldY;
        }
      }
    }
  }


  void _drawDebugCollisionZones(Canvas canvas, List<Rect> clusterRects) {
    // –í–∫–ª—é—á–∏—Ç–µ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π
    final bool showDebug = false;
    
    if (showDebug) {
      for (final rect in clusterRects) {
        final expandedRect = Rect.fromLTRB(
          rect.left - 50 * cameraScale,
          rect.top - 75 * cameraScale,
          rect.right + 50 * cameraScale,
          rect.bottom + 75 * cameraScale,
        );
        
        final debugPaint = Paint()
          ..color = Colors.red.withOpacity(0.3)
          ..style = PaintingStyle.stroke
          ..strokeWidth = 1;
          
        canvas.drawRect(expandedRect, debugPaint);
      }
    }
  }
  
  void _drawConnections(Canvas canvas, Size size, double centerX, double centerY) {
    for (final cluster in network.clusters.values) {
      if (!cluster.isVisible || cluster.parentClusterId == null) continue;
      
      final parent = network.clusters[cluster.parentClusterId!];
      if (parent != null && parent.isVisible) {
        _drawConnectionLine(canvas, parent, cluster, centerX, centerY);
      }
    }
  }

void _drawNeuronConnections(Canvas canvas, Neuron neuron, Offset neuronPosition, Size size) {
  // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ —Å–≤—è–∑–µ–π - —Ç–æ–ª—å–∫–æ –ø–æ –æ–±—â–∏–º —Å–ª–æ–≤–∞–º –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö
  final connectedNeurons = <int, double>{}; // neuronId -> strength
  
  // –ò—â–µ–º –Ω–µ–π—Ä–æ–Ω—ã —Å –æ–±—â–∏–º–∏ —Å–ª–æ–≤–∞–º–∏ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö
  final neuronWords = neuron.keywords.toSet();
  double summaryStrength=0;
  for (final cluster in network.clusters.values){
    if (!cluster.isVisible || !cluster.isExpanded || cluster.neuronIds.isEmpty){continue;}

    for (final otherNeuron in network.neurons.values) {
          if (otherNeuron.id == neuron.id) continue;
          
          final otherWords = otherNeuron.keywords.toSet();
          final commonWords = neuronWords.intersection(otherWords);
          
          if (commonWords.isNotEmpty) {
            // –°–∏–ª–∞ —Å–≤—è–∑–∏ = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—â–∏—Ö —Å–ª–æ–≤
            double strength = (commonWords.length/neuronWords.length + commonWords.length/neuronWords.length)/2;
            connectedNeurons[otherNeuron.id] = strength;
            if (strength>summaryStrength){
              summaryStrength=(summaryStrength+strength)/2;
            }
          }
        }
  }
  
  
  // –ë–µ—Ä–µ–º —Ç–æ–ø-3 —Å–∞–º—ã—Ö —Å–∏–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π
  final topConnections = connectedNeurons.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value))
    ..take(14);
  
  for (final entry in topConnections) {
    if (entry.value> summaryStrength/3*2){
      continue;
    }
    final otherNeuron = network.neurons[entry.key];
    if (otherNeuron == null) continue;
    
    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ –Ω–µ–π—Ä–æ–Ω–∞ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
      final otherPosition = _findNeuronPosition(otherNeuron, size);
    if (otherPosition == null) continue;
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å–∏–ª—É —Å–≤—è–∑–∏ (0.0 - 1.0)
    final normalizedStrength = min(entry.value / 40.0, 1.0);
    
    // –ü—Ä–æ—Å—Ç–æ–π —Ü–≤–µ—Ç –æ—Ç —Ñ–∏–æ–ª–µ—Ç–æ–≤–æ–≥–æ –∫ –≥–æ–ª—É–±–æ–º—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∏–ª—ã —Å–≤—è–∑–∏
    final color = Color.lerp(
      Colors.purple,
      Colors.cyan,
      normalizedStrength,
    )!.withOpacity(0.1);
    
    final paint = Paint()
      ..color = color
      ..strokeWidth = 0.5 + normalizedStrength * 1.0 // –¢–æ–ª—â–∏–Ω–∞ –æ—Ç —Å–∏–ª—ã —Å–≤—è–∑–∏
      ..style = PaintingStyle.stroke;
    
    // –ü—Ä–æ—Å—Ç–∞—è —Å–ª–µ–≥–∫–∞ –∏–∑–æ–≥–Ω—É—Ç–∞—è –ª–∏–Ω–∏—è
    final path = Path();
    path.moveTo(neuronPosition.dx, neuronPosition.dy);
    
    final midX = (neuronPosition.dx + otherPosition.dx) / 2;
    final midY = (neuronPosition.dy + otherPosition.dy) / 2;
    
    // –ù–µ–±–æ–ª—å—à–æ–π –∏–∑–≥–∏–±
    final controlX = midX + (otherPosition.dy - neuronPosition.dy) * 0.1;
    final controlY = midY - (otherPosition.dx - neuronPosition.dx) * 0.1;
    
    path.quadraticBezierTo(
      controlX, controlY,
      otherPosition.dx, otherPosition.dy,
    );
    
    canvas.drawPath(path, paint);
  }
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –Ω–µ–π—Ä–æ–Ω–∞
Offset? _findNeuronPosition(Neuron neuron, Size size) {
  // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫–∞–Ω–≤–∞—Å–∞ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
  final centerX = size.width / 2 - cameraX;
  final centerY = size.height / 2 - cameraY;
  
  // –ò—â–µ–º –Ω–µ–π—Ä–æ–Ω –≤ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã—Ö –∫–ª–∞—Å—Ç–µ—Ä–∞—Ö
  for (final cluster in network.clusters.values) {
    if (cluster.isExpanded && cluster.isVisible && cluster.neuronIds.contains(neuron.id) ) {
      final clusterScreenPos = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
      final neuronIndex = cluster.neuronIds.indexOf(neuron.id);
      if (neuronIndex != -1) {
        final neuronX = clusterScreenPos.dx + 35* cameraScale  - cluster.neuronIds.length.clamp(1,5)*31/2 + (31 * (neuronIndex%5)) * cameraScale ;
        final neuronY = clusterScreenPos.dy - 10* cameraScale  - (cluster.neuronIds.length*11/(cluster.neuronIds.length/5) + neuronIndex~/5 * 11.0) * cameraScale;
        return Offset(neuronX, neuronY);
      }
    }
  }
  
  // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã—Ö –∫–ª–∞—Å—Ç–µ—Ä–∞—Ö, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–ª–∞—Å—Ç–µ—Ä–∞
  for (final cluster in network.clusters.values) {
    if (cluster.neuronIds.contains(neuron.id)) {
      return _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
    }
  }
  
  return null;
}
  void _drawConnectionLine(Canvas canvas, NeuronCluster parent, NeuronCluster child, 
                        double centerX, double centerY) {
  final parentCenter = _projectToScreen(parent.x, parent.y, parent.z, centerX, centerY);
  final childCenter = _projectToScreen(child.x, child.y, child.z, centerX, centerY);
  
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
  final parentSize = 40.0 * cameraScale * parent.size;
  final childSize = 40.0 * cameraScale * child.size;
  
  // –ù–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫–∏ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ö –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
  final start = _getExitPoint(parentCenter, childCenter, parentSize);
  final end = _getEntryPoint(childCenter, parentCenter, childSize);
  
  final weight = connectionWeights[child.id] ?? 1.0;
  final strokeWidth = 2.0 * weight * cameraScale;
  
  final path = Path();
  path.moveTo(start.dx, start.dy);
  
  final dx = end.dx - start.dx;
  final dy = end.dy - start.dy;
  final distance = sqrt(dx * dx + dy * dy);
  
  // –í—ã—Å–æ—Ç—ã –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ–∞–∑ –∫—Ä–∏–≤–æ–π
  final totalHeight = (start.dy - end.dy).abs();
  final phase1Height = totalHeight * 0.3; // 30% - –Ω–∞—á–∞–ª—å–Ω—ã–π –ø–æ–¥—ä–µ–º
  final phase2Height = totalHeight * 0.5; // 50% - –æ—Å–Ω–æ–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
  final phase3Height = totalHeight * 0.2; // 20% - —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥
  
  if (distance > 50) {
    // –¢–æ—á–∫–∏ –∫–æ–Ω—Ç—Ä–æ–ª—è –¥–ª—è –∫—É–±–∏—á–µ—Å–∫–æ–π –∫—Ä–∏–≤–æ–π –ë–µ–∑—å–µ
    final control1 = Offset(
      start.dx + dx * 0.1,
      start.dy - phase1Height,
    );
    
    final control2 = Offset(
      start.dx + dx * 0.4,
      start.dy - phase1Height - phase2Height * 0.3,
    );
    
    final control3 = Offset(
      start.dx + dx * 0.6,
      end.dy + phase3Height + phase2Height * 0.3,
    );
    
    final control4 = Offset(
      start.dx + dx * 0.9,
      end.dy + phase3Height,
    );
    
    // –°–æ–∑–¥–∞–µ–º –ø–ª–∞–≤–Ω—É—é –∫—Ä–∏–≤—É—é —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
    path.cubicTo(
      control1.dx, control1.dy,
      control2.dx, control2.dy,
      (control2.dx + control3.dx) / 2, (control2.dy + control3.dy) / 2
    );
    
    path.cubicTo(
      control3.dx, control3.dy,
      control4.dx, control4.dy,
      end.dx, end.dy
    );
    
  } else {
    // –î–ª—è –±–ª–∏–∑–∫–∏—Ö –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ - –ø—Ä—è–º–∞—è –ª–∏–Ω–∏—è
    path.lineTo(end.dx, end.dy);
  }
  
  // –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç —Ä–æ–¥–∏—Ç–µ–ª—è –∫ —Ä–µ–±–µ–Ω–∫—É
  final gradientColors = [
    Colors.blue.withOpacity(0.8),
    Colors.purple.withOpacity(0.6),
  ];
  
  final gradient = LinearGradient(colors: gradientColors);
  final rect = Rect.fromPoints(start, end);
  final paint = Paint()
    ..shader = gradient.createShader(rect)
    ..strokeWidth = strokeWidth
    ..style = PaintingStyle.stroke
    ..strokeCap = StrokeCap.round;
  
  canvas.drawPath(path, paint);
  
  _drawConnectionArrow(canvas, path, paint, weight);
}
 void _drawConnectionArrow(Canvas canvas, Path path, Paint paint, double weight) {
  try {
    final metrics = path.computeMetrics();
    final metric = metrics.first;
    
    // –ù–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫—É –Ω–∞ 95% –ø—É—Ç–∏ –¥–ª—è —Å—Ç—Ä–µ–ª–∫–∏ (–±–ª–∏–∑–∫–æ –∫ –∫–æ–Ω—Ü—É, –Ω–æ –Ω–µ –≤ —Å–∞–º–æ–π –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–µ)
    final arrowOffset = max(metric.length * 0.95, 5.0);
    final tangent = metric.getTangentForOffset(arrowOffset);
    
    if (tangent != null) {
      final arrowPoint = tangent.position;
      final angle = tangent.angle;
      
      final arrowSize = 8.0 * weight * cameraScale;
      
      final arrowPath = Path();
      arrowPath.moveTo(
        arrowPoint.dx - arrowSize * cos(angle - pi / 6),
        arrowPoint.dy - arrowSize * sin(angle - pi / 6),
      );
      arrowPath.lineTo(arrowPoint.dx, arrowPoint.dy);
      arrowPath.lineTo(
        arrowPoint.dx - arrowSize * cos(angle + pi / 6),
        arrowPoint.dy - arrowSize * sin(angle + pi / 6),
      );
      arrowPath.close();
      
      final arrowPaint = Paint()
        ..color = Colors.red.withOpacity(0.8)
        ..style = PaintingStyle.fill;
      
      canvas.drawPath(arrowPath, arrowPaint);
    }
  } catch (e) {
    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —Å—Ç—Ä–µ–ª–∫–∏
  }
}
  Offset _getExitPoint(Offset fromCenter, Offset toCenter, double fromSize) {
  final angle = atan2(toCenter.dy - fromCenter.dy, toCenter.dx - fromCenter.dx);
  
  // –í—ã—á–∏—Å–ª—è–µ–º —Ç–æ—á–∫—É –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ –∫—Ä—É–≥–∞ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ —Ü–µ–ª–∏
  return Offset(
    fromCenter.dx + cos(angle) * fromSize,
    fromCenter.dy + sin(angle) * fromSize,
  );
}

Offset _getEntryPoint(Offset toCenter, Offset fromCenter, double toSize) {
  final angle = atan2(toCenter.dy - fromCenter.dy, toCenter.dx - fromCenter.dx);
  
  // –í—ã—á–∏—Å–ª—è–µ–º —Ç–æ—á–∫—É –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ –∫—Ä—É–≥–∞ —Å –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
  return Offset(
    toCenter.dx - cos(angle) * toSize,
    toCenter.dy - sin(angle) * toSize,
  );
}
 
  void _drawClusters(Canvas canvas, Size size, double centerX, double centerY) {
    final sortedClusters = network.clusters.values.toList()
      ..sort((a, b) => a.depth.compareTo(b.depth));
    
    // –í—Ä–µ–º–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π
    final List<Rect> debugRects = [];
    
    for (final cluster in sortedClusters) {
      if (!cluster.isVisible) continue;
      
      final projected = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
      final baseSize = 40.0 * cameraScale * cluster.size;
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
      debugRects.add(Rect.fromCircle(center: projected, radius: baseSize));
      
      _drawSingleCluster(canvas, cluster, centerX, centerY);
    }
    
    // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –æ—Ç–ª–∞–¥–∫–∞ - –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ –∑–æ–Ω –∫–æ–ª–ª–∏–∑–∏–π
    //_drawDebugCollisionZones(canvas, debugRects);
  }

  void _drawSingleCluster(Canvas canvas, NeuronCluster cluster, double centerX, double centerY) {
  final projected = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
  final center = Offset(projected.dx, projected.dy);
  final baseSize = 40.0 * cameraScale * cluster.size;
  
  final isHovered = cluster.id == hoveredClusterId;
  final isDragged = cluster.id == draggedClusterId;
  final isExpanded = cluster.isExpanded;
  final isNeuronCluster = cluster.neuronIds.length > 0;
  
  // –°–≤–µ—á–µ–Ω–∏–µ
  final glowIntensity = _getClusterGlowIntensity(cluster.id);
  if (glowIntensity > 0.0) {
    final glowPaint = Paint()
      ..color = isNeuronCluster? Colors.purple.withOpacity(glowIntensity*0.7) : Colors.yellow.withOpacity(glowIntensity * 0.5)
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, 10 * cameraScale);
    
    canvas.drawCircle(center, baseSize * (1.0 + glowIntensity), glowPaint);
  }
  
  // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –∑–∞–ª–∏–≤–∫–∏
  final gradientColors = [
    isNeuronCluster ? Colors.purple.withOpacity(isExpanded ? 1.0 : 0.75) : 
                     Colors.blue.withOpacity(isExpanded ? 0.53 : 0.22),
    isNeuronCluster ? Colors.green.withOpacity(isExpanded ? 1.0 : 0.75) : 
                     Colors.purple.withOpacity(isExpanded ? 0.53 : 0.22),
  ];
  
  // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è —Ä–∞–∑–º–µ—Ä–∞ –∫—Ä—É–≥–∞
  final gradientRect = Rect.fromCircle(center: center, radius: baseSize);
  final gradient = LinearGradient(colors: gradientColors);
  
  // –ó–∞–ª–∏–≤–∫–∞ –∫—Ä—É–≥–∞
  final fillPaint = Paint()
    ..shader = gradient.createShader(gradientRect)
    ..style = PaintingStyle.fill; // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: fill –≤–º–µ—Å—Ç–æ stroke
  
  canvas.drawCircle(center, baseSize, fillPaint);
  
  // –ì—Ä–∞–Ω–∏—Ü–∞
  final borderColor = isExpanded ? Colors.greenAccent : 
                     isHovered ? Colors.yellow : Colors.white;
  
  final borderPaint = Paint()
    ..color = isNeuronCluster ? Colors.purple : borderColor
    ..strokeWidth = isExpanded ? 3.0 : (isHovered ? 2.5 : 2.0)
    ..style = PaintingStyle.stroke;
  
  canvas.drawCircle(center, baseSize, borderPaint);
  
  // –¢–µ–∫—Å—Ç
  _drawClusterText(canvas, cluster, center, baseSize);
}
  
  double _getClusterGlowIntensity(String clusterId) {
    if (clusterId == hoveredClusterId) return 0.2;
    if (clusterId == draggedClusterId) return 0.8;
    return 0.0;
  }
  
  void _drawClusterText(Canvas canvas, NeuronCluster cluster, Offset center, double baseSize) {
    final text = _getClusterDisplayText(cluster);
    final textStyle = ui.TextStyle(
      color: Colors.white,
      fontSize: 10 * cameraScale * cluster.size,
      fontWeight: FontWeight.bold,
    );
    
    final textBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
      textDirection: ui.TextDirection.ltr,
      textAlign: TextAlign.center,
    ))
      ..pushStyle(textStyle)
      ..addText(text);
    
    final textParagraph = textBuilder.build();
    textParagraph.layout(ui.ParagraphConstraints(width: baseSize * 3));
    
    canvas.drawParagraph(
      textParagraph, 
      Offset(center.dx - textParagraph.width / 2, center.dy - textParagraph.height / 2)
    );
  }


Map<int, double> getFastTopConnectionsByKeywords(){
  final Map<int,double> topConnections = {};
  final List<int> keywordList = [];
  
  for (final neuronId in selectedNeuronIds){
    keywordList.addAll(network.neurons[neuronId]?.keywords ?? []);
  }
  
  // –ü–æ–ª—É—á–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ allRating (—á–µ–º –Ω–∏–∂–µ - —Ç–µ–º –≤–∞–∂–Ω–µ–µ)
  final List<int> neuronWords = keywordList.toSet().toList();
  
  // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–ª–æ–≤–∞ –ø–æ allRating (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é - —á–µ–º –º–µ–Ω—å—à–µ —Ä–µ–π—Ç–∏–Ω–≥, —Ç–µ–º –≤–∞–∂–Ω–µ–µ)
  neuronWords.sort((a, b) {
    final ratingA = network.words[a]?.allRating ?? double.infinity;
    final ratingB = network.words[b]?.allRating ?? double.infinity;
    return ratingA.compareTo(ratingB); // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
  });
  
  final Map<int,double> myWordRatings = {};
  
  for (final keyword in neuronWords){
    final dictionary = network.words[keyword]?.ratings ?? {};
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤...
  }
  
  double summaryStrength = 0;
  final Map<int, double> connectedNeurons = {};
  
  // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –Ω–µ–π—Ä–æ–Ω (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—è, —á—Ç–æ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫ neuron.id)
  // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤, –∏–∑–º–µ–Ω–∏—Ç–µ –ª–æ–≥–∏–∫—É
  final currentNeuron = network.neurons[selectedNeuronIds.first];
  if (currentNeuron == null) return {};
  
  for (final otherNeuron in network.neurons.values) {
    if (selectedNeuronIds.contains(otherNeuron.id)) continue;
    
    final otherWords = otherNeuron.keywords.toSet();
    final commonWords = neuronWords.toSet().intersection(otherWords);
    
    if (commonWords.isNotEmpty) {
      // –£—á–∏—Ç—ã–≤–∞–µ–º –≤–∞–∂–Ω–æ—Å—Ç—å —Å–ª–æ–≤: —Å–ª–æ–≤–∞ —Å –º–µ–Ω—å—à–∏–º allRating –∏–º–µ—é—Ç –±–æ–ª—å—à–∏–π –≤–µ—Å
      double strength = 0;
      for (final word in commonWords) {
        final wordRating = network.words[word]?.allRating ?? 1.0;
        // –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–π—Ç–∏–Ω–≥: —á–µ–º –º–µ–Ω—å—à–µ allRating, —Ç–µ–º –±–æ–ª—å—à–µ –≤–µ—Å
        final wordWeight = 1.0 / (wordRating + 1); // +1 —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥–µ–ª–µ–Ω–∏—è –Ω–∞ 0
        strength += wordWeight;
      }
      
      strength /= neuronWords.length; // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º
      connectedNeurons[otherNeuron.id] = strength;
      summaryStrength += strength;
    }
  }
  
  // –ë–µ—Ä–µ–º —Ç–æ–ø-15 —Å–∞–º—ã—Ö —Å–∏–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π
  final topConnectionsList = connectedNeurons.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value))
    ..take(15);
  
  return Map.fromEntries(topConnectionsList.take(15));
}




  double max_similairty_top_neurons = 0;
    double min_similairty_top_neurons = 0;
  Map<int, double> _topNeuronIds = {};
  List<int> _presetSelectedNeurons = [];


  void _drawNeurons(Canvas canvas, Size size, double centerX, double centerY) {
      Map<int, double> topNeurons = {};

      if (_areSetsEqual(_presetSelectedNeurons.toSet(),selectedNeuronIds.toSet())==false){
        _presetSelectedNeurons=selectedNeuronIds.toList();
        topNeurons = getFastTopConnectionsByKeywords();
        _topNeuronIds=topNeurons;
      }
      
        // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    max_similairty_top_neurons = _topNeuronIds!.isEmpty ? 0 : _topNeuronIds!.entries.reduce(
      (a, b) => a.value > b.value ? a : b
    ).value;

    // –ù–∞—Ö–æ–¥–∏–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ  
    min_similairty_top_neurons = _topNeuronIds!.isEmpty ? 0 : _topNeuronIds!.entries.reduce(
      (a, b) => a.value < b.value ? a : b
    ).value;
    for (final cluster in network.clusters.values) {
      if (!cluster.isExpanded || !cluster.isVisible || cluster.childClusterIds.isNotEmpty) continue;
      
      final clusterScreenPos = _projectToScreen(cluster.x, cluster.y, cluster.z, centerX, centerY);
      final startX = clusterScreenPos.dx + 35 * cameraScale - cluster.neuronIds.length.clamp(1,5)*31/2* cameraScale ;
      final startY = clusterScreenPos.dy - 10* cameraScale  - (cluster.neuronIds.length*11/(cluster.neuronIds.length~/5)) * cameraScale;
      //        final neuronX = clusterScreenPos.dx + (20 + 30 * (neuronIndex%5)) * cameraScale ;
//        final neuronY = clusterScreenPos.dy - (cluster.neuronIds.length*11/5 + neuronIndex%5 * 11.0) * cameraScale;
      for (int i = 0; i < cluster.neuronIds.length; i++) {
        final neuronId = cluster.neuronIds[i];
        final neuron = network.neurons[neuronId];
        if (neuron == null) continue;
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —ç–∫—Ä–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –Ω–µ–π—Ä–æ–Ω
        neuron.screenX = startX + 31 * (i%5) * cameraScale;
        neuron.screenY = startY + (i~/5*11) * cameraScale;
        
        _drawSingleNeuron(canvas, neuron, neuron.screenX, neuron.screenY,size);
        
        // –†–∏—Å—É–µ–º —Å–≤—è–∑–∏ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤, –ø–µ—Ä–µ–¥–∞–≤–∞—è size
        if (selectedNeuronIds.contains(neuron.id)) {
          _drawNeuronConnections(canvas, neuron, Offset(neuron.screenX, neuron.screenY), size);
        }
   
      // –†–∏—Å—É–µ–º —É—Å–∏–ª–µ–Ω–Ω—ã–µ –∂–µ–ª—Ç—ã–µ —Å–≤—è–∑–∏ –∫ —Ç–æ–ø –Ω–µ–π—Ä–æ–Ω–∞–º
      if (topNeurons.containsKey(neuron.id)) {
        final similarityScore = topNeurons[neuron.id]!;
        _drawEnhancedConnection(
          canvas,
          neuron,
          similarityScore,
          size
        );
      }
    }
  }
}
(String, int, int, String Function(int))? _findNumericDifference(String startUrl, String endUrl) {
  if (startUrl == endUrl) return null;
  
  // –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –ø–µ—Ä–≤–æ–≥–æ –æ—Ç–ª–∏—á–∞—é—â–µ–≥–æ—Å—è —Å–∏–º–≤–æ–ª–∞
  int diffIndex = 0;
  final minLength = min(startUrl.length, endUrl.length);
  
  while (diffIndex < minLength && startUrl.codeUnitAt(diffIndex) == endUrl.codeUnitAt(diffIndex)) {
    diffIndex++;
  }
  
  if (diffIndex >= minLength) return null;
  
  // –ò—â–µ–º —á–∏—Å–ª–æ–≤—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤–æ–∫—Ä—É–≥ –ø–æ–∑–∏—Ü–∏–∏ —Ä–∞–∑–ª–∏—á–∏—è
  final startNum = _findNumberAtPosition(startUrl, diffIndex);
  final endNum = _findNumberAtPosition(endUrl, diffIndex);
  
  if (startNum == null || endNum == null || startNum.value == endNum.value) {
    return null;
  }
  
  // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π URL
  final beforeDiff = startUrl.substring(0, startNum.start);
  final afterDiff = startUrl.substring(startNum.end);
  final baseUrl = '$beforeDiff{NUM}$afterDiff';
  
  // –§—É–Ω–∫—Ü–∏—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Å—Ç–∏–ª—è
  String formatNumber(int num) {
    final original = startNum.match;
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–µ–¥—É—â–∏–µ –Ω—É–ª–∏
    if (original.startsWith('0')) {
      final targetLength = original.length;
      return num.toString().padLeft(targetLength, '0');
    }
    
    return num.toString();
  }
  
  return (baseUrl, startNum.value, endNum.value, formatNumber);
}

NumberMatch? _findNumberAtPosition(String text, int position) {
  // –ò—â–µ–º –Ω–∞—á–∞–ª–æ —á–∏—Å–ª–∞
  int start = position;
  while (start > 0 && _isDigit(text.codeUnitAt(start - 1))) {
    start--;
  }
  
  // –ò—â–µ–º –∫–æ–Ω–µ—Ü —á–∏—Å–ª–∞
  int end = position;
  while (end < text.length && _isDigit(text.codeUnitAt(end))) {
    end++;
  }
  
  if (start >= end) return null;
  
  final numberStr = text.substring(start, end);
  final number = int.tryParse(numberStr);
  
  if (number == null) return null;
  
  return NumberMatch(
    value: number,
    match: numberStr,
    start: start,
    end: end,
  );
}

bool _isDigit(int codeUnit) {
  return codeUnit >= 48 && codeUnit <= 57; // '0' - '9'
}

Map<String, Map<int, double>> _getTopAndBottomSignatureWords() {
  if (selectedNeuronIds.isEmpty) return {'top': {}, 'bottom': {}};

  final Map<int, double> neuronSignatures = {};
  
  // –°—É–º–º–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞—Ç—É—Ä—ã
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron != null) {
      for (final entry in selectedNeuron.signatureRatings.entries) {
        final wordId = entry.key;
        final value = entry.value.toDouble();
        neuronSignatures[wordId] = (neuronSignatures[wordId] ?? 0) + value;
      }
    }
  }

  if (neuronSignatures.isEmpty) return {'top': {}, 'bottom': {}};

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é
  final sortedEntries = neuronSignatures.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));

  // –ë–µ—Ä–µ–º —Ç–æ–ø 30 –∏ bottom 20 —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –∑–Ω–∞—á–µ–Ω–∏–π
  final topWords = Map.fromEntries(sortedEntries.take(30));
  final bottomWords = Map.fromEntries(sortedEntries.reversed.take(20));

  return {
    'top': topWords,
    'bottom': bottomWords,
  };
}


Map<int,double> _calculateTopNeuronsByCombinedSimilarity() {
  final Map<int, double> combinedScores = {};
  
  if (selectedNeuronIds.isEmpty) return combinedScores;
  final Map<String, Map<int,double>> wordsForUse = _getTopAndBottomSignatureWords();

  final Map<int,double> top = wordsForUse['top'] ?? {};
  final Map<int,double> bottom = wordsForUse['bottom'] ?? {};
  
  // 1. –°–æ–±–∏—Ä–∞–µ–º neuronRatings similarity (35%)
  final Map<int, double> neuronSimilarities = {};
  double averageSimilarity = 0;
  int similarityCount = 0;
  
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron != null) {
      for (final entry in selectedNeuron.neuronRatings.entries) {
        final neuronId = entry.key;
        final similarity = entry.value.toDouble();
        neuronSimilarities[neuronId] = (neuronSimilarities[neuronId] ?? 0.25 + similarity)/2; 
        averageSimilarity += similarity;
        similarityCount++;
      }
    }
  }
  
  // Calculate average similarity
  if (similarityCount > 0) {
    averageSimilarity /= similarityCount;
  }
  
  final Map<int, double> finalSimilarity = {};
  final Map<int, double> comparedVector = {};
  
  for (final entry in neuronSimilarities.entries) {
    if (entry.value > averageSimilarity / 3 * 2) {
      continue;
    }
    
    final key = entry.key;
    final neuron = network.neurons[key];
   
    if (neuron == null) continue;
    
    final signature_allRating = neuron.signature_allRating;
    int counter = 0;
    
    for (final neuronKeyword in neuron.keywords) {
      if (!top.containsKey(neuronKeyword) && !bottom.containsKey(neuronKeyword)) continue;

      double multiplier = bottom.containsKey(neuronKeyword) ? 1.08 : 1.0;
      final neuronSignatureElement = neuron.signatureRatings[neuronKeyword] ?? 0.0;
      
      if (signature_allRating > 0 && neuronSignatureElement / signature_allRating < 0.15) continue;
      
      comparedVector[key] = (comparedVector[key] ?? 0.0) + neuronSignatureElement * multiplier; 
      counter++;
    }
    
    if (counter > 0) {
      comparedVector[key] = (comparedVector[key] ?? 0.0) / counter;
    }
    
    if (counter > 5) {
      finalSimilarity[key] = comparedVector[key] ?? 0.0;
    }
  }
  
  return finalSimilarity;
}
Map<int, double> _calculateTopNeuronsByCombinedSimilarityDD() {
  final Map<int, double> combinedScores = {};
  
  if (selectedNeuronIds.isEmpty || network.neurons.isEmpty) {
    return combinedScores;
  }

  // 1. Neuron ratings similarity (35%)
  final Map<int, double> neuronSimilarities = {};
  
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron != null && selectedNeuron.neuronRatings.isNotEmpty) {
      for (final entry in selectedNeuron.neuronRatings.entries) {
      
        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –Ω–µ–π—Ä–æ–Ω—ã
        if (selectedNeuronIds.contains(entry.key)) continue;

        neuronSimilarities[entry.key]=entry.value.toDouble();
      }
    }
  }
  
  // 2. Keywords similarity (65%)
  final Map<int, double> keywordSimilarities = {};
  final Map<int, int> keywordFrequency = {};
  final Map<int,double> similarityAll = {};
  // –°—á–∏—Ç–∞–µ–º —á–∞—Å—Ç–æ—Ç—É keywords
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron != null && selectedNeuron.keywords.isNotEmpty) {
      for (final keywordId in selectedNeuron.keywords) {
        keywordFrequency[selectedId] = keywordFrequency[selectedId] ?? 0 +1; 
      }
    }
  }
  
  // Keyword similarity –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –Ω–µ–π—Ä–æ–Ω–∞
  for (final neuron in network.neurons.values) {
    if (selectedNeuronIds.contains(neuron.id)) continue;
    
    double keywordScore = 0.0;
    if (neuron.keywords.isNotEmpty) {
      for (final keywordId in neuron.keywords) {
        final frequency = neuron.signatureRatings[keywordId] ?? 0;
        keywordScore += frequency.toDouble()/(neuron.signature_allRating);
      }
    }
    if (keywordScore > 0) {
      keywordSimilarities[neuron.id] = keywordScore;
      similarityAll[neuron.id] = similarityAll[neuron.id]??0 + keywordScore;
    }
  }
  
  // 3. –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º scores —Å –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏ –Ω–∞ –ø—É—Å—Ç–æ—Ç—É
  final allNeuronIds = {...neuronSimilarities.keys, ...keywordSimilarities.keys};
  
  if (allNeuronIds.isEmpty) return combinedScores;


  for (final neuronId in allNeuronIds) {
    final neuronRatingScore = (neuronSimilarities[neuronId] ?? 0.001 )/(network.neurons[neuronId]!.allRating+0.001);
    final keywordScore = ( keywordSimilarities[neuronId]! ?? 0.001 )/(similarityAll[neuronId]!+0.001);
    
    final combinedScore = (neuronRatingScore * 0.35) + (keywordScore * 0.65);
    combinedScores[neuronId] = combinedScore;
  }
  
  // –¢–æ–ø 50 –Ω–µ–π—Ä–æ–Ω–æ–≤
  return Map.fromEntries(
    combinedScores.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value))
      ..take(50)
  );
}



void _drawEnhancedConnection(
  Canvas canvas,
  Neuron neuron,
  double similarityScore,
  Size size
) {
  final neuronPosition = Offset(neuron.screenX, neuron.screenY);
  
  for (final selectedId in selectedNeuronIds) {
    final selectedNeuron = network.neurons[selectedId];
    if (selectedNeuron == null) continue;
    
    final hasConnection = _hasConnectionBetween(neuron, selectedNeuron);
    
    if (hasConnection>0.15) {
      final selectedPosition = _findNeuronPosition(selectedNeuron, size);
      if (selectedPosition == null) continue;
      
      final intensity = similarityScore.clamp(0.0, 1.0);
      final color = Color.lerp(
        Colors.yellow.withOpacity(0.1),
        Colors.yellow.withOpacity(0.2),
        intensity,
      )!;
      
      final strokeWidth = 0.7 + (intensity * 1.0);
      
      final paint = Paint()
        ..color = color
        ..strokeWidth = strokeWidth
        ..style = PaintingStyle.stroke;
      
      // –¢–æ—á–Ω–∞—è –∫–æ–ø–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –∏–∑ _drawNeuronConnections
      _drawCurvedLine(
        canvas,
        selectedPosition,
        neuronPosition,
        paint,
      );
      
      // –°–≤–µ—á–µ–Ω–∏–µ –¥–ª—è —Å–∏–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π
      if (intensity > 0.7) {
        final glowPaint = Paint()
          ..color = Colors.orange.withOpacity(0.2)
          ..strokeWidth = strokeWidth * 1.2
          ..style = PaintingStyle.stroke
          ..maskFilter = MaskFilter.blur(BlurStyle.normal, 3);
        
        _drawCurvedLine(
          canvas,
          selectedPosition,
          neuronPosition,
          glowPaint,
        );
      }
    }
  }
}

// –í—ã–Ω–µ—Å–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –∫—Ä–∏–≤–æ–π –ª–∏–Ω–∏–∏ (–∫–∞–∫ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ)
void _drawCurvedLine(Canvas canvas, Offset start, Offset end, Paint paint) {
  final path = Path();
  path.moveTo(start.dx, start.dy);
  
  final midX = (start.dx + end.dx) / 2;
  final midY = (start.dy + end.dy) / 2;
  
  // –¢–æ—Ç –∂–µ –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞—Å—á–µ—Ç–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
  final controlX = midX + (end.dy - start.dy) * 0.1;
  final controlY = midY - (end.dx - start.dx) * 0.1;
  
  path.quadraticBezierTo(
    controlX, controlY,
    end.dx, end.dy,
  );
  
  canvas.drawPath(path, paint);
}

double _hasConnectionBetween(Neuron neuron1, Neuron neuron2) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤—è–∑—å –ø–æ neuronRatings
  if (neuron1.neuronRatings.containsKey(neuron2.id) || 
      neuron2.neuronRatings.containsKey(neuron1.id)) {
    return neuron2.neuronRatings[neuron1.id]!/neuron2.allRating;
  }
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤—è–∑—å –ø–æ –æ–±—â–∏–º keywords
  final keywords1 = neuron1.keywords.toSet();
  final keywords2 = neuron2.keywords.toSet();
  final commonKeywords = keywords1.intersection(keywords2);
  
  return commonKeywords.length/((keywords1.length+keywords2.length+0.1)/2);
}

  void _drawSingleNeuron(Canvas canvas, Neuron neuron, double screenX, double screenY, Size size) {
  final position = Offset(screenX, screenY);
  final isSelected = selectedNeuronIds.contains(neuron.id);
  
  _drawNeuronCardCached(canvas, neuron, position, isSelected);
  
  // –†–∏—Å—É–µ–º —Å–≤—è–∑–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤ –∏–ª–∏ –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ
  if (selectedNeuronIds.contains(neuron.id)) {
    _drawNeuronConnections(canvas, neuron, position, size);
  }
}
  
  void _drawNeuronCardCached(Canvas canvas, Neuron neuron, Offset position, bool isSelected) {
    final cacheKey = _getNeuronCacheKey(neuron, isSelected);
    
    if (_neuronCardCache.containsKey(cacheKey) && _lastCameraScale == cameraScale) {
      final cachedPicture = _neuronCardCache[cacheKey]!;
      canvas.save();
      canvas.translate(position.dx, position.dy);
      canvas.drawPicture(cachedPicture);
      canvas.restore();
      return;
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –∏ –∫—ç—à–∏—Ä—É–µ–º
    final recorder = ui.PictureRecorder();
    final cardCanvas = Canvas(recorder);
    
    _drawNeuronCardContent(cardCanvas, neuron, isSelected);
    
    final picture = recorder.endRecording();
    _neuronCardCache[cacheKey] = picture;
    
    if (_neuronCardCache.length > 50) {
      _neuronCardCache.remove(_neuronCardCache.keys.first);
    }
    
    canvas.save();
    canvas.translate(position.dx, position.dy);
    canvas.drawPicture(picture);
    canvas.restore();
  }
  
  void _drawNeuronCardContent(Canvas canvas, Neuron neuron, bool isSelected) {
    // –ö–æ–º–ø–∞–∫—Ç–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã 120x50
    final cardWidth = 30.0 * cameraScale;
    final cardHeight = 10.0 * cameraScale;
   final bool isTopNeuron = _topNeuronIds.containsKey(neuron.id);
    final double neuronTopConnectionStr = _topNeuronIds[neuron.id]?? 0;
    final double difference =max_similairty_top_neurons-min_similairty_top_neurons;
    final double max_d = max_similairty_top_neurons-difference;
    final double min_d = max_similairty_top_neurons-difference;
    final double my_d = neuronTopConnectionStr-difference;
    final double percent_similairty = my_d/max_d;
    final double percent_more_than_min = my_d/min_d;
    final bool isSomethingSelected = !selectedNeuronIds.isEmpty;
    //  double max_similairty_top_neurons = 0;
    //double min_similairty_top_neurons = 0;
    final cardRect = Rect.fromCenter(
      center: Offset.zero,
      width: cardWidth,
      height: cardHeight
    );

    // –§–æ–Ω –∫–∞—Ä—Ç–æ—á–∫–∏
    final gradient = LinearGradient(
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
      colors: [
        isSelected ? Colors.orange.withOpacity(0.9) :isTopNeuron? Colors.green.withOpacity(0.6*percent_similairty): isSomethingSelected? Colors.grey.withOpacity(0.25) : Colors.blue.withOpacity(0.5),
        isSelected ? Colors.pink.withOpacity(0.7) : isTopNeuron? Colors.cyan.withOpacity(0.5*percent_similairty):isSomethingSelected? Colors.brown.withOpacity(0.20): Colors.purple.withOpacity(0.5),
      ],
    );
    
    final backgroundPaint = Paint()
      ..shader = gradient.createShader(cardRect)
      ..style = PaintingStyle.fill;
    
    // –¢–µ–Ω—å
    final shadowPaint = Paint()
      ..color = Colors.black.withOpacity(0.3)
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, 4 * cameraScale);
    
    canvas.drawRRect(
      RRect.fromRectAndRadius(cardRect.shift(Offset(2, 2)), Radius.circular(6 * cameraScale)),
      shadowPaint
    );
    
    // –û—Å–Ω–æ–≤–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞
    canvas.drawRRect(
      RRect.fromRectAndRadius(cardRect, Radius.circular(6 * cameraScale)),
      backgroundPaint
    );
    if (isSelected || isTopNeuron) {
      final myColor = isTopNeuron ? Colors.green.withOpacity(0.5) : Colors.yellow.withOpacity(0.6);
      final borderPaint = Paint()
        ..color = myColor
        ..strokeWidth = 1 * cameraScale
        ..style = PaintingStyle.stroke;
      
      canvas.drawRRect(
        RRect.fromRectAndRadius(cardRect, Radius.circular(6 * cameraScale)),
        borderPaint
      );
    }
    final title = neuron.pageTitle ?? 'Neuron #${neuron.id}';
    final shortenedTitle = _shortenText(title, 35); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∑–∞–≥–æ–ª–æ–≤–∫–∞
    
    // –ó–∞–≥–æ–ª–æ–≤–æ–∫ (–≤–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–æ–∫–∞)
    _drawText(
      canvas,
      shortenedTitle,
      TextStyle(
        color: Colors.white,
        fontSize: 1.1 * cameraScale, // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —à—Ä–∏—Ñ—Ç
        fontWeight: FontWeight.bold,
      ),
      Offset(-cardWidth/2 + 1 * cameraScale, -cardHeight/2 + 2 * cameraScale),
      cardWidth - 2 * cameraScale,
    );
    
    // URL (—Å—Ä–µ–¥–Ω—è—è —Å—Ç—Ä–æ–∫–∞)
    if (neuron.sourceUrl != null) {
      final displayUrl = _shortenUrl(neuron.sourceUrl!);
      _drawText(
        canvas,
        displayUrl,
        TextStyle(
          color: Colors.white70,
          fontSize: 0.7 * cameraScale, // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —à—Ä–∏—Ñ—Ç
        ),
        Offset(-cardWidth/2 + 1 * cameraScale, -cardHeight/2 + 6 * cameraScale),
        cardWidth - 2 * cameraScale,
      );
    }
    
    // –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ (–Ω–∏–∂–Ω—è—è —Å—Ç—Ä–æ–∫–∞)
    final keywords = _getTopKeywords(neuron).take(6).join(', '); // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ 2 –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤–∞
    if (keywords.isNotEmpty) {
      final shortKeywords = _shortenText(keywords, 25);
      _drawText(
        canvas,
        shortKeywords,
        TextStyle(
          color: Colors.white.withOpacity(0.7),
          fontSize: 0.6 * cameraScale, // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —à—Ä–∏—Ñ—Ç
        ),
        Offset(-cardWidth/2 + 1 * cameraScale, -cardHeight/2 + 7 * cameraScale),
        cardWidth - 1 * cameraScale,
      );
    }
    
    // ID –Ω–µ–π—Ä–æ–Ω–∞ –≤ –ø—Ä–∞–≤–æ–º –Ω–∏–∂–Ω–µ–º —É–≥–ª—É
    _drawText(
      canvas,
      '#${neuron.id}',
      TextStyle(
        color: Colors.white.withOpacity(0.5),
        fontSize: 5 * cameraScale, // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —à—Ä–∏—Ñ—Ç
      ),
      Offset(cardWidth/2 - 15 * cameraScale, cardHeight/2 - 9 * cameraScale),
      5 * cameraScale,
      align: TextAlign.right,
    );
  }

  String _shortenText(String text, int maxLength) {
    if (text.length <= maxLength) return text;
    return '${text.substring(0, maxLength - 3)}...';
  }
  void _drawText(
    Canvas canvas, 
    String text, 
    TextStyle style, 
    Offset position, 
    double maxWidth, {
    TextAlign align = TextAlign.left,
  }) {
    final paragraphBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
      textDirection: ui.TextDirection.ltr,
      textAlign: align,
    ))
      ..pushStyle(style.getTextStyle())
      ..addText(text);
    
    final paragraph = paragraphBuilder.build();
    paragraph.layout(ui.ParagraphConstraints(width: maxWidth));
    
    canvas.drawParagraph(paragraph, position);
  }
  
  String _getNeuronCacheKey(Neuron neuron, bool isSelected) {
    final contentHash = _getNeuronContentHash(neuron);
    return 'neuron_${neuron.id}_${isSelected}_${cameraScale.toStringAsFixed(2)}_$contentHash';
  }
  
  String _getNeuronContentHash(Neuron neuron) {
    // –°–æ–∑–¥–∞–µ–º —Ö—ç—à –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ, –∫–æ—Ç–æ—Ä–æ–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    final content = '${neuron.pageTitle}_${neuron.sourceUrl}_${_getTopKeywords(neuron).join(",")}';
    return content.hashCode.toString();
  }
  

List<String> _getTopKeywords(Neuron neuron) {
  final wordScores = <int, double>{};
  
  // –°–Ω–∞—á–∞–ª–∞ –≤—ã—á–∏—Å–ª—è–µ–º scores –¥–ª—è —Å–ª–æ–≤ –∏–∑ signatureRatings –Ω–µ–π—Ä–æ–Ω–∞
   for (final wordId in neuron.keywords) {
    final word = network.words[wordId];
    if (word != null) {
      double score = neuron.signatureRatings[wordId]!.toDouble();
      for (final otherWordId in neuron.keywords) {
        final otherWord = network.words[otherWordId];
        if (otherWord != word) {
          final connection = network.words[otherWordId]!.ratings[wordId] ?? 0;
          score += connection * 0.1;
        }
      }
      wordScores[wordId] = score;
    }
  }
  
  
  final sortedWords = wordScores.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value));
  
  // –¢–æ–ø-15 —Å —Å–∞–º—ã–º –≤—ã—Å–æ–∫–∏–º —Ä–µ–π—Ç–∏–Ω–≥–æ–º
  final topKeywords = sortedWords
      .take(4)
      .map((entry) => network.wordLibrary[entry.key] ?? 'unknown')
      .where((word) => word.length > 2)
      .toList();
  
  // –î–ª—è –Ω–∏–∂–Ω–∏—Ö 5 –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–π—Ç–∏–Ω–≥ –∏–∑ network.words
  final bottomWords = <MapEntry<int, double>>[];
  
  for (final wordId in neuron.signatureRatings.keys) {
    final word = network.words[wordId];
    if (word != null) {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º allRating –∏–∑ network.words –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–µ–π—Ç–∏–Ω–≥
      final globalScore = word.allRating.toDouble();
      bottomWords.add(MapEntry(wordId, globalScore));
    }
  }
  
  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é —Ä–µ–π—Ç–∏–Ω–≥–∞ –∏–∑ network.words
  bottomWords.sort((a, b) => a.value.compareTo(b.value));
  
  final bottomKeywords = bottomWords
      .take(2)
      .map((entry) => network.wordLibrary[entry.key] ?? 'unknown')
      .where((word) => word.length > 2)
      .toList();
  
  return [...topKeywords, ...bottomKeywords];
}

  void clearCache() {
    _neuronCardCache.clear();
  }

  Color _getClusterColor(NeuronCluster cluster) {
    final hue = (cluster.id.hashCode % 360).toDouble();
    
    switch (cluster.type) {
      case 'domain':
        return HSLColor.fromAHSL(1.0, hue, 0.8, 0.6).toColor();
      case 'keyword':
        return HSLColor.fromAHSL(1.0, hue, 0.9, 0.4).toColor();
      case 'root':
        return Colors.deepPurple;
      default:
        return HSLColor.fromAHSL(1.0, hue, 0.6, 0.5).toColor();
    }
  }
  
  String _getClusterDisplayText(NeuronCluster cluster) {
    String text = cluster.title;
    
    if (cluster.neuronIds.isNotEmpty) {
      text += '\n${cluster.neuronIds.length}';
    }
    
    if (text.length > 15) {
      text = text.substring(0, 12) + '...';
    }
    
    return text;
  }
    String _shortenUrl(String url) {
    try {
      final uri = Uri.parse(url);
      final host = uri.host;
      final path = uri.path;
      if (path.length > 20) {
        return '$host${path.substring(0, 20)}...';
      }
      return '$host$path';
    } catch (e) {
      return url.length > 30 ? '${url.substring(0, 30)}...' : url;
    }
  }
  
  Offset _projectToScreen(double x, double y, double z, double centerX, double centerY) {
    // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–µ–∫—Ü–∏—è 3D –≤ 2D
    final screenX = centerX + (x * cameraScale);
    final screenY = centerY + (y * cameraScale);
    
    return Offset(screenX, screenY);
  }
  
    @override
  bool shouldRepaint(_AdvancedNeuron3DPainter oldDelegate) {
    return oldDelegate.cameraX != cameraX ||
        oldDelegate.cameraY != cameraY ||
        oldDelegate.cameraScale != cameraScale ||
        oldDelegate.rotationX != rotationX ||
        oldDelegate.rotationY != rotationY ||
        !_areSetsEqual(oldDelegate.selectedNeuronIds, selectedNeuronIds) ||
        oldDelegate.hoveredClusterId != hoveredClusterId ||
        oldDelegate.draggedClusterId != draggedClusterId;
  }
  
    bool _areSetsEqual<T>(Set<T> set1, Set<T> set2) {
    if (set1.length != set2.length) return false;
    for (final item in set1) {
      if (!set2.contains(item)) return false;
    }
    return true;
  }
}
class HitResult {
  final String? clusterId;
  final int? neuronId;
  
  HitResult({this.clusterId, this.neuronId});
}


/// –£–ª—É—á—à–µ–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è —Å —É—á–µ—Ç–æ–º –±–∞–ª–∞–Ω—Å–∞ allRating
class _EnhancedStrategy {
  final String description;
  final double similarityWeight;
  final double entropyWeight;
  final double allRatingWeight;
  final bool preferHighRating;
  final bool preferLowRating;
  
  const _EnhancedStrategy({
    required this.description,
    required this.similarityWeight,
    required this.entropyWeight,
    required this.allRatingWeight,
    required this.preferHighRating,
    required this.preferLowRating,
  });
  
  double calculateScore({
    required double similarityScore,
    required double entropyChange,
    required double allRatingScore,
    required int currentStep,
  }) {
    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –≤–µ—Å–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —à–∞–≥–∞
    final stepFactor = currentStep / 25.0;
    final dynamicSimilarityWeight = similarityWeight * (1.0 - stepFactor * 0.3);
    final dynamicEntropyWeight = entropyWeight * (1.0 + stepFactor * 0.5);
    
    return similarityScore * dynamicSimilarityWeight +
           entropyChange * dynamicEntropyWeight +
           allRatingScore * allRatingWeight;
  }
}

_determineEnhancedStrategy(
  double entropy, 
  _VectorStats stats, 
  double balance,
  int step
) {


    if (entropy > 2.5) {
    return _EnhancedStrategy(
      description: "ENTROPY: Focus content",
      similarityWeight: 0.6,
      entropyWeight: 0.3,
      allRatingWeight: 0.1,
      preferHighRating: false,
      preferLowRating: true,
    );
  }
  
  // –†–∞–Ω–Ω–∏–µ —à–∞–≥–∏: —Ñ–æ–∫—É—Å –Ω–∞ —Å—Ö–æ–¥—Å—Ç–≤–µ
  if (step < 5) {
    return _EnhancedStrategy(
      description: "EARLY: Focus similarity",
      similarityWeight: 0.7,
      entropyWeight: 0.2,
      allRatingWeight: 0.1,
      preferHighRating: true,
      preferLowRating: false,
    );
  }
  
  // –ë–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ allRating
  if (balance < 0.3) {
    return _EnhancedStrategy(
      description: "BALANCE: Correct rating imbalance",
      similarityWeight: 0.4,
      entropyWeight: 0.3,
      allRatingWeight: 0.3,
      preferHighRating: stats.mean < 0.3,
      preferLowRating: stats.mean > 0.7,
    );
  }
  
  // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç–Ω—Ç—Ä–æ–ø–∏–µ–π
  if (entropy < 1.5) {
    return _EnhancedStrategy(
      description: "ENTROPY: Increase diversity",
      similarityWeight: 0.3,
      entropyWeight: 0.6,
      allRatingWeight: 0.1,
      preferHighRating: false,
      preferLowRating: true,
    );
  }
  

  // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
  return _EnhancedStrategy(
    description: "STANDARD: Balanced approach",
    similarityWeight: 0.5,
    entropyWeight: 0.3,
    allRatingWeight: 0.2,
    preferHighRating: true,
    preferLowRating: false,
  );
}
/// –ê–Ω–∞–ª–∏–∑ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ –≤–µ–∫—Ç–æ—Ä–∞
class _VectorStats {
  final OptimizedNeuralNetwork network;
  final double minValue;
  final double maxValue;
  final double valueRange;
  final double mean;
  final double standardDeviation;

  _VectorStats({
    required this.network,
    required this.minValue,
    required this.maxValue,
    required this.valueRange,
    required this.mean,
    required this.standardDeviation,
  });
}

/// –ö–ª–∞—Å—Å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—Ü–µ–Ω–æ–∫ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
class _EnhancedCandidateScore {
  final int wordId;
  final double similarityScore;
  final double entropyChange;
  final double allRatingScore;
  final double combinedScore;
  final int wordAllRating;

  _EnhancedCandidateScore({
    required this.wordId,
    required this.similarityScore,
    required this.entropyChange,
    required this.allRatingScore,
    required this.combinedScore,
    required this.wordAllRating,
  });
}

/// –†–∞—Å—á–µ—Ç —ç–Ω—Ç—Ä–æ–ø–∏–∏ –®–µ–Ω–Ω–æ–Ω–∞ –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞
double _calculateShannonEntropy(Map<int, double> vector) {
  if (vector.isEmpty) return 0.0;

  final values = vector.values.toList();
  final total = values.fold(0.0, (a, b) => a + b);
  
  if (total <= 0 || total.isInfinite || total.isNaN) return 0.0;

  double entropy = 0.0;
  for (final value in values) {
    if (value <= 0) continue;
    final probability = value / total;
    if (probability > 0 && !probability.isInfinite && !probability.isNaN) {
      entropy -= probability * log(probability);
    }
  }

  // –ó–∞—â–∏—Ç–∞ –æ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
  return entropy.isNaN || entropy.isInfinite ? 0.0 : entropy;
}
/// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—Ü–µ–Ω–æ–∫ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
class _Line7CandidateScore {
  final int wordId;
  final double intersectionScore;
  final double entropyChange;
  final double predictedEntropy;
  final double combinedScore;

  _Line7CandidateScore({
    required this.wordId,
    required this.intersectionScore,
    required this.entropyChange,
    required this.predictedEntropy,
    required this.combinedScore,
  });
}
class Fragment3DVisualization extends StatefulWidget {
  final OptimizedNeuralNetwork network;
  final Set<int> selectedFragmentIds;
  final Function(int, bool) onFragmentSelected;
  final Set<int>? neuronIds;
  
  const Fragment3DVisualization({
    Key? key,
    required this.network,
    required this.selectedFragmentIds,
    required this.onFragmentSelected,
    this.neuronIds,
  }) : super(key: key);
  
  @override
  _Fragment3DVisualizationState createState() => _Fragment3DVisualizationState();
}

class _Fragment3DVisualizationState extends State<Fragment3DVisualization> {
  double _rotationX = 0.0;
  double _rotationY = 0.0;
  double _scale = 1.0;
  Offset _offset = Offset.zero;
  Offset? _lastLeftPanPosition;
  Offset? _lastRightPanPosition;
  bool _isRightMouseDown = false;
  bool _shiftPressed = false;
  int? _primaryButtonPointer;
  int? _secondaryButtonPointer;

  @override
  void initState() {
    super.initState();
    RawKeyboard.instance.addListener(_handleKeyEvent);
  }

  @override
  void dispose() {
    RawKeyboard.instance.removeListener(_handleKeyEvent);
    super.dispose();
  }

  void _handleKeyEvent(RawKeyEvent event) {
    if (event.logicalKey == LogicalKeyboardKey.shiftLeft || 
        event.logicalKey == LogicalKeyboardKey.shiftRight) {
      setState(() {
        _shiftPressed = event is RawKeyDownEvent;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerSignal: (pointerSignal) {
        if (pointerSignal is PointerScrollEvent) {
          setState(() {
            _scale = (_scale * (1.0 + pointerSignal.scrollDelta.dy * -0.001))
                .clamp(0.1, 3.0);
          });
        }
      },
      onPointerDown: (event) {
        _handlePointerDown(event);
      },
      onPointerMove: (event) {
        _handlePointerMove(event);
      },
      onPointerUp: (event) {
        _handlePointerUp(event);
      },
      onPointerCancel: (event) {
        _handlePointerCancel(event);
      },
      child: MouseRegion(
        onHover: (event) {
          if (event.kind == PointerDeviceKind.mouse) {
            if ((event.buttons & kPrimaryButton) != 0 && !_isRightMouseDown) {
            }
          }
        },
        child: GestureDetector(
          onScaleUpdate: (details) {
            if (!_isRightMouseDown) {
              setState(() {
                _scale = (_scale * details.scale).clamp(0.1, 3.0);
              });
            }
          },
          onTapDown: (details) {
            _handleTap(details.localPosition, _shiftPressed);
          },
          child: CustomPaint(
            size: Size.infinite,
            painter: Fragment3DPainter(
              network: widget.network,
              neuronIds: widget.neuronIds,
              rotationX: _rotationX,
              rotationY: _rotationY,
              scale: _scale,
              offset: _offset,
              selectedFragmentIds: widget.selectedFragmentIds,
            ),
          ),
        ),
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (event.kind == PointerDeviceKind.mouse) {
      if (event.buttons == kPrimaryButton) {
        _primaryButtonPointer = event.pointer;
        _lastLeftPanPosition = event.position;
      } else if (event.buttons == kSecondaryButton) {
        _secondaryButtonPointer = event.pointer;
        _lastRightPanPosition = event.position;
        _isRightMouseDown = true;
      }
    } else {
      _primaryButtonPointer = event.pointer;
      _lastLeftPanPosition = event.position;
    }
  }

  void _handlePointerMove(PointerMoveEvent event) {
    if (event.kind == PointerDeviceKind.mouse) {
      if (_primaryButtonPointer == event.pointer && _lastLeftPanPosition != null) {
        setState(() {
          final delta = event.position - _lastLeftPanPosition!;
          _rotationY += delta.dx * 0.01;
          _rotationX += delta.dy * 0.01;
          _lastLeftPanPosition = event.position;
        });
      } else if (_secondaryButtonPointer == event.pointer && _lastRightPanPosition != null) {
        setState(() {
          final delta = event.position - _lastRightPanPosition!;
          _offset += Offset(delta.dx, delta.dy);
          _lastRightPanPosition = event.position;
        });
      }
    } else if (_primaryButtonPointer == event.pointer && _lastLeftPanPosition != null) {
      setState(() {
        final delta = event.position - _lastLeftPanPosition!;
        _rotationY += delta.dx * 0.01;
        _rotationX += delta.dy * 0.01;
        _lastLeftPanPosition = event.position;
      });
    }
  }

  void _handlePointerUp(PointerUpEvent event) {
    _resetPointer(event.pointer);
  }

  void _handlePointerCancel(PointerCancelEvent event) {
    _resetPointer(event.pointer);
  }

  void _resetPointer(int pointerId) {
    if (_primaryButtonPointer == pointerId) {
      _primaryButtonPointer = null;
      _lastLeftPanPosition = null;
    }
    if (_secondaryButtonPointer == pointerId) {
      _secondaryButtonPointer = null;
      _lastRightPanPosition = null;
      _isRightMouseDown = false;
    }
  }

  void _handleTap(Offset position, bool shiftPressed) {
    final RenderBox box = context.findRenderObject() as RenderBox;
    final size = box.size;
    final centerX = size.width / 2 + _offset.dx;
    final centerY = size.height / 2 + _offset.dy;
    
    final fragments = _getFragmentsToDisplay();
    final projectedFragments = <_ProjectedFragment>[];
    
    for (int i = 0; i < fragments.length; i++) {
      final fragment = fragments[i];
      final pos = _project3DTo2D(
        fragment.x - 500, fragment.y - 500, fragment.z - 500,
        centerX, centerY,
      );
      
      projectedFragments.add(_ProjectedFragment(
        fragment: fragment,
        screenX: pos.dx,
        screenY: pos.dy,
        depth: pos.depth,
        index: i,
      ));
    }
    
    for (final projFragment in projectedFragments) {
      final distance = sqrt(
        pow(projFragment.screenX - position.dx, 2) + 
        pow(projFragment.screenY - position.dy, 2)
      );
      
      if (distance < 60.0) {
        widget.onFragmentSelected(projFragment.fragment.id, shiftPressed);
        return;
      }
    }
  }

  List<Fragment> _getFragmentsToDisplay() {
    if (widget.neuronIds != null && widget.neuronIds!.isNotEmpty) {
      final allFragments = <Fragment>[];
      for (final neuronId in widget.neuronIds!) {
        final neuron = widget.network.neurons[neuronId];
        if (neuron != null) {
          for (final fragmentId in neuron.fragmentLinks) {
            final fragment = widget.network.fragments[fragmentId];
            if (fragment != null) {
              allFragments.add(fragment);
            }
          }
        }
      }
      return allFragments;
    } else {
      return widget.network.fragments.values.toList();
    }
  }
  
  Projected3D _project3DTo2D(double x, double y, double z, double centerX, double centerY) {
    final cosY = cos(_rotationY);
    final sinY = sin(_rotationY);
    final cosX = cos(_rotationX);
    final sinX = sin(_rotationX);
    
    var x1 = x * cosY - z * sinY;
    var z1 = x * sinY + z * cosY;
    var y1 = y;
    
    final y2 = y1 * cosX - z1 * sinX;
    final z2 = y1 * sinX + z1 * cosX;
    
    final perspective = 1000 / (1000 + z2);
    final screenX = centerX + x1 * _scale * perspective;
    final screenY = centerY + y2 * _scale * perspective;
    
    return Projected3D(dx: screenX, dy: screenY, depth: z2);
  }
}

class Fragment3DPainter extends CustomPainter {
  final OptimizedNeuralNetwork network;
  final Set<int>? neuronIds;
  final double rotationX;
  final double rotationY;
  final double scale;
  final Offset offset;
  final Set<int> selectedFragmentIds;
  
  Fragment3DPainter({
    required this.network,
    required this.neuronIds,
    required this.rotationX,
    required this.rotationY,
    required this.scale,
    required this.offset,
    required this.selectedFragmentIds,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final centerX = size.width / 2 + offset.dx;
    final centerY = size.height / 2 + offset.dy;
    
    final fragments = _getFragmentsToDisplay();
    final projectedFragments = <_ProjectedFragment>[];
    
    _positionFragmentsByNeurons(fragments);
    
    for (int i = 0; i < fragments.length; i++) {
      final fragment = fragments[i];
      final pos = _project3DTo2D(
        fragment.x - 500, fragment.y - 500, fragment.z - 500,
        centerX, centerY,
      );
      
      projectedFragments.add(_ProjectedFragment(
        fragment: fragment,
        screenX: pos.dx,
        screenY: pos.dy,
        depth: pos.depth,
        index: i,
      ));
    }
    
    projectedFragments.sort((a, b) => a.depth.compareTo(b.depth));
    
    for (final projFragment in projectedFragments) {
      _drawFragmentCard(canvas, projFragment);
    }
  }

  void _positionFragmentsByNeurons(List<Fragment> fragments) {
    if (fragments.isEmpty) return;
    
    final neuronFragments = <int, List<Fragment>>{};
    
    for (final fragment in fragments) {
      for (final neuron in network.neurons.values) {
        if (neuron.fragmentLinks.contains(fragment.id)) {
          if (!neuronFragments.containsKey(neuron.id)) {
            neuronFragments[neuron.id] = [];
          }
          neuronFragments[neuron.id]!.add(fragment);
          break;
        }
      }
    }
    
    if (neuronFragments.isEmpty) {
      _positionFragmentsBySemantics(fragments);
      return;
    }
    
    final neuronEntries = neuronFragments.entries.toList();
    final neuronCount = neuronEntries.length;
    
    for (int neuronIndex = 0; neuronIndex < neuronCount; neuronIndex++) {
      final entry = neuronEntries[neuronIndex];
      final neuronFrags = entry.value;
      
      final planeX = 100.0 + (neuronIndex % 3) * 600.0;
      final planeY = 100.0 + (neuronIndex ~/ 3) * 400.0;
      final planeZ = (neuronIndex % 2) * 200.0;
      
      for (int fragIndex = 0; fragIndex < neuronFrags.length; fragIndex++) {
        final fragment = neuronFrags[fragIndex];
        final row = fragIndex ~/ 4;
        final col = fragIndex % 4;
        
        fragment.x = planeX + col * 280.0;
        fragment.y = planeY + row * 120.0;
        fragment.z = planeZ;
      }
    }
    
    for (final fragment in fragments) {
      if (fragment.x == 0.0 && fragment.y == 0.0 && fragment.z == 0.0) {
        fragment.x = network.random.nextDouble() * 800 + 100;
        fragment.y = network.random.nextDouble() * 800 + 100;
        fragment.z = network.random.nextDouble() * 800 + 100;
      }
    }
  }

  List<List<Fragment>> _clusterFragmentsBySemantics(List<Fragment> fragments) {
    final clusters = <List<Fragment>>[];
    final visited = <int>{};
    
    for (final fragment in fragments) {
      if (visited.contains(fragment.id)) continue;
      
      final cluster = <Fragment>[fragment];
      visited.add(fragment.id);
      
      for (final other in fragments) {
        if (visited.contains(other.id)) continue;
        
        final similarity = _calculateFragmentSimilarity(fragment, other);
        if (similarity > 0.3) {
          cluster.add(other);
          visited.add(other.id);
        }
      }
      
      if (cluster.isNotEmpty) {
        clusters.add(cluster);
      }
    }
    
    return clusters;
  }
  
  double _calculateFragmentSimilarity(Fragment frag1, Fragment frag2) {
    final set1 = frag1.wordIds.toSet();
    final set2 = frag2.wordIds.toSet();
    final intersection = set1.intersection(set2).length;
    final union = set1.union(set2).length;
    
    double lexicalSimilarity = union > 0 ? intersection / union : 0.0;
    
    double semanticBonus = frag1.semanticType == frag2.semanticType ? 0.2 : 0.0;
    
    final lengthFactor = min(frag1.text.length, frag2.text.length) / 1000.0;
    
    return (lexicalSimilarity * 0.6 + semanticBonus * 0.2 + lengthFactor * 0.2).clamp(0.0, 1.0);
  }

  void _positionFragmentsBySemantics(List<Fragment> fragments) {
    final clusters = _clusterFragmentsBySemantics(fragments);
    final clusterCount = clusters.length;
    
    for (int i = 0; i < clusterCount; i++) {
      final cluster = clusters[i];
      final phi = acos(-1.0 + 2.0 * i / clusterCount);
      final theta = sqrt(clusterCount * pi) * phi;
      
      final centerX = 500.0 + 300.0 * sin(phi) * cos(theta);
      final centerY = 500.0 + 300.0 * sin(phi) * sin(theta);
      final centerZ = 500.0 + 300.0 * cos(phi);
      
      for (int j = 0; j < cluster.length; j++) {
        final fragment = cluster[j];
        final angle = 2 * pi * j / cluster.length;
        final radius = 80.0;
        
        fragment.x = centerX + radius * cos(angle);
        fragment.y = centerY + radius * sin(angle);
        fragment.z = centerZ;
      }
    }
  }

  void _drawFragmentCard(Canvas canvas, _ProjectedFragment projFragment) {
    final fragment = projFragment.fragment;
    final isSelected = selectedFragmentIds.contains(fragment.id);
    
    final center = Offset(projFragment.screenX, projFragment.screenY);
    const double maxWidth = 250.0;
    final double width = maxWidth * scale;
    final double height = 80.0 * scale;
    
    final cardRect = Rect.fromCenter(
      center: center,
      width: width,
      height: height
    );
    
    final backgroundPaint = Paint()
      ..color = Color(0xFF2D2D2D).withOpacity(0.9)
      ..style = PaintingStyle.fill;
    
    canvas.drawRRect(
      RRect.fromRectAndRadius(cardRect, Radius.circular(8 * scale)),
      backgroundPaint
    );
    
    if (isSelected) {
      final borderPaint = Paint()
        ..color = Colors.amber.withOpacity(0.8)
        ..strokeWidth = 2.5
        ..style = PaintingStyle.stroke;
      
      canvas.drawRRect(
        RRect.fromRectAndRadius(cardRect, Radius.circular(8 * scale)),
        borderPaint
      );
    }
    
    final textPainter = _createTextPainter(fragment.text, width - 3, 9 * scale);
    
    final textOffset = Offset(
      center.dx - textPainter.width / 2,
      center.dy - textPainter.height / 2
    );
    
    textPainter.paint(canvas, textOffset);
    
    final infoText = '#${fragment.id} ‚Ä¢ ${fragment.semanticType} ‚Ä¢ ${fragment.wordIds.length} —Å–ª–æ–≤';
    final infoPainter = _createTextPainter(infoText, width - 16, 8 * scale, color: Colors.white70);
    
    final infoOffset = Offset(
      center.dx - infoPainter.width / 2,
      center.dy + height / 2 - infoPainter.height - 4
    );
    
    infoPainter.paint(canvas, infoOffset);
  }

  TextPainter _createTextPainter(String text, double maxWidth, double fontSize, {Color color = Colors.white}) {
    final textStyle = TextStyle(
      color: color,
      fontSize: fontSize,
      height: 1.2,
    );
    
    final textSpan = TextSpan(
      text: text,
      style: textStyle,
    );
    
    final textPainter = TextPainter(
      text: textSpan,
      textDirection: ui.TextDirection.ltr,
      maxLines: 5,
      ellipsis: '...',
    );
    
    textPainter.layout(maxWidth: maxWidth);
    return textPainter;
  }

  void _positionFragmentsInGrid(List<Fragment> fragments) {
    const double maxWidth = 1008.0;
    const double cardWidth = 250.0;
    const double cardHeight = 80.0;
    const double horizontalSpacing = 2.0;
    const double verticalSpacing = 2.0;
    
    double currentX = 0;
    double currentY = 0;
    double currentZ = 0.0;
    int rowFragmentCount = 0;
    
    for (final fragment in fragments) {
      if (currentX + cardWidth > maxWidth) {
        currentX = 0;
        currentY += cardHeight + verticalSpacing;
        rowFragmentCount = 0;
      }
      
      fragment.x = currentX;
      fragment.y = currentY;
      fragment.z = currentZ;
      
      currentX += cardWidth + horizontalSpacing;
      rowFragmentCount++;
      
      currentZ += 5.0;
    }
  }

  List<Fragment> _getFragmentsToDisplay() {
    List<Fragment> fragments;
    
    if (neuronIds != null && neuronIds!.isNotEmpty) {
      final allFragments = <Fragment>[];
      for (final neuronId in neuronIds!) {
        final neuron = network.neurons[neuronId];
        if (neuron != null) {
          for (final fragmentId in neuron.fragmentLinks) {
            final fragment = network.fragments[fragmentId];
            if (fragment != null) {
              allFragments.add(fragment);
            }
          }
        }
      }
      fragments = allFragments;
    } else {
      fragments = network.fragments.values.take(100).toList();
    }
    
    _positionFragmentsInGrid(fragments);
    return fragments;
  }
  
  _Projected3D _project3DTo2D(double x, double y, double z, double centerX, double centerY) {
    final cosY = cos(rotationY);
    final sinY = sin(rotationY);
    final cosX = cos(rotationX);
    final sinX = sin(rotationX);
    
    var x1 = x * cosY - z * sinY;
    var z1 = x * sinY + z * cosY;
    var y1 = y;
    
    final y2 = y1 * cosX - z1 * sinX;
    final z2 = y1 * sinX + z1 * cosX;
    
    final perspective = 1000 / (1000 + z2);
    final screenX = centerX + x1 * scale * perspective;
    final screenY = centerY + y2 * scale * perspective;
    
    return _Projected3D(dx: screenX, dy: screenY, depth: z2);
  }
  
  @override
  bool shouldRepaint(Fragment3DPainter oldDelegate) {
    return oldDelegate.rotationX != rotationX ||
        oldDelegate.rotationY != rotationY ||
        oldDelegate.scale != scale ||
        oldDelegate.offset != offset ||
        oldDelegate.selectedFragmentIds.length != selectedFragmentIds.length;
  }
}

class _ProjectedFragment {
  final Fragment fragment;
  final double screenX;
  final double screenY;
  final double depth;
  final int index;
  
  _ProjectedFragment({
    required this.fragment,
    required this.screenX,
    required this.screenY,
    required this.depth,
    required this.index,
  });
}

// –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞–º
extension Fragment3DExtension on Fragment {
  static final Map<int, double> _xCoords = {};
  static final Map<int, double> _yCoords = {};
  static final Map<int, double> _zCoords = {};
  
  double get x => _xCoords[id] ?? 0.0;
  set x(double value) => _xCoords[id] = value;
  
  double get y => _yCoords[id] ?? 0.0;
  set y(double value) => _yCoords[id] = value;
  
  double get z => _zCoords[id] ?? 0.0;
  set z(double value) => _zCoords[id] = value;
}



extension TextStyleExtension on TextStyle {
  ui.TextStyle getTextStyle() {
    return ui.TextStyle(
      color: color,
      fontSize: fontSize,
      fontWeight: fontWeight,
      fontStyle: fontStyle,
      letterSpacing: letterSpacing,
      wordSpacing: wordSpacing,
      height: height,
      decoration: decoration,
      decorationColor: decorationColor,
      decorationStyle: decorationStyle,
      decorationThickness: decorationThickness,
      background: background,
      shadows: shadows,
      fontFeatures: fontFeatures,
    );
  }
}


































// ==================== ENUMS ====================

enum KeyContentType { image, text, url, windowsShortcut, macros }
enum KeyAction { copyToClipboard, pasteToForeground, open, openInExplorer, run }
enum MacroActionType { hotkey, click, delay, runPath }

// ==================== MACRO ACTION ====================

class MacroAction {
  final MacroActionType type;
  final String value;
  final int? x, y, x1, y1, delay;

  MacroAction({
    required this.type,
    required this.value,
    this.x, this.y, this.x1, this.y1, this.delay,
  });

  Map<String, dynamic> toJson() => {
    'type': type.index, 'value': value,
    'x': x, 'y': y, 'x1': x1, 'y1': y1, 'delay': delay,
  };

  factory MacroAction.fromJson(Map<String, dynamic> json) => MacroAction(
    type: MacroActionType.values[json['type'] ?? 0],
    value: json['value'] ?? '',
    x: json['x'], y: json['y'], x1: json['x1'], y1: json['y1'], delay: json['delay'],
  );

  String toScript() {
    switch (type) {
      case MacroActionType.hotkey: return 'HOTKEY: $value';
      case MacroActionType.click: return 'CLICK: ($x,$y) ‚Üí ($x1,$y1)';
      case MacroActionType.delay: return 'DELAY: ${delay}ms';
      case MacroActionType.runPath: return 'RUN: $value';
    }
  }

  IconData get icon {
    switch (type) {
      case MacroActionType.hotkey: return Icons.keyboard;
      case MacroActionType.click: return Icons.mouse;
      case MacroActionType.delay: return Icons.timer;
      case MacroActionType.runPath: return Icons.play_arrow;
    }
  }

  String get displayName {
    switch (type) {
      case MacroActionType.hotkey: return value;
      case MacroActionType.click: return 'Click';
      case MacroActionType.delay: return '${delay}ms';
      case MacroActionType.runPath: return p.basename(value);
    }
  }
}

// ==================== MACRO ====================

class Macro {
  List<MacroAction> actions;
  int loopAmount;
  
  Macro({required this.actions, this.loopAmount = 1});

  Map<String, dynamic> toJson() => {
    'actions': actions.map((a) => a.toJson()).toList(),
    'loopAmount': loopAmount,
  };
  
  factory Macro.fromJson(Map<String, dynamic> json) => Macro(
    actions: (json['actions'] as List? ?? []).map((a) => MacroAction.fromJson(a)).toList(),
    loopAmount: json['loopAmount'] ?? 1,
  );
  
  String toScript() => 'LOOP: $loopAmount\n${actions.map((a) => a.toScript()).join('\n')}';
}

// ==================== KEY BIND ====================

class KeyBind {
  final String key;
  String name, hint, description, combination;
  KeyContentType type;
  String? imagePath, filePath, textContent, url;
  Macro? macro;
  List<KeyAction> actions;
  IconData? icon;
  Uint8List? fileIcon;

  KeyBind({
    required this.key, required this.name, required this.hint,
    required this.description, required this.type, required this.combination,
    required this.actions, this.imagePath, this.filePath, this.textContent,
    this.url, this.macro, this.icon, this.fileIcon,
  });

  Map<String, dynamic> toJson() => {
    'key': key, 'name': name, 'hint': hint, 'description': description,
    'type': type.index, 'imagePath': imagePath, 'filePath': filePath,
    'textContent': textContent, 'url': url, 'macro': macro?.toJson(),
    'combination': combination, 'actions': actions.map((a) => a.index).toList(),
    'icon': icon?.codePoint,
  };

  factory KeyBind.fromJson(Map<String, dynamic> json) => KeyBind(
    key: json['key'] ?? '', name: json['name'] ?? '', hint: json['hint'] ?? '',
    description: json['description'] ?? '', type: KeyContentType.values[json['type'] ?? 0],
    imagePath: json['imagePath'], filePath: json['filePath'],
    textContent: json['textContent'], url: json['url'],
    macro: json['macro'] != null ? Macro.fromJson(json['macro']) : null,
    combination: json['combination'] ?? '',
    actions: (json['actions'] as List? ?? [0]).map((a) => KeyAction.values[a]).toList(),
    icon: json['icon'] != null ? IconData(json['icon'], fontFamily: 'MaterialIcons') : null,
  );
}

// ==================== –°–ï–†–í–ò–° –®–ò–§–†–û–í–ê–ù–ò–Ø ====================

class EncryptionService {
  static final EncryptionService _instance = EncryptionService._internal();
  factory EncryptionService() => _instance;
  EncryptionService._internal();

  bool _initialized = false;
  late Uint8List _key;

  Future<void> initialize() async {
    if (_initialized) return;
    final prefs = await SharedPreferences.getInstance();
    String? keyString = prefs.getString('encryption_key');
    if (keyString == null) {
      final random = Random.secure();
      _key = Uint8List.fromList(List<int>.generate(32, (i) => random.nextInt(256)));
      await prefs.setString('encryption_key', base64.encode(_key));
    } else {
      _key = base64.decode(keyString);
    }
    _initialized = true;
  }

  String encrypt(String plainText) {
    if (!_initialized) throw Exception('EncryptionService not initialized');
    final plainBytes = utf8.encode(plainText);
    final encryptedBytes = Uint8List(plainBytes.length);
    for (int i = 0; i < plainBytes.length; i++) {
      encryptedBytes[i] = plainBytes[i] ^ _key[i % _key.length];
    }
    return base64.encode(encryptedBytes);
  }

  String decrypt(String encryptedText) {
    if (!_initialized) throw Exception('EncryptionService not initialized');
    final encryptedBytes = base64.decode(encryptedText);
    final decryptedBytes = Uint8List(encryptedBytes.length);
    for (int i = 0; i < encryptedBytes.length; i++) {
      decryptedBytes[i] = encryptedBytes[i] ^ _key[i % _key.length];
    }
    return utf8.decode(decryptedBytes);
  }
}

// ==================== –•–†–ê–ù–ò–õ–ò–©–ï ====================

class KeyBindStorage {
  static final KeyBindStorage _instance = KeyBindStorage._internal();
  factory KeyBindStorage() => _instance;
  KeyBindStorage._internal();

  final Map<String, KeyBind> _keyBinds = {};
  bool _loaded = false;

  Future<void> loadKeyBinds() async {
    if (_loaded) return;
    try {
      await EncryptionService().initialize();
      final prefs = await SharedPreferences.getInstance();
      final encryptedData = prefs.getString('key_binds_encrypted');
      if (encryptedData != null) {
        final jsonData = EncryptionService().decrypt(encryptedData);
        final Map<String, dynamic> data = json.decode(jsonData);
        _keyBinds.clear();
        data.forEach((key, value) {
          try {
            _keyBinds[key] = KeyBind.fromJson(value);
          } catch (e) {
            print('Error loading keybind $key: $e');
          }
        });
      }
      _loaded = true;
    } catch (e) {
      print('Error loading key binds: $e');
      _keyBinds.clear();
      _loaded = true;
    }
  }

  Future<void> saveKeyBinds() async {
    try {
      final data = <String, dynamic>{};
      _keyBinds.forEach((key, value) => data[key] = value.toJson());
      final jsonData = json.encode(data);
      final encryptedData = EncryptionService().encrypt(jsonData);
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('key_binds_encrypted', encryptedData);
    } catch (e) {
      print('Error saving key binds: $e');
    }
  }

  KeyBind? getKeyBind(String key) => _keyBinds[key];
  void setKeyBind(String key, KeyBind keyBind) {
    _keyBinds[key] = keyBind;
    saveKeyBinds();
  }
  void removeKeyBind(String key) {
    _keyBinds.remove(key);
    saveKeyBinds();
  }
  bool hasKeyBind(String key) => _keyBinds.containsKey(key);
  List<String> getAllKeys() => _keyBinds.keys.toList();
}

// ==================== –°–ï–†–í–ò–° –í–´–ü–û–õ–ù–ï–ù–ò–Ø –î–ï–ô–°–¢–í–ò–ô ====================

class ActionService {
  static final ActionService _instance = ActionService._internal();
  factory ActionService() => _instance;
  ActionService._internal();
final NativeMouseService _mouseService = NativeMouseService();
  Future<void> executeKeyBind(KeyBind keyBind) async {
    try {
      for (final action in keyBind.actions) {
        await _executeAction(keyBind, action);
      }
    } catch (e) {
      print('Error executing keybind: $e');
    }
  }

  Future<void> _executeAction(KeyBind keyBind, KeyAction action) async {
    switch (action) {
      case KeyAction.copyToClipboard:
        await _copyToClipboard(keyBind);
        break;
      case KeyAction.pasteToForeground:
        await _pasteToForeground(keyBind);
        break;
      case KeyAction.open:
        await _open(keyBind);
        break;
      case KeyAction.openInExplorer:
        await _openInExplorer(keyBind);
        break;
      case KeyAction.run:
        await _run(keyBind);
        break;
    }
  }

  Future<void> _copyToClipboard(KeyBind keyBind) async {
    switch (keyBind.type) {
      case KeyContentType.text:
        if (keyBind.textContent != null) {
          await Clipboard.setData(ClipboardData(text: keyBind.textContent!));
        }
        break;
      case KeyContentType.image:
        if (keyBind.imagePath != null) {
          final file = File(keyBind.imagePath!);
          if (file.existsSync()) {
            final imageBytes = await file.readAsBytes();
            try {
              const MethodChannel clipboardChannel = MethodChannel('screenshot_channel');
              await clipboardChannel.invokeMethod('copyImageToClipboard', {
                
                'imageData': imageBytes,
              });
            } catch (e) {
              print('Error copying image to clipboard: $e');
              await Clipboard.setData(ClipboardData(text: keyBind.imagePath!));
            }
          }
        }
        break;
      case KeyContentType.url:
        if (keyBind.url != null) {
          await Clipboard.setData(ClipboardData(text: keyBind.url!));
        }
        break;
      case KeyContentType.windowsShortcut:
        if (keyBind.filePath != null) {
          final file = File(keyBind.filePath!);
          if (file.existsSync()) {
            try {
              final content = await file.readAsBytes();
              const MethodChannel clipboardChannel = MethodChannel('clipboard_channel');
              await clipboardChannel.invokeMethod('copyFileToClipboard', {
                'filePath': keyBind.filePath,
                'fileBytes': content,
              });
            } catch (e) {
              print('Error copying file to clipboard: $e');
              await Clipboard.setData(ClipboardData(text: keyBind.filePath!));
            }
          } else {
            await Clipboard.setData(ClipboardData(text: keyBind.filePath!));
          }
        }
        break;
      default:
        print('Cannot copy this content type to clipboard');
    }
  }

  Future<void> _pasteToForeground(KeyBind keyBind) async {
    await _copyToClipboard(keyBind);
    print('Pasting to foreground: ${keyBind.name}');
  }

  Future<void> _open(KeyBind keyBind) async {
    switch (keyBind.type) {
      case KeyContentType.url:
        if (keyBind.url != null) {
          await Process.run('start', [keyBind.url!], runInShell: true);
        }
        break;
      case KeyContentType.windowsShortcut:
        if (keyBind.filePath != null) {
          await Process.run('cmd', ['/c', 'start', '', keyBind.filePath!], runInShell: true);
        }
        break;
      default:
        print('Cannot open this content type');
    }
  }

  Future<void> _openInExplorer(KeyBind keyBind) async {
    if (keyBind.filePath != null) {
      final directory = p.dirname(keyBind.filePath!);
      await Process.run('explorer', [directory]);
    }
  }

  Future<void> _run(KeyBind keyBind) async {
    if (keyBind.type == KeyContentType.macros && keyBind.macro != null) {
      await _executeMacro(keyBind.macro!);
    } else if (keyBind.filePath != null) {
      await Process.run(keyBind.filePath!, [], runInShell: true);
    }
  }

  Future<void> _executeMacro(Macro macro) async {
  for (int i = 0; i < macro.loopAmount; i++) {
    for (final action in macro.actions) {
      await _executeMacroAction(action);
      // –£–±—Ä–∞–ª –¥—É–±–ª–∏—Ä—É—é—â—É—é –∑–∞–¥–µ—Ä–∂–∫—É –∑–¥–µ—Å—å, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ —Ç–µ–ø–µ—Ä—å –≤ _executeMacroAction
    }
  }
}
Future<void> _executeMacroAction(MacroAction action) async {
  switch (action.type) {
    case MacroActionType.hotkey:
      await _simulateHotkey(action.value);
      break;
    case MacroActionType.click:
      await _simulateClick(action.x!, action.y!);
      break;
    case MacroActionType.delay:
      await Future.delayed(Duration(milliseconds: action.delay ?? 1000));
      print('Delayed for ${action.delay}ms');
      break;
    case MacroActionType.runPath:
      if (action.value.isNotEmpty) {
        await Process.run(action.value, [], runInShell: true);
      }
      break;
  }
}

Future<void> _simulateHotkey(String hotkey) async {
  try {
    _mouseService.simulateKeyPress(hotkey);
  } catch (e) {
    print('Error simulating hotkey: $e');
  }
}



String _convertHotkeyToSendKeys(String hotkey) {
  // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç —Ö–æ—Ç–∫–µ–µ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç SendKeys
  return hotkey
      .replaceAll('Ctrl+', '^')
      .replaceAll('Alt+', '%')
      .replaceAll('Shift+', '+')
      .replaceAll('Win+', '#');
}

Future<void> _simulateClick(int x, int y) async {
  try {
    _mouseService.simulateMouseClick(x, y);
  } catch (e) {
    print('Error simulating click: $e');
  }
}
}

// ==================== –ì–õ–ê–í–ù–û–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–ï ====================

class VirtualKeyboardApp extends StatelessWidget {
  const VirtualKeyboardApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Virtual Keyboard',
      debugShowCheckedModeBanner: false,
      theme: ThemeData.dark().copyWith(
        scaffoldBackgroundColor: Colors.transparent,
        colorScheme: ColorScheme.dark(
          primary: Colors.blue,
          secondary: Colors.blueAccent,
        ),
      ),
      home: const VirtualKeyboardScreen(),
    );
  }
}

// ==================== –ì–õ–ê–í–ù–´–ô –≠–ö–†–ê–ù ====================

class VirtualKeyboardScreen extends StatefulWidget {
  const VirtualKeyboardScreen({Key? key}) : super(key: key);

  @override
  State<VirtualKeyboardScreen> createState() => _VirtualKeyboardScreenState();
}

class _VirtualKeyboardScreenState extends State<VirtualKeyboardScreen> with WindowListener {
  final KeyBindStorage _storage = KeyBindStorage();
  final ActionService _actionService = ActionService();
  bool _isLoading = true;
  bool _isEditing = false;
  bool _isMinimized = false;
  final FocusNode _focusNode = FocusNode();
  bool _isDragging = false;
  Offset _dragOffset = Offset.zero;

final List<List<String>> _keyboardLayout = [
  ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
  ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
  ['Z', 'X', 'C', 'V', 'B', 'N', 'M', 'ADD'],
];

  @override
  void initState() {
    super.initState();
    windowManager.addListener(this);
    _initialize();
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    _focusNode.dispose();
    super.dispose();
  }

  Future<void> _initialize() async {
    await windowManager.ensureInitialized();
      final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    final windowHeight = screenSize.height * 0.35;
    final windowWidth = screenSize.width * 0.55;
    WindowOptions windowOptions = WindowOptions(
      size:  Size(windowWidth, windowHeight),
      minimumSize:  Size(windowWidth, windowHeight),
      center: false,
      backgroundColor: Colors.transparent,
      skipTaskbar: false,
      titleBarStyle: TitleBarStyle.hidden,
      title: 'Virtual Keyboard',
    );

    await windowManager.waitUntilReadyToShow(windowOptions, () async {
      try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }
    
     await windowManager.show();
      await _setWindowPosition();
      await windowManager.focus();
    });

    await _storage.loadKeyBinds();
    if (mounted) setState(() => _isLoading = false);
    
    _focusNode.requestFocus();
  }

  Future<void> _setWindowPosition() async {
    final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    
    if (_isMinimized) {
      await windowManager.setPosition(const Offset(0, 25));
    } else {
       final windowHeight = screenSize.height * 0.32;
       final windowWidth = screenSize.width * 0.55;
      final yPosition = screenSize.height - windowHeight - 50;
      await windowManager.setPosition(Offset( (screenSize.width - windowWidth )/2, yPosition));
    }
  }

  Future<void> _toggleMinimize() async {
    setState(() => _isMinimized = !_isMinimized);
     final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    if (_isMinimized) {
      await windowManager.setSize( Size(550, 300));
      await windowManager.setPosition( Offset(50, 150));
    } else {
          final windowHeight = screenSize.height * 0.32;
       final windowWidth = screenSize.width * 0.55;
      await windowManager.setSize( Size(windowWidth, windowHeight));
      await _setWindowPosition();
    }
  }

  void _onKeyPressed(String key) {
    if (_isEditing) return;
    
    if (key == 'ADD') {
      _showAddDialog();
      return;
    }

    final keyBind = _storage.getKeyBind(key);
    if (keyBind != null) {
      _actionService.executeKeyBind(keyBind);
    }
  }

  void _onKeySecondaryTap(String key) {
    _showKeyEditor(key);
  }

  void _onKeyLongPressed(String key) {
    _showKeyEditor(key);
  }

  void _handleKeyEvent(RawKeyEvent event) {
    if (event is RawKeyDownEvent && !_isEditing) {
      final keyLabel = event.logicalKey.keyLabel;
      
      if (event.logicalKey.keyLabel == 'Escape' || event.logicalKey.keyLabel == 'Caps Lock') {
         _animateWindowFadeOutToBottomToClose();
        return;
      }
      
      for (final key in _storage.getAllKeys()) {
        final keyBind = _storage.getKeyBind(key);
        if (keyBind != null) {
          final parts = keyBind.combination.split('+');
          if (parts.length == 2 && parts[1] == keyLabel) {
            _actionService.executeKeyBind(keyBind);
            break;
          }
        }
      }
    }
  }

Future<void> _animateWindowFadeOutToBottomToClose() async {

   final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    final windowHeight = screenSize.height * 0.32;
    final windowWidth = screenSize.width * 0.55;
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä
    await windowManager.setSize(Size(windowWidth, windowHeight));

    // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (–∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —ç–∫—Ä–∞–Ω–∞ —Å–ø—Ä–∞–≤–∞)
    final endPosition = Offset(
      (screenSize.width - windowWidth)/2, // –ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞ –ø—Ä–∞–≤—ã–º –∫—Ä–∞–µ–º
      (screenSize.height ) ,
    );

    // –ö–æ–Ω–µ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
    final startPosition = Offset(
  (screenSize.width - windowWidth )/2, // –ü—Ä–∞–≤—ã–π –∫—Ä–∞–π
      (screenSize.height - windowHeight) - 50,
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é (–Ω–µ–≤–∏–¥–∏–º–æ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º)
    await windowManager.setPosition(startPosition);

  const duration = Duration(milliseconds: 390);
  const steps = 60;
  final stepDuration = duration ~/ steps;

  for (int i = 0; i <= steps; i++) {
    final progress = i / steps;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—Ä–∏–≤—É—é –¥–ª—è –±–æ–ª–µ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
    final curvedProgress = Curves.easeOutCubic.transform(progress);
    
    final currentY = startPosition.dy + (endPosition.dy - startPosition.dy) * curvedProgress;
    final currentPosition = Offset(startPosition.dx,currentY);
    
    // –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ –∫—Ä–∏–≤—ã–µ –¥–ª—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∏ –¥–≤–∏–∂–µ–Ω–∏—è
    final fadeProgress = Curves.easeOutCubic.transform(progress);
    final currentOpacity = fadeProgress;

    await windowManager.setPosition(currentPosition);
    await windowManager.setOpacity(1.0-currentOpacity);

    await Future.delayed(stepDuration);
  }

  // –§–∏–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  await windowManager.setPosition(endPosition);
  await windowManager.setOpacity(0.0);
  await windowManager.close();
}

  void _showKeyEditorWithBind(String key, KeyBind bind) {
    setState(() => _isEditing = true);
    
    showDialog(
      context: context,
      barrierColor: Colors.black54,
      builder: (context) => KeyBindEditor(
        keyId: key,
        existingBind: bind,
        onSave: (newBind) {
          _storage.setKeyBind(key, newBind);
          setState(() {});
          Navigator.of(context).pop();
          setState(() => _isEditing = false);
        },
        onDelete: _storage.hasKeyBind(key) ? () {
          _storage.removeKeyBind(key);
          setState(() {});
          Navigator.of(context).pop();
          setState(() => _isEditing = false);
        } : null,
      ),
    ).then((_) => setState(() => _isEditing = false));
  }
@override
Widget build(BuildContext context) {
  if (_isLoading) {
    return Scaffold(
      backgroundColor: Colors.transparent,
      body: Center(
        child: CircularProgressIndicator(color: Colors.blue),
      ),
    );
  }

  return RepaintBoundary(
    child: RawKeyboardListener(
      focusNode: _focusNode,
      autofocus: true,
      onKey: _handleKeyEvent,
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            // –§–æ–Ω, –∫–æ—Ç–æ—Ä—ã–π –≤—Å–µ–≥–¥–∞ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –∫–ª–∏–∫–∏
            Positioned.fill(
              child: IgnorePointer(
                ignoring: !_isEditing, // –í—Å–µ–≥–¥–∞ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–ª–∏–∫–∏ –Ω–∞ —Ñ–æ–Ω–µ
                child: Container(color: Colors.transparent),
              ),
            ),
            // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ - –ù–ï –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –∫–ª–∏–∫–∏
            _buildKeyboard(),
            // –ö–Ω–æ–ø–∫–∞ —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è - –ù–ï –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –∫–ª–∏–∫–∏
            Positioned(
              top: 10,
              right: 10,
              child: IgnorePointer(
                ignoring: false, // –ù–µ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–ª–∏–∫–∏ –Ω–∞ –∫–Ω–æ–ø–∫–µ
                child: Container(
                  width: 30,
                  height: 30,
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.7),
                    borderRadius: BorderRadius.circular(15),
                  ),
                  child: IconButton(
                    icon: Icon(_isMinimized ? Icons.open_in_full : Icons.minimize, 
                      color: Colors.white70, size: 16),
                    onPressed: _toggleMinimize,
                    padding: EdgeInsets.zero,
                  ),
                ),
              ),
            ),
            // –û–±–ª–∞—Å—Ç—å –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è - –ù–ï –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –∫–ª–∏–∫–∏
            _buildDragArea(),
          ],
        ),
      ),
    ),
  );
}
  Widget _buildDragArea() {
    return Positioned(
      top: 0,
      left: 0,
      right: 50,
      height: 30,
      child: GestureDetector(
        onPanStart: (details) {
          windowManager.startDragging();
        },
        child: Container(
          color: Colors.transparent,
        ),
      ),
    );
  }
Future<void> _handleFileDrop(String key, List<File> files) async {
  if (files.isEmpty) return;
  
  final file = files.first;
  final path = file.path;
  if (path.isEmpty) return;

  if (_isMinimized) {
    await _toggleMinimize();
  }

  KeyBind newBind;
  
  // –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –∏–∑ –ø—É—Ç–∏
  final extension = p.extension(path).toLowerCase();
  final fileName = p.basename(path);
  final fileNameWithoutExt = p.basenameWithoutExtension(path);
  
  if (extension == '.png' || extension == '.jpg' || extension == '.jpeg') {
    newBind = KeyBind(
      key: key,
      name: fileNameWithoutExt,
      hint: 'Image: $fileName',
      description: 'Dropped image file',
      type: KeyContentType.image,
      combination: 'CTRL+$key',
      actions: [KeyAction.copyToClipboard, KeyAction.open],
      imagePath: path,
    );
  } else if (extension == '.lnk' || extension == '.exe') {
    newBind = KeyBind(
      key: key,
      name: fileNameWithoutExt,
      hint: 'File: $fileName',
      description: 'Dropped file',
      type: KeyContentType.windowsShortcut,
      combination: 'CTRL+$key',
      actions: [KeyAction.open, KeyAction.openInExplorer],
      filePath: path,
    );
  } else if (extension == '.txt') {
    try {
      final content = await file.readAsString();
      newBind = KeyBind(
        key: key,
        name: fileNameWithoutExt,
        hint: 'Text: $fileName',
        description: 'Dropped text file',
        type: KeyContentType.text,
        combination: 'CTRL+$key',
        actions: [KeyAction.copyToClipboard],
        textContent: content,
      );
    } catch (e) {
      // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª –∫–∞–∫ —Ç–µ–∫—Å—Ç, —Å–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—ã–π —Ñ–∞–π–ª–æ–≤—ã–π –±–∏–Ω–¥
      newBind = KeyBind(
        key: key,
        name: fileNameWithoutExt,
        hint: 'File: $fileName',
        description: 'Dropped file',
        type: KeyContentType.windowsShortcut,
        combination: 'CTRL+$key',
        actions: [KeyAction.open, KeyAction.openInExplorer],
        filePath: path,
      );
    }
  } else {
    newBind = KeyBind(
      key: key,
      name: fileNameWithoutExt,
      hint: 'File: $fileName',
      description: 'Dropped file',
      type: KeyContentType.windowsShortcut,
      combination: 'CTRL+$key',
      actions: [KeyAction.open, KeyAction.openInExplorer],
      filePath: path,
    );
  }

  _showKeyEditorWithBind(key, newBind);
}
  Widget _buildKeyboard() {
    return Container(
      padding: _isMinimized?  EdgeInsets.all(3) :  EdgeInsets.all(12),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: _keyboardLayout.map((row) {
          return Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: row.map((key) {
              return Padding(
                padding:  _isMinimized?  EdgeInsets.all(1) :  EdgeInsets.all(3),
                child: _buildKey(key),
              );
            }).toList(),
          );
        }).toList(),
      ),
    );
  }
Widget _buildKey(String key) {
  final hasBind = _storage.hasKeyBind(key);
  final keyBind = _storage.getKeyBind(key);
  final isAddButton = key == 'ADD';
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
  Color? backgroundColor;
  if (hasBind && keyBind != null) {
      Color baseColor = _getColorForType(keyBind.type);
    Color darkGray = Color.fromRGBO(35, 35, 35, 1.0);

    // –°–º–µ—à–∏–≤–∞–Ω–∏–µ 50/50
    backgroundColor = Color.lerp(baseColor, darkGray, 0.9)!;
  }
  
  return Tooltip(
    message: isAddButton ? 'Add new bind' : (hasBind ? (keyBind?.hint ?? '') : 'Right-click to add bind'),
    waitDuration: const Duration(milliseconds: 500),
    child: DropTarget(
      onDragDone: (detail) async {
        final files = <File>[];
        
        try {
          final processedPaths = <String>{};
          
          for (final item in detail.files) {
            final path = item.path;
            
            if (path != null && path.isNotEmpty && !processedPaths.contains(path)) {
              processedPaths.add(path);
              
              final file = File(path);
              if (await file.exists()) {
                files.add(file);
                break; // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–π —Ñ–∞–π–ª
              }
            }
          }
        } catch (e) {
          print('Error in key drop: $e');
        }
        
        if (files.isNotEmpty) {
          _handleFileDrop(key, files);
          if (mounted) {
            setState(() {});
          }
          files.clear();
        }
      },
      child: GestureDetector(
        onTap: () => _onKeyPressed(key),
        onLongPress: isAddButton ? null : () => _onKeyLongPressed(key),
        onSecondaryTap: isAddButton ? null : () => _onKeySecondaryTap(key),
        child: Container(
          width: _isMinimized? 35 : 70,
          height: _isMinimized? 35 : 70,
          decoration: BoxDecoration(
            color: isAddButton 
                ? Colors.green.withOpacity(0.3)
                : hasBind 
                    ? backgroundColor ?? const Color(0xFF404040) // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ü–≤–µ—Ç–Ω–æ–π —Ñ–æ–Ω –µ—Å–ª–∏ –µ—Å—Ç—å –±–∏–Ω–¥
                    : Color.fromRGBO(35, 35, 35, 0.4),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: isAddButton 
                  ? Colors.green
                  : hasBind 
                      ? _getBorderColorForType(keyBind?.type) ?? Colors.blue.withOpacity(0.5)
                      : Colors.black.withOpacity(0.2),
              width: 1,
            ),
          ),
          child: Stack(
            children: [
              if (isAddButton)
                Center(
                  child: Icon(Icons.add, color: Colors.green, size: _isMinimized ? 16 : 28),
                )
              else ...[
                Positioned(
                  top: 4,
                  left: 6,
                  child: Text(
                    key,
                    style: TextStyle(
                      color: hasBind ? Colors.white : Colors.white.withOpacity(0.5),
                      fontSize: _isMinimized ? 8 : 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                if (hasBind && keyBind != null)
                  Positioned(
                    top: 4,
                    right: 6,
                    child: Icon(
                      keyBind.icon ?? _getTypeIcon(keyBind.type),
                      size: _isMinimized ? 10 : 14,
                      color: Colors.white70,
                    ),
                  ),
                if (hasBind && keyBind != null)
                  Center(child: _buildContentPreview(keyBind, _isMinimized ? 20 : 35)),
                if (hasBind && keyBind != null && keyBind.name.isNotEmpty)
                  Positioned(
                    bottom: 4,
                    left: 4,
                    right: 4,
                    child: Text(
                      keyBind.name.length > (_isMinimized ? 4 : 8) 
                          ? '${keyBind.name.substring(0, _isMinimized ? 4 : 8)}..' 
                          : keyBind.name,
                      style: TextStyle(
                        color: Colors.white70, 
                        fontSize: _isMinimized ? 7 : 10
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
              ],
            ],
          ),
        ),
      ),
    ),
  );
}

// –ú–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–∞ –ø–æ —Ç–∏–ø—É –∫–æ–Ω—Ç–µ–Ω—Ç–∞
Color _getColorForType(KeyContentType type) {
  switch (type) {
    case KeyContentType.image:
      return Colors.purple; // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    case KeyContentType.text:
      return Colors.green; // –ó–µ–ª–µ–Ω—ã–π –¥–ª—è —Ç–µ–∫—Å—Ç–∞
    case KeyContentType.url:
      return Colors.blue; // –°–∏–Ω–∏–π –¥–ª—è URL
    case KeyContentType.windowsShortcut:
      return Colors.orange; // –û—Ä–∞–Ω–∂–µ–≤—ã–π –¥–ª—è —Ñ–∞–π–ª–æ–≤/—è—Ä–ª—ã–∫–æ–≤
    case KeyContentType.macros:
      return Colors.red; // –ö—Ä–∞—Å–Ω—ã–π –¥–ª—è –º–∞–∫—Ä–æ—Å–æ–≤
  }
}

// –ú–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–≤–µ—Ç–∞ –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ —Ç–∏–ø—É –∫–æ–Ω—Ç–µ–Ω—Ç–∞
Color _getBorderColorForType(KeyContentType? type) {
  if (type == null) return Colors.black.withOpacity(0.5);
  
  switch (type) {
    case KeyContentType.image:
      return Colors.purpleAccent.withOpacity(0.7);
    case KeyContentType.text:
      return Colors.greenAccent.withOpacity(0.7);
    case KeyContentType.url:
      return Colors.blueAccent.withOpacity(0.7);
    case KeyContentType.windowsShortcut:
      return Colors.orangeAccent.withOpacity(0.7);
    case KeyContentType.macros:
      return Colors.redAccent.withOpacity(0.7);
  }
}

  IconData _getTypeIcon(KeyContentType type) {
    switch (type) {
      case KeyContentType.image: return Icons.image;
      case KeyContentType.text: return Icons.text_fields;
      case KeyContentType.url: return Icons.link;
      case KeyContentType.windowsShortcut: return Icons.insert_drive_file;
      case KeyContentType.macros: return Icons.play_arrow;
    }
  }

  Widget _buildContentPreview(KeyBind keyBind, double size) {
    if (keyBind.type == KeyContentType.image && keyBind.imagePath != null) {
      final file = File(keyBind.imagePath!);
      if (file.existsSync()) {
        return ClipRRect(
          borderRadius: BorderRadius.circular(4),
          child: Image.file(
            file,
            width: size,
            height: size,
            fit: BoxFit.cover,
            errorBuilder: (_, __, ___) => Icon(
              Icons.broken_image,
              size: size * 0.5,
              color: Colors.white30,
            ),
          ),
        );
      }
    }
    return const SizedBox.shrink();
  }

  void _showKeyEditor(String key) async {
    if (_isMinimized) {
      await _toggleMinimize();
    }

    setState(() => _isEditing = true);
    
    showDialog(
      context: context,
      barrierColor: Colors.black54,
      builder: (context) => KeyBindEditor(
        keyId: key,
        existingBind: _storage.getKeyBind(key),
        onSave: (bind) {
          _storage.setKeyBind(key, bind);
          setState(() {});
          Navigator.of(context).pop();
          setState(() => _isEditing = false);
        },
        onDelete: _storage.hasKeyBind(key) ? () {
          _storage.removeKeyBind(key);
          setState(() {});
          Navigator.of(context).pop();
          setState(() => _isEditing = false);
        } : null,
      ),
    ).then((_) => setState(() => _isEditing = false));
  }

  void _showAddDialog() {
    setState(() => _isEditing = true);
    
    String? selectedKey;
    showDialog(
      context: context,
      barrierColor: Colors.black54,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          backgroundColor: Colors.black.withOpacity(0.8),
          title: const Text('–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞–≤–∏—à—É', style: TextStyle(color: Colors.white)),
          content: SizedBox(
            width: 400,
            height: 200,
            child: GridView.count(
              crossAxisCount: 10,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
              children: _keyboardLayout.expand((row) => row)
                  .where((k) => k != 'ADD')
                  .map((key) {
                return GestureDetector(
                  onTap: () => setState(() => selectedKey = key),
                  child: Container(
                    decoration: BoxDecoration(
                      color: selectedKey == key ? Colors.blue : Colors.grey.withOpacity(0.3),
                      borderRadius: BorderRadius.circular(4),
                      border: Border.all(
                        color: selectedKey == key ? Colors.blue : Colors.white.withOpacity(0.2),
                      ),
                    ),
                    child: Center(
                      child: Text(
                        key,
                        style: TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.pop(context);
                setState(() => _isEditing = false);
              },
              child: const Text('–û—Ç–º–µ–Ω–∞'),
            ),
            ElevatedButton(
              onPressed: selectedKey == null ? null : () {
                Navigator.pop(context);
                _showKeyEditor(selectedKey!);
              },
              child: const Text('–î–∞–ª–µ–µ'),
            ),
          ],
        ),
      ),
    ).then((_) => setState(() => _isEditing = false));
  }
}

// ==================== –†–ï–î–ê–ö–¢–û–† –ë–ò–ù–î–û–í ====================

class KeyBindEditor extends StatefulWidget {
  final String keyId;
  final KeyBind? existingBind;
  final Function(KeyBind) onSave;
  final VoidCallback? onDelete;

  const KeyBindEditor({
    Key? key,
    required this.keyId,
    this.existingBind,
    required this.onSave,
    this.onDelete,
  }) : super(key: key);

  @override
  State<KeyBindEditor> createState() => _KeyBindEditorState();
}

class _KeyBindEditorState extends State<KeyBindEditor> {
  late TextEditingController _nameCtrl, _hintCtrl, _descCtrl;
  String _modifier = 'CTRL';
  KeyContentType _type = KeyContentType.text;
  List<KeyAction> _actions = [KeyAction.copyToClipboard];
  String? _imagePath, _filePath, _textContent, _url;
  Macro? _macro;
  IconData? _selectedIcon;
  bool _showIconGrid = false;

  final List<IconData> _icons = [
    Icons.home, Icons.settings, Icons.favorite, Icons.star, Icons.person,
    Icons.email, Icons.phone, Icons.chat, Icons.notifications, Icons.search,
    Icons.menu, Icons.close, Icons.arrow_back, Icons.arrow_forward, Icons.refresh,
    Icons.add, Icons.remove, Icons.create, Icons.delete, Icons.share,
    Icons.download, Icons.upload, Icons.cloud, Icons.wifi, Icons.bluetooth,
    Icons.gps_fixed, Icons.location_on, Icons.map, Icons.navigation, Icons.directions,
    Icons.camera, Icons.image, Icons.music_note, Icons.videocam, Icons.movie,
    Icons.games, Icons.sports_esports, Icons.fitness_center, Icons.beach_access, Icons.work,
    Icons.school, Icons.book, Icons.library_books, Icons.calculate, Icons.code,
    Icons.computer, Icons.phone_android, Icons.tablet, Icons.headset, Icons.keyboard,
    Icons.mouse, Icons.touch_app, Icons.memory, Icons.storage, Icons.usb,
    Icons.battery_std, Icons.power, Icons.lightbulb, Icons.flash_on, Icons.wb_sunny,
    Icons.ac_unit, Icons.whatshot, Icons.local_drink, Icons.restaurant, Icons.local_cafe,
    Icons.shopping_cart, Icons.credit_card, Icons.attach_money, Icons.account_balance,
    Icons.security, Icons.lock, Icons.visibility, Icons.visibility_off, Icons.vpn_key,
    Icons.fingerprint, Icons.face, Icons.verified_user, Icons.admin_panel_settings,
    Icons.warning, Icons.error, Icons.info, Icons.help, Icons.check_circle,
    Icons.cancel, Icons.remove_circle, Icons.add_circle, Icons.play_arrow, Icons.pause,
    Icons.stop, Icons.skip_next, Icons.skip_previous, Icons.fast_forward, Icons.fast_rewind,
    Icons.volume_up, Icons.volume_off, Icons.mic, Icons.mic_off, Icons.headphones,
    Icons.brightness_high, Icons.brightness_low, Icons.palette, Icons.format_paint, Icons.brush,
  ];

  @override
  void initState() {
    super.initState();
    final bind = widget.existingBind;
    _nameCtrl = TextEditingController(text: bind?.name ?? '');
    _hintCtrl = TextEditingController(text: bind?.hint ?? '');
    _descCtrl = TextEditingController(text: bind?.description ?? '');
    _selectedIcon = bind?.icon;
    
    if (bind != null) {
      _type = bind.type;
      _actions = List.from(bind.actions);
      _imagePath = bind.imagePath;
      _filePath = bind.filePath;
      _textContent = bind.textContent;
      _url = bind.url;
      _macro = bind.macro;
      final parts = bind.combination.split('+');
      if (parts.isNotEmpty) _modifier = parts[0];
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;

    return Dialog(
      backgroundColor: Colors.transparent,
      insetPadding: EdgeInsets.zero,
      child: Container(
        width: screenWidth,
        height: 450,
        padding: const EdgeInsets.all(20),
        child: Row(
          children: [
            Expanded(flex: 1, child: _buildLeftSection()),
            const SizedBox(width: 12),
            Expanded(flex: 1, child: _buildMiddleSection()),
            const SizedBox(width: 12),
            Expanded(flex: 1, child: _buildRightSection()),
          ],
        ),
      ),
    );
  }

  Widget _buildLeftSection() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.7),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          Row(
            children: [
              Expanded(
                flex: 2,
                child: DropdownButtonFormField<String>(
                  value: _modifier,
                  items: ['CTRL', 'SHIFT', 'ALT', 'TAB']
                      .map((m) => DropdownMenuItem(value: m, child: Text(m, style: const TextStyle(color: Colors.white))))
                      .toList(),
                  onChanged: (v) => setState(() => _modifier = v!),
                  decoration: const InputDecoration(
                    labelText: '–ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä',
                    labelStyle: TextStyle(color: Colors.white70),
                    filled: true,
                    fillColor: Color(0xFF1E1E1E),
                  ),
                  dropdownColor: const Color(0xFF1E1E1E),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: GestureDetector(
                  onTap: _showKeySelector,
                  child: AbsorbPointer(
                    child: TextField(
                      enabled: false,
                      decoration: InputDecoration(
                        labelText: '–ö–ª–∞–≤–∏—à–∞',
                        hintText: widget.keyId,
                        hintStyle: const TextStyle(color: Colors.white),
                        labelStyle: const TextStyle(color: Colors.white70),
                        filled: true,
                        fillColor: const Color(0xFF1E1E1E),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          _buildIconSelector(),
          const SizedBox(height: 12),
          TextField(
            controller: _nameCtrl,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: '–ù–∞–∑–≤–∞–Ω–∏–µ',
              labelStyle: TextStyle(color: Colors.white70),
              filled: true,
              fillColor: Color(0xFF1E1E1E),
            ),
          ),
          const SizedBox(height: 12),
          TextField(
            controller: _hintCtrl,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: '–ü–æ–¥—Å–∫–∞–∑–∫–∞',
              labelStyle: TextStyle(color: Colors.white70),
              filled: true,
              fillColor: Color(0xFF1E1E1E),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildIconSelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('–ò–∫–æ–Ω–∫–∞', style: TextStyle(color: Colors.white70, fontSize: 14)),
        const SizedBox(height: 8),
        GestureDetector(
          onTap: () => setState(() => _showIconGrid = !_showIconGrid),
          child: Container(
            width: double.infinity,
            height: 40,
            decoration: BoxDecoration(
              color: const Color(0xFF1E1E1E),
              borderRadius: BorderRadius.circular(4),
              border: Border.all(color: Colors.white24),
            ),
            child: Row(
              children: [
                const SizedBox(width: 8),
                Icon(_selectedIcon ?? Icons.help_outline, color: Colors.white70),
                const SizedBox(width: 8),
                Text(
                  _selectedIcon != null ? '–ò–∫–æ–Ω–∫–∞ –≤—ã–±—Ä–∞–Ω–∞' : '–í—ã–±–µ—Ä–∏—Ç–µ –∏–∫–æ–Ω–∫—É',
                  style: const TextStyle(color: Colors.white70),
                ),
                const Spacer(),
                Icon(_showIconGrid ? Icons.expand_less : Icons.expand_more, color: Colors.white70),
                const SizedBox(width: 8),
              ],
            ),
          ),
        ),
        if (_showIconGrid) ...[
          const SizedBox(height: 8),
          Container(
            height: 120,
            decoration: BoxDecoration(
              color: const Color(0xFF1E1E1E),
              borderRadius: BorderRadius.circular(4),
              border: Border.all(color: Colors.white24),
            ),
            child: Scrollbar(
              child: GridView.builder(
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 5,
                  crossAxisSpacing: 4,
                  mainAxisSpacing: 4,
                ),
                itemCount: _icons.length,
                itemBuilder: (context, index) {
                  final icon = _icons[index];
                  final isSelected = _selectedIcon == icon;
                  return GestureDetector(
                    onTap: () => setState(() {
                      _selectedIcon = icon;
                      _showIconGrid = false;
                    }),
                    child: Container(
                      decoration: BoxDecoration(
                        color: isSelected ? Colors.blue : Colors.grey.withOpacity(0.3),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Icon(icon, color: Colors.white, size: 20),
                    ),
                  );
                },
              ),
            ),
          ),
        ],
      ],
    );
  }

  void _showKeySelector() {
    String? selectedKey;
    showDialog(
      context: context,
      barrierColor: Colors.black54,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          backgroundColor: Colors.black.withOpacity(0.8),
          title: const Text('–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞–≤–∏—à—É', style: TextStyle(color: Colors.white)),
          content: SizedBox(
            width: 400,
            height: 200,
            child: GridView.count(
              crossAxisCount: 10,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
              children: ['Q','W','E','R','T','Y','U','I','O','P','A','S','D','F','G','H','J','K','L','Z','X','C','V','B','N','M']
                  .map((key) {
                return GestureDetector(
                  onTap: () => setState(() => selectedKey = key),
                  child: Container(
                    decoration: BoxDecoration(
                      color: selectedKey == key ? Colors.blue : Colors.grey.withOpacity(0.3),
                      borderRadius: BorderRadius.circular(4),
                      border: Border.all(
                        color: selectedKey == key ? Colors.blue : Colors.white.withOpacity(0.2),
                      ),
                    ),
                    child: Center(
                      child: Text(
                        key,
                        style: TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('–û—Ç–º–µ–Ω–∞'),
            ),
            ElevatedButton(
              onPressed: selectedKey == null ? null : () {
                Navigator.pop(context);
              },
              child: const Text('–í—ã–±—Ä–∞—Ç—å'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMiddleSection() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.7),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π',
                style: TextStyle(color: Colors.white, fontSize: 16, fontWeight: FontWeight.bold),
              ),
              Tooltip(
                message: '–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞',
                child: IconButton(
                  icon: const Icon(Icons.content_copy, size: 18),
                  color: Colors.white70,
                  onPressed: () {
                    if (_descCtrl.text.isNotEmpty) {
                      Clipboard.setData(ClipboardData(text: _descCtrl.text));
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text('–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞')),
                      );
                    }
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Expanded(
            child: TextField(
              controller: _descCtrl,
              maxLines: null,
              expands: true,
              textAlignVertical: TextAlignVertical.top,
              style: const TextStyle(color: Colors.white),
              decoration: const InputDecoration(
                hintText: '–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –±–∏–Ω–¥–∞...',
                hintStyle: TextStyle(color: Colors.white30),
                filled: true,
                fillColor: Color(0xFF1E1E1E),
                border: OutlineInputBorder(),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRightSection() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.7),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        children: [
          _buildTypeSelector(),
          const SizedBox(height: 12),
          Expanded(child: _buildContentEditor()),
          const SizedBox(height: 12),
          _buildActionSelector(),
          const SizedBox(height: 8),
          _buildButtons(),
        ],
      ),
    );
  }

  Widget _buildTypeSelector() {
    return DropdownButtonFormField<KeyContentType>(
      value: _type,
      items: KeyContentType.values.map((t) {
        return DropdownMenuItem(value: t, child: Text(_getTypeName(t), style: const TextStyle(color: Colors.white)));
      }).toList(),
      onChanged: (v) => setState(() {
        _type = v!;
        _actions = _getDefaultActions(v);
      }),
      decoration: const InputDecoration(
        labelText: '–¢–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞',
        labelStyle: TextStyle(color: Colors.white70),
        filled: true,
        fillColor: Color(0xFF1E1E1E),
      ),
      dropdownColor: const Color(0xFF1E1E1E),
    );
  }

  String _getTypeName(KeyContentType type) {
    switch (type) {
      case KeyContentType.image: return '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ';
      case KeyContentType.text: return '–¢–µ–∫—Å—Ç';
      case KeyContentType.url: return 'URL';
      case KeyContentType.windowsShortcut: return '–Ø—Ä–ª—ã–∫/–§–∞–π–ª';
      case KeyContentType.macros: return '–ú–∞–∫—Ä–æ—Å';
    }
  }

  List<KeyAction> _getDefaultActions(KeyContentType type) {
    switch (type) {
      case KeyContentType.image:
      case KeyContentType.text:
      case KeyContentType.url:
        return [KeyAction.copyToClipboard];
      case KeyContentType.windowsShortcut:
        return [KeyAction.open];
      case KeyContentType.macros:
        return [KeyAction.run];
    }
  }

  Widget _buildContentEditor() {
    switch (_type) {
      case KeyContentType.image: return _buildImageEditor();
      case KeyContentType.text: return _buildTextEditor();
      case KeyContentType.url: return _buildUrlEditor();
      case KeyContentType.windowsShortcut: return _buildFileEditor();
      case KeyContentType.macros: return _buildMacroEditor();
    }
  }

  Widget _buildImageEditor() {
    return Column(
      children: [
        DragTarget<PlatformFile>(
          onWillAccept: (data) => true,
          onAccept: (file) {
            if (file.path != null) {
              setState(() {
                _imagePath = file.path!;
                if (_nameCtrl.text.isEmpty) _nameCtrl.text = p.basenameWithoutExtension(file.name);
              });
            }
          },
          builder: (context, candidateData, rejectedData) {
            return Container(
              width: 100,
              height: 100,
              decoration: BoxDecoration(
                color: const Color(0xFF1E1E1E),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: candidateData.isNotEmpty ? Colors.blue : Colors.white24,
                  width: candidateData.isNotEmpty ? 2 : 1,
                ),
              ),
              child: _imagePath != null && File(_imagePath!).existsSync()
                  ? ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: Image.file(File(_imagePath!), fit: BoxFit.cover),
                    )
                  : const Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.add_photo_alternate, size: 40, color: Colors.white30),
                        SizedBox(height: 8),
                        Text('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ\n–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', 
                          textAlign: TextAlign.center,
                          style: TextStyle(color: Colors.white30, fontSize: 12),
                        ),
                      ],
                    ),
            );
          },
        ),
        const SizedBox(height: 12),
        ElevatedButton.icon(
          onPressed: _pickImage,
          icon: const Icon(Icons.folder_open),
          label: const Text('–í—ã–±—Ä–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ'),
        ),
      ],
    );
  }

  Widget _buildTextEditor() {
    return TextField(
      onChanged: (v) => _textContent = v,
      controller: TextEditingController(text: _textContent),
      maxLines: 5,
      style: const TextStyle(color: Colors.white),
      decoration: const InputDecoration(
        labelText: '–¢–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ',
        labelStyle: TextStyle(color: Colors.white70),
        filled: true,
        fillColor: Color(0xFF1E1E1E),
        border: OutlineInputBorder(),
      ),
    );
  }

  Widget _buildUrlEditor() {
    return Column(
      children: [
        TextField(
          onChanged: (v) => _url = v,
          controller: TextEditingController(text: _url),
          style: const TextStyle(color: Colors.white),
          decoration: const InputDecoration(
            labelText: 'URL –∞–¥—Ä–µ—Å',
            labelStyle: TextStyle(color: Colors.white70),
            filled: true,
            fillColor: Color(0xFF1E1E1E),
            border: OutlineInputBorder(),
          ),
        ),
      ],
    );
  }

  Widget _buildFileEditor() {
    return Column(
      children: [
        TextField(
          onChanged: (v) => _filePath = v,
          controller: TextEditingController(text: _filePath),
          style: const TextStyle(color: Colors.white),
          decoration: const InputDecoration(
            labelText: '–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É',
            labelStyle: TextStyle(color: Colors.white70),
            filled: true,
            fillColor: Color(0xFF1E1E1E),
            border: OutlineInputBorder(),
          ),
        ),
        const SizedBox(height: 8),
        ElevatedButton.icon(
          onPressed: _pickFile,
          icon: const Icon(Icons.folder_open),
          label: const Text('–í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª'),
        ),
      ],
    );
  }

  Widget _buildMacroEditor() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: const Color(0xFF1E1E1E),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: Colors.white24),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const Text(
                    '–î–µ–π—Å—Ç–≤–∏—è –º–∞–∫—Ä–æ—Å–∞:',
                    style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold),
                  ),
                  const Spacer(),
                  if (_macro != null)
                    SizedBox(
                      width: 80,
                      child: TextField(
                        keyboardType: TextInputType.number,
                        decoration: const InputDecoration(
                          labelText: 'Loop',
                          labelStyle: TextStyle(color: Colors.white70, fontSize: 12),
                          filled: true,
                          fillColor: Color(0xFF2A2A2A),
                          contentPadding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        ),
                        style: const TextStyle(color: Colors.white, fontSize: 12),
                        onChanged: (value) {
                          final amount = int.tryParse(value) ?? 1;
                          setState(() => _macro!.loopAmount = amount.clamp(1, 100));
                        },
                        controller: TextEditingController(text: _macro?.loopAmount.toString() ?? '1'),
                      ),
                    ),
                ],
              ),
              const SizedBox(height: 8),
              SizedBox(
                height: 100,
                child: GridView.builder(
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 5,
                    crossAxisSpacing: 4,
                    mainAxisSpacing: 4,
                    childAspectRatio: 1.0,
                  ),
                  itemCount: (_macro?.actions.length ?? 0) + 1,
                  itemBuilder: (context, index) {
                    if (index == (_macro?.actions.length ?? 0)) {
                      return Tooltip(
                        message: '–î–æ–±–∞–≤–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ',
                        child: GestureDetector(
                          onTap: _addMacroAction,
                          child: Container(
                            decoration: BoxDecoration(
                              color: Colors.green.withOpacity(0.3),
                              borderRadius: BorderRadius.circular(4),
                              border: Border.all(color: Colors.green),
                            ),
                            child: const Icon(Icons.add, color: Colors.green, size: 20),
                          ),
                        ),
                      );
                    }
                    final action = _macro!.actions[index];
                    return Tooltip(
                      message: action.toScript(),
                      child: GestureDetector(
                        onTap: () => _editMacroAction(index),
                        child: Container(
                          width: 45,
                          height: 45,
                          decoration: BoxDecoration(
                            color: Colors.blue.withOpacity(0.3),
                            borderRadius: BorderRadius.circular(4),
                            border: Border.all(color: Colors.blue),
                          ),
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(action.icon, size: 20, color: Colors.white),
                              const SizedBox(height: 2),
                              Text(
                                action.displayName.length > 4 
                                    ? '${action.displayName.substring(0, 4)}..' 
                                    : action.displayName,
                                style: const TextStyle(color: Colors.white, fontSize: 8),
                                textAlign: TextAlign.center,
                                maxLines: 2,
                              ),
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  void _editMacroAction(int index) {
    showDialog(
      context: context,
      barrierColor: Colors.black54,
      builder: (context) => MacroActionDialog(
        existingAction: _macro!.actions[index],
        onAdd: (action) {
          setState(() => _macro!.actions[index] = action);
          Navigator.pop(context);
        },
      ),
    );
  }

  Widget _buildActionSelector() {
    final availableActions = _getAvailableActions();
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('–î–µ–π—Å—Ç–≤–∏—è:', style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        Wrap(
          spacing: 4,
          runSpacing: 4,
          children: availableActions.map((action) {
            final selected = _actions.contains(action);
            return Tooltip(
              message: _getActionName(action),
              child: FilterChip(
                label: Icon(_getActionIcon(action), size: 20),
                selected: selected,
                onSelected: (v) => setState(() {
                  if (v) _actions.add(action); else _actions.remove(action);
                }),
                backgroundColor: const Color(0xFF1E1E1E),
                selectedColor: Colors.blue,
                checkmarkColor: Colors.white,
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  String _getActionName(KeyAction action) {
    switch (action) {
      case KeyAction.copyToClipboard: return '–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä';
      case KeyAction.pasteToForeground: return '–í—Å—Ç–∞–≤–∏—Ç—å –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ';
      case KeyAction.open: return '–û—Ç–∫—Ä—ã—Ç—å';
      case KeyAction.openInExplorer: return '–û—Ç–∫—Ä—ã—Ç—å –≤ –ø—Ä–æ–≤–æ–¥–Ω–∏–∫–µ';
      case KeyAction.run: return '–ó–∞–ø—É—Å—Ç–∏—Ç—å';
    }
  }

  IconData _getActionIcon(KeyAction action) {
    switch (action) {
      case KeyAction.copyToClipboard: return Icons.content_copy;
      case KeyAction.pasteToForeground: return Icons.content_paste;
      case KeyAction.open: return Icons.open_in_new;
      case KeyAction.openInExplorer: return Icons.folder_open;
      case KeyAction.run: return Icons.play_arrow;
    }
  }

  List<KeyAction> _getAvailableActions() {
    switch (_type) {
      case KeyContentType.image: return [KeyAction.copyToClipboard, KeyAction.pasteToForeground, KeyAction.open];
      case KeyContentType.text: return [KeyAction.copyToClipboard, KeyAction.pasteToForeground];
      case KeyContentType.url: return [KeyAction.copyToClipboard, KeyAction.pasteToForeground, KeyAction.open];
      case KeyContentType.windowsShortcut: return [KeyAction.open, KeyAction.openInExplorer, KeyAction.run];
      case KeyContentType.macros: return [KeyAction.run];
    }
  }

  Widget _buildButtons() {
    return Align(
      alignment: Alignment.bottomRight,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (widget.onDelete != null)
            Tooltip(
              message: '–£–¥–∞–ª–∏—Ç—å',
              child: Container(
                width: 30,
                height: 30,
                decoration: BoxDecoration(
                  color: Colors.red,
                  borderRadius: BorderRadius.circular(15),
                ),
                child: IconButton(
                  onPressed: widget.onDelete,
                  icon: const Icon(Icons.delete, size: 16),
                  color: Colors.white,
                  padding: EdgeInsets.zero,
                ),
              ),
            ),
          const SizedBox(width: 8),
          Tooltip(
            message: '–û—Ç–º–µ–Ω–∞',
            child: Container(
              width: 30,
              height: 30,
              decoration: BoxDecoration(
                color: Colors.grey.withOpacity(0.7),
                borderRadius: BorderRadius.circular(15),
              ),
              child: IconButton(
                onPressed: () => Navigator.pop(context),
                icon: const Icon(Icons.close, size: 16),
                color: Colors.white,
                padding: EdgeInsets.zero,
              ),
            ),
          ),
          const SizedBox(width: 8),
          Tooltip(
            message: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å',
            child: Container(
              width: 30,
              height: 30,
              decoration: BoxDecoration(
                color: Colors.green,
                borderRadius: BorderRadius.circular(15),
              ),
              child: IconButton(
                onPressed: _save,
                icon: const Icon(Icons.save, size: 16),
                color: Colors.white,
                padding: EdgeInsets.zero,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _pickImage() async {
    final result = await FilePicker.platform.pickFiles(type: FileType.image, allowMultiple: false);
    if (result != null && result.files.single.path != null) {
      setState(() {
        _imagePath = result.files.single.path!;
        if (_nameCtrl.text.isEmpty) _nameCtrl.text = p.basenameWithoutExtension(result.files.single.name);
      });
    }
  }

  Future<void> _pickFile() async {
    final result = await FilePicker.platform.pickFiles(allowMultiple: false);
    if (result != null && result.files.single.path != null) {
      setState(() {
        _filePath = result.files.single.path!;
        if (_nameCtrl.text.isEmpty) _nameCtrl.text = p.basename(result.files.single.name);
      });
    }
  }

  void _addMacroAction() {
    showDialog(
      context: context,
      barrierColor: Colors.black54,
      builder: (context) => MacroActionDialog(
        onAdd: (action) => setState(() {
          _macro ??= Macro(actions: [], loopAmount: 1);
          _macro!.actions.add(action);
        }),
      ),
    );
  }

  void _save() {
    final bind = KeyBind(
      key: widget.keyId,
      name: _nameCtrl.text.isEmpty ? 'Key ${widget.keyId}' : _nameCtrl.text,
      hint: _hintCtrl.text,
      description: _descCtrl.text,
      type: _type,
      imagePath: _imagePath,
      filePath: _filePath,
      textContent: _textContent,
      url: _url,
      macro: _macro,
      combination: '$_modifier+${widget.keyId}',
      actions: _actions.isEmpty ? [KeyAction.copyToClipboard] : _actions,
      icon: _selectedIcon,
    );
    widget.onSave(bind);
  }

  @override
  void dispose() {
    _nameCtrl.dispose();
    _hintCtrl.dispose();
    _descCtrl.dispose();
    super.dispose();
  }
}

// ==================== –î–ò–ê–õ–û–ì –†–ï–î–ê–ö–¢–û–†–ê –ú–ê–ö–†–û–°–û–í ====================

class MacroActionDialog extends StatefulWidget {
  final Function(MacroAction) onAdd;
  final MacroAction? existingAction;
  const MacroActionDialog({Key? key, required this.onAdd, this.existingAction}) : super(key: key);

  @override
  State<MacroActionDialog> createState() => _MacroActionDialogState();
}

class _MacroActionDialogState extends State<MacroActionDialog> {
  MacroActionType _type = MacroActionType.delay;
  final _valueCtrl = TextEditingController();
  int _delay = 1000;
// –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ –∫–ª–∞—Å—Å _MacroActionDialogState
late StreamSubscription<RawKeyEvent> _keyboardSubscription;
final NativeMouseService _mouseService = NativeMouseService();
Timer? _mousePositionTimer;
({int x, int y}) _currentMousePosition = (x: 0, y: 0);
bool _isRecordingHotkey = false;
bool _isRecordingClick = false;
List<String> _currentHotkey = [];
Timer? _hotkeyTimer;

  @override
  void initState() {
    super.initState();
    if (widget.existingAction != null) {
      _type = widget.existingAction!.type;
      _valueCtrl.text = widget.existingAction!.value;
      _delay = widget.existingAction!.delay ?? 1000;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      backgroundColor: Colors.black.withOpacity(0.8),
      child: Container(
        width: 400,
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              widget.existingAction != null ? '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ' : '–î–æ–±–∞–≤–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –º–∞–∫—Ä–æ—Å–∞', 
              style: const TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold)
            ),
            const SizedBox(height: 20),
            DropdownButtonFormField<MacroActionType>(
              value: _type,
              items: MacroActionType.values.map((t) {
                return DropdownMenuItem(value: t, child: Text(_getTypeName(t), style: const TextStyle(color: Colors.white)));
              }).toList(),
              onChanged: (v) => setState(() => _type = v!),
              decoration: const InputDecoration(
                labelText: '–¢–∏–ø –¥–µ–π—Å—Ç–≤–∏—è',
                labelStyle: TextStyle(color: Colors.white70),
                filled: true,
                fillColor: Color(0xFF1E1E1E),
              ),
              dropdownColor: const Color(0xFF1E1E1E),
            ),
            const SizedBox(height: 16),
            _buildTypeSpecificWidget(),
            const SizedBox(height: 24),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    child: const Text('–û—Ç–º–µ–Ω–∞'),
                    style: OutlinedButton.styleFrom(foregroundColor: Colors.white70),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _add,
                    child: Text(widget.existingAction != null ? '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å' : '–î–æ–±–∞–≤–∏—Ç—å'),
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.green, foregroundColor: Colors.white),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  String _getTypeName(MacroActionType type) {
    switch (type) {
      case MacroActionType.hotkey: return '–ì–æ—Ä—è—á–∞—è –∫–ª–∞–≤–∏—à–∞';
      case MacroActionType.click: return '–ö–ª–∏–∫ –º—ã—à–∏';
      case MacroActionType.delay: return '–ó–∞–¥–µ—Ä–∂–∫–∞';
      case MacroActionType.runPath: return '–ó–∞–ø—É—Å–∫ –ø—Ä–æ–≥—Ä–∞–º–º—ã/URL';
    }
  }


Widget _buildTypeSpecificWidget() {
  switch (_type) {
    case MacroActionType.hotkey:
      return Column(
        children: [
          TextField(
            controller: _valueCtrl,
            readOnly: true,
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              labelText: _isRecordingHotkey ? '–ó–∞–ø–∏—Å—ã–≤–∞–µ–º...' : '–ù–∞–∂–º–∏—Ç–µ —Å–æ—á–µ—Ç–∞–Ω–∏–µ –∫–ª–∞–≤–∏—à',
              labelStyle: TextStyle(
                color: _isRecordingHotkey ? Colors.blue : Colors.white70,
              ),
              filled: true,
              fillColor: const Color(0xFF1E1E1E),
              border: const OutlineInputBorder(),
            ),
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: _isRecordingHotkey ? _stopRecordingHotkey : _startRecordingHotkey,
                  icon: Icon(_isRecordingHotkey ? Icons.stop : Icons.keyboard),
                  label: Text(_isRecordingHotkey ? '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å' : '–ó–∞–ø–∏—Å–∞—Ç—å —Ö–æ—Ç–∫–µ–π'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: _isRecordingHotkey ? Colors.red : Colors.blue,
                  ),
                ),
              ),
              const SizedBox(width: 8),
              IconButton(
                onPressed: _clearHotkey,
                icon: const Icon(Icons.clear),
                tooltip: '–û—á–∏—Å—Ç–∏—Ç—å',
              ),
            ],
          ),
          if (_currentHotkey.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 8),
              child: Text(
                '–¢–µ–∫—É—â–∏–π —Ö–æ—Ç–∫–µ–π: ${_currentHotkey.join(' + ')}',
                style: const TextStyle(color: Colors.green),
              ),
            ),
        ],
      );
case MacroActionType.click:
  return Column(
    children: [
      Text(
        _isRecordingClick 
          ? '–¢–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è: (${_currentMousePosition.x}, ${_currentMousePosition.y}) - –ù–∞–∂–º–∏—Ç–µ SPACE –¥–ª—è –∑–∞–ø–∏—Å–∏'
          : '–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–ª–∏–∫–∞ –±—É–¥—É—Ç –∑–∞–ø–∏—Å–∞–Ω—ã',
        style: TextStyle(
          color: _isRecordingClick ? Colors.blue : Colors.white70,
        ),
        textAlign: TextAlign.center,
      ),
          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: _isRecordingClick ? _stopRecordingClick : _startRecordingClick,
                  icon: Icon(_isRecordingClick ? Icons.stop : Icons.mouse),
                  label: Text(_isRecordingClick ? '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å' : '–ó–∞–ø–∏—Å–∞—Ç—å –∫–ª–∏–∫'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: _isRecordingClick ? Colors.red : Colors.blue,
                  ),
                ),
              ),
              const SizedBox(width: 8),
              IconButton(
                onPressed: _clearClick,
                icon: const Icon(Icons.clear),
                tooltip: '–û—á–∏—Å—Ç–∏—Ç—å',
              ),
            ],
          ),
          if (_valueCtrl.text.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 8),
              child: Text(_valueCtrl.text, style: const TextStyle(color: Colors.green)),
            ),
        ],
      );
    case MacroActionType.delay:
      return Column(
        children: [
          Text('–ó–∞–¥–µ—Ä–∂–∫–∞: ${_delay}ms', style: const TextStyle(color: Colors.white, fontSize: 16)),
          Slider(
            value: _delay.toDouble(),
            min: 0,
            max: 5000,
            divisions: 50,
            label: '${_delay}ms',
            onChanged: (v) => setState(() => _delay = v.round()),
            activeColor: Colors.blue,
          ),
        ],
      );
    case MacroActionType.runPath:
      return Column(
        children: [
          TextField(
            controller: _valueCtrl,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: '–ü—É—Ç—å –∏–ª–∏ URL',
              labelStyle: TextStyle(color: Colors.white70),
              filled: true,
              fillColor: Color(0xFF1E1E1E),
              border: OutlineInputBorder(),
              hintText: 'C:\\Program Files\\...\\app.exe',
              hintStyle: TextStyle(color: Colors.white30),
            ),
          ),
          const SizedBox(height: 8),
          ElevatedButton.icon(
            onPressed: _pickExecutable,
            icon: const Icon(Icons.folder_open),
            label: const Text('–í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª'),
          ),
        ],
      );
  }
}

// –ú–µ—Ç–æ–¥—ã –¥–ª—è –∑–∞–ø–∏—Å–∏ —Ö–æ—Ç–∫–µ–µ–≤
void _startRecordingHotkey() {
  setState(() {
    _isRecordingHotkey = true;
    _currentHotkey.clear();
    _valueCtrl.clear();
  });

  // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
  RawKeyboard.instance.addListener(_handleKeyEvent);
  
  // –¢–∞–π–º–µ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∑–∞–ø–∏—Å–∏ —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
  _hotkeyTimer = Timer(const Duration(seconds: 10), _stopRecordingHotkey);
}

void _stopRecordingHotkey() {
  _hotkeyTimer?.cancel();
  RawKeyboard.instance.removeListener(_handleKeyEvent);
  
  if (_currentHotkey.isNotEmpty) {
    _valueCtrl.text = _currentHotkey.join('+');
  }
  
  setState(() {
    _isRecordingHotkey = false;
  });
}

void _clearHotkey() {
  setState(() {
    _currentHotkey.clear();
    _valueCtrl.clear();
  });
}

void _handleKeyEvent(RawKeyEvent event) {
  if (event is RawKeyDownEvent && _isRecordingHotkey) {
    final keyLabel = event.logicalKey.keyLabel;
    
    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∫–ª–∞–≤–∏—à–∏
    if (_shouldIgnoreKey(keyLabel)) return;
    
    final keyName = _getKeyName(event.logicalKey);
    
    if (!_currentHotkey.contains(keyName)) {
      setState(() {
        _currentHotkey.add(keyName);
      });
    }
  }
}

bool _shouldIgnoreKey(String keyLabel) {
  const ignoredKeys = ['Caps Lock', 'Num Lock', 'Scroll Lock', 'Shift', 'Control', 'Alt', 'Meta'];
  return ignoredKeys.contains(keyLabel);
}

String _getKeyName(LogicalKeyboardKey key) {
  final keyLabel = key.keyLabel;
  
  // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–ª—É—á–∞–∏ –¥–ª—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤
  if (key == LogicalKeyboardKey.controlLeft || key == LogicalKeyboardKey.controlRight) {
    return 'Ctrl';
  } else if (key == LogicalKeyboardKey.altLeft || key == LogicalKeyboardKey.altRight) {
    return 'Alt';
  } else if (key == LogicalKeyboardKey.shiftLeft || key == LogicalKeyboardKey.shiftRight) {
    return 'Shift';
  } else if (key == LogicalKeyboardKey.metaLeft || key == LogicalKeyboardKey.metaRight) {
    return 'Win';
  }
  
  // –î–ª—è –±—É–∫–≤–µ–Ω–Ω—ã—Ö –∫–ª–∞–≤–∏—à –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–ª–∞–≤–Ω—ã–µ –±—É–∫–≤—ã
  if (keyLabel.length == 1 && keyLabel.toLowerCase() != keyLabel.toUpperCase()) {
    return keyLabel.toUpperCase();
  }
  
  return keyLabel;
}

void _startRecordingClick() {
  setState(() {
    _isRecordingClick = true;
    _valueCtrl.clear();
  });

  _mouseService.startMouseTracking();
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º—ã—à–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
  _mousePositionTimer = Timer.periodic(const Duration(milliseconds: 100), (timer) {
    final position = _mouseService.getCursorPosition();
    setState(() {
      _currentMousePosition = position;
    });
  });

  // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –∑–∞–ø–∏—Å–∏ –ø–æ SPACE
  RawKeyboard.instance.addListener(_handleHotkeyRecording);

  ScaffoldMessenger.of(context).showSnackBar(
    const SnackBar(
      content: Text('–ù–∞–≤–µ–¥–∏—Ç–µ –∫—É—Ä—Å–æ—Ä –∏ –Ω–∞–∂–º–∏—Ç–µ SPACE –¥–ª—è –∑–∞–ø–∏—Å–∏ –ø–æ–∑–∏—Ü–∏–∏'),
      duration: Duration(seconds: 10),
    ),
  );
}


void _recordMousePosition() {
  setState(() {
    _valueCtrl.text = '(${_currentMousePosition.x}, ${_currentMousePosition.y})';
  });
  
  _stopRecordingClick();
  
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(content: Text('–ü–æ–∑–∏—Ü–∏—è –∑–∞–ø–∏—Å–∞–Ω–∞: (${_currentMousePosition.x}, ${_currentMousePosition.y})')),
  );
}


void _stopRecordingClick() {
  _mousePositionTimer?.cancel();
  _mouseService.stopMouseTracking();
  RawKeyboard.instance.removeListener(_handleHotkeyRecording);
  setState(() {
    _isRecordingClick = false;
  });
}
void _handleHotkeyRecording(RawKeyEvent event) {
  if (event is RawKeyDownEvent && _isRecordingClick) {
    if (event.logicalKey == LogicalKeyboardKey.space) {
      _recordMousePosition();
    }
  }
}

void _clearClick() {
  setState(() {
    _valueCtrl.clear();
  });
}



// –ú–µ—Ç–æ–¥ –¥–ª—è –≤—ã–±–æ—Ä–∞ –∏—Å–ø–æ–ª–Ω—è–µ–º–æ–≥–æ —Ñ–∞–π–ª–∞
Future<void> _pickExecutable() async {
  final result = await FilePicker.platform.pickFiles(
    type: FileType.any,
    allowMultiple: false,
  );
  
  if (result != null && result.files.single.path != null) {
    setState(() {
      _valueCtrl.text = result.files.single.path!;
    });
  }
}

// –ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç –ø–æ–¥–ø–∏—Å–æ–∫ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –¥–∏–∞–ª–æ–≥–∞
@override
void dispose() {
  _keyboardSubscription.cancel();

  _hotkeyTimer?.cancel();
  _valueCtrl.dispose();
  super.dispose();
}

// –û–±–Ω–æ–≤–∏—Ç–µ –º–µ—Ç–æ–¥ _add –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø–∏—Å–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
void _add() {
  MacroAction action;
  switch (_type) {
    case MacroActionType.hotkey:
      final hotkey = _currentHotkey.isNotEmpty ? _currentHotkey.join('+') : _valueCtrl.text;
      if (hotkey.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('–í–≤–µ–¥–∏—Ç–µ —Ö–æ—Ç–∫–µ–π')));
        return;
      }
      action = MacroAction(type: _type, value: hotkey);
      break;
    case MacroActionType.click:
      final clickText = _valueCtrl.text;
      if (clickText.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('–ó–∞–ø–∏—à–∏—Ç–µ –∫–ª–∏–∫')));
        return;
      }
      // –ü–∞—Ä—Å–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ —Ç–µ–∫—Å—Ç–∞
      final regex = RegExp(r'\((\d+),\s*(\d+)\)');
      final match = regex.firstMatch(clickText);
      if (match != null) {
        final x = int.parse(match.group(1)!);
        final y = int.parse(match.group(2)!);
        action = MacroAction(type: _type, value: 'click', x: x, y: y, x1: x, y1: y);
      } else {
        action = MacroAction(type: _type, value: 'click', x: 100, y: 100, x1: 100, y1: 100);
      }
      break;
    case MacroActionType.delay:
      action = MacroAction(type: _type, value: '${_delay}ms', delay: _delay);
      break;
    case MacroActionType.runPath:
      if (_valueCtrl.text.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('–í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∏–ª–∏ URL')));
        return;
      }
      action = MacroAction(type: _type, value: _valueCtrl.text);
      break;
  }
  widget.onAdd(action);
  Navigator.pop(context);
}



  
}







































class MusicBrainzService {
  static const String _baseUrl = 'https://musicbrainz.org/ws/2/';
  static const Map<String, String> _headers = {
    'User-Agent': 'MediaMetadataApp/1.0 ( your-email@example.com )',
    'Accept': 'application/json'
  };

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –∂–∞–Ω—Ä–æ–≤ —Ç—Ä–µ–∫–∞ –ø–æ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—é –∏ –Ω–∞–∑–≤–∞–Ω–∏—é
  Future<List<String>> getTrackGenres(String artist, String title) async {
    try {
      print('MusicBrainz: –ü–æ–∏—Å–∫ –∂–∞–Ω—Ä–æ–≤ –¥–ª—è "$artist" - "$title"');

      // 1. –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –∑–∞–ø–∏—Å—å (recording)
      final recordingId = await _findRecordingId(artist, title);
      if (recordingId == null) {
        print('MusicBrainz: –ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞');
        return [];
      }

      // 2. –ü–æ–ª—É—á–∞–µ–º —Ç–µ–≥–∏/–∂–∞–Ω—Ä—ã –¥–ª—è –∑–∞–ø–∏—Å–∏
      return await _getRecordingTags(recordingId);
    } catch (e) {
      print('MusicBrainz –û—à–∏–±–∫–∞: $e');
      return [];
    }
  }

  // –ü–æ–∏—Å–∫ ID –∑–∞–ø–∏—Å–∏ –ø–æ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—é –∏ –Ω–∞–∑–≤–∞–Ω–∏—é
  Future<String?> _findRecordingId(String artist, String title) async {
    final query = 'artist:"${_escapeQuery(artist)}" AND recording:"${_escapeQuery(title)}"';
    final url = '${_baseUrl}recording?query=${Uri.encodeQueryComponent(query)}&fmt=json&limit=5';

    try {
      final response = await http.get(Uri.parse(url), headers: _headers);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final recordings = data['recordings'] as List?;
        
        if (recordings != null && recordings.isNotEmpty) {
          // –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é –Ω–∞–∏–±–æ–ª–µ–µ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—É—é –∑–∞–ø–∏—Å—å
          final recording = recordings.first;
          return recording['id'] as String;
        }
      } else {
        print('MusicBrainz: HTTP ${response.statusCode}');
      }
    } catch (e) {
      print('MusicBrainz –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∑–∞–ø–∏—Å–∏: $e');
    }
    
    return null;
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–≥–æ–≤/–∂–∞–Ω—Ä–æ–≤ –¥–ª—è –∑–∞–ø–∏—Å–∏
  Future<List<String>> _getRecordingTags(String recordingId) async {
    final url = '${_baseUrl}recording/$recordingId?fmt=json&inc=tags';

    try {
      final response = await http.get(Uri.parse(url), headers: _headers);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final tags = data['tags'] as List?;
        
        if (tags != null && tags.isNotEmpty) {
          final genreTags = tags.map<String>((tag) {
            return tag['name'] as String;
          }).toList();
          
          print('MusicBrainz: –ù–∞–π–¥–µ–Ω—ã —Ç–µ–≥–∏: $genreTags');
          return genreTags;
        }
      }
    } catch (e) {
      print('MusicBrainz –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–≥–æ–≤: $e');
    }
    
    return [];
  }

  // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥: –ø–æ–∏—Å–∫ –∂–∞–Ω—Ä–æ–≤ —á–µ—Ä–µ–∑ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è
  Future<List<String>> getArtistGenres(String artist) async {
    try {
      final query = 'artist:"${_escapeQuery(artist)}"';
      final url = '${_baseUrl}artist?query=${Uri.encodeQueryComponent(query)}&fmt=json&limit=1';

      final response = await http.get(Uri.parse(url), headers: _headers);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final artists = data['artists'] as List?;
        
        if (artists != null && artists.isNotEmpty) {
          final artistData = artists.first;
          final tags = artistData['tags'] as List?;
          
          if (tags != null && tags.isNotEmpty) {
            return tags.map<String>((tag) => tag['name'] as String).toList();
          }
        }
      }
    } catch (e) {
      print('MusicBrainz –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∞—Ä—Ç–∏—Å—Ç–∞: $e');
    }
    
    return [];
  }

  // –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –≤ –∑–∞–ø—Ä–æ—Å–µ
  String _escapeQuery(String text) {
    return text.replaceAll('"', '\\"').replaceAll("'", "\\'");
  }

  // –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥: —Å–Ω–∞—á–∞–ª–∞ —Ç—Ä–µ–∫, –ø–æ—Ç–æ–º –∞—Ä—Ç–∏—Å—Ç
  Future<String> getCombinedGenre(String artist, String title) async {
    // –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –∂–∞–Ω—Ä—ã —Ç—Ä–µ–∫–∞
    final trackGenres = await getTrackGenres(artist, title);
    if (trackGenres.isNotEmpty) {
      return trackGenres.first;
    }

    // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –ø—Ä–æ–±—É–µ–º –ø–æ –∞—Ä—Ç–∏—Å—Ç—É
    final artistGenres = await getArtistGenres(artist);
    if (artistGenres.isNotEmpty) {
      return artistGenres.first;
    }

    return 'unknown';
  }
}
































































Future<String> _getPageTitle(String url) async {
  try {
    // –ü—Ä–æ—Å—Ç–æ–π —Å–ø–æ—Å–æ–± - —Å–æ–∑–¥–∞–µ–º HttpClient –∏ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º SSL –æ—à–∏–±–∫–∏
    HttpClient client = HttpClient();
    client.badCertificateCallback = (X509Certificate cert, String host, int port) => true;
    
    HttpClientRequest request = await client.getUrl(Uri.parse(url));
    HttpClientResponse response = await request.close();
    
    if (response.statusCode == HttpStatus.ok) {
      String html = await response.transform(utf8.decoder).join();
      
      debugPrint('Fetching title from: $url');
      debugPrint('HTML length: ${html.length}');
      
      // –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ —Ä–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ title
      final titleRegex = RegExp(
        r'<title\s*>([\s\S]*?)</title>',
        caseSensitive: false,
      );
      
      final match = titleRegex.firstMatch(html);
      
      if (match != null) {
        String title = match.group(1)!;
        debugPrint('Raw title found: "$title"');
        
        // –û—á–∏—Å—Ç–∫–∞ title
        title = title
            .replaceAll(RegExp(r'\s+'), ' ')
            .trim();
            
        AppLogger.writeLog('Cleaned title: "$title"');
        return title.isNotEmpty ? title : "none";
      } else {
        AppLogger.writeLog('Title tag not found');
        
        // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–æ–∏—Å–∫–∞ title
        final alternativeRegexes = [
          RegExp(r'<meta\s+property="og:title"\s+content="([^"]*)"', caseSensitive: false),
          RegExp(r"<meta\s+property='og:title'\s+content='([^']*)'", caseSensitive: false),
          RegExp(r'<meta\s+name="twitter:title"\s+content="([^"]*)"', caseSensitive: false),
        ];
        
        for (final regex in alternativeRegexes) {
          final altMatch = regex.firstMatch(html);
          if (altMatch != null) {
            String altTitle = altMatch.group(1)!;
            AppLogger.writeLog('Found alternative title: "$altTitle"');

            return altTitle.trim();
          }
        }
      }
    } else {
      AppLogger.writeLog('HTTP error: ${response.statusCode}');
    }
    
    client.close();
  } catch (e) {
    AppLogger.writeLog('Error getting page title: $e');
  }
  return 'none';
}

void _writeToDebugLog1(String message) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final debugFile = File('${directory.path}/chat_debug1.log');
      await debugFile.writeAsString('${DateTime.now()}: $message\n', mode: FileMode.append);
      print('DEBUG: $message'); // –¢–∞–∫–∂–µ –≤—ã–≤–æ–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª—å
    } catch (e) {
      print('Error writing to debug log: $e');
    }
  }
class AppLogger {
  static Future<void> writeLog(String message) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final logFile = File('${directory.path}/music_listener.log');
      final timestamp = DateTime.now().toString();
      final logMessage = '[$timestamp] $message\n';
      await logFile.writeAsString(logMessage, mode: FileMode.append);
      
      print('QUANTUM LOG: $message');
    } catch (e) {
      print('ERROR WRITING LOG: $e');
    }
  }
}
class ScreenAnalysis {
  static const MethodChannel _channel = MethodChannel('screenshot_channel');
  
  // Callback –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞
  static Function(String)? onAnalysisResult;
  
  static void initialize() {
    _channel.setMethodCallHandler(_handleMethodCall);
  }
  
  static Future<dynamic> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'onScreenAnalysisResult':
        final String result = call.arguments;
        if (onAnalysisResult != null) {
          onAnalysisResult!(result);
        }
        break;
      default:
        throw PlatformException(
          code: 'Unimplemented',
          message: 'Method ${call.method} not implemented',
        );
    }
  }
  
  static Future<bool> startAnalysis() async {
    try {
      final bool result = await _channel.invokeMethod('startScreenAnalysis');
      return result;
    } catch (e) {
      print('Failed to start analysis: $e');
      return false;
    }
  }
  
  static Future<bool> stopAnalysis() async {
    try {
      final bool result = await _channel.invokeMethod('stopScreenAnalysis');
      return result;
    } catch (e) {
      print('Failed to stop analysis: $e');
      return false;
    }
  }
}


class EssentialsApp extends StatelessWidget {
  const EssentialsApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        backgroundColor: Colors.transparent,
        body: EssentialsContent(),
      ),
    );
  }
}

class EssentialsContent extends StatefulWidget {
  const EssentialsContent({Key? key}) : super(key: key);

  @override
  _EssentialsContentState createState() => _EssentialsContentState();
}

class _EssentialsContentState extends State<EssentialsContent> {
   List<EssentialItem> _essentials = [];
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isLoading = true;
  final TextEditingController _searchController = TextEditingController();
  List<EssentialItem> _filteredEssentials = [];
  String? _backgroundImagePath;
  final Map<String, int> _hashtagFrequency = {};
  final Map<String, int> _emojiFrequency = {};
  final GlobalKey _essentialsListKey = GlobalKey();
final _searchFocusNode = FocusNode();
bool _isDragging = false;
int _draggedIndex = -1;
double _dragOffset = 0.0;
final ScrollController _scrollController = ScrollController();

final String _orderFileName = 'essentials_order.json';
double _lastDragPosition = 0.0;
double _dragStartY = 0.0;
double _dragStartLocalY = 0.0; // –ü–æ–∑–∏—Ü–∏—è –≤–Ω—É—Ç—Ä–∏ –≤–∏–¥–∂–µ—Ç–∞
Map<int, Rect> _widgetRects = {}; // –ü–æ–∑–∏—Ü–∏–∏ –∏ —Ä–∞–∑–º–µ—Ä—ã –≤–∏–¥–∂–µ—Ç–æ–≤
final Map<String, GlobalKey> _essentialKeys = {};

Future<void> _loadOrder() async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final orderFile = File('${directory.path}/essentials/$_orderFileName');
    
    if (orderFile.existsSync()) {
      final content = await orderFile.readAsString();
      final List<dynamic> orderList = json.decode(content);
      
      // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º –ø–æ ID
      final Map<String, EssentialItem> itemsMap = {
        for (var item in _essentials) item.id: item
      };
      
      // –°–æ—Ä—Ç–∏—Ä—É–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —Å–æ–≥–ª–∞—Å–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É
      final List<EssentialItem> orderedItems = [];
      for (final id in orderList) {
        if (itemsMap.containsKey(id)) {
          orderedItems.add(itemsMap[id]!);
        }
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ –ø–æ—Ä—è–¥–∫–µ (–Ω–æ–≤—ã–µ)
      for (final item in _essentials) {
        if (!orderList.contains(item.id)) {
          orderedItems.add(item);
        }
      }
      
      setState(() {
        _essentials = orderedItems;
      });
      _filterEssentials();
 
    }
  } catch (e) {
    print('Error loading order: $e');
  }
}
Future<void> _saveOrder() async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final essentialsDir = Directory('${directory.path}/essentials');
    
    if (!essentialsDir.existsSync()) {
      essentialsDir.createSync(recursive: true);
    }
    
    final orderFile = File('${essentialsDir.path}/$_orderFileName');
    final orderList = _essentials.map((item) => item.id).toList();
    
    print('Saving order: $orderList');
    
    await orderFile.writeAsString(json.encode(orderList));
  } catch (e) {
    print('Error saving order: $e');
  }
}

  @override
  void initState() {
    super.initState();
    _loadEssentials().then((_) {
    _loadOrder(); // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Ä—è–¥–æ–∫ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
  });
    
    _startFileMonitoring();
    
    _searchController.addListener(_filterEssentials);
    _loadBackground();
  }

  void _filterEssentials() {
    final query = _searchController.text.trim().toLowerCase();
    
    if (query.isEmpty) {
      setState(() {
        _filteredEssentials = List.from(_essentials);
      });
      return;
    }

    final searchWords = query.split(' ').where((word) => word.isNotEmpty).toList();
    
    setState(() {
      _filteredEssentials = _essentials.where((item) {
        final searchText = '${item.icon ?? ''} ${item.name} ${item.comment ?? ''}'.toLowerCase();
        
        for (final word in searchWords) {
          if (!searchText.contains(word)) {
            return false;
          }
        }
        return true;
      }).toList();
    });
  }

  void _startFileMonitoring() {
    Timer.periodic(Duration(seconds: 12), (timer) async {
      if (!mounted) {
        timer.cancel();
        return;
      }
      
      await _checkForNewFiles();
    });
  }

  Future<void> _checkForNewFiles() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final essentialsDir = Directory('${directory.path}/essentials');
      
      if (!essentialsDir.existsSync()) return;
      
      final files = essentialsDir.listSync();
      final currentFilePaths = _essentials.map((e) => e.originalFilePath).whereType<String>().toSet();
      
      for (var file in files) {
        if (!currentFilePaths.contains(file.path) && !file.path.endsWith('.json')) {
          final newItem = EssentialItem.fromFile(file);
          setState(() {
            _essentials.add(newItem);
          });
          _filterEssentials();
        }
      }
    } catch (e) {
      print('Error monitoring files: $e');
    }
  }

  void _addNewEssential() {
    final newItem = EssentialItem(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: '–ù–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç',
      icon: 'üìù',
      backgroundColor: Colors.blue.value,
      textColor: Colors.white.value,
    );
    
    _showEditDialog(newItem, isNewItem: true);
    
    setState(() {
      _essentials.add(newItem);
    });
    _saveEssential(newItem);
    _saveOrder();
  }

  Future<void> _loadEssentials() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final essentialsDir = Directory('${directory.path}/essentials');
      
      if (!essentialsDir.existsSync()) {
        essentialsDir.createSync(recursive: true);
      }
      
      final files = essentialsDir.listSync();
      final List<EssentialItem> loadedItems = [];
      
      for (var file in files) {
        if (file.path.endsWith('.json')) {
          try {
            final content = await File(file.path).readAsString();
            final jsonData = json.decode(content);
            loadedItems.add(EssentialItem.fromJson(jsonData));
          } catch (e) {
            print('Error loading essential: $e');
          }
        } else {
          loadedItems.add(EssentialItem.fromFile(file));
        }
      }
      
      if (mounted) {
        setState(() {
          _essentials.addAll(loadedItems);
          _isLoading = false;
          _updateHashtagFrequency();
          _updateEmojiFrequency();
        });
      }
    } catch (e) {
      print('Error loading essentials: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  void _updateHashtagFrequency() {
    _hashtagFrequency.clear();
    for (final item in _essentials) {
      if (item.comment != null) {
        final hashtags = RegExp(r'#\w+').allMatches(item.comment!);
        for (final match in hashtags) {
          final hashtag = match.group(0)!;
          _hashtagFrequency[hashtag] = (_hashtagFrequency[hashtag] ?? 0) + 1;
        }
      }
    }
  }

  void _updateEmojiFrequency() {
    _emojiFrequency.clear();
    for (final item in _essentials) {
      _emojiFrequency[item.icon] = (_emojiFrequency[item.icon] ?? 0) + 1;
    }
  }

Future<void> _saveEssential(EssentialItem item) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final essentialsDir = Directory('${directory.path}/essentials');
    
    if (!essentialsDir.existsSync()) {
      essentialsDir.createSync(recursive: true);
    }
    
    final file = File('${essentialsDir.path}/${item.id}.json');
    await file.writeAsString(json.encode(item.toJson()));
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
    if (mounted) {
      setState(() {
        final index = _essentials.indexWhere((e) => e.id == item.id);
        if (index != -1) {
          _essentials[index] = item;
          _filterEssentials();
        }
      });
    }
    
    _updateHashtagFrequency();
    _updateEmojiFrequency();
  } catch (e) {
    print('Error saving essential: $e');
  }
}

  Future<void> _deleteEssential(EssentialItem item) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final essentialsDir = Directory('${directory.path}/essentials');
      
      final jsonFile = File('${essentialsDir.path}/${item.id}.json');
      if (jsonFile.existsSync()) {
        jsonFile.deleteSync();
      }
      
     
      
      setState(() {
        _essentials.remove(item);
      });
      
      _updateHashtagFrequency();
      _updateEmojiFrequency();
      _saveOrder();
    } catch (e) {
      print('Error deleting essential: $e');
    }
  }

  void _showEditDialog(EssentialItem item, {bool isNewItem = false}) {
    final sourceWidgetKey = GlobalKey();
    
    showDialog(
      context: context,
      builder: (context) => EssentialEditDialog(
        item: item,
        onSave: (updatedItem) {
          setState(() {
            final index = _essentials.indexOf(item);
            _essentials[index] = updatedItem;
          });
          _saveEssential(updatedItem);
        },
        onDelete: () => _showDeleteConfirmation(item),
        isNewItem: isNewItem,
        sourceWidgetKey: sourceWidgetKey,
      ),
    );
  }

  void _showDeleteConfirmation(EssentialItem item) {
    showDialog(
      context: context,
      builder: (context) => DeleteConfirmationDialog(
        item: item,
        onDelete: () => _deleteEssential(item),
      ),
    );
  }

  void _copyToClipboard(String text) {
    final textToCopy = text.contains(':') ? text.split(':').sublist(1).join(':').trim() : text;
    Clipboard.setData(ClipboardData(text: textToCopy));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ: $textToCopy'),
        backgroundColor: Colors.green,
      ),
    );
  }

  Future<void> _loadBackground() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final backgroundFile = File('${directory.path}/essentials_background.jpg');
      if (backgroundFile.existsSync()) {
        setState(() {
          _backgroundImagePath = backgroundFile.path;
        });
      }
    } catch (e) {
      print('Error loading background: $e');
    }
  }

  Future<void> _saveBackground(String imagePath) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final backgroundFile = File('${directory.path}/essentials_background.jpg');
      final originalFile = File(imagePath);
      await originalFile.copy(backgroundFile.path);
      setState(() {
        _backgroundImagePath = backgroundFile.path;
      });
    } catch (e) {
      print('Error saving background: $e');
    }
  }

  void _handleFileDrop(List<File> files) {
    if (files.isNotEmpty) {
      final file = files.first;
      final newItem = EssentialItem.fromFile(file);
      setState(() {
        _essentials.add(newItem);
      });
      _saveEssential(newItem);
    }
  }

  void _handleBackgroundDrop(List<File> files) {
    if (files.isNotEmpty) {
      _saveBackground(files.first.path);
    }
  }
void _updateMainListOrder() {
  // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º –ø–æ ID
  final Map<String, EssentialItem> itemsMap = {
    for (var item in _essentials) item.id: item
  };

  // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ
  final List<EssentialItem> newOrderedEssentials = [];

  for (final filteredItem in _filteredEssentials) {
    if (itemsMap.containsKey(filteredItem.id)) {
      newOrderedEssentials.add(itemsMap[filteredItem.id]!);
    }
  }

  // –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ
  for (final item in _essentials) {
    if (!_filteredEssentials.any((filteredItem) => filteredItem.id == item.id)) {
      newOrderedEssentials.add(item);
    }
  }

  setState(() {
    _essentials = newOrderedEssentials;
  });
}
void _reorderItems(int oldIndex, int newIndex) {
  if (oldIndex == newIndex) return;

  print('REORDER: Moving from $oldIndex to $newIndex');

  setState(() {
    final item = _filteredEssentials.removeAt(oldIndex);
    
    // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º newIndex –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    final adjustedNewIndex = newIndex > oldIndex ? newIndex - 1 : newIndex;
    _filteredEssentials.insert(adjustedNewIndex, item);

    _updateMainListOrder();
  });

  _saveOrder();
}
void _addHashtagToSearch(String hashtag) {
  final currentText = _searchController.text;
  
  // –ï—Å–ª–∏ —Ö—ç—à—Ç–µ–≥ —É–∂–µ –µ—Å—Ç—å –≤ —Ç–µ–∫—Å—Ç–µ - —É–¥–∞–ª—è–µ–º –µ–≥–æ
  if (currentText.contains(hashtag)) {
    // –£–¥–∞–ª—è–µ–º —Ö—ç—à—Ç–µ–≥ –∏–∑ —Ç–µ–∫—Å—Ç–∞
    final newText = currentText
        .replaceAll('$hashtag ', '') // –£–¥–∞–ª—è–µ–º —Å –ø—Ä–æ–±–µ–ª–æ–º –ø–æ—Å–ª–µ
        .replaceAll(' $hashtag', '') // –£–¥–∞–ª—è–µ–º —Å –ø—Ä–æ–±–µ–ª–æ–º –ø–µ—Ä–µ–¥
        .replaceAll(hashtag, '')     // –£–¥–∞–ª—è–µ–º –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤
        .trim();                     // –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
    
    _searchController.text = newText;
    _searchFocusNode.requestFocus();
    return; // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é
  }
  
  // –ï—Å–ª–∏ —Ö—ç—à—Ç–µ–≥–∞ –Ω–µ—Ç - –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ
  final newText = currentText.isEmpty ? hashtag : '$currentText $hashtag';
  _searchController.text = newText;
}

  void _addEmojiToSearch(String emoji) {
    final currentText = _searchController.text;
    if (currentText.contains(emoji)) {
    // –£–¥–∞–ª—è–µ–º —Ö—ç—à—Ç–µ–≥ –∏–∑ —Ç–µ–∫—Å—Ç–∞
    final newText = currentText
        .replaceAll('$emoji ', '') // –£–¥–∞–ª—è–µ–º —Å –ø—Ä–æ–±–µ–ª–æ–º –ø–æ—Å–ª–µ
        .replaceAll(' $emoji', '') // –£–¥–∞–ª—è–µ–º —Å –ø—Ä–æ–±–µ–ª–æ–º –ø–µ—Ä–µ–¥
        .replaceAll(emoji, '')     // –£–¥–∞–ª—è–µ–º –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤
        .trim();                     // –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
    
    _searchController.text = newText;
    return; // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é
  }
  
    final newText = currentText.isEmpty ? emoji : '$currentText $emoji';
    _searchController.text = newText;
    _searchFocusNode.requestFocus();
  }

 @override
Widget build(BuildContext context) {
  return Material(
    color: Colors.transparent,
    child: Stack(
      children: [
        // Background with pattern
        if (_backgroundImagePath != null)
          _buildBackgroundPattern(),
        
        // Main content
        Container(
          width: 400,
          height: MediaQuery.of(context).size.height,
          margin: EdgeInsets.only(right: 0),
          decoration: BoxDecoration(
            color: Color(0xFF2B2B2B).withOpacity(0.95),
            borderRadius: BorderRadius.only(
              topLeft: Radius.circular(12),
              bottomLeft: Radius.circular(12),
            ),
          ),
          child: Column(
            children: [
              // Header with DropTarget
              DropTarget(
                onDragDone: (detail) async {
                  final files = <File>[];
                  
                  try {
                    final processedPaths = <String>{};
                    
                    for (final item in detail.files) {
                      final path = item.path;
                      
                      if (path != null && path.isNotEmpty && !processedPaths.contains(path)) {
                        processedPaths.add(path);
                        
                        final file = File(path);
                        if (await file.exists()) {
                          files.add(file);
                          break; // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–π —Ñ–∞–π–ª
                        }
                      }
                    }
                  } catch (e) {
                    print('Error in header drop: $e');
                  }
                  
                  if (files.isNotEmpty) {
                    _handleBackgroundDrop(files);
                    if (mounted) {
                      setState(() {});
                    }
                    files.clear();
                  }
                },
                child: Container(
                  height: 40,
                  padding: EdgeInsets.symmetric(horizontal: 16),
                  decoration: BoxDecoration(
                    color: Color(0xFF1A1A1A).withOpacity(0.9),
                    borderRadius: BorderRadius.only(
                      topLeft: Radius.circular(12),
                    ),
                  ),
                  child: Row(
                    children: [
                      Text(
                        'Essentials',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Spacer(),
                      MouseRegion(
                        cursor: SystemMouseCursors.click,
                        child: GestureDetector(
                          onTap: () => windowManager.close(),
                          child: Icon(Icons.close, size: 20, color: Colors.white),
                        ),
                      ),
                    ],
                  ),
                ),
              ),

              // Search row
              Container(
                padding: EdgeInsets.all(12),
                color: Color(0xFF1A1A1A).withOpacity(0.7),
                child: Column(
                  children: [
                    TextField(
                      controller: _searchController,
                      focusNode: _searchFocusNode, 
                      style: TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        hintText: '–ü–æ–∏—Å–∫...',
                        hintStyle: TextStyle(color: Colors.white54),
                        prefixIcon: Icon(Icons.search, color: Colors.white54),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(20),
                          borderSide: BorderSide.none,
                        ),
                        filled: true,
                        fillColor: Color(0xFF2B2B2B).withOpacity(0.8),
                        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                      ),
                    ),
                    
                    // Hashtags suggestions
                    if ( _searchFocusNode.hasFocus && _hashtagFrequency.isNotEmpty)
                      _buildHashtagSuggestions(),
                    
                    // Emoji suggestions
                    if ( _searchFocusNode.hasFocus && _emojiFrequency.isNotEmpty)
                      _buildEmojiSuggestions(),
                  ],
                ),
              ),

              // Essentials list with DropTarget
              Expanded(
                child: DropTarget(
                  onDragDone: (detail) async {
                    final files = <File>[];
                    
                    try {
                      final processedPaths = <String>{};
                      
                      for (final item in detail.files) {
                        final path = item.path;
                        
                        if (path != null && path.isNotEmpty && !processedPaths.contains(path)) {
                          processedPaths.add(path);
                          
                          final file = File(path);
                          if (await file.exists()) {
                            files.add(file);
                            break; // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–π —Ñ–∞–π–ª
                          }
                        }
                      }
                    } catch (e) {
                      print('Error in essentials drop: $e');
                    }
                    
                    if (files.isNotEmpty) {
                      _handleFileDrop(files);
                      if (mounted) {
                        setState(() {});
                      }
                      files.clear();
                    }
                  },
                  child: _isLoading
                      ? Center(child: CircularProgressIndicator(color: Colors.white))
                      : _filteredEssentials.isEmpty
                          ? Center(
                              child: Container(
                                padding: EdgeInsets.all(16),
                                decoration: BoxDecoration(
                                  color: Color(0xFF2B2B2B).withOpacity(0.8),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: Text(
                                  _searchController.text.isEmpty ? '–ù–µ—Ç —ç–ª–µ–º–µ–Ω—Ç–æ–≤' : '–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ',
                                  style: TextStyle(color: Colors.white54),
                                ),
                              ),
                            )
                          : _buildReorderableList(),
                ),
              ),

              // Add new Essential button
              Container(
                margin: EdgeInsets.all(16),
                child: MouseRegion(
                  cursor: SystemMouseCursors.click,
                  child: GestureDetector(
                    onTap: _addNewEssential,
                    child: Container(
                      padding: EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.blue.withOpacity(0.8),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.add, color: Colors.white, size: 16),
                          SizedBox(width: 8),
                          Text(
                            '–î–æ–±–∞–≤–∏—Ç—å Essential',
                            style: TextStyle(color: Colors.white),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),

        // Drag and drop areas for background
        Positioned.fill(
          child: IgnorePointer(
            ignoring: true,
            child: Row(
              children: [
                // Left drop zone
                Expanded(
                  flex: 1,
                  child: Container(
                    color: Colors.transparent,
                  ),
                ),
                
                // Center content area (protected)
                Container(
                  width: 400,
                  color: Colors.transparent,
                ),
                
                // Right drop zone
                Expanded(
                  flex: 1,
                  child: Container(
                    color: Colors.transparent,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    ),
  );
}

  Widget _buildBackgroundPattern() {
    return Positioned.fill(
      child: Image.file(
        File(_backgroundImagePath!),
        fit: BoxFit.cover,
        alignment: Alignment.center,
        repeat: ImageRepeat.repeat,
      ),
    );
  }

  Widget _buildHashtagSuggestions() {
  final sortedHashtags = _hashtagFrequency.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value))
    ..take(10);

  return Container(
    margin: EdgeInsets.only(top: 8),
    padding: EdgeInsets.all(8),
    decoration: BoxDecoration(
      color: Color(0xFF1A1A1A).withOpacity(0.9),
      borderRadius: BorderRadius.circular(12),
    ),
    child: Wrap(
      spacing: 8, // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –æ—Ç—Å—Ç—É–ø –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
      runSpacing: 8, // –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –æ—Ç—Å—Ç—É–ø –º–µ–∂–¥—É —Å—Ç—Ä–æ–∫–∞–º–∏
      children: sortedHashtags.map((entry) {
        return Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(8),
            onTap: () => _addHashtagToSearch(entry.key),
            child: Container(
              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 12),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.white30),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                entry.key,
                style: TextStyle(
                  color: Colors.white70,
                  fontSize: 14,
                ),
              ),
            ),
          ),
        );
      }).toList(),
    ),
  );
}

Widget _buildEmojiSuggestions() {
  final sortedEmojis = _emojiFrequency.entries.toList()
    ..sort((a, b) => b.value.compareTo(a.value))
    ..take(15);

  return Container(
    height: 50,
    margin: EdgeInsets.only(top: 8),
    decoration: BoxDecoration(
      color: Color(0xFF1A1A1A).withOpacity(0.9),
      borderRadius: BorderRadius.circular(12),
    ),
    child: ListView.builder(
      scrollDirection: Axis.horizontal,
      itemCount: sortedEmojis.length,
      itemBuilder: (context, index) {
        final entry = sortedEmojis[index];
        return Container(
          width: 45,
          height: 45,
          margin: EdgeInsets.all(2.5),
          child: GestureDetector(
            onTap: () => _addEmojiToSearch(entry.key),
            child: Text(
              entry.key,
              style: TextStyle(fontSize: 20),
              textAlign: TextAlign.center,
            ),
          ),
        );
      },
    ),
  );
}
void _collectWidgetRects() {
  _widgetRects.clear();
  
  final listRenderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
  if (listRenderBox == null) return;

  final listPosition = listRenderBox.localToGlobal(Offset.zero);
  
  for (int i = 0; i < _filteredEssentials.length; i++) {
    try {
      // –ù–∞—Ö–æ–¥–∏–º —ç–ª–µ–º–µ–Ω—Ç –≤–∏–¥–∂–µ—Ç–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É
      final widgetElement = _findWidgetByIndex(i);
      if (widgetElement == null) continue;
      
      final widgetRenderBox = widgetElement.findRenderObject() as RenderBox?;
      if (widgetRenderBox != null) {
        final widgetPosition = widgetRenderBox.localToGlobal(Offset.zero);
        final relativeY = widgetPosition.dy - listPosition.dy + _scrollController.offset;
        
        _widgetRects[i] = Rect.fromLTWH(
          0, 
          relativeY, 
          widgetRenderBox.size.width, 
          widgetRenderBox.size.height
        );
        
        print('Widget $i: Y=$relativeY, height=${widgetRenderBox.size.height}');
      }
    } catch (e) {
      print('Error collecting rect for widget $i: $e');
    }
  }
}
void _handleDragUpdate(DragUpdateDetails details, int draggedIndex) {
  if (!_isDragging) return;

  final renderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
  if (renderBox == null) return;

  final listPosition = renderBox.localToGlobal(Offset.zero);
  final mouseY = details.globalPosition.dy;

  // –í—ã—á–∏—Å–ª—è–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –≤–Ω—É—Ç—Ä–∏ —Å–ø–∏—Å–∫–∞
  final relativeY = mouseY - listPosition.dy;
  _lastDragPosition = relativeY;

  // –°–æ–±–∏—Ä–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –≤—Å–µ—Ö –≤–∏–¥–∏–º—ã—Ö –≤–∏–¥–∂–µ—Ç–æ–≤
  // _collectWidgetRects();

  // –ê–≤—Ç–æ–ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –ø—Ä–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏ –∫ –≥—Ä–∞–Ω–∏—Ü–∞–º
  const scrollThreshold = 50.0;
  const scrollSpeed = 10.0;

  if (relativeY < scrollThreshold && _scrollController.offset > 0) {
    _scrollController.jumpTo(_scrollController.offset - scrollSpeed);
  } else if (relativeY > renderBox.size.height - scrollThreshold && 
             _scrollController.offset < _scrollController.position.maxScrollExtent) {
    _scrollController.jumpTo(_scrollController.offset + scrollSpeed);
  }
}


  void _handleDragStart(int index) {
    setState(() {
      _isDragging = true;
      _dragOffset = 0.0;
    });
  }



// –û–±–Ω–æ–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞
Widget _buildReorderableList() {
  return Container(
    key: _essentialsListKey,
    child: ListView.builder(
      controller: _scrollController,
      padding: EdgeInsets.all(5), // –£–º–µ–Ω—å—à–∏–ª–∏ padding
      itemCount: _filteredEssentials.length,
      itemBuilder: (context, index) {
        final item = _filteredEssentials[index];
        return _buildDraggableEssentialItem(
          item: item,
          index: index,
        );
      },
    ),
  );
}
void _handleDragUpdateWithCustomLogic(DragUpdateDetails details, int draggedIndex) {
  final renderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
  if (renderBox == null) return;

  final listPosition = renderBox.localToGlobal(Offset.zero);
  final mouseY = details.globalPosition.dy - listPosition.dy;

  // –ê–≤—Ç–æ–ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –ø—Ä–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏ –∫ –≥—Ä–∞–Ω–∏—Ü–∞–º
  const scrollThreshold = 150.0;
  const scrollSpeed = 20.0;

  if (mouseY < scrollThreshold && _scrollController.offset > 0) {
    _scrollController.jumpTo(_scrollController.offset - scrollSpeed);
  } else if (mouseY > renderBox.size.height - scrollThreshold && 
             _scrollController.offset < _scrollController.position.maxScrollExtent) {
    _scrollController.jumpTo(_scrollController.offset + scrollSpeed);
  }

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏ Y
  final itemHeight = 92.0; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
  final newIndex = (mouseY / itemHeight).clamp(0, _essentials.length - 1).floor();

  if (newIndex != draggedIndex && newIndex >= 0 && newIndex < _essentials.length) {
    _reorderItems(draggedIndex, newIndex);
  }
}
void _handleDragEnd(int draggedIndex) {
  if (_lastDragPosition < 0) return;

  // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–æ–≥–æ –≤–∏–¥–∂–µ—Ç–∞
  final double widgetHeight = _getWidgetHeight(draggedIndex);
  final double minDragDistance = widgetHeight * 0.3; // –£–º–µ–Ω—å—à–∏–ª–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ

  final double dragDistance = (_lastDragPosition - _dragStartLocalY).abs();
  
  print('Real widget height: $widgetHeight, drag distance: $dragDistance');

  if (dragDistance < minDragDistance) {
    print('Drag distance too small, returning to original position');
    setState(() {
      _isDragging = false;
      _draggedIndex = -1;
      _lastDragPosition = 0.0;
    });
    return;
  }

  // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –∏ —Ä–∞–∑–º–µ—Ä—ã –≤—Å–µ—Ö –≤–∏–¥–∂–µ—Ç–æ–≤
  final Map<int, double> widgetHeights = {};
  final Map<int, double> widgetPositions = {};
  
  double currentY = 0;
  for (int i = 0; i < _filteredEssentials.length; i++) {
    final double height = _getWidgetHeight(i);
    widgetHeights[i] = height;
    widgetPositions[i] = currentY;
    currentY += height + 8; // + margin
  }

  // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Å —É—á–µ—Ç–æ–º –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
  final double dropPosition = _lastDragPosition + _scrollController.offset;

  // –ò—â–µ–º –º–µ–∂–¥—É –∫–∞–∫–∏–º–∏ –≤–∏–¥–∂–µ—Ç–∞–º–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Ç–æ—á–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è
  int newIndex = draggedIndex;
  
  for (int i = 0; i < _filteredEssentials.length; i++) {
    final double widgetTop = widgetPositions[i]!;
    final double widgetBottom = widgetTop + widgetHeights[i]!;
    final double widgetCenter = widgetTop + (widgetHeights[i]! / 2);

    if (i == draggedIndex) continue;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø–∞–¥–∞–µ—Ç –ª–∏ —Ç–æ—á–∫–∞ –≤ –∑–æ–Ω—É –≤–∏–¥–∂–µ—Ç–∞
    if (dropPosition >= widgetTop && dropPosition <= widgetBottom) {
      // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å —Ü–µ–Ω—Ç—Ä–æ–º –≤–∏–¥–∂–µ—Ç–∞
      if (dropPosition < widgetCenter) {
        newIndex = i; // –°—Ç–∞–≤–∏–º –ü–ï–†–ï–î —ç—Ç–∏–º –≤–∏–¥–∂–µ—Ç–æ–º
      } else {
        newIndex = i + 1; // –°—Ç–∞–≤–∏–º –ü–û–°–õ–ï —ç—Ç–æ–≥–æ –≤–∏–¥–∂–µ—Ç–∞
      }
      break;
    }
  }

  // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å
  newIndex = newIndex.clamp(0, _filteredEssentials.length - 1);

  print('Moving from $draggedIndex to $newIndex based on real positions');

  // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –Ω–∞ —Ç–æ –∂–µ –º–µ—Å—Ç–æ
  if (newIndex != draggedIndex) {
    _reorderItems(draggedIndex, newIndex);
  }

  setState(() {
    _isDragging = false;
    _draggedIndex = -1;
    _lastDragPosition = 0.0;
  });
}

Map<int, Rect> _getVisibleWidgetRects() {
  final Map<int, Rect> rects = {};
  
  final listRenderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
  if (listRenderBox == null) return rects;

  final listPosition = listRenderBox.localToGlobal(Offset.zero);
  final listTop = listPosition.dy;
  final listBottom = listTop + listRenderBox.size.height;

  for (int i = 0; i < _filteredEssentials.length; i++) {
    try {
      // –°–æ–∑–¥–∞–µ–º GlobalKey –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–∏–¥–∂–µ—Ç–∞ —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –µ–≥–æ –ø–æ–∑–∏—Ü–∏—é
      final key = GlobalKey();
      
      // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤–∏–¥–∂–µ—Ç–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–π —Å–ø–æ—Å–æ–±)
      final widgetContext = _essentialsListKey.currentContext;
      if (widgetContext == null) continue;

      // –ò—â–µ–º –≤—Å–µ RenderBox –≤ —Å–ø–∏—Å–∫–µ
      final widgetFinder = _findWidgetByIndex(i);
      if (widgetFinder != null) {
        final widgetRenderBox = widgetFinder.findRenderObject() as RenderBox?;
        if (widgetRenderBox != null) {
          final widgetPosition = widgetRenderBox.localToGlobal(Offset.zero);
          final widgetTop = widgetPosition.dy;
          final widgetBottom = widgetTop + widgetRenderBox.size.height;

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∏–¥–µ–Ω –ª–∏ –≤–∏–¥–∂–µ—Ç –≤ –æ–±–ª–∞—Å—Ç–∏ —Å–ø–∏—Å–∫–∞
          if (widgetBottom >= listTop && widgetTop <= listBottom) {
            final relativeTop = widgetTop - listTop + _scrollController.offset;
            rects[i] = Rect.fromLTWH(
              0, 
              relativeTop, 
              widgetRenderBox.size.width, 
              widgetRenderBox.size.height
            );
            
            print('Widget $i: top=$relativeTop, height=${widgetRenderBox.size.height}');
          }
        }
      }
    } catch (e) {
      print('Error getting rect for widget $i: $e');
    }
  }

  return rects;
}
Element? _findWidgetByIndex(int index) {
  try {
    final listContext = _essentialsListKey.currentContext;
    if (listContext == null) return null;

    Element? targetElement;
    int foundIndex = 0;
    
    void traverse(Element element) {
      if (targetElement != null) return;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ Container —Å EssentialWidget
      final widget = element.widget;
      if (widget is Container) {
        if (widget.child is EssentialWidget) {
          if (foundIndex == index) {
            targetElement = element;
            return;
          }
          foundIndex++;
        }
      }

      element.visitChildren(traverse);
    }

    // –ü—Ä–∏–≤–æ–¥–∏–º BuildContext –∫ Element –∏ –æ–±—Ö–æ–¥–∏–º
    (listContext as Element).visitChildren(traverse);
    return targetElement;
  } catch (e) {
    print('Error finding widget by index: $e');
    return null;
  }
}

double _getWidgetHeight(int index) {
  try {
    final item = _filteredEssentials[index];
    final widgetKey = _essentialKeys[item.id];
    if (widgetKey != null && widgetKey.currentContext != null) {
      final renderBox = widgetKey.currentContext!.findRenderObject() as RenderBox?;
      if (renderBox != null) {
        return renderBox.size.height;
      }
    }
  } catch (e) {
    print('Error getting widget height for index $index: $e');
  }
  
  // Fallback –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä
  return 80.0; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
}
int _findPositionBetweenWidgets(double draggedCenter, Map<int, Rect> widgetRects, int draggedIndex) {
  if (widgetRects.isEmpty) return draggedIndex;

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –≤–∏–¥–∂–µ—Ç—ã –ø–æ –ø–æ–∑–∏—Ü–∏–∏
  final sortedEntries = widgetRects.entries.toList()
    ..sort((a, b) => a.value.top.compareTo(b.value.top));

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤—ã–º –≤–∏–¥–∂–µ—Ç–æ–º
  final firstWidget = sortedEntries.first;
  if (draggedCenter < firstWidget.value.top) {
    return 0;
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤–∏–¥–∂–µ—Ç–∞
  final lastWidget = sortedEntries.last;
  if (draggedCenter > lastWidget.value.bottom) {
    return _filteredEssentials.length - 1;
  }

  // –ò—â–µ–º –º–µ–∂–¥—É –∫–∞–∫–∏–º–∏ –≤–∏–¥–∂–µ—Ç–∞–º–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Ü–µ–Ω—Ç—Ä
  for (int i = 0; i < sortedEntries.length - 1; i++) {
    final currentWidget = sortedEntries[i];
    final nextWidget = sortedEntries[i + 1];

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ü–µ–Ω—Ç—Ä –º–µ–∂–¥—É —Ç–µ–∫—É—â–∏–º –∏ —Å–ª–µ–¥—É—é—â–∏–º –≤–∏–¥–∂–µ—Ç–æ–º
    if (draggedCenter > currentWidget.value.bottom && 
        draggedCenter < nextWidget.value.top) {
      
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω–¥–µ–∫—Å —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤–∏–¥–∂–µ—Ç–∞ (—Å—Ç–∞–≤–∏–º –ø–µ—Ä–µ–¥ –Ω–∏–º)
      return nextWidget.key;
    }
  }

  return draggedIndex; // –û—Å—Ç–∞–≤–ª—è–µ–º –Ω–∞ –º–µ—Å—Ç–µ –µ—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ–¥—Ö–æ–¥—è—â—É—é –ø–æ–∑–∏—Ü–∏—é
}

Widget _buildDraggableEssentialItem({
  required EssentialItem item,
  required int index,
}) {
  return LongPressDraggable<int>(
    data: index,
    feedback: Material(
      elevation: 8,
      borderRadius: BorderRadius.circular(16),
      child: Opacity(
        opacity: 0.8,
        child: Container(
          width: 360,
          child: _buildEssentialContent(item),
        ),
      ),
    ),
    childWhenDragging: Container(
      height: 76,
      margin: EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: Colors.grey.withOpacity(0.3),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white30, width: 2),
      ),
    ),
    onDragStarted: () {
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º PostFrameCallback —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —á—Ç–æ –≤–∏–¥–∂–µ—Ç—ã –æ—Ç—Ä–µ–Ω–¥–µ—Ä–µ–Ω—ã
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final renderBox = _essentialsListKey.currentContext?.findRenderObject() as RenderBox?;
        if (renderBox != null) {
          final listPosition = renderBox.localToGlobal(Offset.zero);
          
          // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤–∏–¥–∂–µ—Ç–∞
          final widgetElement = _findWidgetByIndex(index);
          if (widgetElement != null) {
            final widgetRenderBox = widgetElement.findRenderObject() as RenderBox?;
            if (widgetRenderBox != null) {
              final widgetPosition = widgetRenderBox.localToGlobal(Offset.zero);
              _dragStartY = widgetPosition.dy;
              _dragStartLocalY = widgetPosition.dy - listPosition.dy;
              
              print('Drag started at index $index, localY: $_dragStartLocalY');
            }
          }
        }
      });

      setState(() {
        _isDragging = true;
        _draggedIndex = index;
      });
    },
    onDragUpdate: (details) {
      _handleDragUpdate(details, index);
    },
    onDragEnd: (details) {
      _handleDragEnd(index);
    },
    child: _buildEssentialWidget(item, index),
  );
}



  Widget _buildEssentialContent(EssentialItem item) {
    return Container(
      width: 360, // –®–∏—Ä–∏–Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Color(item.backgroundColor).withOpacity(0.9),
        borderRadius: BorderRadius.circular(16),
        image: item.backgroundImagePath != null
            ? DecorationImage(
                image: FileImage(File(item.backgroundImagePath!)),
                fit: BoxFit.cover,
                alignment: Alignment.center,
              )
            : null,
      ),
      child: _buildEssentialInfo(item),
    );
  }

  Widget _buildEssentialInfo(EssentialItem item) {
    final filePathDisplay = _getFilePathDisplay(item);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              item.icon,
              style: TextStyle(fontSize: 20),
            ),
            SizedBox(width: 8),
            Expanded(
              child: Text(
                item.name,
                style: TextStyle(
                  color: Color(item.textColor),
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
        
        if (filePathDisplay != null)
          Padding(
            padding: EdgeInsets.only(top: 4),
            child: Text(
              filePathDisplay,
              style: TextStyle(
                color: Color(item.textColor).withOpacity(0.6),
                fontSize: 10,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        
        if (item.comment != null && item.comment!.isNotEmpty)
          Padding(
            padding: EdgeInsets.only(top: 8),
            child: Text(
              item.comment!,
              style: TextStyle(
                color: Color(item.textColor).withOpacity(0.8),
                fontSize: 12,
              ),
              maxLines: 3,
              overflow: TextOverflow.ellipsis,
            ),
          ),
      ],
    );
  }
Widget _buildEssentialWidget(EssentialItem item, int index) {
  if (!_essentialKeys.containsKey(item.id)) {
    _essentialKeys[item.id] = GlobalKey();
  }
  
  return Container(
    key: _essentialKeys[item.id], // ‚Üê –≤–æ—Ç —ç—Ç–æ –≤–∞–∂–Ω–æ
    margin: EdgeInsets.only(bottom: 8),
    child: EssentialWidget(
      key: Key(item.id),
      item: item,
      onTap: () => _copyToClipboard(item.name),
      
      onEdit: () => _showEditDialog(item),
      onDelete: () => _showDeleteConfirmation(item),
    ),
  );
}

  String? _getFilePathDisplay(EssentialItem item) {
    if (item.shortcutTarget != null) {
      return '–Ø—Ä–ª—ã–∫: ${item.shortcutTarget}';
    } else if (item.filePath != null) {
      return '–§–∞–π–ª: ${item.filePath}';
    }
    return null;
  }


  @override
void dispose() {
  _searchFocusNode.dispose();
   _scrollController.dispose();
  super.dispose();
}
}
class EssentialWidget extends StatefulWidget {
  final EssentialItem item;
  final VoidCallback onTap;

  final VoidCallback onEdit;
  final VoidCallback onDelete;

  const EssentialWidget({
    Key? key,
    required this.item,
    required this.onTap,

    required this.onEdit,
    required this.onDelete,
  }) : super(key: key);

  @override
  _EssentialWidgetState createState() => _EssentialWidgetState();
}

class _EssentialWidgetState extends State<EssentialWidget> {
  bool _isHovered = false;
  Uint8List? _imagePreview;
  Uint8List? _appIcon;
  Uint8List? _favicon;
  Timer? _doubleTapTimer;
  bool _isWaitingDoubleTap = false;

  @override
  void initState() {
    super.initState();
    _loadImagePreview();
    _loadAppIcon();
    _loadFavicon();
  }

  @override
  void dispose() {
    _doubleTapTimer?.cancel();
    super.dispose();
  }

  void _handleTap() {
    if (_isWaitingDoubleTap) {
      // –≠—Ç–æ –¥–≤–æ–π–Ω–æ–π –∫–ª–∏–∫
      _doubleTapTimer?.cancel();
      _isWaitingDoubleTap = false;
      _handleDoubleTap();
    } else {
      // –≠—Ç–æ –æ–¥–∏–Ω–∞—Ä–Ω—ã–π –∫–ª–∏–∫ - –∂–¥–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–π –≤—Ç–æ—Ä–æ–π –∫–ª–∏–∫
      _isWaitingDoubleTap = true;
      _doubleTapTimer = Timer(Duration(milliseconds: 300), () {
        if (_isWaitingDoubleTap) {
          _isWaitingDoubleTap = false;
          _handleSingleTap();
        }
      });
    }
  }

  void _handleSingleTap() {
    final url = _extractUrlFromText(widget.item.name);
    if (url != null) {
      _launchUrl(url);
    } else if (widget.item.originalFilePath != null) {
      _openFile();
    } else {
      widget.onTap();
    }
  }

  void _handleDoubleTap() {
    final url = _extractUrlFromText(widget.item.name);
    if (url != null) {
      // –î–ª—è URL –æ—Ç–∫—Ä—ã–≤–∞–µ–º –≤ Google
      _launchUrlInGoogle(url);
    } else if (widget.item.originalFilePath != null) {
      // –î–ª—è —Ñ–∞–π–ª–æ–≤ –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ
      _openFileLocation();
    } else {
      // –î–ª—è –æ–±—ã—á–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ - –∫–æ–ø–∏—Ä—É–µ–º –≤ –±—É—Ñ–µ—Ä
      widget.onTap();
    }
  }

  Future<void> _openFileLocation() async {
    try {
      if (widget.item.originalFilePath != null) {
        final file = File(widget.item.originalFilePath!);
        final directory = file.parent;
        
        if (await directory.exists()) {
          final uri = Uri.file(directory.path);
          if (await canLaunchUrl(uri)) {
            await launchUrl(uri);
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ñ–∞–π–ª–∞'),
                backgroundColor: Colors.orange,
              ),
            );
          }
        }
      }
    } catch (e) {
      print('Error opening file location: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è —Ñ–∞–π–ª–∞'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  Future<void> _launchUrlInGoogle(String url) async {
    try {
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º URL –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –≤ Google
      final googleUrl = 'https://www.google.com/search?q=${Uri.encodeComponent(url)}';
      final uri = Uri.parse(googleUrl);
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri);
      } else {
        // –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –≤ Google, –æ—Ç–∫—Ä—ã–≤–∞–µ–º –æ–±—ã—á–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º
        await _launchUrl(url);
      }
    } catch (e) {
      print('Error launching URL in Google: $e');
      await _launchUrl(url);
    }
  }

  
  Widget _buildIcon() {
    final url = _extractUrlFromText(widget.item.name);
    
    if (_imagePreview != null) {
      return Container(
        width: 32,
        height: 32,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(4),
          image: DecorationImage(
            image: MemoryImage(_imagePreview!),
            fit: BoxFit.cover,
          ),
        ),
      );
    } else if (_appIcon != null) {
      return Image.memory(_appIcon!, width: 32, height: 32);
    } else if (_favicon != null) {
      return Image.memory(_favicon!, width: 32, height: 32);
    } else if (url != null) {
      return Icon(Icons.public, color: Color(widget.item.textColor), size: 20);
    } else {
      return Text(
        widget.item.icon,
        style: TextStyle(fontSize: 20),
      );
    }
  }

  String? _getFilePathDisplay() {
  if (widget.item.shortcutTarget != null) {
    return '–Ø—Ä–ª—ã–∫: ${widget.item.shortcutTarget}';
  } else if (widget.item.filePath != null) {
    return '–§–∞–π–ª: ${widget.item.filePath}';
  } else if (widget.item.originalFilePath != null) {
    return '–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ: ${widget.item.originalFilePath}';
  }
  return null;
}
  Future<void> _openFile() async {
    try {
      final file = File(widget.item.originalFilePath!);
      if (await file.exists()) {
        final uri = Uri.file(widget.item.originalFilePath!);
        if (Platform.isWindows) {
        await Process.run('start', ['""', widget.item.originalFilePath!], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', [widget.item.originalFilePath!]);
      } else {
        await Process.run('xdg-open', [widget.item.originalFilePath!]);
      }
      }
    } catch (e) {
      print('Error opening file: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }


    String? _extractUrlFromText(String text) {
    try {
      final uri = Uri.parse(text);
      if (uri.scheme == 'http' || uri.scheme == 'https') {
        return text;
      }
      
      if (text.toLowerCase().contains('http') && text.contains('://')) {
        final start = text.indexOf('http');
        final end = text.indexOf(' ', start);
        if (end == -1) return text.substring(start);
        return text.substring(start, end);
      }
      
      return null;
    } catch (_) {
      return null;
    }
  }

  bool _isImageFile(String path) {
    final ext = path.toLowerCase().split('.').last;
    return ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].contains(ext);
  }

  bool _isWebUrl(String text) {
    try {
      final uri = Uri.parse(text);
      return uri.scheme == 'http' || uri.scheme == 'https';
    } catch (_) {
      return false;
    }
  }
    Future<void> _loadImagePreview() async {
    if (widget.item.originalFilePath != null && 
        _isImageFile(widget.item.originalFilePath!)) {
      try {
        final file = File(widget.item.originalFilePath!);
        final bytes = await file.readAsBytes();
        if (mounted) {
          setState(() {
            _imagePreview = bytes;
          });
        }
      } catch (e) {
        print('Error loading image preview: $e');
      }
    }
  }

  Future<void> _loadAppIcon() async {
    if (widget.item.originalFilePath != null && 
        widget.item.originalFilePath!.toLowerCase().endsWith('.exe')) {
      try {
        // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ MethodChannel –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–∫–æ–Ω–∫–∏ EXE
        // –≠—Ç–æ —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∑–∞–≥–ª—É—à–∫–∞
        final iconBytes = await _extractExeIcon(widget.item.originalFilePath!);
        if (mounted && iconBytes != null) {
          setState(() {
            _appIcon = iconBytes;
          });
        }
      } catch (e) {
        print('Error loading app icon: $e');
      }
    }
  }

  Future<void> _loadFavicon() async {
    final url = _extractUrlFromText(widget.item.name);
    if (url != null) {
      try {
        final faviconBytes = await _downloadFavicon(url);
        if (mounted && faviconBytes != null) {
          setState(() {
            _favicon = faviconBytes;
          });
        }
      } catch (e) {
        print('Error loading favicon: $e');
      }
    }
  }

  Future<Uint8List?> _extractExeIcon(String exePath) async {
    // –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–∫–æ–Ω–∫–∏ EXE
    // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ platform channels –¥–ª—è –≤—ã–∑–æ–≤–∞ WinAPI
    try {
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–ª—É—à–∫—É - –∑–µ–ª–µ–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder);
      final paint = Paint()..color = Colors.green;
      canvas.drawRect(Rect.fromLTWH(0, 0, 32, 32), paint);
      final picture = recorder.endRecording();
      final image = await picture.toImage(32, 32);
      final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      return byteData?.buffer.asUint8List();
    } catch (e) {
      print('Error extracting EXE icon: $e');
      return null;
    }
  }

  Future<Uint8List?> _downloadFavicon(String url) async {
    try {
      final uri = Uri.parse(url);
      final faviconUrl = '${uri.scheme}://${uri.host}/favicon.ico';
      final response = await http.get(Uri.parse(faviconUrl));
      if (response.statusCode == 200) {
        return response.bodyBytes;
      }
      
      // –ü—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏
      final alternativeUrls = [
        '${uri.scheme}://${uri.host}/apple-touch-icon.png',
        '${uri.scheme}://${uri.host}/favicon.png',
      ];
      
      for (final altUrl in alternativeUrls) {
        try {
          final altResponse = await http.get(Uri.parse(altUrl));
          if (altResponse.statusCode == 200) {
            return altResponse.bodyBytes;
          }
        } catch (e) {
          continue;
        }
      }
    } catch (e) {
      print('Error downloading favicon: $e');
    }
    return null;
  }


  // –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∫–ª–∞—Å—Å–∞ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...
  // _loadImagePreview, _loadAppIcon, _loadFavicon, _launchUrl, _openFile –∏ —Ç.–¥.

  Future<void> _launchUrl(String url) async {
    try {
      final uri = Uri.parse(url);
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri);
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Å—Å—ã–ª–∫—É: $url'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e) {
      print('Error launching URL: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Å—Å—ã–ª–∫–∏'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final filePathDisplay = _getFilePathDisplay();

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTap: _handleTap,
        
        child: Container(
          margin: EdgeInsets.only(bottom: 12),
          padding: EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Color(widget.item.backgroundColor).withOpacity(0.9),
            borderRadius: BorderRadius.circular(16),
            image: widget.item.backgroundImagePath != null
                ? DecorationImage(
                    image: FileImage(File(widget.item.backgroundImagePath!)),
                    fit: BoxFit.cover,
                    alignment: Alignment.center,
                  )
                : null,
          ),
          child: Stack(
            children: [
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      _buildIcon(),
                      SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          widget.item.name,
                          style: TextStyle(
                            color: Color(widget.item.textColor),
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ],
                  ),
                  
                  // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—É—Ç–∏ —Ñ–∞–π–ª–∞/—è—Ä–ª—ã–∫–∞ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –∫–ª–∏–∫–∞
                  if (filePathDisplay != null)
                    GestureDetector(
                      onTap: _openFileLocation,
                      child: MouseRegion(
                        cursor: SystemMouseCursors.click,
                        child: Padding(
                          padding: EdgeInsets.only(top: 4),
                          child: Text(
                            filePathDisplay,
                            style: TextStyle(
                              color: Color(widget.item.textColor).withOpacity(0.8),
                              fontSize: 10,
                              decoration: TextDecoration.underline,
                            ),
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ),
                    ),
                  
                  // –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...
                  if (widget.item.comment != null && widget.item.comment!.isNotEmpty)
                    Padding(
                      padding: EdgeInsets.only(top: 8),
                      child: Text(
                        widget.item.comment!,
                        style: TextStyle(
                          color: Color(widget.item.textColor).withOpacity(0.8),
                          fontSize: 12,
                        ),
                        maxLines: 3,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  if (widget.item.reminderTime != null)
                    Padding(
                      padding: EdgeInsets.only(top: 4),
                      child: Text(
                        '–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: ${DateFormat('dd.MM.yyyy HH:mm').format(widget.item.reminderTime!)}',
                        style: TextStyle(
                          color: Color(widget.item.textColor).withOpacity(0.6),
                          fontSize: 10,
                        ),
                      ),
                    ),
                ],
              ),

              if (_isHovered)
                Positioned(
                  top: 4,
                  right: 4,
                  child: Row(
                    children: [
                      MouseRegion(
                        cursor: SystemMouseCursors.click,
                        child: GestureDetector(
                          onTap: widget.onEdit,
                          child: Container(
                            padding: EdgeInsets.all(4),
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.settings, size: 12, color: Colors.white),
                          ),
                        ),
                      ),
                      SizedBox(width: 4),
                      MouseRegion(
                        cursor: SystemMouseCursors.click,
                        child: GestureDetector(
                          onTap: widget.onDelete,
                          child: Container(
                            padding: EdgeInsets.all(4),
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.close, size: 12, color: Colors.white),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class EssentialEditDialog extends StatefulWidget {
  final EssentialItem item;
  final Function(EssentialItem) onSave;
  final VoidCallback onDelete;
  final bool isNewItem;
  final GlobalKey? sourceWidgetKey;

  const EssentialEditDialog({
    Key? key,
    required this.item,
    required this.onSave,
    required this.onDelete,
    this.isNewItem = false,
    this.sourceWidgetKey,
  }) : super(key: key);

  @override
  _EssentialEditDialogState createState() => _EssentialEditDialogState();
}

class _EssentialEditDialogState extends State<EssentialEditDialog> {
  late EssentialItem _editedItem;
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _iconController = TextEditingController();
  final TextEditingController _commentController = TextEditingController();
  final TextEditingController _musicController = TextEditingController();
  DateTime? _selectedDate;
  TimeOfDay? _selectedTime;
  final FocusNode _nameFocusNode = FocusNode();
  final FocusNode _iconFocusNode = FocusNode();
  bool _showReminderSettings = false;
  bool _showEmojiGrid = false;
  Color _currentColor = Colors.blue;

  final List<String> _quickEmojis = ['üîë', '‚≠ê', 'üìÑ', '‚ÑπÔ∏è', '‚ö†Ô∏è', 'üåê', 'üìù', 'üü¢', '‚ùì'];

  @override
  void initState() {
    super.initState();
    _editedItem = widget.item;
    _nameController.text = _editedItem.name;
    _iconController.text = _editedItem.icon;
    _commentController.text = _editedItem.comment ?? '';
    _musicController.text = _editedItem.musicFile ?? 'alarm.mp3';
    _selectedDate = _editedItem.reminderTime;
    _selectedTime = _editedItem.reminderTime != null
        ? TimeOfDay.fromDateTime(_editedItem.reminderTime!)
        : null;
    _showReminderSettings = _editedItem.reminderTime != null;
    _currentColor = Color(_editedItem.backgroundColor);

    if (widget.isNewItem) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _nameFocusNode.requestFocus();
      });
    }

    _iconFocusNode.addListener(() {
      setState(() {
        _showEmojiGrid = _iconFocusNode.hasFocus;
      });
    });
  }

  Future<void> _pickImage() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
      );

      if (result != null && result.files.single.path != null) {
        final directory = await getApplicationDocumentsDirectory();
        final backgroundsDir = Directory('${directory.path}/Essentials_backgrounds');
        if (!backgroundsDir.existsSync()) {
          backgroundsDir.createSync(recursive: true);
        }

        final originalFile = File(result.files.single.path!);
        final newPath = '${backgroundsDir.path}/${DateTime.now().millisecondsSinceEpoch}.${result.files.single.extension}';
        await originalFile.copy(newPath);

        setState(() {
          _editedItem = _editedItem.copyWith(backgroundImagePath: newPath);
        });
      }
    } catch (e) {
      print('Error picking image: $e');
    }
  }

  void _removeImage() {
    setState(() {
      _editedItem = _editedItem.copyWith(backgroundImagePath: null);
    });
  }

  Future<void> _pickMusic() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.audio,
        allowedExtensions: ['mp3', 'wav'],
      );

      if (result != null && result.files.single.path != null) {
        final path = result.files.single.path!;
        final extension = result.files.single.extension?.toLowerCase();
        
        if (extension == 'mp3' || extension == 'wav') {
          setState(() {
            _editedItem = _editedItem.copyWith(musicFile: path);
            _musicController.text = path;
          });
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ MP3 –∏ WAV —Ñ–∞–π–ª—ã'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      print('Error picking music: $e');
    }
  }

  Future<void> _pickDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime(2100),
    );
    if (picked != null) {
      setState(() {
        _selectedDate = picked;
      });
    }
  }

  Future<void> _pickTime() async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: _selectedTime ?? TimeOfDay.now(),
    );
    if (picked != null) {
      setState(() {
        _selectedTime = picked;
      });
    }
  }

  void _saveChanges() {
    final updatedItem = _editedItem.copyWith(
      name: _nameController.text.trim(),
      icon: _iconController.text.trim(),
      comment: _commentController.text.trim().isEmpty ? null : _commentController.text.trim(),
      musicFile: _musicController.text.trim(),
      reminderTime: _showReminderSettings && _selectedDate != null && _selectedTime != null
          ? DateTime(
              _selectedDate!.year,
              _selectedDate!.month,
              _selectedDate!.day,
              _selectedTime!.hour,
              _selectedTime!.minute,
            )
          : null,
    );

    widget.onSave(updatedItem);
    Navigator.of(context).pop();
  }

  void _selectEmoji(String emoji) {
    setState(() {
      _iconController.text = emoji;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (widget.isNewItem || widget.sourceWidgetKey == null) {
      return _buildDialog(context);
    } else {
      return Stack(
        children: [
          Positioned.fill(
            child: Container(color: Colors.transparent),
          ),
          Positioned(
            top: _getDialogPosition(context).dy,
            left: _getDialogPosition(context).dx,
            child: _buildDialog(context),
          ),
        ],
      );
    }
  }

  Offset _getDialogPosition(BuildContext context) {
    try {
      final renderBox = widget.sourceWidgetKey?.currentContext?.findRenderObject() as RenderBox?;
      if (renderBox != null) {
        final offset = renderBox.localToGlobal(Offset.zero);
        return offset;
      }
    } catch (e) {
      print('Error getting widget position: $e');
    }
    return Offset.zero;
  }

  Widget _buildDialog(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: Container(
        width: MediaQuery.of(context).size.width ,
        height: MediaQuery.of(context).size.height * 0.7,
        decoration: BoxDecoration(
          color: Color(_editedItem.backgroundColor).withOpacity(0.95),
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.5),
              blurRadius: 10,
              spreadRadius: 2,
            ),
          ],
        ),
        child: Column(
          children: [
            Container(
              padding: EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Color(0xFF1A1A1A).withOpacity(0.9),
                borderRadius: BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
              ),
              child: Row(
                children: [
                  Text(
                    '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Essential',
                    style: TextStyle(color: Colors.white, fontSize: 16),
                  ),
                  Spacer(),
                  MouseRegion(
                    cursor: SystemMouseCursors.click,
                    child: GestureDetector(
                      onTap: () => Navigator.of(context).pop(),
                      child: Icon(Icons.close, size: 20, color: Colors.white),
                    ),
                  ),
                ],
              ),
            ),

            Expanded(
              child: Padding(
                padding: EdgeInsets.all(16),
                child: Column(
                  children: [
                    Row(
                      children: [
                        // Icon field with emoji grid
                        Container(
                          width: 60,
                          child: Column(
                            children: [
                              TextField(
                                controller: _iconController,
                                focusNode: _iconFocusNode,
                                style: TextStyle(color: Colors.white, fontSize: 20),
                                textAlign: TextAlign.center,
                                decoration: InputDecoration(
                                  hintText: 'üîñ',
                                  hintStyle: TextStyle(fontSize: 20),
                                  border: OutlineInputBorder(),
                                  contentPadding: EdgeInsets.symmetric(vertical: 8),
                                ),
                              ),
                              
                            // Emoji grid
if (_showEmojiGrid)
  Container(
    margin: EdgeInsets.only(top: 4),
    padding: EdgeInsets.all(4),
    decoration: BoxDecoration(
      color: Colors.black.withOpacity(0.8),
      borderRadius: BorderRadius.circular(8),
    ),
    child: GridView.builder(
      shrinkWrap: true,
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        crossAxisSpacing: 4,
        mainAxisSpacing: 4,
      ),
      itemCount: _quickEmojis.length,
      itemBuilder: (context, index) {
        return GestureDetector(
          onTap: () => _selectEmoji(_quickEmojis[index]),
          child: Container(
            decoration: BoxDecoration(
              color: Colors.grey[800],
              borderRadius: BorderRadius.circular(4),
            ),
            child: Center(
              child: Text(
                _quickEmojis[index],
                style: TextStyle(fontSize: 16),
              ),
            ),
          ),
        );
      },
    ),
  ),
],
),
),
SizedBox(width: 12),
Expanded(
  child: TextField(
    controller: _nameController,
    focusNode: _nameFocusNode,
    style: TextStyle(color: Colors.white),
    decoration: InputDecoration(
      labelText: '–ù–∞–∑–≤–∞–Ω–∏–µ',
      labelStyle: TextStyle(color: Colors.white70),
      border: OutlineInputBorder(),
    ),
  ),
),
],
),

// –ü–†–ê–í–ò–õ–¨–ù–û–ï –ú–ï–°–¢–û –î–õ–Ø –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø –ü–£–¢–ò –§–ê–ô–õ–ê - –ø–æ—Å–ª–µ —Å—Ç—Ä–æ–∫–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º
if (_editedItem.filePath != null || _editedItem.shortcutTarget != null)
  Container(
    width: double.infinity,
    padding: EdgeInsets.symmetric(vertical: 8, horizontal: 12),
    margin: EdgeInsets.only(top: 8, bottom: 8),
    decoration: BoxDecoration(
      color: Colors.black.withOpacity(0.3),
      borderRadius: BorderRadius.circular(8),
    ),
    child: Text(
      _editedItem.shortcutTarget != null 
          ? '–Ø—Ä–ª—ã–∫: ${_editedItem.shortcutTarget}'
          : '–§–∞–π–ª: ${_editedItem.filePath}',
      style: TextStyle(
        color: Colors.white70,
        fontSize: 10,
      ),
      maxLines: 2,
      overflow: TextOverflow.ellipsis,
    ),
  ),

SizedBox(height: 16),
                    // Color pickers
                    Row(
                      children: [
                        Text('–¶–≤–µ—Ç –≤–∏–¥–∂–µ—Ç–∞:', style: TextStyle(color: Colors.white)),
                        SizedBox(width: 8),
                        Expanded(
                          child: Container(
                            height: 40,
                            child: _buildColorPicker(
                              initialColor: Color(_editedItem.backgroundColor),
                              onColorChanged: (color) {
                                setState(() {
                                  _editedItem = _editedItem.copyWith(backgroundColor: color.value);
                                  _currentColor = color;
                                });
                              },
                            ),
                          ),
                        ),
                        SizedBox(width: 16),
                        Text('–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞:', style: TextStyle(color: Colors.white)),
                        SizedBox(width: 16),
                        Expanded(
                          child: Container(
                            height: 40,
                            child: _buildColorPicker(
                              initialColor: Color(_editedItem.textColor),
                              onColorChanged: (color) {
                                setState(() {
                                  _editedItem = _editedItem.copyWith(textColor: color.value);
                                });
                              },
                            ),
                          ),
                        ),
                      ],
                    ),

                    SizedBox(height: 16),

                    Expanded(
                      child: SingleChildScrollView(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            TextField(
                              controller: _commentController,
                              style: TextStyle(color: Colors.white),
                              maxLines: 4,
                              decoration: InputDecoration(
                                labelText: '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π',
                                labelStyle: TextStyle(color: Colors.white70),
                                border: OutlineInputBorder(),
                                alignLabelWithHint: true,
                              ),
                            ),

                            SizedBox(height: 16),

                            // Image management
                            Row(
                              children: [
                                Expanded(
                                  child: Text(
                                    _editedItem.backgroundImagePath != null
                                        ? '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ'
                                        : '–ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è',
                                    style: TextStyle(color: Colors.white),
                                  ),
                                ),
                                MouseRegion(
                                  cursor: SystemMouseCursors.click,
                                  child: GestureDetector(
                                    onTap: _pickImage,
                                    child: Container(
                                      padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                      decoration: BoxDecoration(
                                        color: Colors.blue.withOpacity(0.8),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        '–í—ã–±—Ä–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ',
                                        style: TextStyle(color: Colors.white, fontSize: 12),
                                      ),
                                    ),
                                  ),
                                ),
                                if (_editedItem.backgroundImagePath != null) ...[
                                  SizedBox(width: 8),
                                  MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: _removeImage,
                                      child: Container(
                                        padding: EdgeInsets.all(8),
                                        decoration: BoxDecoration(
                                          color: Colors.red.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Icon(Icons.delete, size: 16, color: Colors.white),
                                      ),
                                    ),
                                  ),
                                ],
                              ],
                            ),

                            SizedBox(height: 16),

                            // Reminder toggle
                            Row(
                              children: [
                                Checkbox(
                                  value: _showReminderSettings,
                                  onChanged: (value) {
                                    setState(() {
                                      _showReminderSettings = value ?? false;
                                      if (!_showReminderSettings) {
                                        _selectedDate = null;
                                        _selectedTime = null;
                                      }
                                    });
                                  },
                                ),
                                Text(
                                  '–°–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–ª–∫—É',
                                  style: TextStyle(color: Colors.white),
                                ),
                              ],
                            ),

                            // Reminder settings (only visible when toggle is on)
                            if (_showReminderSettings) ...[
                              SizedBox(height: 8),
                              Text(
                                '–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ',
                                style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
                              ),
                              SizedBox(height: 8),
                              Row(
                                children: [
                                  Expanded(
                                    child: Text(
                                      _selectedDate != null
                                          ? '${_selectedDate!.day}-${_selectedDate!.month}-${_selectedDate!.year}'
                                          : '–î–∞—Ç–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞',
                                      style: TextStyle(color: Colors.white70),
                                    ),
                                  ),
                                  MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: _pickDate,
                                      child: Container(
                                        padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                        decoration: BoxDecoration(
                                          color: Colors.green.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Text(
                                          '–í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É',
                                          style: TextStyle(color: Colors.white, fontSize: 12),
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              SizedBox(height: 8),
                              Row(
                                children: [
                                  Expanded(
                                    child: Text(
                                      _selectedTime != null
                                          ? '${_selectedTime!.hour}:${_selectedTime!.minute.toString().padLeft(2, '0')}'
                                          : '–í—Ä–µ–º—è –Ω–µ –≤—ã–±—Ä–∞–Ω–æ',
                                      style: TextStyle(color: Colors.white70),
                                    ),
                                  ),
                                  MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: _pickTime,
                                      child: Container(
                                        padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                        decoration: BoxDecoration(
                                          color: Colors.green.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Text(
                                          '–í—ã–±—Ä–∞—Ç—å –≤—Ä–µ–º—è',
                                          style: TextStyle(color: Colors.white, fontSize: 12),
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              
                            // Music
                            Row(
                              children: [
                                Expanded(
                                  child: TextField(
                                    controller: _musicController,
                                    style: TextStyle(color: Colors.white),
                                    decoration: InputDecoration(
                                      labelText: '–ú—É–∑—ã–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª',
                                      labelStyle: TextStyle(color: Colors.white70),
                                      border: OutlineInputBorder(),
                                    ),
                                  ),
                                ),
                                SizedBox(width: 8),
                                MouseRegion(
                                  cursor: SystemMouseCursors.click,
                                  child: GestureDetector(
                                    onTap: _pickMusic,
                                    child: Container(
                                      padding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                      decoration: BoxDecoration(
                                        color: Colors.orange.withOpacity(0.8),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        '–í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª',
                                        style: TextStyle(color: Colors.white, fontSize: 12),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                              SizedBox(height: 16),
                            ],


                            SizedBox(height: 16),

                            // Action buttons
                            Row(
                              children: [
                                Expanded(
                                  child: MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: _saveChanges,
                                      child: Container(
                                        padding: EdgeInsets.all(12),
                                        decoration: BoxDecoration(
                                          color: Colors.blue.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Text(
                                          '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å',
                                          style: TextStyle(color: Colors.white),
                                          textAlign: TextAlign.center,
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                                SizedBox(width: 12),
                                Expanded(
                                  child: MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: widget.onDelete,
                                      child: Container(
                                        padding: EdgeInsets.all(12),
                                        decoration: BoxDecoration(
                                          color: Colors.red.withOpacity(0.8),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Text(
                                          '–£–¥–∞–ª–∏—Ç—å',
                                          style: TextStyle(color: Colors.white),
                                          textAlign: TextAlign.center,
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

Widget _buildColorPicker({required Color initialColor, required ValueChanged<Color> onColorChanged}) {
  return GestureDetector(
    onTap: () {
      Color selectedColor = initialColor; // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π —Ü–≤–µ—Ç
      
      showDialog(
        context: context,
        builder: (context) => StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              backgroundColor: selectedColor,
              title: Text('–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç', style: TextStyle(
                color: selectedColor.computeLuminance() > 0.5 ? Colors.black : Colors.white
              )),
              content: Container(
                width: 300,
                height: 300,
                child: ColorPicker(
                  color: selectedColor,
                  onColorChanged: (color) {
                    setDialogState(() {
                      selectedColor = color; // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç
                    });
                  },
                  showLabel: false,
                  pickerAreaHeightPercent: 0.8,
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: Text('–û—Ç–º–µ–Ω–∞', style: TextStyle(
                    color: selectedColor.computeLuminance() > 0.5 ? Colors.black : Colors.white
                  )),
                ),
                TextButton(
                  onPressed: () {
                    onColorChanged(selectedColor); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç
                    Navigator.of(context).pop();
                  },
                  child: Text('OK', style: TextStyle(
                    color: selectedColor.computeLuminance() > 0.5 ? Colors.black : Colors.white
                  )),
                ),
              ],
            );
          },
        ),
      );
    },
    child: Container(
      decoration: BoxDecoration(
        color: initialColor,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.white, width: 2),
      ),
    ),
  );
}
}

class ColorPicker extends StatefulWidget {
  final Color color;
  final ValueChanged<Color> onColorChanged;
  final bool showLabel;
  final double pickerAreaHeightPercent;

  const ColorPicker({
    Key? key,
    required this.color,
    required this.onColorChanged,
    this.showLabel = true,
    this.pickerAreaHeightPercent = 0.8,
  }) : super(key: key);

  @override
  _ColorPickerState createState() => _ColorPickerState();
}

class _ColorPickerState extends State<ColorPicker> {
  late Color _currentColor;

  @override
  void initState() {
    super.initState();
    _currentColor = widget.color;
  }

  List<Color> _generateColors() {
    final colors = <Color>[];
    
    // Basic colors
    colors.addAll([
      Colors.black, Colors.white, Colors.grey,
      Colors.red, Colors.pink, Colors.purple,
      Colors.deepPurple, Colors.indigo, Colors.blue,
      Colors.lightBlue, Colors.cyan, Colors.teal,
      Colors.green, Colors.lightGreen, Colors.lime,
      Colors.yellow, Colors.amber, Colors.orange,
      Colors.deepOrange, Colors.brown,
    ]);

    // Generate more shades
    for (var baseColor in [Colors.red, Colors.blue, Colors.green, Colors.yellow, Colors.purple]) {
      for (int i = 1; i <= 9; i++) {
        colors.add(baseColor[i * 100]!);
      }
    }

    return colors;
  }

  @override
  Widget build(BuildContext context) {
    final colors = _generateColors();
    
    return Column(
      children: [
        Expanded(
          child: GridView.builder(
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 10,
              crossAxisSpacing: 2,
              mainAxisSpacing: 2,
            ),
            itemCount: colors.length,
            itemBuilder: (context, index) {
              final color = colors[index];
              return GestureDetector(
                onTap: () {
                  setState(() {
                    _currentColor = color;
                  });
                  widget.onColorChanged(color);
                },
                child: Container(
                  decoration: BoxDecoration(
                    color: color,
                    border: Border.all(
                      color: _currentColor.value == color.value ? Colors.white : Colors.transparent,
                      width: 2,
                    ),
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
              );
            },
          ),
        ),
        
        SizedBox(height: 16),
        
        // Gradient picker
        Container(
          height: 40,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            gradient: LinearGradient(
              colors: [
                Colors.red, Colors.orange, Colors.yellow, 
                Colors.green, Colors.blue, Colors.indigo, 
                Colors.purple
              ],
            ),
          ),
          child: GestureDetector(
            onTapDown: (details) {
              final relativeX = details.localPosition.dx;
              final containerWidth = context.size?.width ?? 1;
              final ratio = relativeX / containerWidth;
              
              final hue = ratio * 360;
              final color = HSVColor.fromAHSV(1.0, hue, 1.0, 1.0).toColor();
              
              setState(() {
                _currentColor = color;
              });
              widget.onColorChanged(color);
            },
          ),
        ),
        
        SizedBox(height: 8),
        
        // Current color display
        Container(
          padding: EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: _currentColor,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: Colors.white),
          ),
          child: Text(
            'RGB: ${_currentColor.red}, ${_currentColor.green}, ${_currentColor.blue}',
            style: TextStyle(
              color: _currentColor.computeLuminance() > 0.5 ? Colors.black : Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ],
    );
  }
}

class DeleteConfirmationDialog extends StatelessWidget {
  final EssentialItem item;
  final VoidCallback onDelete;

  const DeleteConfirmationDialog({
    Key? key,
    required this.item,
    required this.onDelete,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: Color(0xFF2B2B2B),
      title: Text(
        '–£–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞',
        style: TextStyle(color: Colors.white),
      ),
      content: Text(
        '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å "${item.name}"?',
        style: TextStyle(color: Colors.white70),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text('–û—Ç–º–µ–Ω–∞', style: TextStyle(color: Colors.white)),
        ),
        TextButton(
          onPressed: () {
            onDelete();
            Navigator.of(context).pop();
          },
          child: Text('–£–¥–∞–ª–∏—Ç—å', style: TextStyle(color: Colors.red)),
        ),
      ],
    );
  }
}
class EssentialItem {
  final String id;
  final String name;
  final String icon;
  final int backgroundColor;
  final int textColor;
  final String? comment;
  final String? backgroundImagePath;
  final String? musicFile;
  final DateTime? reminderTime;
  final String? originalFilePath;
  final String? filePath; // –ù–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è –ø—É—Ç–∏ —Ñ–∞–π–ª–∞/—è—Ä–ª—ã–∫–∞
  final String? shortcutTarget; // –ù–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è —Ü–µ–ª–∏ —è—Ä–ª—ã–∫–∞

  EssentialItem({
    required this.id,
    required this.name,
    required this.icon,
    required this.backgroundColor,
    required this.textColor,
    this.comment,
    this.backgroundImagePath,
    this.musicFile,
    this.reminderTime,
    this.originalFilePath,
    this.filePath,
    this.shortcutTarget,
  });

  factory EssentialItem.fromFile(FileSystemEntity file) {
    final fileName = file.path.split('/').last;
    final extension = fileName.split('.').last.toLowerCase();
    
    String icon = 'üìÑ';
    String? shortcutTarget;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª —è—Ä–ª—ã–∫–æ–º
    if (extension == 'lnk' || extension == 'url') {
      icon = 'üîó';
      shortcutTarget = _readShortcutTarget(file.path);
    } else if (['jpg', 'jpeg', 'png', 'gif', 'bmp'].contains(extension)) {
      icon = 'üñºÔ∏è';
    } else if (['mp3', 'wav', 'ogg'].contains(extension)) {
      icon = 'üéµ';
    } else if (['exe'].contains(extension)) {
      icon = '‚öôÔ∏è';
    }
    
    return EssentialItem(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: fileName,
      icon: icon,
      backgroundColor: Colors.blue.value,
      textColor: Colors.white.value,
      originalFilePath: file.path,
      filePath: file.path,
      shortcutTarget: shortcutTarget,
    );
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —á—Ç–µ–Ω–∏—è —Ü–µ–ª–∏ —è—Ä–ª—ã–∫–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
  static String? _readShortcutTarget(String shortcutPath) {
    try {
      if (shortcutPath.toLowerCase().endsWith('.url')) {
        final file = File(shortcutPath);
        final lines = file.readAsLinesSync();
        for (final line in lines) {
          if (line.toLowerCase().startsWith('url=')) {
            return line.substring(4).trim();
          }
        }
      }
      // –î–ª—è .lnk —Ñ–∞–π–ª–æ–≤ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å native channel
      return shortcutPath;
    } catch (e) {
      return shortcutPath;
    }
  }

  factory EssentialItem.fromJson(Map<String, dynamic> json) {
    return EssentialItem(
      id: json['id'],
      name: json['name'],
      icon: json['icon'],
      backgroundColor: json['backgroundColor'],
      textColor: json['textColor'],
      comment: json['comment'],
      backgroundImagePath: json['backgroundImagePath'],
      musicFile: json['musicFile'],
      reminderTime: json['reminderTime'] != null ? DateTime.parse(json['reminderTime']) : null,
      originalFilePath: json['originalFilePath'],
      filePath: json['filePath'],
      shortcutTarget: json['shortcutTarget'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'icon': icon,
      'backgroundColor': backgroundColor,
      'textColor': textColor,
      'comment': comment,
      'backgroundImagePath': backgroundImagePath,
      'musicFile': musicFile,
      'reminderTime': reminderTime?.toIso8601String(),
      'originalFilePath': originalFilePath,
      'filePath': filePath,
      'shortcutTarget': shortcutTarget,
    };
  }

  EssentialItem copyWith({
    String? id,
    String? name,
    String? icon,
    int? backgroundColor,
    int? textColor,
    String? comment,
    String? backgroundImagePath,
    String? musicFile,
    DateTime? reminderTime,
    String? originalFilePath,
    String? filePath,
    String? shortcutTarget,
  }) {
    return EssentialItem(
      id: id ?? this.id,
      name: name ?? this.name,
      icon: icon ?? this.icon,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      textColor: textColor ?? this.textColor,
      comment: comment ?? this.comment,
      backgroundImagePath: backgroundImagePath ?? this.backgroundImagePath,
      musicFile: musicFile ?? this.musicFile,
      reminderTime: reminderTime ?? this.reminderTime,
      originalFilePath: originalFilePath ?? this.originalFilePath,
      filePath: filePath ?? this.filePath,
      shortcutTarget: shortcutTarget ?? this.shortcutTarget,
    );
  }
}
class ClipboardHistoryWindow extends StatefulWidget {
  const ClipboardHistoryWindow({super.key});

  @override
  State<ClipboardHistoryWindow> createState() => _ClipboardHistoryWindowState();
}

class _ClipboardHistoryWindowState extends State<ClipboardHistoryWindow> {
  final TextEditingController _searchController = TextEditingController();
  List<Map<String, dynamic>> _clipboardHistory = [];
  List<Map<String, dynamic>> _filteredHistory = [];
  bool _isLoading = true;
  late Timer _keyboardInputTimer;
  String _currentTypedText = '';
  DateTime _lastTypedTime = DateTime.now();
  late Directory _copypasteDir;
  late StreamSubscription<FileSystemEvent> _fileWatcher;
  int _currentTab = 0; // 0 - –≤—Å–µ, 1 - –∏–∑–±—Ä–∞–Ω–Ω–æ–µ
  File? _backgroundImage;
  Map<String, dynamic>? _expandedItem;
  List<String> _selectedItems = []; // –î–ª—è compose —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞
  bool _showExportOptions = false;
  String _exportMode = 'auto'; // auto, image, text, html, archive, separate

  // CSS –¥–ª—è HTML —ç–∫—Å–ø–æ—Ä—Ç–∞
  final String _htmlCss = '''
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        max-width: 70%;
        margin: 0 auto;
        padding: 40px 20px;
        background-color: #1a1a1a;
        color: #ffffff;
        line-height: 1.6;
      }
      .text-block {
        background: #2b2b2b;
        padding: 25px;
        margin: 20px 0;
        border-radius: 8px;
        border-left: 4px solid #4CAF50;
      }
      .code-block {
        background: #1e1e1e;
        padding: 25px;
        margin: 20px 0;
        border-radius: 8px;
        border-left: 4px solid #2196F3;
        font-family: 'Consolas', 'Monaco', monospace;
        white-space: pre-wrap;
        overflow-x: auto;
      }
      .image-block {
        text-align: center;
        margin: 30px 0;
        padding: 15px;
        background: #2b2b2b;
        border-radius: 8px;
        border-left: 4px solid #FF9800;
      }
      .image-block img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
      }
      .image-caption {
        margin-top: 10px;
        font-style: italic;
        color: #cccccc;
      }
      .header {
        text-align: center;
        margin-bottom: 40px;
        padding-bottom: 20px;
        border-bottom: 2px solid #333;
      }
      .timestamp {
        color: #888;
        font-size: 0.9em;
        margin-top: 10px;
      }
    </style>
  ''';

  @override
  void initState() {
    super.initState();
    _initializeApp();
    _setupKeyboardListeners();
  }

  void _setupKeyboardListeners() {
    // –°–ª—É—à–∞—Ç–µ–ª—å –¥–ª—è –∫–ª–∞–≤–∏—à Esc –∏ Ctrl+Z
    RawKeyboard.instance.addListener(_handleKeyEvent);
  }

  void _handleKeyEvent(RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      // Esc - –æ—á–∏—Å—Ç–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ
      if (event.logicalKey == LogicalKeyboardKey.escape) {
        if (_selectedItems.isNotEmpty) {
          setState(() {
            _selectedItems.clear();
            _showExportOptions = false;
          });
        }
      }
      // Ctrl+Z - –æ—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
      else if (event.logicalKey == LogicalKeyboardKey.keyZ && 
               event.isControlPressed) {
        if (_selectedItems.isNotEmpty) {
          setState(() {
            _selectedItems.removeLast();
            _showExportOptions = _selectedItems.isNotEmpty;
          });
        }
      }
    }
  }

  void _handleBackgroundImageDrop(List<File> files) async {
    if (files.isNotEmpty && (files.first.path.endsWith('.png') || files.first.path.endsWith('.jpg'))) {
      try {
        final directory = await getApplicationDocumentsDirectory();
        final bgDir = Directory('${directory.path}/imeyou_pet/widget_backgrounds');
        if (!bgDir.existsSync()) {
          bgDir.createSync(recursive: true);
        }
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        final newFile = File('${bgDir.path}/cnp_bg${path.extension(files.first.path)}');
        await newFile.writeAsBytes(await files.first.readAsBytes());
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Ç—å –≤ JSON
        final configFile = File('${bgDir.path}/current_cnp_bg.json');
        final configData = {
          'current_bg': newFile.path
        };
        await configFile.writeAsString(json.encode(configData));
        
        setState(() {
          _backgroundImage = newFile;
        });
        
        print('Background saved: ${newFile.path}');
        
      } catch (e) {
        print('Error setting background: $e');
      }
    }
  }

  void _loadBackgroundImage() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final bgDir = Directory('${directory.path}/imeyou_pet/widget_backgrounds');
      
      if (bgDir.existsSync()) {
        // –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ JSON
        final configFile = File('${bgDir.path}/current_cnp_bg.json');
        if (configFile.existsSync()) {
          final jsonString = await configFile.readAsString();
          final configData = json.decode(jsonString);
          final bgPath = configData['current_bg'];
          
          if (bgPath != null && File(bgPath).existsSync()) {
            setState(() {
              _backgroundImage = File(bgPath);
            });
            print('Background loaded from config: $bgPath');
            return; // –í—ã—Ö–æ–¥–∏–º, –µ—Å–ª–∏ –Ω–∞—à–ª–∏ –≤ –∫–æ–Ω—Ñ–∏–≥–µ
          }
        }
        
        // –ï—Å–ª–∏ JSON –Ω–µ—Ç –∏–ª–∏ –ø—É—Ç—å –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π, –∏—â–µ–º –ª—é–±–æ–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Ñ–∞–π–ª
        final files = bgDir.listSync();
        for (var file in files) {
          if (file.path.endsWith('cnp_bg.png') || file.path.endsWith('cnp_bg.jpg')) {
            setState(() {
              _backgroundImage = File(file.path);
            });
            print('Background loaded from fallback: ${file.path}');
            break;
          }
        }
      }
    } catch (e) {
      print('Error loading background: $e');
    }
  }

  void _initializeApp() async {
    try {
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–∫–Ω–∞
      await windowManager.ensureInitialized();
      await windowManager.setAsFrameless();
      await windowManager.setSize(const Size(400, 700));
      await windowManager.setAlwaysOnTop(true);
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
      final directory = await getApplicationDocumentsDirectory();
      _copypasteDir = Directory('${directory.path}/copypasted');
      if (!_copypasteDir.existsSync()) {
        _copypasteDir.createSync(recursive: true);
      }

      // –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ –∏ –∑–∞–ø—É—Å–∫ —Å–ª—É—à–∞—Ç–µ–ª–µ–π
      await _loadClipboardHistory();
      _searchController.addListener(_filterHistory);
      _startFileWatcher();
      _startKeyboardListener();
      _loadBackgroundImage();
      
    } catch (e) {
      print('Error initializing app: $e');
      setState(() {
        _isLoading = false;
      });
    }
  }

  void _startFileWatcher() {
    _fileWatcher = _copypasteDir.watch(events: FileSystemEvent.all).listen((event) {
      if (event.type == FileSystemEvent.create || event.type == FileSystemEvent.modify) {
        // –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ —á—Ç–æ —Ñ–∞–π–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–ø–∏—Å–∞–Ω
        Future.delayed(const Duration(milliseconds: 100), () {
          _loadClipboardHistory();
        });
      }
    });
  }

  void _startKeyboardListener() {
    return;
    _keyboardInputTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      _checkKeyboardInput();
    });
  }

  void _checkKeyboardInput() {
    final now = DateTime.now();
    final timeDiff = now.difference(_lastTypedTime).inSeconds;
    
    // –ï—Å–ª–∏ –ø—Ä–æ—à–ª–æ –±–æ–ª—å—à–µ 45 —Å–µ–∫—É–Ω–¥ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤–≤–æ–¥–∞ –∏ –µ—Å—Ç—å –Ω–∞–±—Ä–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
    if (timeDiff > 45 && _currentTypedText.trim().isNotEmpty) {
      _saveKeyboardInput(_currentTypedText);
      _currentTypedText = '';
    }
  }

  bool _isValidContent(String content) {
    if (content.isEmpty) return false;
    
    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ç–µ–∫—Å—Ç–æ–≤ (–º–µ–Ω—å—à–µ 3 —Å–∏–º–≤–æ–ª–æ–≤)
    if (content.length < 3) return false;
    
    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Ç–æ–ª—å–∫–æ –ø—Ä–æ–±–µ–ª–æ–≤/–ø–µ—Ä–µ–Ω–æ—Å–æ–≤ —Å—Ç—Ä–æ–∫
    if (content.trim().isEmpty) return false;
    
    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Å–∏–º–≤–æ–ª–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "aaaaaaa")
    final regex = RegExp(r'^(.)\1+$');
    if (regex.hasMatch(content)) return false;
    
    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä –±–µ–∑ –±—É–∫–≤
    final onlyDigits = RegExp(r'^\d+$');
    if (onlyDigits.hasMatch(content) && content.length < 10) return false;
    
    return true;
  }

  Future<void> _saveKeyboardInput(String text) async {
    if (!_isValidContent(text)) return;
    
    try {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'keyboard_$timestamp.cnp';
      final file = File('${_copypasteDir.path}/$fileName');
      
      final entry = {
        'content': text,
        'timestamp': timestamp,
        'source': 'keyboard',
        'starred': false,
      };
      
      await file.writeAsString(jsonEncode(entry), encoding: utf8);
      print('Keyboard input saved: ${text.length} characters');
    } catch (e) {
      print('Error saving keyboard input: $e');
    }
  }

  Future<void> _saveToClipboardHistory(String text) async {
    if (!_isValidContent(text)) return;
    
    try {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'clipboard_$timestamp.cnp';
      final file = File('${_copypasteDir.path}/$fileName');
      
      final entry = {
        'content': text,
        'timestamp': timestamp,
        'source': 'clipboard',
        'starred': false,
      };
      
      await file.writeAsString(jsonEncode(entry), encoding: utf8);
      print('Clipboard content saved: ${text.length} characters');
    } catch (e) {
      print('Error saving clipboard content: $e');
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    _keyboardInputTimer.cancel();
    _fileWatcher.cancel();
    RawKeyboard.instance.removeListener(_handleKeyEvent);
    super.dispose();
  }
Future<void> _loadClipboardHistory() async {
  try {
    List<Map<String, dynamic>> history = [];
    
    if (_copypasteDir.existsSync()) {
      final files = _copypasteDir.listSync()
        .where((file) => file is File && file.path.endsWith('.cnp'))
        .toList();

      // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è
      files.sort((a, b) {
        final aStat = a.statSync();
        final bStat = b.statSync();
        return bStat.modified.compareTo(aStat.modified);
      });

      for (final file in files.take(100)) {
        try {
          final content = await File(file.path).readAsString(encoding: utf8);
          final entry = jsonDecode(content);
          
          if (entry is Map<String, dynamic>) {
            final textContent = entry['content']?.toString() ?? '';
            String itemType = entry['type'] as String? ?? 'text';
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –¥–ª—è —Ñ–∞–π–ª–æ–≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
            if (itemType == 'file') {
              final fileExtension = path.extension(textContent).toLowerCase();
              if (fileExtension == '.png' || fileExtension == '.jpg' || fileExtension == '.jpeg') {
                itemType = 'image';
              }
            }
            
            history.add({
              'content': textContent,
              'timestamp': entry['timestamp'] as int? ?? DateTime.now().millisecondsSinceEpoch,
              'length': textContent.length,
              'filePath': file.path,
              'starred': entry['starred'] as bool? ?? false,
              'source': entry['source'] as String? ?? 'clipboard',
              'type': itemType, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ç–∏–ø
              'file_info': entry['file_info'],
            });
          }
        } catch (e) {
          print('Error reading file ${file.path}: $e');
        }
      }
    }

    setState(() {
      _clipboardHistory = history;
      _filterHistory();
      _isLoading = false;
    });
    
  } catch (e) {
    print('Error loading history: $e');
    setState(() {
      _isLoading = false;
      _clipboardHistory = [];
      _filteredHistory = [];
    });
  }
}

 void _filterHistory() {
  final query = _searchController.text.toLowerCase().trim();
  setState(() {
    if (query.isEmpty) {
      _filteredHistory = _currentTab == 0 
          ? _clipboardHistory 
          : _clipboardHistory.where((item) => item['starred'] == true).toList();
    } else {
      final baseList = _currentTab == 0 
          ? _clipboardHistory 
          : _clipboardHistory.where((item) => item['starred'] == true).toList();
      
      // –†–∞–∑–±–∏–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞
      final queryWords = query.split(RegExp(r'\s+')).where((word) => word.length > 1).toList();
      
      // –ï—Å–ª–∏ –∑–∞–ø—Ä–æ—Å —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –æ–¥–Ω–æ–≥–æ —Å–ª–æ–≤–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫
      if (queryWords.length <= 1) {
        _filteredHistory = baseList.where((item) {
          final content = item['content']?.toString().toLowerCase() ?? '';
          final type = _getTypeDisplayName(item['type'] as String? ?? 'text').toLowerCase();
          final date = _formatDate(item['timestamp'] as int? ?? 0).toLowerCase();
          final time = _formatTime(item['timestamp'] as int? ?? 0).toLowerCase();
          
          return content.contains(query) || 
                 type.contains(query) || 
                 date.contains(query) || 
                 time.contains(query);
        }).toList();
      } else {
        // –î–ª—è –º–Ω–æ–≥–æ–∫–æ–º–ø–æ–Ω–µ–Ω—Ç–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª–æ–∂–Ω—É—é –ª–æ–≥–∏–∫—É —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏—è
        final List<Map<String, dynamic>> resultsWithScore = [];
        
        for (final item in baseList) {
          final content = item['content']?.toString().toLowerCase() ?? '';
          final type = _getTypeDisplayName(item['type'] as String? ?? 'text').toLowerCase();
          final date = _formatDate(item['timestamp'] as int? ?? 0).toLowerCase();
          final time = _formatTime(item['timestamp'] as int? ?? 0).toLowerCase();
          
          double score = 0.0;
          int foundWords = 0;
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ –∑–∞–ø—Ä–æ—Å–∞
          for (final word in queryWords) {
            bool wordFound = false;
            
            // –ü–æ–∏—Å–∫ —Ç–æ—á–Ω–æ–≥–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è —Å–ª–æ–≤–∞
            final wordVariations = _getWordVariations(word);
            for (final variation in wordVariations) {
              if (content.contains(variation)) {
                score += variation == word ? 3.0 : 2.5; // –ß—É—Ç—å –º–µ–Ω—å—à–µ –±–∞–ª–ª–æ–≤ –∑–∞ –≤–∞—Ä–∏–∞—Ü–∏–∏
                wordFound = true;
                break;
              }
            }
            
            // –ü–æ–∏—Å–∫ —á–∞—Å—Ç–∏—á–Ω–æ–≥–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è (–¥–ª—è –≤–µ—Ä—Å–∏–π —Å–ª–æ–≤)
            if (!wordFound) {
              // –ò—â–µ–º —Å–ª–æ–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å —ç—Ç–æ–≥–æ –∫–æ—Ä–Ω—è
              final wordPattern = RegExp(r'\b' + word);
              if (wordPattern.hasMatch(content)) {
                score += 2.0; // –°—Ä–µ–¥–Ω–∏–π –±–∞–ª–ª –∑–∞ —á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
                wordFound = true;
              }
            }
            
            // –ü–æ–∏—Å–∫ –≤ –¥—Ä—É–≥–∏—Ö –ø–æ–ª—è—Ö
            if (!wordFound) {
              if (type.contains(word) || date.contains(word) || time.contains(word)) {
                score += 1.0; // –ù–∏–∑–∫–∏–π –±–∞–ª–ª –∑–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –≤ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
                wordFound = true;
              }
            }
            
            if (wordFound) foundWords++;
          }
          
          // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –±–æ–Ω—É—Å—ã
          if (foundWords == queryWords.length) {
            score += 5.0; // –ë–æ–Ω—É—Å –∑–∞ –≤—Å–µ —Å–ª–æ–≤–∞
          }
          
          // –ë–æ–Ω—É—Å –∑–∞ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ
          if (item['starred'] == true) {
            score += 2.0;
          }
          
          // –®—Ç—Ä–∞—Ñ –∑–∞ –¥–ª–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (–ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–∏–º —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º)
          final lengthPenalty = content.length > 200 ? content.length / 1000.0 : 0.0;
          score -= lengthPenalty;
          
          // –ë–æ–Ω—É—Å –∑–∞ —Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –≤—Å–µ–π —Ñ—Ä–∞–∑—ã
          if (content.contains(query)) {
            score += 4.0;
          }
          
          // –ë–æ–Ω—É—Å –∑–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –≤ –Ω–∞—á–∞–ª–µ —Ç–µ–∫—Å—Ç–∞
          if (content.startsWith(query)) {
            score += 3.0;
          }
          
          if (foundWords > 0) {
            resultsWithScore.add({
              'item': item,
              'score': score,
              'foundWords': foundWords,
              'contentLength': content.length,
            });
          }
        }
        
        // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏
        resultsWithScore.sort((a, b) {
          final double scoreA = a['score'] as double;
          final double scoreB = b['score'] as double;
          
          // –°–Ω–∞—á–∞–ª–∞ –ø–æ –±–∞–ª–ª–∞–º (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)
          if (scoreB > scoreA) return 1;
          if (scoreB < scoreA) return -1;
          
          // –ó–∞—Ç–µ–º –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —Å–ª–æ–≤ (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)
          final int wordsA = a['foundWords'] as int;
          final int wordsB = b['foundWords'] as int;
          if (wordsB > wordsA) return 1;
          if (wordsB < wordsA) return -1;
          
          // –ó–∞—Ç–µ–º –ø–æ –¥–ª–∏–Ω–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é - –∫–æ—Ä–æ—Ç–∫–∏–µ –ø–µ—Ä–≤—ã–º–∏)
          final int lengthA = a['contentLength'] as int;
          final int lengthB = b['contentLength'] as int;
          return lengthA.compareTo(lengthB);
        });
        
        _filteredHistory = resultsWithScore.map((e) => e['item'] as Map<String, dynamic>).toList();
      }

      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–ª—è –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ (–µ—Å–ª–∏ –ø–æ–∏—Å–∫ –Ω–µ –º–Ω–æ–≥–æ–∫–æ–º–ø–æ–Ω–µ–Ω—Ç–Ω—ã–π)
      if (queryWords.length <= 1) {
        _filteredHistory.sort((a, b) {
          final aStarred = a['starred'] as bool? ?? false;
          final bStarred = b['starred'] as bool? ?? false;
          
          if (aStarred && !bStarred) return -1;
          if (!aStarred && bStarred) return 1;
          return 0;
        });
      }
    }
  });
}

// –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –≤ –∫–ª–∞—Å—Å
List<String> _getWordVariations(String word) {
  final variations = <String>[];
  
  // –ë–∞–∑–æ–≤–æ–µ —Å–ª–æ–≤–æ
  variations.add(word);
  
  // –ü—Ä–æ—Å—Ç—ã–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–ª—è —Ä—É—Å—Å–∫–æ–≥–æ —è–∑—ã–∫–∞
  if (word.length > 3) {
    if (word.endsWith('–∞')) {
      variations.add(word.substring(0, word.length - 1)); // –º–∞—à–∞ -> –º–∞—à
    }
    if (word.endsWith('—è')) {
      variations.add(word.substring(0, word.length - 1)); // —Ç–∞–Ω—Ü—É—é -> —Ç–∞–Ω—Ü—É
    }
    if (word.endsWith('–æ')) {
      variations.add(word.substring(0, word.length - 1)); // —è–±–ª–æ–∫–æ -> —è–±–ª–æ–∫
    }
    if (word.endsWith('—ã')) {
      variations.add(word.substring(0, word.length - 1)); // —è–±–ª–æ–∫–∏ -> —è–±–ª–æ–∫
    }
    if (word.endsWith('–∏')) {
      variations.add(word.substring(0, word.length - 1)); // –≥—Ä—É—à–∏ -> –≥—Ä—É—à
    }
  }
  
  return variations;
}
String _getTypeDisplayName(String type) {
  switch (type) {
    case 'file': return '–§–∞–π–ª';
    case 'image_url': return '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ';
    case 'url': return '–°—Å—ã–ª–∫–∞';
    case 'document_url': return '–î–æ–∫—É–º–µ–Ω—Ç';
    case 'email': return 'Email';
    case 'code': return '–ö–æ–¥';
    case 'html': return 'HTML';
    case 'keyboard': return '–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞';
    case 'image': return '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ';
    default: return '–¢–µ–∫—Å—Ç';
  }
}

  Color _getTypeBorderColor(String type) {
    switch (type) {
      case 'file': return Colors.orange;
      case 'image_url': return Colors.pink;
      case 'image': return Colors.pink;
      case 'url': return Colors.blue;
      case 'document_url': return Colors.purple;
      case 'email': return Colors.green;
      case 'code': return Colors.cyan;
      case 'html': return Colors.yellow;
      case 'keyboard': return Colors.grey;
      default: return Colors.white;
    }
  }

  Future<void> _copyToClipboard(Map<String, dynamic> item) async {
    try {
      final content = item['content']?.toString() ?? '';
      final type = item['type'] as String? ?? 'text';
      
      if (type == 'file') {
        final file = File(content);
        if (await file.exists()) {
          if (Platform.isWindows) {
            await _copyFileToClipboardWindows(content);
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text('–§–∞–π–ª —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞'),
                backgroundColor: Colors.green,
                duration: const Duration(seconds: 2),
              ),
            );
          } else {
            await Clipboard.setData(ClipboardData(text: content));
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Text('–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞'),
                backgroundColor: Colors.green,
                duration: const Duration(seconds: 2),
              ),
            );
          }
        } else {
          await Clipboard.setData(ClipboardData(text: content));
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –ø—É—Ç—å'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 2),
            ),
          );
        }
      } else {
        await Clipboard.setData(ClipboardData(text: content));
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞'),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      print('Error copying to clipboard: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: $e'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  Future<void> _openItem(Map<String, dynamic> item) async {
    try {
      final content = item['content']?.toString() ?? '';
      final type = item['type'] as String? ?? 'text';
      
      if (type == 'url' || type == 'image_url' || type == 'document_url') {
        // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É –≤ –±—Ä–∞—É–∑–µ—Ä–µ
        if (await canLaunch(content)) {
          await launch(content);
        } else {
          throw Exception('Could not launch $content');
        }
      } else if (type == 'file') {
        // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ñ–∞–π–ª
        final file = File(content);
        if (await file.exists()) {
          if (Platform.isWindows) {
            await Process.run('start', ['""', content], runInShell: true);
          } else if (Platform.isMacOS) {
            await Process.run('open', [content]);
          } else if (Platform.isLinux) {
            await Process.run('xdg-open', [content]);
          }
        } else {
          throw Exception('File not found: $content');
        }
      }
    } catch (e) {
      print('Error opening item: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è: $e'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  Future<void> _copyFileToClipboardWindows(String filePath) async {
    try {
      final powerShellScript = '''
        Add-Type -AssemblyName System.Windows.Forms
        \$file = Get-Item '$filePath'
        
        if (\$file.Attributes -band [System.IO.FileAttributes]::Directory) {
          [System.Windows.Forms.Clipboard]::SetText('$filePath')
        } else {
          \$collection = New-Object System.Collections.Specialized.StringCollection
          \$collection.Add('$filePath')
          [System.Windows.Forms.Clipboard]::SetFileDropList(\$collection)
        }
      ''';

      final result = await Process.run('powershell', [
        '-NoProfile',
        '-ExecutionPolicy', 
        'Bypass',
        '-Command',
        powerShellScript
      ]);

      if (result.stderr != null && result.stderr.toString().isNotEmpty) {
        print('PowerShell error: ${result.stderr}');
        await Clipboard.setData(ClipboardData(text: filePath));
      }
    } catch (e) {
      print('Error copying file to clipboard: $e');
      await Clipboard.setData(ClipboardData(text: filePath));
    }
  }

  Future<void> _toggleStar(Map<String, dynamic> item) async {
    try {
      final filePath = item['filePath']?.toString();
      if (filePath != null && File(filePath).existsSync()) {
        final currentStarred = item['starred'] as bool? ?? false;
        final newStarred = !currentStarred;
        
        final content = await File(filePath).readAsString(encoding: utf8);
        final entry = jsonDecode(content) as Map<String, dynamic>;
        
        entry['starred'] = newStarred;
        
        await File(filePath).writeAsString(jsonEncode(entry), encoding: utf8);
        
        _loadClipboardHistory();
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(newStarred ? '–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ' : '–£–¥–∞–ª–µ–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'),
            backgroundColor: Colors.blue,
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      print('Error toggling star: $e');
    }
  }

  Future<void> _deleteItem(Map<String, dynamic> item) async {
    try {
      final filePath = item['filePath']?.toString();
      if (filePath != null && File(filePath).existsSync()) {
        await File(filePath).delete();
      }
    } catch (e) {
      print('Error deleting file: $e');
    }
    
    setState(() {
      _clipboardHistory.remove(item);
      _filteredHistory.remove(item);
    });
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('–≠–ª–µ–º–µ–Ω—Ç —É–¥–∞–ª–µ–Ω'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 2),
      ),
    );
  }

  Future<void> _clearAllHistory() async {
    try {
      int deletedCount = 0;
      int skippedCount = 0;
      
      if (_copypasteDir.existsSync()) {
        final files = _copypasteDir.listSync()
          .where((file) => file is File && file.path.endsWith('.cnp'))
          .toList();

        for (final file in files) {
          try {
            final content = await File(file.path).readAsString(encoding: utf8);
            final entry = jsonDecode(content) as Map<String, dynamic>;
            
            final isStarred = entry['starred'] as bool? ?? false;
            
            if (isStarred) {
              skippedCount++;
              continue;
            }
            
            await file.delete();
            deletedCount++;
            
          } catch (e) {
            print('Error processing file ${file.path}: $e');
            skippedCount++;
          }
        }
      }

      _loadClipboardHistory();

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–£–¥–∞–ª–µ–Ω–æ $deletedCount —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ $skippedCount –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 3),
        ),
      );
    } catch (e) {
      print('Error clearing history: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏: $e'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  void _toggleSelection(Map<String, dynamic> item) {
    final filePath = item['filePath']?.toString() ?? '';
    setState(() {
      if (_selectedItems.contains(filePath)) {
        _selectedItems.remove(filePath);
      } else {
        _selectedItems.add(filePath);
      }
      _showExportOptions = _selectedItems.isNotEmpty;
    });
  }

  bool _isSelected(Map<String, dynamic> item) {
    return _selectedItems.contains(item['filePath']?.toString() ?? '');
  }
Future<void> _executeCompose() async {
  try {
    // –ü–æ–ª—É—á–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
    final selectedItems = _clipboardHistory.where(
      (item) => _selectedItems.contains(item['filePath']?.toString() ?? '')
    ).toList();

    if (selectedItems.isEmpty) return;

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —ç–∫—Å–ø–æ—Ä—Ç–∞
    String exportType = _exportMode;
    if (_exportMode == 'auto') {
      exportType = _determineExportType(selectedItems);
    }

    // –í—ã–ø–æ–ª–Ω—è–µ–º —ç–∫—Å–ø–æ—Ä—Ç
    String? resultPath;
    switch (exportType) {
      case 'text':
        resultPath = await _exportAsText(selectedItems);
        break;
      case 'image':
        resultPath = await _exportAsImage(selectedItems);
        break;
      case 'html':
        resultPath = await _exportAsHtml(selectedItems);
        break;
      case 'archive':
        resultPath = await _exportAsArchive(selectedItems);
        break;
      case 'separate':
        resultPath = await _exportAsSeparateFiles(selectedItems);
        break;
    }

    // –û—á–∏—â–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ —ç–∫—Å–ø–æ—Ä—Ç–∞
    setState(() {
      _selectedItems.clear();
      _showExportOptions = false;
    });

    // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –µ—Å–ª–∏ –µ—Å—Ç—å –ø—É—Ç—å
    if (resultPath != null && await File(resultPath).exists()) {
      await _openResultFile(resultPath, exportType);
    }

  } catch (e) {
    print('Error during compose: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: $e'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

String _determineExportType(List<Map<String, dynamic>> items) {
  final hasImages = items.any((item) => item['type'] == 'image' || item['type'] == 'image_url');
  final hasText = items.any((item) => item['type'] == 'text' || item['type'] == 'code' || item['type'] == 'html');
  final hasFiles = items.any((item) => item['type'] == 'file');
  
  if (hasFiles) return 'archive';
  if (hasImages || hasText) return 'html'; // HTML –¥–æ—Å—Ç—É–ø–µ–Ω –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –∏ —Ç–µ–∫—Å—Ç–∞ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
  if (hasImages) return 'image';
  if (hasText) return 'text';
  return 'archive';
}
 Future<String?> _exportAsText(List<Map<String, dynamic>> items) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final buffer = StringBuffer();
    for (final item in items) {
      if (item['type'] == 'text' || item['type'] == 'code' || item['type'] == 'html') {
        buffer.writeln(item['content']?.toString() ?? '');
        buffer.writeln('---'); // –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
      }
    }

    final content = buffer.toString();
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final file = File('${exportDir.path}/text_export_$timestamp.txt');
    await file.writeAsString(content, encoding: utf8);

    await Clipboard.setData(ClipboardData(text: content));

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–¢–µ–∫—Å—Ç —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω: ${file.path}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );
    
    return file.path;
  } catch (e) {
    print('Error exporting text: $e');
    rethrow;
  }
}

Future<String?> _exportAsSeparateFiles(List<Map<String, dynamic>> items) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export/separate_${DateTime.now().millisecondsSinceEpoch}');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    for (final item in items) {
      try {
        final content = item['content']?.toString() ?? '';
        final type = item['type'] as String? ?? 'text';
        final timestamp = item['timestamp'] as int? ?? 0;
        final fileInfo = item['file_info'] as Map<String, dynamic>?;
        
        String extension = '.txt';
        String filename = 'item_${items.indexOf(item)}';
        
        switch (type) {
          case 'image':
            // –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–∞–∫ –µ—Å—Ç—å
            final sourceFile = File(content);
            if (await sourceFile.exists()) {
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              final targetFile = File('${exportDir.path}/$originalName');
              await sourceFile.copy(targetFile.path);
              print('Copied image: ${sourceFile.path} -> ${targetFile.path} (${sourceFile.lengthSync()} bytes)');
            }
            break;
            
          case 'file':
            // –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª –∫–∞–∫ –µ—Å—Ç—å
            final sourceFile = File(content);
            if (await sourceFile.exists()) {
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              final targetFile = File('${exportDir.path}/$originalName');
              await sourceFile.copy(targetFile.path);
            }
            break;
            
          default:
            // –¢–µ–∫—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
            switch (type) {
              case 'code': extension = '.txt'; break;
              case 'html': extension = '.html'; break;
              case 'url': extension = '.url.txt'; break;
            }
            final file = File('${exportDir.path}/$filename$extension');
            await file.writeAsString(content, encoding: utf8);
            break;
        }
      } catch (e) {
        print('Error exporting separate file: $e');
      }
    }

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–§–∞–π–ª—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã: ${exportDir.path}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );
    
    return exportDir.path;
  } catch (e) {
    print('Error exporting separate files: $e');
    rethrow;
  }
}

Future<String?> _exportAsImage(List<Map<String, dynamic>> items) async {
  try {
    final imageItems = items.where((item) => 
      item['type'] == 'image' || item['type'] == 'image_url'
    ).toList();

    if (imageItems.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('–ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞'),
          backgroundColor: Colors.orange,
          duration: const Duration(seconds: 3),
        ),
      );
      return null;
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    final List<img.Image> loadedImages = [];
    final List<String> imageSources = [];

    for (final item in imageItems) {
      try {
        final content = item['content']?.toString() ?? '';
        final type = item['type'] as String? ?? 'text';
        
        img.Image? image;
        
        if (type == 'image_url') {
          // –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ URL
          final response = await http.get(Uri.parse(content));
          if (response.statusCode == 200) {
            image = img.decodeImage(response.bodyBytes);
          }
        } else if (type == 'image') {
          // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑ —Ñ–∞–π–ª–∞
          final file = File(content);
          if (await file.exists()) {
            final bytes = await file.readAsBytes();
            image = img.decodeImage(bytes);
          }
        }
        
        if (image != null) {
          loadedImages.add(image);
          imageSources.add(content);
        }
      } catch (e) {
        print('Error loading image: $e');
      }
    }

    if (loadedImages.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
      return null;
    }

    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ —Å–æ–∑–¥–∞–µ–º –∫–æ–ª–ª–∞–∂
    final img.Image collage = await _createCollage(loadedImages);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–ª–ª–∞–∂
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final outputFile = File('${exportDir.path}/collage_$timestamp.png');
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ PNG
    final pngBytes = img.encodePng(collage);
    await outputFile.writeAsBytes(pngBytes);

    // –ö–æ–ø–∏—Ä—É–µ–º –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
    await _copyImageToClipboard(pngBytes);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–ö–æ–ª–ª–∞–∂ —Å–æ–∑–¥–∞–Ω: ${outputFile.path}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );

    return outputFile.path;

  } catch (e) {
    print('Error creating image collage: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–ª–ª–∞–∂–∞: $e'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
    return null;
  }
}

Future<img.Image> _createCollage(List<img.Image> images) async {
  if (images.length == 1) {
    // –ï—Å–ª–∏ –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ - –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ
    return images.first;
  }

  // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä—ã –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
  final List<ImageInfo> imageInfos = [];
  int totalWidth = 0;
  int totalHeight = 0;
  bool allLandscape = true;
  bool allPortrait = true;
  bool allSameSize = true;
  int firstWidth = images.first.width;
  int firstHeight = images.first.height;

  for (final image in images) {
    final bool isLandscape = image.width >= image.height;
    final bool isPortrait = image.height > image.width;
    
    imageInfos.add(ImageInfo(
      image: image,
      width: image.width,
      height: image.height,
      isLandscape: isLandscape,
      isPortrait: isPortrait,
      aspectRatio: image.width / image.height
    ));

    allLandscape = allLandscape && isLandscape;
    allPortrait = allPortrait && isPortrait;
    allSameSize = allSameSize && 
                  image.width == firstWidth && 
                  image.height == firstHeight;
  }

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –∫–æ–º–ø–æ–Ω–æ–≤–∫–∏
  CollageStrategy strategy;
  
  if (allLandscape && allSameSize) {
    // –í—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∞–ª—å–±–æ–º–Ω—ã–µ –∏ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ - –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Ä—è–¥
    strategy = _createHorizontalRowStrategy(images, 1920, 1080);
  } else if (allPortrait && allSameSize) {
    // –í—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ—Ä—Ç—Ä–µ—Ç–Ω—ã–µ –∏ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ - –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –∫–æ–ª–æ–Ω–∫–∞
    strategy = _createVerticalColumnStrategy(images, 1080, 1920);
  } else if (allLandscape) {
    // –í—Å–µ –∞–ª—å–±–æ–º–Ω—ã–µ, –Ω–æ —Ä–∞–∑–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤ - –∞–¥–∞–ø—Ç–∏–≤–Ω–∞—è —Å–µ—Ç–∫–∞
    strategy = _createAdaptiveGridStrategy(images, 1920, 1080, true);
  } else if (allPortrait) {
    // –í—Å–µ –ø–æ—Ä—Ç—Ä–µ—Ç–Ω—ã–µ, –Ω–æ —Ä–∞–∑–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤ - –∞–¥–∞–ø—Ç–∏–≤–Ω–∞—è —Å–µ—Ç–∫–∞
    strategy = _createAdaptiveGridStrategy(images, 1080, 1920, false);
  } else {
    // –°–º–µ—à–∞–Ω–Ω—ã–µ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ - –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è –∫–æ–º–ø–æ–Ω–æ–≤–∫–∞
    strategy = _createMixedOrientationStrategy(images, 1920, 1080);
  }

  // –°–æ–∑–¥–∞–µ–º —Ö–æ–ª—Å—Ç
  final canvas = img.Image(
    width: strategy.canvasWidth,
    height: strategy.canvasHeight,
  );

  // –†–∏—Å—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ —Ö–æ–ª—Å—Ç–µ
  for (final placement in strategy.placements) {
    final resizedImage = img.copyResize(
      placement.image,
      width: placement.width,
      height: placement.height,
    );
    
    img.compositeImage(
      canvas,
      resizedImage,
      dstX: placement.x,
      dstY: placement.y,
    );
  }

  return canvas;
}

Future<void> _copyImageToClipboard(List<int> imageBytes) async {
  try {
    if (Platform.isWindows) {
      await _copyImageToClipboardWindows(imageBytes);
    } else {
      // –î–ª—è –¥—Ä—É–≥–∏—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º –ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Ç—å
      final tempDir = await getTemporaryDirectory();
      final tempFile = File('${tempDir.path}/clipboard_image.png');
      await tempFile.writeAsBytes(imageBytes);
      
      await Clipboard.setData(ClipboardData(text: tempFile.path));
    }
  } catch (e) {
    print('Error copying image to clipboard: $e');
    // Fallback - –∫–æ–ø–∏—Ä—É–µ–º –∫–∞–∫ —Ç–µ–∫—Å—Ç
    await Clipboard.setData(ClipboardData(text: '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ, –Ω–æ –Ω–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä'));
  }
}

Future<void> _copyImageToClipboardWindows(List<int> imageBytes) async {
  try {
    final powerShellScript = '''
      Add-Type -AssemblyName System.Windows.Forms
      Add-Type -AssemblyName System.Drawing
      
      \$memoryStream = New-Object System.IO.MemoryStream
      \$memoryStream.Write([byte[]] @(${imageBytes.join(',')}), 0, ${imageBytes.length})
      \$memoryStream.Seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
      
      \$bitmap = [System.Drawing.Bitmap]::FromStream(\$memoryStream)
      [System.Windows.Forms.Clipboard]::SetImage(\$bitmap)
      
      \$bitmap.Dispose()
      \$memoryStream.Dispose()
    ''';

    final result = await Process.run('powershell', [
      '-NoProfile',
      '-ExecutionPolicy', 
      'Bypass',
      '-Command',
      powerShellScript
    ]);

    if (result.stderr != null && result.stderr.toString().isNotEmpty) {
      print('PowerShell error: ${result.stderr}');
      throw Exception('PowerShell execution failed');
    }
  } catch (e) {
    print('Error in Windows image copy: $e');
    rethrow;
  }
}
Future<String?> _exportAsHtml(List<Map<String, dynamic>> items) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export/html_${DateTime.now().millisecondsSinceEpoch}');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final htmlBuffer = StringBuffer();
    htmlBuffer.writeln('<!DOCTYPE html>');
    htmlBuffer.writeln('<html lang="ru">');
    htmlBuffer.writeln('<head>');
    htmlBuffer.writeln('<meta charset="UTF-8">');
    htmlBuffer.writeln('<meta name="viewport" content="width=device-width, initial-scale=1.0">');
    htmlBuffer.writeln('<title>QWA Clipboard Export</title>');
    htmlBuffer.writeln(_htmlCss);
    htmlBuffer.writeln('</head>');
    htmlBuffer.writeln('<body>');
    
    htmlBuffer.writeln('<div class="header">');
    htmlBuffer.writeln('<h1>Clipboard Export</h1>');
    htmlBuffer.writeln('<p>–°–æ–∑–¥–∞–Ω–æ: ${DateTime.now()}</p>');
    htmlBuffer.writeln('</div>');

    for (final item in items) {
      final type = item['type'] as String? ?? 'text';
      final content = item['content']?.toString() ?? '';
      final timestamp = item['timestamp'] as int? ?? 0;

      switch (type) {
        case 'text':
        case 'email':
        case 'url':
          htmlBuffer.writeln('<div class="text-block">');
          htmlBuffer.writeln(content);
          htmlBuffer.writeln('<div class="timestamp">${_formatDate(timestamp)} ${_formatTime(timestamp)}</div>');
          htmlBuffer.writeln('</div>');
          break;
        
        case 'code':
        case 'html':
          htmlBuffer.writeln('<div class="code-block">');
          htmlBuffer.writeln(content);
          htmlBuffer.writeln('<div class="timestamp">${_formatDate(timestamp)} ${_formatTime(timestamp)}</div>');
          htmlBuffer.writeln('</div>');
          break;
        
        case 'image':
        case 'image_url':
          htmlBuffer.writeln('<div class="image-block">');
          // –î–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω—É–∂–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ base64
          htmlBuffer.writeln('<img src="$content" alt="Image">');
          htmlBuffer.writeln('<div class="image-caption">${_formatDate(timestamp)} ${_formatTime(timestamp)}</div>');
          htmlBuffer.writeln('</div>');
          break;
      }
    }

    htmlBuffer.writeln('</body>');
    htmlBuffer.writeln('</html>');

    final htmlFile = File('${exportDir.path}/export.html');
    await htmlFile.writeAsString(htmlBuffer.toString(), encoding: utf8);

    // –ö–æ–ø–∏—Ä—É–µ–º HTML –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
    await Clipboard.setData(ClipboardData(text: htmlBuffer.toString()));

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('HTML —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω: ${htmlFile.path}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );
    
    return htmlFile.path;
  } catch (e) {
    print('Error exporting HTML: $e');
    rethrow;
  }
}
Future<String?> _exportAsArchive(List<Map<String, dynamic>> items) async {
  try {
    if (items.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('–ù–µ—Ç —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –∞—Ä—Ö–∏–≤–∞—Ü–∏–∏'),
          backgroundColor: Colors.orange,
          duration: const Duration(seconds: 3),
        ),
      );
      return null;
    }

    final archive = Archive();
    int addedFiles = 0;

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç
    for (final item in items) {
      try {
        final content = item['content']?.toString() ?? '';
        final type = item['type'] as String? ?? 'text';
        final timestamp = item['timestamp'] as int? ?? DateTime.now().millisecondsSinceEpoch;
        final fileInfo = item['file_info'] as Map<String, dynamic>?;

        switch (type) {
          case 'text':
          case 'code':
          case 'html':
          case 'email':
          case 'url':
          case 'document_url':
          case 'image_url':
          case 'keyboard':
            // –¢–µ–∫—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
            final extension = _getFileExtension(type);
            final filename = 'text_${items.indexOf(item)}_$timestamp$extension';
            final data = utf8.encode(content);
            archive.addFile(ArchiveFile(filename, data.length, data));
            addedFiles++;
            break;

          case 'image':
            // –õ–æ–∫–∞–ª—å–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è - —á–∏—Ç–∞–µ–º –∫–∞–∫ –±–∏–Ω–∞—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            final file = File(content);
            if (await file.exists()) {
              final bytes = await file.readAsBytes();
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              final filename = 'image_${items.indexOf(item)}_$originalName';
              archive.addFile(ArchiveFile(filename, bytes.length, bytes));
              addedFiles++;
              print('Added image to archive: $filename (${bytes.length} bytes)');
            }
            break;

          case 'file':
            // –§–∞–π–ª—ã –∏–∑ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
            final file = File(content);
            if (await file.exists()) {
              final bytes = await file.readAsBytes();
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              final filename = 'file_${items.indexOf(item)}_$originalName';
              archive.addFile(ArchiveFile(filename, bytes.length, bytes));
              addedFiles++;
              print('Added file to archive: $filename (${bytes.length} bytes)');
            }
            break;

          default:
            // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ —Ç–µ–∫—Å—Ç
            final filename = 'unknown_${items.indexOf(item)}_$timestamp.txt';
            final data = utf8.encode('Type: $type\nContent: $content');
            archive.addFile(ArchiveFile(filename, data.length, data));
            addedFiles++;
            break;
        }
      } catch (e) {
        print('Error processing item for archive: $e');
      }
    }

    if (addedFiles == 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª—ã –≤ –∞—Ä—Ö–∏–≤'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
      return null;
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞—Ä—Ö–∏–≤
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final zipFile = File('${exportDir.path}/archive_$timestamp.zip');
    
    // –ö–æ–¥–∏—Ä—É–µ–º –∞—Ä—Ö–∏–≤ –≤ ZIP
    final zipData = ZipEncoder().encode(archive);
    if (zipData != null) {
      await zipFile.writeAsBytes(zipData);
      print('Archive created: ${zipFile.path} (${zipData.length} bytes)');

      // –ö–æ–ø–∏—Ä—É–µ–º –ø—É—Ç—å –∫ –∞—Ä—Ö–∏–≤—É –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
      await Clipboard.setData(ClipboardData(text: zipFile.path));

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–ê—Ä—Ö–∏–≤ —Å–æ–∑–¥–∞–Ω: $addedFiles —Ñ–∞–π–ª–æ–≤\n${zipFile.path}'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 4),
        ),
      );
      
      return zipFile.path;
    } else {
      throw Exception('Failed to encode ZIP archive');
    }

  } catch (e) {
    print('Error creating archive: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞—Ä—Ö–∏–≤–∞: $e'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
    return null;
  }
}

String _getFileExtension(String type) {
  switch (type) {
    case 'code':
      return '.txt';
    case 'html':
      return '.html';
    case 'url':
    case 'document_url':
    case 'image_url':
      return '.url.txt';
    case 'email':
      return '.email.txt';
    case 'keyboard':
      return '.keyboard.txt';
    default:
      return '.txt';
  }
}
Future<void> _openResultFile(String filePath, String exportType) async {
  try {
    if (exportType == 'html') {
      // –û—Ç–∫—Ä—ã–≤–∞–µ–º HTML –≤ –±—Ä–∞—É–∑–µ—Ä–µ
      if (await canLaunch(filePath)) {
        await launch(filePath);
      } else {
        // –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç—å –∫–∞–∫ —Ñ–∞–π–ª, –ø—Ä–æ–±—É–µ–º –∫–∞–∫ file:// URL
        await launch('file://$filePath');
      }
    } else if (exportType == 'text') {
      // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Ñ–∞–π–ª
      if (Platform.isWindows) {
        await Process.run('notepad', [filePath], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', ['-t', filePath]);
      } else if (Platform.isLinux) {
        await Process.run('xdg-open', [filePath]);
      }
    } else if (exportType == 'image') {
      // –û—Ç–∫—Ä—ã–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º –ø—Ä–æ—Å–º–æ—Ç—Ä—â–∏–∫–µ
      if (Platform.isWindows) {
        await Process.run('start', ['""', filePath], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', [filePath]);
      } else if (Platform.isLinux) {
        await Process.run('xdg-open', [filePath]);
      }
    } else if (exportType == 'archive' || exportType == 'separate') {
      // –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–∞–ø–∫—É –∏ –≤—ã–¥–µ–ª—è–µ–º —Ñ–∞–π–ª/–ø–∞–ø–∫—É
      final directory = path.dirname(filePath);
      if (Platform.isWindows) {
        await Process.run('explorer', ['/select,', filePath], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', ['-R', filePath]);
      } else if (Platform.isLinux) {
        await Process.run('xdg-open', [directory]);
      }
    }
  } catch (e) {
    print('Error opening result file: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–§–∞–π–ª —Å–æ–∑–¥–∞–Ω, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å: $e'),
        backgroundColor: Colors.orange,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

void _ensureDirectoryInArchive(Archive archive, String directoryPath) {
  final parts = directoryPath.split('/');
  String currentPath = '';
  
  for (final part in parts) {
    if (part.isEmpty) continue;
    
    currentPath = currentPath.isEmpty ? part : '$currentPath/$part';
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
    final exists = archive.files.any((file) => 
      file.name == '$currentPath/' || file.name.startsWith('$currentPath/')
    );
    
    if (!exists) {
      // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
      archive.addFile(ArchiveFile('$currentPath/', 0, []));
    }
  }
}

// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∞—Ä—Ö–∏–≤–∞ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
Future<void> _exportAsArchiveWithMetadata(List<Map<String, dynamic>> items) async {
  try {
    final archive = Archive();
    int addedFiles = 0;

    // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∞–π–ª —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
    final metadata = StringBuffer();
    metadata.writeln('QWA Clipboard Export Archive');
    metadata.writeln('Created: ${DateTime.now()}');
    metadata.writeln('Total items: ${items.length}');
    metadata.writeln('\n=== Items List ===');
    
    for (final item in items) {
      final index = items.indexOf(item);
      final type = item['type'] as String? ?? 'text';
      final timestamp = item['timestamp'] as int? ?? 0;
      final starred = item['starred'] as bool? ?? false;
      
      metadata.writeln('\nItem $index:');
      metadata.writeln('  Type: $type');
      metadata.writeln('  Date: ${_formatDate(timestamp)} ${_formatTime(timestamp)}');
      metadata.writeln('  Starred: $starred');
      metadata.writeln('  Source: ${item['source']}');
      
      if (type == 'file') {
        final fileInfo = item['file_info'] as Map<String, dynamic>?;
        metadata.writeln('  File: ${fileInfo?['name'] ?? item['content']}');
        if (fileInfo?['size'] != null) {
          metadata.writeln('  Size: ${_formatFileSize(fileInfo!['size'])}');
        }
      } else {
        final content = item['content']?.toString() ?? '';
        final preview = content.length > 100 ? 
            '${content.substring(0, 100)}...' : content;
        metadata.writeln('  Preview: $preview');
      }
    }

    final metadataBytes = utf8.encode(metadata.toString());
    archive.addFile(ArchiveFile('metadata.txt', metadataBytes.length, metadataBytes));
    addedFiles++;

    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã (–∫–∞–∫ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –º–µ—Ç–æ–¥–µ)
    for (final item in items) {
      try {
        final content = item['content']?.toString() ?? '';
        final type = item['type'] as String? ?? 'text';
        final timestamp = item['timestamp'] as int? ?? DateTime.now().millisecondsSinceEpoch;
        final fileInfo = item['file_info'] as Map<String, dynamic>?;

        String filename;
        List<int> data;

        switch (type) {
          case 'text':
          case 'code':
          case 'html':
          case 'email':
          case 'url':
          case 'document_url':
          case 'image_url':
          case 'keyboard':
            final extension = _getFileExtension(type);
            filename = 'items/item_${items.indexOf(item)}$extension';
            data = utf8.encode(content);
            break;

          case 'image':
            final file = File(content);
            if (await file.exists()) {
              data = await file.readAsBytes();
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              filename = 'images/$originalName';
            } else {
              continue;
            }
            break;

          case 'file':
            final file = File(content);
            if (await file.exists()) {
              data = await file.readAsBytes();
              final originalName = fileInfo?['name']?.toString() ?? path.basename(content);
              filename = 'files/$originalName';
            } else {
              continue;
            }
            break;

          default:
            filename = 'unknown/item_${items.indexOf(item)}.txt';
            data = utf8.encode('Type: $type\nContent: $content');
            break;
        }

        // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        final dirPath = path.dirname(filename);
        if (dirPath.isNotEmpty && dirPath != '.') {
          _ensureDirectoryInArchive(archive, dirPath);
        }

        archive.addFile(ArchiveFile(filename, data.length, data));
        addedFiles++;

      } catch (e) {
        print('Error processing item for archive: $e');
      }
    }

    if (addedFiles == 0) {
      throw Exception('No files were added to archive');
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞—Ä—Ö–∏–≤
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/qwa_clipboard_export');
    if (!exportDir.existsSync()) {
      exportDir.createSync(recursive: true);
    }

    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final zipFile = File('${exportDir.path}/archive_${timestamp}_with_metadata.zip');
    
    final zipData = ZipEncoder().encode(archive);
    if (zipData != null) {
      await zipFile.writeAsBytes(zipData);
      await Clipboard.setData(ClipboardData(text: zipFile.path));

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('–ê—Ä—Ö–∏–≤ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ —Å–æ–∑–¥–∞–Ω: $addedFiles —Ñ–∞–π–ª–æ–≤'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 4),
        ),
      );
    }

  } catch (e) {
    print('Error creating archive with metadata: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞—Ä—Ö–∏–≤–∞: $e'),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

String _formatFileSize(dynamic size) {
  try {
    final bytes = size is int ? size : int.tryParse(size.toString()) ?? 0;
    if (bytes == 0) return '0 B';
    
    const units = ['B', 'KB', 'MB', 'GB'];
    var unitIndex = 0;
    double value = bytes.toDouble();
    
    while (value >= 1024 && unitIndex < units.length - 1) {
      value /= 1024;
      unitIndex++;
    }
    
    return '${value.toStringAsFixed(1)} ${units[unitIndex]}';
  } catch (e) {
    return 'Unknown';
  }
}

Widget _buildHistoryItem(Map<String, dynamic> item) {
  return HistoryItemWidget(
    item: item,
    isSelected: _isSelected(item),
    onCopy: () => _copyToClipboard(item),
    onLongPress: () {
      final type = item['type'] as String? ?? 'text';
      if (type == 'text' || type == 'code') {
        setState(() {
          _expandedItem = item;
        });
      } else {
        _openItem(item);
      }
    },
    onToggleSelection: () => _toggleSelection(item),
    onToggleStar: () => _toggleStar(item),
    onDelete: () => _deleteItem(item),
    showExportOptions: _showExportOptions,
  );
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∞–π–ª–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
Future<File> _getImageFile(String content, Map<String, dynamic>? fileInfo) async {
  try {
    final file = File(content);
    if (await file.exists()) {
      return file;
    } else {
      // –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –∏–∑ base64 –∏–ª–∏ –¥—Ä—É–≥–∏—Ö –¥–∞–Ω–Ω—ã—Ö
      throw Exception('File not found');
    }
  } catch (e) {
    throw Exception('Failed to load image: $e');
  }
}

  Widget _buildExpandedView() {
    if (_expandedItem == null) return const SizedBox.shrink();

    final content = _expandedItem!['content']?.toString() ?? '';
    final timestamp = _expandedItem!['timestamp'] as int? ?? 0;
    final type = _expandedItem!['type'] as String? ?? 'text';

    return Positioned.fill(
      child: Container(
        color: Colors.black.withOpacity(0.9),
        child: Column(
          children: [
            // –ó–∞–≥–æ–ª–æ–≤–æ–∫
            Container(
              height: 60,
              padding: const EdgeInsets.symmetric(horizontal: 16),
              decoration: BoxDecoration(
                color: const Color(0xFF1A1A1A).withOpacity(0.9),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12),
                ),
              ),
              child: Row(
                children: [
                  IconButton(
                    icon: const Icon(Icons.arrow_back, color: Colors.white),
                    onPressed: () {
                      setState(() {
                        _expandedItem = null;
                      });
                    },
                  ),
                  const SizedBox(width: 12),
                  Text(
                    type == 'code' ? '–ü—Ä–æ—Å–º–æ—Ç—Ä –∫–æ–¥–∞' : '–ü–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  Text(
                    '${_formatDate(timestamp)} ${_formatTime(timestamp)}',
                    style: const TextStyle(color: Colors.white70),
                  ),
                ],
              ),
            ),
            // –ö–æ–Ω—Ç–µ–Ω—Ç
            Expanded(
              child: Container(
                padding: const EdgeInsets.all(16),
                child: SingleChildScrollView(
                  child: type == 'code' 
                      ? SelectableText(
                          content,
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                            fontFamily: 'Monospace',
                          ),
                        )
                      : SelectableText(
                          content,
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                          ),
                        ),
                ),
              ),
            ),
            // –ö–Ω–æ–ø–∫–∏
            Container(
              padding: const EdgeInsets.all(16),
              child: Row(
                children: [
                  Expanded(
                    child: ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.blue,
                        foregroundColor: Colors.white,
                      ),
                      onPressed: () => _copyToClipboard(_expandedItem!),
                      child: const Text('–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å'),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.grey,
                        foregroundColor: Colors.white,
                      ),
                      onPressed: () {
                        setState(() {
                          _expandedItem = null;
                        });
                      },
                      child: const Text('–ó–∞–∫—Ä—ã—Ç—å'),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSearchField() {
    return Container(
      padding: const EdgeInsets.all(16),
      color: const Color(0xFF1A1A1A).withOpacity(0.7),
      child: TextField(
        controller: _searchController,
        style: const TextStyle(color: Colors.white, fontSize: 14),
        decoration: InputDecoration(
          hintText: '–ü–æ–∏—Å–∫ –≤ –∏—Å—Ç–æ—Ä–∏–∏...',
          hintStyle: const TextStyle(color: Colors.white54, fontSize: 14),
          filled: true,
          fillColor: const Color(0xFF2B2B2B).withOpacity(0.8),
          prefixIcon: const Icon(Icons.search, color: Colors.white54),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(20),
            borderSide: BorderSide.none,
          ),
          contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      height: 60,
      decoration: BoxDecoration(
        color: const Color(0xFF1A1A1A).withOpacity(0.9),
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(12),
        ),
      ),
      child: Row(
        children: [
          // –ö–Ω–æ–ø–∫–∞ Compose
          if (_selectedItems.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: MouseRegion(
                cursor: SystemMouseCursors.click,
                child: GestureDetector(
                  onTap: _executeCompose,
                  child: Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: Colors.blue.withOpacity(0.7),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.get_app_outlined, color: Colors.white, size: 20),
                  ),
                ),
              ),
            ),
          // –ö–Ω–æ–ø–∫–∞ Clear Selection
          if (_selectedItems.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(left: 8),
              child: MouseRegion(
                cursor: SystemMouseCursors.click,
                child: GestureDetector(
                  onTap: () {
                    setState(() {
                      _selectedItems.clear();
                      _showExportOptions = false;
                    });
                  },
                  child: Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: Colors.grey.withOpacity(0.7),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.clear, color: Colors.white, size: 20),
                  ),
                ),
              ),
            ),
          // –ö–Ω–æ–ø–∫–∞ Clear All
          Padding(
            padding: const EdgeInsets.only(left: 8),
            child: MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: _clearAllHistory,
                child: Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    color: Colors.red.withOpacity(0.7),
                    shape: BoxShape.circle,
                  ),
                  child: const Icon(Icons.delete_forever, color: Colors.white, size: 20),
                ),
              ),
            ),
          ),
          const Spacer(),
          // –ó–∞–≥–æ–ª–æ–≤–æ–∫
          Text(
            _currentTab == 0 ? 'üìã –ò—Å—Ç–æ—Ä–∏—è –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞' : '‚≠ê –ò–∑–±—Ä–∞–Ω–Ω–æ–µ',
            style: const TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const Spacer(),
          // –ö–Ω–æ–ø–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è
          Padding(
            padding: const EdgeInsets.only(right: 16),
            child: MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: () => windowManager.close(),
                child: Container(
                  width: 35,
                  height: 35,
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.7),
                    shape: BoxShape.circle,
                  ),
                  child: const Icon(Icons.close, color: Colors.white, size: 18),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTabBar() {
    return Container(
      color: const Color(0xFF1A1A1A).withOpacity(0.8),
      child: Row(
        children: [
          Expanded(
            child: TextButton(
              style: TextButton.styleFrom(
                backgroundColor: _currentTab == 0 ? const Color(0xFF2B2B2B).withOpacity(0.8) : Colors.transparent,
                shape: const RoundedRectangleBorder(),
                padding: const EdgeInsets.symmetric(vertical: 12),
              ),
              onPressed: () {
                setState(() {
                  _currentTab = 0;
                  _filterHistory();
                });
              },
              child: Text(
                '–í—Å–µ',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 14,
                ),
              ),
            ),
          ),
          Expanded(
            child: TextButton(
              style: TextButton.styleFrom(
                backgroundColor: _currentTab == 1 ? const Color(0xFF2B2B2B).withOpacity(0.8) : Colors.transparent,
                shape: const RoundedRectangleBorder(),
                padding: const EdgeInsets.symmetric(vertical: 12),
              ),
              onPressed: () {
                setState(() {
                  _currentTab = 1;
                  _filterHistory();
                });
              },
              child: Text(
                '–ò–∑–±—Ä–∞–Ω–Ω–æ–µ',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 14,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
Widget _buildExportOptions() {
  if (!_showExportOptions) return const SizedBox.shrink();

  final selectedItems = _clipboardHistory.where(
    (item) => _selectedItems.contains(item['filePath']?.toString() ?? '')
  ).toList();

  final hasImages = selectedItems.any((item) => item['type'] == 'image' || item['type'] == 'image_url');
  final hasText = selectedItems.any((item) => item['type'] == 'text' || item['type'] == 'code' || item['type'] == 'html');
  final hasFiles = selectedItems.any((item) => item['type'] == 'file');

  return Container(
    height: 60, // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞
    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
    color: const Color(0xFF1A1A1A).withOpacity(0.9),
    child: Row(
      children: [
        Expanded(
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children: [
                _buildExportOption('simple', 'auto', true, Colors.grey),
                const SizedBox(width: 6),
                if (hasImages) _buildExportOption('IMG', 'image', hasImages, Colors.pink),
                if (hasImages) const SizedBox(width: 6),
                if (hasText) _buildExportOption('TXT', 'text', hasText, Colors.green),
                if (hasText) const SizedBox(width: 6),
                if (hasImages || hasText) _buildExportOption('WEB', 'html', hasImages || hasText, Colors.blue),
                if (hasImages || hasText) const SizedBox(width: 6),
                if (hasFiles) _buildExportOption('ZIP', 'archive', hasFiles, Colors.orange),
                if (hasFiles) const SizedBox(width: 6),
                _buildExportOption('Plain', 'separate', true, Colors.purple),
              ],
            ),
          ),
        ),
        const SizedBox(width: 12),
        // –ö–Ω–æ–ø–∫–∞ Process
        MouseRegion(
          cursor: SystemMouseCursors.click,
          child: GestureDetector(
            onTap: _executeCompose,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: Colors.blue,
                borderRadius: BorderRadius.circular(20),
              ),
              child: Text(
                'Process',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 11,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ),
      ],
    ),
  );
}

Widget _buildExportOption(String label, String value, bool enabled, Color color) {
  final isSelected = _exportMode == value;
  return FilterChip(
    label: Text(
      label,
      style: TextStyle(
        color: isSelected ? Colors.white : Colors.white70,
        fontSize: 9, // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —à—Ä–∏—Ñ—Ç
      ),
    ),
    selected: isSelected,
    onSelected: enabled ? (selected) {
      setState(() {
        _exportMode = value;
      });
    } : null,
    backgroundColor:  Colors.grey[600],
    selectedColor: color,
    checkmarkColor: Colors.white,
    disabledColor: Colors.grey[600],
    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
  );
}

  Widget _buildContent() {
    if (_isLoading) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(color: Colors.white),
            SizedBox(height: 16),
            Text(
              '–ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏...',
              style: TextStyle(color: Colors.white, fontSize: 16),
            ),
          ],
        ),
      );
    }

    if (_filteredHistory.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              _currentTab == 0 ? Icons.content_paste : Icons.star,
              size: 64, 
              color: Colors.white54
            ),
            const SizedBox(height: 16),
            Text(
              _clipboardHistory.isEmpty 
                  ? '–ò—Å—Ç–æ—Ä–∏—è –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞ –ø—É—Å—Ç–∞'
                  : _currentTab == 1 
                    ? '–ù–µ—Ç –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤'
                    : '–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ',
              style: const TextStyle(color: Colors.white, fontSize: 16),
            ),
            const SizedBox(height: 8),
            Text(
              _clipboardHistory.isEmpty
                  ? '–°–∫–æ–ø–∏—Ä—É–π—Ç–µ —Ç–µ–∫—Å—Ç –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞'
                  : '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å –ø–æ–∏—Å–∫–∞',
              style: const TextStyle(color: Colors.white54, fontSize: 14),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: 8),
      itemCount: _filteredHistory.length,
      itemBuilder: (context, index) {
        return _buildHistoryItem(_filteredHistory[index]);
      },
    );
  }

  String _formatTime(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.day.toString().padLeft(2, '0')}.${date.month.toString().padLeft(2, '0')}.${date.year}';
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      home: Scaffold(
        backgroundColor: Colors.transparent,
        body: Stack(
          children: [
            // Background
            if (_backgroundImage != null)
              Positioned.fill(
                child: Image.file(
                  _backgroundImage!,
                  fit: BoxFit.cover,
                ),
              ),
            
            // Main content
            Container(
              width: 400,
              height: MediaQuery.of(context).size.height,
              margin: const EdgeInsets.only(right: 0),
              decoration: BoxDecoration(
                color: const Color(0xFF2B2B2B).withOpacity(0.95),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12),
                  bottomLeft: Radius.circular(12),
                ),
              ),
              child: Column(
                children: [
                  _buildHeader(),
                  _buildTabBar(),
                  _buildSearchField(),
                  _buildExportOptions(),
                  Expanded(
                    child: _buildContent(),
                  ),
                ],
              ),
            ),

            // Expanded view
            if (_expandedItem != null)
              _buildExpandedView(),
          ],
        ),
      ),
    );
  }
}
class HistoryItemWidget extends StatefulWidget {
  final Map<String, dynamic> item;
  final bool isSelected;
  final VoidCallback onCopy;
  final VoidCallback onLongPress;
  final VoidCallback onToggleSelection;
  final VoidCallback onToggleStar;
  final VoidCallback onDelete;
  final bool showExportOptions;

  const HistoryItemWidget({
    Key? key,
    required this.item,
    required this.isSelected,
    required this.onCopy,
    required this.onLongPress,
    required this.onToggleSelection,
    required this.onToggleStar,
    required this.onDelete,
    required this.showExportOptions,
  }) : super(key: key);

  @override
  State<HistoryItemWidget> createState() => _HistoryItemWidgetState();
}

class _HistoryItemWidgetState extends State<HistoryItemWidget> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final item = widget.item;
    final content = item['content']?.toString() ?? '';
    final timestamp = item['timestamp'] as int? ?? 0;
    final isStarred = item['starred'] as bool? ?? false;
    final type = item['type'] as String? ?? 'text';
    final fileInfo = item['file_info'] as Map<String, dynamic>?;
    final isSelected = widget.isSelected;
    final borderColor = _getTypeBorderColor(type);
    
    String displayText;
    String typeText = _getTypeDisplayName(type);
    IconData leadingIcon;
    Color backgroundColor = const Color(0xFF2B2B2B).withOpacity(0.8);
    
    // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–µ–≤—å—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    Widget? imagePreview;
    bool showImagePreview = false;
    bool isImageFile = false;
    
    switch (type) {
      case 'file':
        final fileName = fileInfo?['name']?.toString() ?? path.basename(content);
        displayText = fileName;
        leadingIcon = fileInfo?['is_directory'] as bool? ?? false ? Icons.folder : Icons.insert_drive_file;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
        final fileExtension = path.extension(content).toLowerCase();
        if (fileExtension == '.png' || fileExtension == '.jpg' || fileExtension == '.jpeg') {
          isImageFile = true;
          showImagePreview = true;
          typeText = 'Image';
          leadingIcon = Icons.image;
          
          // –°–æ–∑–¥–∞–µ–º –ø—Ä–µ–≤—å—é –¥–ª—è —Ñ–∞–π–ª–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
          imagePreview = Container(
            height: 150,
            width: double.infinity,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(4),
              color: Colors.grey[800],
            ),
            child: FutureBuilder<File>(
              future: Future.value(File(content)),
              builder: (context, snapshot) {
                if (snapshot.hasData && snapshot.data != null) {
                  return ClipRRect(
                    borderRadius: BorderRadius.circular(4),
                    child: Image.file(
                      snapshot.data!,
                      fit: BoxFit.cover,
                      errorBuilder: (context, error, stackTrace) {
                        return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                      },
                    ),
                  );
                } else if (snapshot.hasError) {
                  return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                } else {
                  return Center(child: CircularProgressIndicator(color: Colors.white54));
                }
              },
            ),
          );
        }
        break;
      case 'image_url':
      case 'image':
        displayText = type == 'image' ? 'Image: ${fileInfo?['name'] ?? 'From Clipboard'}' : 'Image URL: $content';
        leadingIcon = Icons.image;
        showImagePreview = true;
        
        // –°–æ–∑–¥–∞–µ–º –ø—Ä–µ–≤—å—é –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        if (type == 'image_url') {
          // –î–ª—è URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
          imagePreview = Container(
            height: 150,
            width: double.infinity,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(4),
              color: Colors.grey[800],
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: Image.network(
                content,
                fit: BoxFit.cover,
                loadingBuilder: (context, child, loadingProgress) {
                  if (loadingProgress == null) return child;
                  return Center(
                    child: CircularProgressIndicator(
                      value: loadingProgress.expectedTotalBytes != null
                          ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes!
                          : null,
                    ),
                  );
                },
                errorBuilder: (context, error, stackTrace) {
                  return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                },
              ),
            ),
          );
        } else if (type == 'image') {
          // –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
          imagePreview = Container(
            height: 150,
            width: double.infinity,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(4),
              color: Colors.grey[800],
            ),
            child: FutureBuilder<File>(
              future: _getImageFile(content, fileInfo),
              builder: (context, snapshot) {
                if (snapshot.hasData && snapshot.data != null) {
                  return ClipRRect(
                    borderRadius: BorderRadius.circular(4),
                    child: Image.file(
                      snapshot.data!,
                      fit: BoxFit.cover,
                      errorBuilder: (context, error, stackTrace) {
                        return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                      },
                    ),
                  );
                } else if (snapshot.hasError) {
                  return Icon(Icons.broken_image, size: 50, color: Colors.white54);
                } else {
                  return Center(child: CircularProgressIndicator(color: Colors.white54));
                }
              },
            ),
          );
        }
        break;
      case 'url':
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.link;
        break;
      case 'document_url':
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.description;
        break;
      case 'email':
        displayText = content;
        leadingIcon = Icons.email;
        break;
      case 'code':
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.code;
        break;
      case 'html':
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.web;
        break;
      default:
        displayText = content.length > 100 ? '${content.substring(0, 100)}...' : content;
        leadingIcon = Icons.text_fields;
        break;
    }

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 16),
        child: Stack(
          children: [
            GestureDetector(
              onTap: widget.onCopy,
              onLongPress: widget.onLongPress,
              child: Card(
                color: backgroundColor,
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                  side: BorderSide(
                    color: isSelected ? Colors.blue : borderColor,
                    width: isSelected ? 2 : 1,
                  ),
                ),
                child: Container(
                  padding: const EdgeInsets.all(12),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // –ò–∫–æ–Ω–∫–∞ –∏ —Ç–∏–ø
                      Column(
                        children: [
                          CircleAvatar(
                            backgroundColor: Colors.blueGrey[700],
                            radius: 20,
                            child: Icon(
                              leadingIcon,
                              size: 20,
                              color: Colors.white,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            typeText,
                            style: TextStyle(
                              color: Colors.white70,
                              fontSize: 10,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(width: 12),
                      // –ö–æ–Ω—Ç–µ–Ω—Ç
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            if (showImagePreview && imagePreview != null)
                              Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  imagePreview,
                                  const SizedBox(height: 8),
                                  Text(
                                    isImageFile ? 'Image File: ${path.basename(content)}' : displayText,
                                    style: const TextStyle(
                                      color: Colors.white,
                                      fontSize: 12,
                                    ),
                                    maxLines: 2,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ],
                              )
                            else
                              Text(
                                displayText,
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 12,
                                ),
                                maxLines: 3,
                                overflow: TextOverflow.ellipsis,
                              ),
                            const SizedBox(height: 4),
                            Text(
                              '${_formatDate(timestamp)} ${_formatTime(timestamp)} ‚Ä¢ ${content.length} —Å–∏–º–≤–æ–ª–æ–≤',
                              style: TextStyle(
                                color: Colors.white54,
                                fontSize: 10,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
            // –ö–Ω–æ–ø–∫–∞ –≤—ã–±–æ—Ä–∞ –¥–ª—è compose (–≤–∏–¥–Ω–∞ –ø—Ä–∏ hover –∏–ª–∏ –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω–∞)
            if (_isHovered || isSelected)
              Positioned(
                top: 8,
                left: 8,
                child: MouseRegion(
                  cursor: SystemMouseCursors.click,
                  child: GestureDetector(
                    onTap: widget.onToggleSelection,
                    child: Container(
                      width: 25,
                      height: 25,
                      decoration: BoxDecoration(
                        color: isSelected ? Colors.blue : Colors.black.withOpacity(0.8),
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 1),
                      ),
                      child: isSelected 
                          ? const Icon(Icons.check, size: 14, color: Colors.white)
                          : const Icon(Icons.add, size: 14, color: Colors.white),
                    ),
                  ),
                ),
              ),
            // –ö–Ω–æ–ø–∫–∏ –∑–≤–µ–∑–¥–æ—á–∫–∏ –∏ —É–¥–∞–ª–µ–Ω–∏—è (–≤–∏–¥–Ω—ã —Ç–æ–ª—å–∫–æ –ø—Ä–∏ hover)
            if (_isHovered)
              Positioned(
                top: 8,
                right: 8,
                child: MouseRegion(
                  cursor: SystemMouseCursors.click,
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // –ó–≤–µ–∑–¥–æ—á–∫–∞ (–≤–∏–¥–Ω–∞ –≤—Å–µ–≥–¥–∞ –µ—Å–ª–∏ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ, –∏ –ø—Ä–∏ hover)
                      GestureDetector(
                        onTap: widget.onToggleStar,
                        child: Container(
                          width: 25,
                          height: 25,
                          decoration: BoxDecoration(
                            color: Colors.black.withOpacity(0.8),
                            shape: BoxShape.circle,
                          ),
                          child: Icon(
                            isStarred ? Icons.star : Icons.star_border,
                            color: isStarred ? Colors.amber : Colors.white,
                            size: 14,
                          ),
                        ),
                      ),
                      const SizedBox(width: 4),
                      // –ö—Ä–µ—Å—Ç–∏–∫ (–≤–∏–¥–µ–Ω —Ç–æ–ª—å–∫–æ –ø—Ä–∏ hover)
                      GestureDetector(
                        onTap: widget.onDelete,
                        child: Container(
                          width: 25,
                          height: 25,
                          decoration: BoxDecoration(
                            color: Colors.black.withOpacity(0.8),
                            shape: BoxShape.circle,
                          ),
                          child: const Icon(
                            Icons.close,
                            color: Colors.white,
                            size: 14,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  String _getTypeDisplayName(String type) {
    switch (type) {
      case 'file': return '–§–∞–π–ª';
      case 'image_url': return '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ';
      case 'url': return '–°—Å—ã–ª–∫–∞';
      case 'document_url': return '–î–æ–∫—É–º–µ–Ω—Ç';
      case 'email': return 'Email';
      case 'code': return '–ö–æ–¥';
      case 'html': return 'HTML';
      case 'keyboard': return '–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞';
      case 'image': return '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ';
      default: return '–¢–µ–∫—Å—Ç';
    }
  }

  Color _getTypeBorderColor(String type) {
    switch (type) {
      case 'file': return Colors.orange;
      case 'image_url': return Colors.pink;
      case 'image': return Colors.pink;
      case 'url': return Colors.blue;
      case 'document_url': return Colors.purple;
      case 'email': return Colors.green;
      case 'code': return Colors.cyan;
      case 'html': return Colors.yellow;
      case 'keyboard': return Colors.grey;
      default: return Colors.white;
    }
  }

  String _formatTime(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.day.toString().padLeft(2, '0')}.${date.month.toString().padLeft(2, '0')}.${date.year}';
  }

  Future<File> _getImageFile(String content, Map<String, dynamic>? fileInfo) async {
    try {
      final file = File(content);
      if (await file.exists()) {
        return file;
      } else {
        throw Exception('File not found');
      }
    } catch (e) {
      throw Exception('Failed to load image: $e');
    }
  }
}

class ArrowPainter extends CustomPainter {
  final List<Arrow> arrows;
  final Offset? arrowStart;
  final Offset? currentArrowEnd;
  
  ArrowPainter(this.arrows, {this.arrowStart, this.currentArrowEnd});
  
  @override
  void paint(Canvas canvas, Size size) {
    // –†–∏—Å—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ —Å—Ç—Ä–µ–ª–∫–∏
    for (final arrow in arrows) {
      _drawArrow(canvas, arrow.start, arrow.end);
    }
    
    // –†–∏—Å—É–µ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–µ–ª–∫–∏
    if (arrowStart != null && currentArrowEnd != null) {
      _drawArrow(canvas, arrowStart!, currentArrowEnd!, isPreview: true);
    }
  }
  
  void _drawArrow(Canvas canvas, Offset start, Offset end, {bool isPreview = false}) {
    final paint = Paint()
      ..color = isPreview ? Colors.red.withOpacity(0.7) : Colors.red
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;

    canvas.drawLine(start, end, paint);
    
    // –†–∏—Å—É–µ–º –Ω–∞–∫–æ–Ω–µ—á–Ω–∏–∫ —Å—Ç—Ä–µ–ª–∫–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —Å—Ç—Ä–µ–ª–æ–∫
    if (!isPreview) {
      final angle = (end - start).direction;
      const arrowSize = 8.0;
      
      final path = Path()
        ..moveTo(end.dx, end.dy)
        ..lineTo(
          end.dx - arrowSize * cos(angle - pi / 6),
          end.dy - arrowSize * sin(angle - pi / 6),
        )
        ..lineTo(
          end.dx - arrowSize * cos(angle + pi / 6),
          end.dy - arrowSize * sin(angle + pi / 6),
        )
        ..close();
      
      canvas.drawPath(path, paint..style = PaintingStyle.fill);
    }
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}
/// –î–µ–∫–æ–¥–µ—Ä –¥–ª—è CP1251
class Windows1251Decoder extends Converter<List<int>, String> {
  const Windows1251Decoder();
  static const _cp1251 = [
    '–É','–Ç','–É','—ì','‚Äû','‚Ä¶','‚Ä†','‚Ä°','‚Ç¨','‚Ä∞','–â','‚Äπ','–ä','–å','–ã','–è',
    '—í','‚Äò','‚Äô','‚Äú','‚Äù','‚Ä¢','‚Äì','‚Äî','','‚Ñ¢','—ô','‚Ä∫','—ö','—ú','—õ','—ü',
    ' ','–é','—û','–à','¬§','“ê','¬¶','¬ß','–Å','¬©','–Ñ','¬´','¬¨','¬≠','¬Æ','–á',
    '¬∞','¬±','–Ü','—ñ','“ë','¬µ','¬∂','¬∑','—ë','‚Ññ','—î','¬ª','—ò','–Ö','—ï','—ó',
    '–ê','–ë','–í','–ì','–î','–ï','–ñ','–ó','–ò','–ô','–ö','–õ','–ú','–ù','–û','–ü',
    '–†','–°','–¢','–£','–§','–•','–¶','–ß','–®','–©','–™','–´','–¨','–≠','–Æ','–Ø',
    '–∞','–±','–≤','–≥','–¥','–µ','–∂','–∑','–∏','–π','–∫','–ª','–º','–Ω','–æ','–ø',
    '—Ä','—Å','—Ç','—É','—Ñ','—Ö','—Ü','—á','—à','—â','—ä','—ã','—å','—ç','—é','—è'
  ];

  @override
  String convert(List<int> input) {
    final sb = StringBuffer();
    for (final b in input) {
      if (b >= 0xC0) {
        sb.write(_cp1251[b - 0xC0 + 64]);
      } else {
        sb.writeCharCode(b);
      }
    }
    return sb.toString();
  }
}

String _fixEncoding(String text) {
  try {
    // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–∏–º–≤–æ–ª—ã –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–∏, –ø—Ä–æ–±—É–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å
    if (text.contains('–†') && text.contains('–°')) {
      // –ü—Ä–æ–±—É–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–∑ CP1251/Windows-1251 –≤ UTF-8
      final bytes = latin1.encode(text);
      return utf8.decode(bytes, allowMalformed: true);
    }
    return text;
  } catch (e) {
    return text;
  }
}

class Arrow {
  final Offset start;
  final Offset end;
  
  Arrow(this.start, this.end);
}

class ScreenshotApp extends StatelessWidget {
  const ScreenshotApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: '–°–∫—Ä–∏–Ω—à–æ—Ç –º–æ–¥—É–ª—å',
      theme: ThemeData.dark(),
      home: ScreenshotScreen(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class ScreenshotScreen extends StatefulWidget {
  const ScreenshotScreen({Key? key}) : super(key: key);

  @override
  _ScreenshotScreenState createState() => _ScreenshotScreenState();
}

class _ScreenshotScreenState extends State<ScreenshotScreen> with WindowListener {
  Uint8List? _screenshotData;
  Offset _startOffset = Offset.zero;
  Offset _currentOffset = Offset.zero;
  bool _isSelecting = false;
  final TextEditingController _textController = TextEditingController();
  bool _isProcessing = false;
  Rect? _selectedRegion;
  bool _showTextInput = false;
  final FocusNode _focusNode = FocusNode();
  final GlobalKey _screenshotKey = GlobalKey();
  final GlobalKey _globalKey = GlobalKey(); // –î–æ–±–∞–≤–ª—è–µ–º GlobalKey
  List<Arrow> _arrows = []; // –°–ø–∏—Å–æ–∫ —Å—Ç—Ä–µ–ª–æ–∫
final List<List<Arrow>> _arrowHistory = []; // –ò—Å—Ç–æ—Ä–∏—è –¥–ª—è undo
Offset? _currentArrowEnd; 
// –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ –ø–æ–ª—è –≤ –∫–ª–∞—Å—Å State
Offset _selectionStart = Offset.zero;
Offset _selectionEnd = Offset.zero;
String _recognizedTextFromScreenshot ="";
final _httpClient = http.Client();
String _defaultLanguage = 'ru'; // –†—É—Å—Å–∫–∏–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

  @override
  void initState() {
    super.initState();
    windowManager.addListener(this);
    _initializeScreenshot();
    _setupKeyboardListener();
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    _textController.dispose();
    _focusNode.dispose();
    super.dispose();
  }

void _setupKeyboardListener() {
  RawKeyboard.instance.addListener((RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      final isControlPressed = event.isControlPressed;
      
      if (event.logicalKey == LogicalKeyboardKey.escape) {
        windowManager.close();
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyZ) {
        _undoArrow();
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyS) {
        _copyScreenshotToClipboard();
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyX) {
        _createMemeScreenshot();
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyC) {
        _copyTextAndClose(); // –û–±–Ω–æ–≤–ª–µ–Ω–æ
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyQ) {
        _translateTextToDefaultLanguage(); // –û–±–Ω–æ–≤–ª–µ–Ω–æ
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyW) {
        _translateTextToEnglishLanguage(); // –û–±–Ω–æ–≤–ª–µ–Ω–æ
      }
    }
  });
}
Future<void> _copyTextAndClose() async {
  final text = _textController.text.trim();
  if (text.isNotEmpty) {
    await Clipboard.setData(ClipboardData(text: text));
    _showMessage('–¢–µ–∫—Å—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä');
    Future.delayed(Duration(milliseconds: 500), () {
      windowManager.close();
    });
  } else {
    _showMessage('–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è');
  }
}


Future<void> _translateTextToDefaultLanguage() async {
  await _translateText(_defaultLanguage);
}

Future<void> _translateTextToEnglishLanguage() async {
  await _translateText('en');
}

Future<void> _translateText(String targetLanguage) async {
  final text = _textController.text.trim();
  if (text.isEmpty) {
    _showMessage('–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞');
    return;
  }

  try {
    setState(() {
      _isProcessing = true;
    });

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —è–∑—ã–∫
    final sourceLanguage = await _detectLanguage(text);
    
    // –ï—Å–ª–∏ –∏—Å—Ö–æ–¥–Ω—ã–π —è–∑—ã–∫ —É–∂–µ —Ü–µ–ª–µ–≤–æ–π - –Ω–µ –ø–µ—Ä–µ–≤–æ–¥–∏–º
    if (sourceLanguage == targetLanguage) {
      _showMessage('–¢–µ–∫—Å—Ç —É–∂–µ –Ω–∞ —Ü–µ–ª–µ–≤–æ–º —è–∑—ã–∫–µ');
      return;
    }

    // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ API –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–æ–≤
    String translatedText = await _translateWithLibreTranslate(text, sourceLanguage, targetLanguage);
    
    if (translatedText.isEmpty) {
      translatedText = await _translateWithMyMemory(text, sourceLanguage, targetLanguage);
    }

    if (translatedText.isNotEmpty) {
      setState(() {
        _textController.text = translatedText;
      });
      _showMessage('–¢–µ–∫—Å—Ç –ø–µ—Ä–µ–≤–µ–¥–µ–Ω');
    } else {
      _showMessage('–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥');
    }
    
  } catch (e) {
    _showMessage('–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: $e');
  } finally {
    setState(() {
      _isProcessing = false;
    });
  }
}

// –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π API LibreTranslate
Future<String> _translateWithLibreTranslate(String text, String from, String to) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/translate'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'q': text,
        'source': from,
        'target': to,
        'format': 'text'
      }),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['translatedText'] ?? '';
    }
  } catch (e) {
    print('LibreTranslate error: $e');
  }
  return '';
}

// –†–µ–∑–µ—Ä–≤–Ω—ã–π API MyMemory
Future<String> _translateWithMyMemory(String text, String from, String to) async {
  try {
    final response = await _httpClient.get(
      Uri.parse('https://api.mymemory.translated.net/get?'
          'q=${Uri.encodeComponent(text)}&'
          'langpair=$from|$to'),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['responseData']['translatedText'] ?? '';
    }
  } catch (e) {
    print('MyMemory error: $e');
  }
  return '';
}

Future<String> _detectLanguage(String text) async {
  try {
    // –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —è–∑—ã–∫–∞
    return _detectLanguageBasic(text);
    
    // –î–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å API (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
    // return await _detectLanguageWithAPI(text);
  } catch (e) {
    return _detectLanguageBasic(text);
  }
}

// API –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞ (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
/*
Future<String> _detectLanguageWithAPI(String text) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/detect'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'q': text}),
    ).timeout(Duration(seconds: 5));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      if (data is List && data.isNotEmpty) {
        return data[0]['language'] ?? 'en';
      }
    }
  } catch (e) {
    print('Language detection API error: $e');
  }
  return _detectLanguageBasic(text);
}
*/

String _detectLanguageBasic(String text) {
  // –£–ª—É—á—à–µ–Ω–Ω–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —è–∑—ã–∫–∞
  final russianRegex = RegExp(r'[–∞-—è–ê-–Ø—ë–Å]');
  final englishRegex = RegExp(r'[a-zA-Z]');
  final koreanRegex = RegExp(r'[„Ñ±-„Öé„Öè-„Ö£Í∞Ä-Ìû£]');
  final chineseRegex = RegExp(r'[\u4e00-\u9fff]');
  final japaneseRegex = RegExp(r'[\u3040-\u309F\u30A0-\u30FF]');
  
  // –ü–æ–¥—Å—á–µ—Ç —Å–∏–º–≤–æ–ª–æ–≤ —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–æ–≤
  int russianCount = russianRegex.allMatches(text).length;
  int englishCount = englishRegex.allMatches(text).length;
  int koreanCount = koreanRegex.allMatches(text).length;
  int chineseCount = chineseRegex.allMatches(text).length;
  int japaneseCount = japaneseRegex.allMatches(text).length;
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫ –ø–æ –ø—Ä–µ–æ–±–ª–∞–¥–∞—é—â–∏–º —Å–∏–º–≤–æ–ª–∞–º
  if (russianCount > 0 && russianCount > englishCount) return 'ru';
  if (koreanCount > 0) return 'ko';
  if (chineseCount > 0) return 'zh';
  if (japaneseCount > 0) return 'ja';
  if (englishCount > 0) return 'en';
  
  return 'en'; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
}


  Future<void> _initializeScreenshot() async {
    try {
      // –°–Ω–∞—á–∞–ª–∞ —Å–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–æ, –¥–µ–ª–∞–µ–º —Å–∫—Ä–∏–Ω—à–æ—Ç, –ø–æ—Ç–æ–º –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
      
      
      final screenshot = await _takeRealScreenshot();
      if (screenshot != null) {
        setState(() {
          _screenshotData = screenshot;
        });
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–≤–µ—Ä—Ö —Å–∫—Ä–∏–Ω—à–æ—Ç–∞
        await windowManager.show();
        await windowManager.focus();
        await windowManager.setAlwaysOnTop(true);
        await windowManager.setFullScreen(true);
      }
    } catch (e) {
      print('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞: $e');
      await windowManager.show();
      await windowManager.focus();
    }
  }

  Future<Uint8List?> _takeRealScreenshot() async {
    return takeScreen();
  }

  Future<Uint8List?> takeScreen() async {
    try {
      // Using platform channels to take screenshot
      const channel = MethodChannel('screenshot_channel');
      final result = await channel.invokeMethod('takeScreenshot');
      if (result != null && result is Uint8List) {
        return result;
      }
      return null;
    } catch (e) {
      print('–û—à–∏–±–∫–∞ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞: $e');
      return _takeScreenshotFallback();
    }
  }

  Future<Uint8List?> _takeScreenshotFallback() async {
    try {
      // Alternative method using screenshot package
      // You'll need to implement this based on your platform
      return null;
    } catch (e) {
      print('Fallback screenshot failed: $e');
      return null;
    }
  }



Future<void> _writeTextLog(String message) async {
  try {
    final documentsDir = await getApplicationDocumentsDirectory();
    final logFile = File('${documentsDir.path}/log_decode_text.log');
    final timestamp = DateTime.now().toString();
    final logMessage = '[$timestamp] $message\n';
    await logFile.writeAsString(logMessage, mode: FileMode.append);
    if (kDebugMode) print(message);
  } catch (e) {
    if (kDebugMode) print('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –ª–æ–≥–∞: $e');
  }
}
Future<String> _recognizeTextFromBytes(Uint8List imageData) async {
  await _writeTextLog('=== –ù–ê–ß–ê–õ–û –†–ê–°–ü–û–ó–ù–ê–í–ê–ù–ò–Ø –¢–ï–ö–°–¢–ê ===');
  await _writeTextLog('–†–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${imageData.length} –±–∞–π—Ç');
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ª–∏ Tesseract –≤ —Å–∏—Å—Ç–µ–º–µ
  final isTesseractAvailable = await _isTesseractInstalled();
  
  if (!isTesseractAvailable) {
    await _writeTextLog('Tesseract –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ');
    return _getTesseractNotInstalledMessage(imageData);
  }
  
  // –ï—Å–ª–∏ Tesseract —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
  return await _useSystemTesseract(imageData);
}

Future<bool> _isTesseractInstalled() async {
  try {
    await _writeTextLog('–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ Tesseract...');
    
    final result = await Process.run('tesseract', ['--version']);
    
    await _writeTextLog('–ö–æ–¥ –≤—ã—Ö–æ–¥–∞: ${result.exitCode}');
    await _writeTextLog('Stdout: ${result.stdout}');
    
    return result.exitCode == 0;
    
  } catch (e) {
    await _writeTextLog('Tesseract –Ω–µ –Ω–∞–π–¥–µ–Ω: $e');
    return false;
  }
}


Future<String> _useSystemTesseract(Uint8List imageData) async {
  try {
    final tempDir = await getTemporaryDirectory();
    final filePath = '${tempDir.path}/ocr_input_${DateTime.now().millisecondsSinceEpoch}.png';
    final file = File(filePath);
    await file.writeAsBytes(imageData);

    await _writeTextLog('–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ Tesseract...');

    final process = await Process.start(
      'tesseract',
      [
        filePath,
        'stdout',
        '-l', 'rus+eng',
        '--psm', '6',
        '--oem', '3',
      ],
      runInShell: true,
      environment: {
        'LANG': 'ru_RU.UTF-8',
        'LC_ALL': 'ru_RU.UTF-8',
      },
    );

    // —á–∏—Ç–∞–µ–º –±–∞–π—Ç—ã, –Ω–µ –ø–æ–ª–∞–≥–∞—è—Å—å –Ω–∞ –∞–≤—Ç–æ-–¥–µ–∫–æ–¥
    final stdoutBytes = await process.stdout.fold<List<int>>([], (a, b) => a..addAll(b));
    final stderrBytes = await process.stderr.fold<List<int>>([], (a, b) => a..addAll(b));
    final exitCode = await process.exitCode;

    await file.delete();

    // –ü—Ä–æ–±—É–µ–º –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∫ UTF-8, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è ‚Äî CP1251
    String decodeBytes(List<int> bytes) {
      try {
        return utf8.decode(bytes);
      } catch (_) {
        return const Windows1251Decoder().convert(bytes);
      }
    }

    final recognizedText = decodeBytes(stdoutBytes).trim();
    final stderrText = decodeBytes(stderrBytes);

    if (exitCode == 0) {
      await _writeTextLog('Tesseract —Ä–∞—Å–ø–æ–∑–Ω–∞–ª: ${recognizedText.length} —Å–∏–º–≤–æ–ª–æ–≤');
      await _writeTextLog('–¢–µ–∫—Å—Ç: "$recognizedText"');
      if (recognizedText.isNotEmpty) {
        setState(() {
         _recognizedTextFromScreenshot=_cleanRecognizedText(recognizedText);
      });
       
        return _cleanRecognizedText(_recognizedTextFromScreenshot);
      } else {
        return '–¢–µ–∫—Å—Ç –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–¥–µ–ª–∏—Ç—å –æ–±–ª–∞—Å—Ç—å —Å –±–æ–ª–µ–µ —á–µ—Ç–∫–∏–º —Ç–µ–∫—Å—Ç–æ–º.';
      }
    } else {
      await _writeTextLog('–û—à–∏–±–∫–∞ Tesseract. Exit code: $exitCode');
      await _writeTextLog('Stderr: $stderrText');
      return '–û—à–∏–±–∫–∞ Tesseract: $stderrText';
    }
  } on TimeoutException catch (e) {
    await _writeTextLog('–¢–∞–π–º–∞—É—Ç Tesseract: $e');
    return '–¢–∞–π–º–∞—É—Ç: Tesseract –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –∑–∞ 15 —Å–µ–∫—É–Ω–¥';
  } catch (e) {
    await _writeTextLog('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞ Tesseract: $e');
    return '–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞ Tesseract: $e';
  }
}

String _cleanRecognizedText(String text) {
  // –û—á–∏—â–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫
  text = text.trim();
  
  // –£–¥–∞–ª—è–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –º—É—Å–æ—Ä–æ–º
  text = text.replaceAll(RegExp(r'[^\w\s–∞-—è–ê-–Ø—ë–Å.,!?;:()\\/_-]'), '');
  
  // –ó–∞–º–µ–Ω—è–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –Ω–∞ –æ–¥–∏–Ω–∞—Ä–Ω—ã–µ
  text = text.replaceAll(RegExp(r'\s+'), ' ');
  
  // –£–¥–∞–ª—è–µ–º —Å—Ç—Ä–æ–∫–∏ —Å–æ—Å—Ç–æ—è—â–∏–µ —Ç–æ–ª—å–∫–æ –∏–∑ —Å–∏–º–≤–æ–ª–æ–≤ –ø—É–Ω–∫—Ç—É–∞—Ü–∏–∏
  final lines = text.split('\n');
  final cleanedLines = lines.where((line) {
    final trimmed = line.trim();
    if (trimmed.isEmpty) return false;
    return RegExp(r'[a-zA-Z–∞-—è–ê-–Ø0-9]').hasMatch(trimmed);
  }).toList();
  
  return cleanedLines.join('\n').trim();
}

Future<String> _getTesseractNotInstalledMessage(Uint8List imageData) async {
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
  final documentsDir = await getApplicationDocumentsDirectory();
  final debugFilePath = '${documentsDir.path}/screenshot_area_${DateTime.now().millisecondsSinceEpoch}.png';
  final debugFile = File(debugFilePath);
  await debugFile.writeAsBytes(imageData);
  
  // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
  String imageInfo = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏';
  try {
    final codec = await ui.instantiateImageCodec(imageData);
    final frame = await codec.getNextFrame();
    final image = frame.image;
    imageInfo = '${image.width}√ó${image.height} –ø–∏–∫—Å–µ–ª–µ–π';
  } catch (e) {
    imageInfo = '–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: $e';
  }

  return '''
üîç **Tesseract OCR –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω**

**–î–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ:**

üì• **–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å Tesseract:**
1. –°–∫–∞—á–∞–π—Ç–µ —Å: https://github.com/UB-Mannheim/tesseract/wiki
2. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Å –æ—Ç–º–µ—Ç–∫–æ–π "Add Tesseract to the system PATH"
3. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ

**–ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º:**
‚Ä¢ ‚úçÔ∏è **–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –≤—Ä—É—á–Ω—É—é** –≤ –ø–æ–ª–µ –Ω–∏–∂–µ
‚Ä¢ üìã –°–∫–æ–ø–∏—Ä—É–π—Ç–µ —Ç–µ–∫—Å—Ç –∏–∑ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏
‚Ä¢ ü§ñ –ù–∞–∂–º–∏—Ç–µ "Send to AI" –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

**–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏:**
‚Ä¢ –†–∞–∑–º–µ—Ä: $imageInfo
‚Ä¢ –§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω: `$debugFilePath`

_–ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ Tesseract –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ_
''';
}
  Future<void> _processSelectedRegion(Rect region) async {
    if (_screenshotData == null) return;

    try {
      setState(() {
        _isProcessing = true;
      });

      print('–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–ª–∞—Å—Ç–∏: $region');

      // –í—ã—Ä–µ–∑–∞–µ–º –æ–±–ª–∞—Å—Ç—å –∏–∑ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞
      final croppedImage = await _cropImageRegion(_screenshotData!, region);
      if (croppedImage == null) {
        _showMessage('–û—à–∏–±–∫–∞ –æ–±—Ä–µ–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
        return;
      }

      // –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å QR-–∫–æ–¥
      final qrResult = await _scanQRCode(croppedImage);
      if (qrResult.isNotEmpty) {
        setState(() {
          _textController.text = qrResult;
        });
        _showMessage('QR-–∫–æ–¥ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω!');
        return;
      }

      // –ï—Å–ª–∏ QR –Ω–µ –Ω–∞–π–¥–µ–Ω, —Ä–∞—Å–ø–æ–∑–Ω–∞–µ–º —Ç–µ–∫—Å—Ç
      final textResult = await _recognizeTextFromBytes(croppedImage);
      setState(() {
        _textController.text = textResult;
      });
      _showMessage('–¢–µ–∫—Å—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω!');

    } catch (e) {
      print('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: $e');
      _showMessage('–û—à–∏–±–∫–∞: $e');
    } finally {
      setState(() {
        _isProcessing = false;
      });
    }
  }

Future<Uint8List?> _cropImageRegion(Uint8List imageData, Rect region) async {
  try {
    print('–û–±—Ä–µ–∑–∫–∞ –∏–∑ –≥–æ—Ç–æ–≤–æ–≥–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞, —Ä–µ–≥–∏–æ–Ω: $region');
    
    // –î–µ–∫–æ–¥–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    final codec = await ui.instantiateImageCodec(imageData);
    final frame = await codec.getNextFrame();
    final originalImage = frame.image;
    
    // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã —ç–∫—Ä–∞–Ω–∞
    final screenSize = MediaQuery.of(context).size;
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∞—Å—à—Ç–∞–± –º–µ–∂–¥—É —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–º –∏ —ç–∫—Ä–∞–Ω–æ–º
    final scaleX = originalImage.width / screenSize.width;
    final scaleY = originalImage.height / screenSize.height;
    
    print('Original image: ${originalImage.width}x${originalImage.height}');
    print('Screen size: $screenSize');
    print('Scale: $scaleX x $scaleY');
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –º–∞—Å—à—Ç–∞–±–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    final cropX = (region.left * scaleX).round();
    final cropY = (region.top * scaleY).round();
    final cropWidth = (region.width * scaleX).round();
    final cropHeight = (region.height * scaleY).round();
    
    print('Crop coordinates: $cropX,$cropY ${cropWidth}x$cropHeight');
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã
    if (cropX < 0 || cropY < 0 || 
        cropX + cropWidth > originalImage.width || 
        cropY + cropHeight > originalImage.height) {
      print('–í—ã—Ö–æ–¥ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
      return null;
    }
    
    // –°–æ–∑–¥–∞–µ–º –æ–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    
    canvas.drawImageRect(
      originalImage,
      ui.Rect.fromLTWH(
        cropX.toDouble(),
        cropY.toDouble(),
        cropWidth.toDouble(),
        cropHeight.toDouble(),
      ),
      ui.Rect.fromLTWH(0, 0, cropWidth.toDouble(), cropHeight.toDouble()),
      Paint(),
    );
    
    final picture = recorder.endRecording();
    final croppedImage = await picture.toImage(cropWidth, cropHeight);
    final byteData = await croppedImage.toByteData(format: ui.ImageByteFormat.png);
    final resultBytes = byteData!.buffer.asUint8List();
    
    print('–£—Å–ø–µ—à–Ω–æ –æ–±—Ä–µ–∑–∞–Ω–æ: ${resultBytes.length} –±–∞–π—Ç');
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    final docDir = await getApplicationDocumentsDirectory();
    final debugFile = File('${docDir.path}/debug_crop.png');
    await debugFile.writeAsBytes(resultBytes);
    print('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏: ${debugFile.path}');
    
    return resultBytes;
    
  } catch (e) {
    print('–û—à–∏–±–∫–∞ –æ–±—Ä–µ–∑–∫–∏: $e');
    return null;
  }
}


Future<String> _scanQRCode(Uint8List imageData) async {
     const channel = MethodChannel('screenshot_channel');
  final String result = await channel.invokeMethod('scanQRCode', {
    'imageData': imageData,
  });
  return result;
}
Future<void> _sendToAI(String recognizedText, String userText) async {
  // –í—ã–ø–æ–ª–Ω—è–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≤ –∏–∑–æ–ª—è—Ç–µ
  final combinedText = await compute(_prepareCombinedText, {
    'recognizedText': recognizedText,
    'recognizedTextFromScreenshot': _recognizedTextFromScreenshot,
  });
  
  print('=' * 50);
  print('–û–¢–ü–†–ê–í–ö–ê –í AI:');
  print('=' * 50);
  print(combinedText);
  print('=' * 50);
  
  // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
  await _sendToServer(combinedText).timeout(const Duration(seconds: 30));
  
  // –ó–∞–∫—Ä—ã—Ç–∏–µ –æ–∫–Ω–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ
  WidgetsBinding.instance.addPostFrameCallback((_) {
    windowManager.close();
  });
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–æ–ª—è—Ç–∞
static String _prepareCombinedText(Map<String, String> data) {
  final recognizedText = data['recognizedText']!;
  final recognizedTextFromScreenshot = data['recognizedTextFromScreenshot']!;
  
  bool isSame = recognizedText == recognizedTextFromScreenshot;
  
  if (isSame) {
    return '''
    $recognizedTextFromScreenshot
    \n
    ''';
  } else {
    return '''
    $recognizedTextFromScreenshot
    \n
    $recognizedText
    ''';
  }
}
//–ø–∏–∫–µ–π


static Future<void> _sendToServer(String data) async {
  try {
    final socket = await Socket.connect('localhost', 8081);
    // –Ø–≤–Ω–æ –∫–æ–¥–∏—Ä—É–µ–º –≤ UTF-8
    final encodedData = utf8.encode(data);
    socket.add(encodedData);
    await socket.flush();
    socket.destroy();
  } catch (e) {
    print('Error sending data: $e');
  }
}


  Rect _getSelectionRect() {
    final left = _startOffset.dx < _currentOffset.dx ? _startOffset.dx : _currentOffset.dx;
    final top = _startOffset.dy < _currentOffset.dy ? _startOffset.dy : _currentOffset.dy;
    final right = _startOffset.dx > _currentOffset.dx ? _startOffset.dx : _currentOffset.dx;
    final bottom = _startOffset.dy > _currentOffset.dy ? _startOffset.dy : _currentOffset.dy;

    return Rect.fromLTRB(left, top, right, bottom);
  }

void _onPanStart(DragStartDetails details) {
  setState(() {
    _startOffset = details.localPosition;
    _currentOffset = details.localPosition;
    _isSelecting = true;
    _showTextInput = false;
    _arrows.clear(); // –û—á–∏—â–∞–µ–º —Å—Ç—Ä–µ–ª–∫–∏ –ø—Ä–∏ –Ω–æ–≤–æ–º –≤—ã–¥–µ–ª–µ–Ω–∏–∏
  });
}

void _onPanUpdate(DragUpdateDetails details) {
  setState(() {
    _currentOffset = details.localPosition;
  });
}

void _onPanEnd(DragEndDetails details) {
  final selectionRect = _getSelectionRect();
  setState(() {
    _selectedRegion = selectionRect;
    _isSelecting = false;
    _showTextInput = true;
  });

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—É—é –æ–±–ª–∞—Å—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–æ–ª—å—à–∞—è
  if (selectionRect.width >= 20 && selectionRect.height >= 20) {
    _processSelectedRegion(selectionRect);
  }
}
void _onSend() async {
  if (_isProcessing || _selectedRegion == null) return;

  try {
    setState(() {
      _isProcessing = true;
    });

    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ –ø–æ–ª—è –≤–≤–æ–¥–∞
    final recognizedText = _textController.text.trim();
    
    if (recognizedText.isEmpty) {
      _showMessage('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ AI');
      return;
    }

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ AI
    await _sendToAI(recognizedText, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–≤–æ–¥");

    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–æ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
    Future.delayed(Duration(milliseconds: 500), () {
      if (mounted) {
        windowManager.close();
      }
    });

  } catch (e) {
    _showMessage('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: $e');
  } finally {
    if (mounted) {
      setState(() {
        _isProcessing = false;
      });
    }
  }
}

  void _showMessage(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: message.contains('–û—à–∏–±–∫–∞') ? Colors.red : Colors.green,
        duration: Duration(seconds: 3),
      ),
    );
  }

  void _cancelScreenshot() {
    windowManager.close();
  }


  Offset? _arrowStart;
bool _isDrawingArrow = false;

void _undoArrow() {
  if (_arrowHistory.isNotEmpty) {
    setState(() {
      _arrowHistory.removeLast();
      _arrows = _arrowHistory.isNotEmpty ? List.from(_arrowHistory.last) : [];
    });
  }
}
Future<void> _copyScreenshotToClipboard() async {
  if (_screenshotData == null || _selectedRegion == null) return;

  try {
    // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ null –∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä ! –¥–ª—è —è–≤–Ω–æ–≥–æ —É–∫–∞–∑–∞–Ω–∏—è non-null
    final croppedImageData = await _cropImageRegion(_screenshotData!, _selectedRegion!);
    if (croppedImageData != null) {
      // –î–ª—è Windows –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–Ω–∞–ª –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –±—É—Ñ–µ—Ä
      const channel = MethodChannel('screenshot_channel');
      await channel.invokeMethod('copyImageToClipboard', {
        'imageData': croppedImageData,
      });
      windowManager.close();
    }
  } catch (e) {
    _showMessage('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: $e');
  }
}

Future<void> _createMemeScreenshot() async {
  if (_screenshotData == null || _selectedRegion == null) return;

  try {
    final memeImage = await _createMemeImage(_screenshotData!, _selectedRegion!, _textController.text);
    if (memeImage != null) {
      // –î–ª—è Windows –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–Ω–∞–ª –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –±—É—Ñ–µ—Ä
      const channel = MethodChannel('screenshot_channel');
      await channel.invokeMethod('copyImageToClipboard', {
        'imageData': memeImage,
      });
      windowManager.close();
    }
  } catch (e) {
    _showMessage('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –¥–µ–º–æ—Ç–∏–≤–∞—Ç–æ—Ä–∞: $e');
  }
}

Future<Uint8List?> _addArrowsToImage(Uint8List imageData, Rect region) async {
  try {
    final codec = await ui.instantiateImageCodec(imageData);
    final frame = await codec.getNextFrame();
    final originalImage = frame.image;

    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    
    // –†–∏—Å—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    canvas.drawImage(originalImage, Offset.zero, Paint());
    
    // –†–∏—Å—É–µ–º —Å—Ç—Ä–µ–ª–∫–∏
    for (final arrow in _arrows) {
      _drawArrow(canvas, arrow.start, arrow.end);
    }
    
    final picture = recorder.endRecording();
    final finalImage = await picture.toImage(originalImage.width, originalImage.height);
    final byteData = await finalImage.toByteData(format: ui.ImageByteFormat.png);
    
    return byteData?.buffer.asUint8List();
  } catch (e) {
    print('–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–µ–ª–æ–∫: $e');
    return null;
  }
}

void _drawArrow(Canvas canvas, Offset start, Offset end) {
  final paint = Paint()
    ..color = Colors.red
    ..strokeWidth = 2.0
    ..style = PaintingStyle.stroke;

  // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é
  canvas.drawLine(start, end, paint);
  
  // –†–∏—Å—É–µ–º —Å—Ç—Ä–µ–ª–∫—É
  final angle = (end - start).direction;
  const arrowSize = 4.0;
  
  final path = Path()
    ..moveTo(end.dx, end.dy)
    ..lineTo(
      end.dx - arrowSize * cos(angle - pi / 6),
      end.dy - arrowSize * sin(angle - pi / 6),
    )
    ..lineTo(
      end.dx - arrowSize * cos(angle + pi / 6),
      end.dy - arrowSize * sin(angle + pi / 6),
    )
    ..close();
  
  canvas.drawPath(path, paint..style = PaintingStyle.fill);
}
Future<Uint8List?> _createMemeImage(Uint8List imageData, Rect region, String text) async {
  try {
    // –°–Ω–∞—á–∞–ª–∞ –æ–±—Ä–µ–∑–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏
    final croppedImageData = await _cropImageRegion(imageData, region);
    if (croppedImageData == null) return null;

    final codec = await ui.instantiateImageCodec(croppedImageData);
    final frame = await codec.getNextFrame();
    var baseImage = frame.image;

    // –ë–∞–∑–æ–≤—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è –¥–µ–º–æ—Ç–∏–≤–∞—Ç–æ—Ä–∞
    const padding = 80.0;
    const bottomPadding = 80.0;
    const watermarkHeight = 40.0;
    const qrCodeSize = 70.0;

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —à–∏—Ä–∏–Ω—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å —É—á–µ—Ç–æ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
    double imageWidth = baseImage.width.toDouble();
    if (imageWidth > 1600) {
      // –†–µ—Å–∞–π–∑–∏–º –¥–æ 1440 —à–∏—Ä–∏–Ω—ã
      final scale = 1440 / imageWidth;
      final scaledWidth = 1440;
      final scaledHeight = (baseImage.height * scale).toDouble();
      
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder);
      canvas.drawImageRect(
        baseImage,
        Rect.fromLTWH(0, 0, baseImage.width.toDouble(), baseImage.height.toDouble()),
        Rect.fromLTWH(0, 0, scaledWidth.toDouble(), scaledHeight),
        Paint(),
      );
      final picture = recorder.endRecording();
      baseImage = await picture.toImage(scaledWidth, scaledHeight.toInt());
      imageWidth = scaledWidth.toDouble();
    }

    // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â—É—é —à–∏—Ä–∏–Ω—É —Å –æ—Ç—Å—Ç—É–ø–∞–º–∏
    final totalWidth = imageWidth + 160; // +160px (80px —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã)
    
    // –í—ã—Å–æ—Ç–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    final imageHeight = baseImage.height.toDouble();

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –¥–ª–∏–Ω—ã —Ç–µ–∫—Å—Ç–∞
    double fontSize = 25.0;
    if (text.length <= 30) {
      fontSize = 32.0;
    } else if (text.length <= 50) {
      fontSize = 28.0;
    }

    // –°–æ–∑–¥–∞–µ–º Paragraph –¥–ª—è —Ç–µ–∫—Å—Ç–∞, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –µ–≥–æ –≤—ã—Å–æ—Ç—É
    final textParagraphBuilder = ui.ParagraphBuilder(
      ui.ParagraphStyle(
        fontSize: fontSize,
        textAlign: ui.TextAlign.center,
        fontWeight: ui.FontWeight.bold,
      ),
    )..pushStyle(ui.TextStyle(
        color: Colors.white,
      ))
     ..addText(text);
    
    final textParagraph = textParagraphBuilder.build();
    textParagraph.layout(ui.ParagraphConstraints(
      width: totalWidth - 40, // –û—Ç—Å—Ç—É–ø—ã –ø–æ 20 —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
    ));

    final textHeight = textParagraph.height;

    // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â—É—é –≤—ã—Å–æ—Ç—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    final totalHeight = padding + imageHeight + padding + textHeight + bottomPadding;

    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    
    // –†–∏—Å—É–µ–º —á–µ—Ä–Ω—ã–π —Ñ–æ–Ω
    canvas.drawRect(
      Rect.fromLTWH(0, 0, totalWidth, totalHeight),
      Paint()..color = Colors.black,
    );
    
    // –†–∏—Å—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ —Å–º–µ—â–µ–Ω–∏–µ–º –Ω–∞ 80px –ø–æ X
    final imageRect = Rect.fromLTWH(
      padding, // 80px –æ—Ç—Å—Ç—É–ø —Å–ª–µ–≤–∞
      padding, 
      imageWidth, 
      imageHeight
    );
    
    // –°–æ–∑–¥–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –±–µ–ª–æ–π —Ä–∞–º–∫–æ–π
    canvas.drawRect(
      imageRect.inflate(2),
      Paint()..color = Colors.white,
    );
    
    // –†–∏—Å—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    canvas.drawImageRect(
      baseImage,
      Rect.fromLTWH(0, 0, baseImage.width.toDouble(), baseImage.height.toDouble()),
      imageRect,
      Paint(),
    );

    // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
    final textY = padding + imageHeight + padding;
    canvas.drawParagraph(
      textParagraph,
      Offset(20, textY),
    );

    // –°–æ–∑–¥–∞–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π Row –¥–ª—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ "Created with" –∏ –ª–æ–≥–æ—Ç–∏–ø–∞
    const logoWidth = 70.0;
    const logoHeight = 40.0;
    const textLogoSpacing = 5.0; // –û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É —Ç–µ–∫—Å—Ç–æ–º –∏ –ª–æ–≥–æ—Ç–∏–ø–æ–º
    
    // –°–æ–∑–¥–∞–µ–º Paragraph –¥–ª—è —Ç–µ–∫—Å—Ç–∞ "Created with"
    final createdWithBuilder = ui.ParagraphBuilder(
      ui.ParagraphStyle(
        fontSize: 11,
      ),
    )..pushStyle(ui.TextStyle(
        color: Colors.white,
      ))
     ..addText("Created with");
    
    final createdWithParagraph = createdWithBuilder.build();
    createdWithParagraph.layout(ui.ParagraphConstraints(
      width: 100,
    ));

    final createdWithHeight = createdWithParagraph.height;
    
    // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â—É—é —à–∏—Ä–∏–Ω—É –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ (—Ç–µ–∫—Å—Ç + –æ—Ç—Å—Ç—É–ø + –ª–æ–≥–æ—Ç–∏–ø)
    final watermarkTotalWidth = createdWithParagraph.width + textLogoSpacing + logoWidth;
    
    // –ü–æ–∑–∏—Ü–∏—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ (–ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª)
    final watermarkX = totalWidth - watermarkTotalWidth - 10;
    final watermarkY = totalHeight - logoHeight - 10;
    
    // –°–æ–∑–¥–∞–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π Rect –¥–ª—è –≤—Å–µ–≥–æ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞
    final watermarkRect = Rect.fromLTWH(
      watermarkX,
      watermarkY,
      watermarkTotalWidth,
      logoHeight, // –í—ã—Å–æ—Ç–∞ —Ä–∞–≤–Ω–∞ –≤—ã—Å–æ—Ç–µ –ª–æ–≥–æ—Ç–∏–ø–∞
    );

    // –í—ã—á–∏—Å–ª—è–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Ü–µ–Ω—Ç—Ä –¥–ª—è —Ç–µ–∫—Å—Ç–∞
    final textVerticalCenter = watermarkRect.top + (watermarkRect.height - createdWithHeight) / 2;

    // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç "Created with" –ø–æ —Ü–µ–Ω—Ç—Ä—É –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
    canvas.drawParagraph(
      createdWithParagraph,
      Offset(watermarkRect.left, textVerticalCenter),
    );

    // –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–≥–æ—Ç–∏–ø (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ assets)
    try {
      final logoData = await rootBundle.load('assets/images/logo.png');
      final logoCodec = await ui.instantiateImageCodec(logoData.buffer.asUint8List());
      final logoFrame = await logoCodec.getNextFrame();
      final logoImage = logoFrame.image;
      
      final logoRect = Rect.fromLTWH(
        watermarkRect.left + createdWithParagraph.width + textLogoSpacing,
        watermarkRect.top,
        logoWidth,
        logoHeight
      );
      
      canvas.drawImageRect(
        logoImage,
        Rect.fromLTWH(0, 0, logoImage.width.toDouble(), logoImage.height.toDouble()),
        logoRect,
        Paint(),
      );
    } catch (e) {
      print('–õ–æ–≥–æ—Ç–∏–ø –Ω–µ –Ω–∞–π–¥–µ–Ω: $e');
    }

    // –î–æ–±–∞–≤–ª—è–µ–º QR-–∫–æ–¥
    try {
      final qrData = await rootBundle.load('assets/images/qr_code.png');
      final qrCodec = await ui.instantiateImageCodec(qrData.buffer.asUint8List());
      final qrFrame = await qrCodec.getNextFrame();
      final qrImage = qrFrame.image;
      
      canvas.drawImageRect(
        qrImage,
        Rect.fromLTWH(0, 0, qrImage.width.toDouble(), qrImage.height.toDouble()),
        Rect.fromLTWH(
          10.0, 
          totalHeight - qrCodeSize - 10, 
          qrCodeSize, 
          qrCodeSize
        ),
        Paint(),
      );
    } catch (e) {
      print('QR-–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω: $e');
    }

    final picture = recorder.endRecording();
    final memeImage = await picture.toImage(totalWidth.toInt(), totalHeight.toInt());
    final byteData = await memeImage.toByteData(format: ui.ImageByteFormat.png);
    
    return byteData?.buffer.asUint8List();
  } catch (e) {
    print('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –¥–µ–º–æ—Ç–∏–≤–∞—Ç–æ—Ä–∞: $e');
    return null;
  }
}

Widget _buildMainInteractionListener() {
  return Positioned.fill(
    child: Listener(
      behavior: HitTestBehavior.translucent,
      onPointerDown: (event) {
        if (event.buttons == kPrimaryButton) {
          setState(() {
            _isSelecting = true;
            _selectionStart = event.localPosition;
            _selectionEnd = event.localPosition;
            _selectedRegion = null;
            _showTextInput = false;
            _arrows.clear();
            _arrowHistory.clear();
          });
        }
      },
      onPointerMove: (event) {
        if (_isSelecting) {
          setState(() {
            _selectionEnd = event.localPosition;
          });
        }
      },
      onPointerUp: (event) {
        if (_isSelecting) {
          setState(() {
            _isSelecting = false;
            final selectionRect = _getSelectionRect();
            if (selectionRect.width > 10 && selectionRect.height > 10) {
              _selectedRegion = selectionRect;
              _showTextInput = true;
              _focusNode.requestFocus();
            } else {
              _selectedRegion = null;
              _showTextInput = false;
            }
          });
        }
      },
    ),
  );
}

Widget _buildArrowInteractionListener() {
  return Positioned.fill(
    child: MouseRegion(
      cursor: SystemMouseCursors.precise,
      child: Listener(
        behavior: HitTestBehavior.translucent,
        onPointerDown: (event) {
          if (event.buttons == kSecondaryButton) {
            final localPosition = event.localPosition;
            if (_selectedRegion!.contains(localPosition)) {
              setState(() {
                _arrowStart = localPosition;
                _isDrawingArrow = true;
                _currentArrowEnd = localPosition;
              });
            }
          }
        },
        onPointerMove: (event) {
          if (_isDrawingArrow && _arrowStart != null) {
            setState(() {
              _currentArrowEnd = event.localPosition;
            });
          }
        },
        onPointerUp: (event) {
          if (_isDrawingArrow && _arrowStart != null) {
            setState(() {
              _arrows.add(Arrow(_arrowStart!, event.localPosition));
              _arrowHistory.add(List.from(_arrows));
              _isDrawingArrow = false;
              _arrowStart = null;
              _currentArrowEnd = null;
            });
          }
        },
        onPointerCancel: (event) {
          if (_isDrawingArrow) {
            setState(() {
              _isDrawingArrow = false;
              _arrowStart = null;
              _currentArrowEnd = null;
            });
          }
        },
      ),
    ),
  );
}
@override
Widget build(BuildContext context) {
  return Scaffold(
    backgroundColor: Colors.transparent,
    body: RawKeyboardListener(
      focusNode: FocusNode(),
      autofocus: true,
      onKey: (RawKeyEvent event) {
        if (event is RawKeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
          _cancelScreenshot();
        }
      },
      child: Stack(
        children: [
          if (_screenshotData == null)
            Center(
              child: Container(
                padding: EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.8),
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    CircularProgressIndicator(),
                    SizedBox(height: 10),
                    Text(
                      '–ó–∞—Ö–≤–∞—Ç —ç–∫—Ä–∞–Ω–∞...',
                      style: TextStyle(color: Colors.white),
                    ),
                  ],
                ),
              ),
            )
          else
            Stack(
              children: [
                // –§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (—Å–∫—Ä–∏–Ω—à–æ—Ç)
                Positioned.fill(
                  child: Image.memory(
                    _screenshotData!,
                    fit: BoxFit.cover,
                  ),
                ),

                // –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ
                Positioned.fill(
                  child: Container(
                    color: Colors.black.withOpacity(0.2),
                  ),
                ),

                // –û–±–ª–∞—Å—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏—è (–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –∫–∞–∫ –≤–æ –≤—Ä–µ–º—è –≤—ã–¥–µ–ª–µ–Ω–∏—è, —Ç–∞–∫ –∏ –ø–æ—Å–ª–µ)
                if (_isSelecting || _selectedRegion != null) _buildSelectionArea(),
                
                // –°—Ç—Ä–µ–ª–∫–∏
                if (_selectedRegion != null)
                  Positioned.fill(
                    child: CustomPaint(
                      painter: ArrowPainter(
                        _arrows, 
                        arrowStart: _arrowStart,
                        currentArrowEnd: _currentArrowEnd,
                      ),
                    ),
                  ),

                // –ö–æ–Ω—Ç—Ä–æ–ª—ã —Å –ø–æ–ª–µ–º –≤–≤–æ–¥–∞
                if (_showTextInput && _selectedRegion != null) _buildControls(),

                // –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è
                if (!_showTextInput)
                  Positioned(
                    top: 20,
                    left: 20,
                    child: _buildInstructions(),
                  ),

                // –ö–Ω–æ–ø–∫–∞ –æ—Ç–º–µ–Ω—ã
                Positioned(
                  top: 20,
                  right: 20,
                  child: _buildCancelButton(),
                ),

                // –û—Å–Ω–æ–≤–Ω–æ–π GestureDetector –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
                if (!_isProcessing)
                  Positioned.fill(
                    child: IgnorePointer(
                      ignoring: _showTextInput,
                      child: MouseRegion(
                        cursor: SystemMouseCursors.precise,
                        child: GestureDetector(
                          behavior: HitTestBehavior.translucent,
                          onPanStart: (details) {
                            if (_selectedRegion == null) {
                              // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ - –≤—ã–¥–µ–ª–µ–Ω–∏–µ –æ–±–ª–∞—Å—Ç–∏
                              _isSelecting = true;
                              _onPanStart(details);
                            } else if (_selectedRegion!.contains(details.localPosition)) {
                              // –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ - —Ä–∏—Å–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏ (—Ç–æ–ª—å–∫–æ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –≤—ã–¥–µ–ª–µ–Ω–∏—è)
                              setState(() {
                                _arrowStart = details.localPosition;
                                _isDrawingArrow = true;
                              });
                            }
                          },
                          onPanUpdate: (details) {
                            if (_isSelecting) {
                              _onPanUpdate(details);
                            } else if (_isDrawingArrow) {
                              // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç—Ä–µ–ª–∫–∏
                              setState(() {
                                _currentArrowEnd = details.localPosition;
                              });
                            }
                          },
                          onPanEnd: (details) {
                            if (_isSelecting) {
                              _onPanEnd(details);
                              _isSelecting = false;
                            } else if (_isDrawingArrow && _arrowStart != null) {
                              // –ó–∞–≤–µ—Ä—à–∞–µ–º —Ä–∏—Å–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏
                              setState(() {
                                _arrows.add(Arrow(_arrowStart!, _currentArrowEnd ?? _arrowStart!));
                                _arrowHistory.add(List.from(_arrows));
                                _isDrawingArrow = false;
                                _arrowStart = null;
                                _currentArrowEnd = null;
                              });
                            }
                          },
                          onPanCancel: () {
                            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –∂–µ—Å—Ç–∞
                            _isSelecting = false;
                            if (_isDrawingArrow) {
                              setState(() {
                                _isDrawingArrow = false;
                                _arrowStart = null;
                                _currentArrowEnd = null;
                              });
                            }
                          },
                        ),
                      ),
                    ),
                  ),

                // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –æ–±—Ä–∞–±–æ—Ç–∫–∏
                if (_isProcessing)
                  Center(
                    child: Container(
                      padding: EdgeInsets.all(20),
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.8),
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          CircularProgressIndicator(),
                          SizedBox(height: 10),
                          Text(
                            '–û–±—Ä–∞–±–æ—Ç–∫–∞...',
                            style: TextStyle(color: Colors.white),
                          ),
                        ],
                      ),
                    ),
                  ),
              ],
            ),
        ],
      ),
    ),
  );
}

Widget _buildSelectionArea() {
  final selectionRect = _getSelectionRect();
  
  return Stack(
    children: [
      // –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ (—Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –≤—ã–¥–µ–ª–µ–Ω–∏—è)
      if (_isSelecting)
        Positioned.fill(
          child: Container(
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.3),
            ),
          ),
        ),
      
      // –í—ã–¥–µ–ª–µ–Ω–Ω–∞—è –æ–±–ª–∞—Å—Ç—å (–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –≤—Å–µ–≥–¥–∞)
      Positioned(
        left: selectionRect.left,
        top: selectionRect.top,
        child: Container(
          width: selectionRect.width,
          height: selectionRect.height,
          decoration: BoxDecoration(
            color: Colors.blue.withOpacity(0.1),
            border: Border.all(
              color: Colors.blue,
              width: 2.0,
            ),
          ),
        ),
      ),

      // –†–∞–∑–º–µ—Ä—ã –æ–±–ª–∞—Å—Ç–∏ (–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –≤—Å–µ–≥–¥–∞)
      if (selectionRect.width > 50 && selectionRect.height > 20)
        Positioned(
          left: selectionRect.left,
          top: selectionRect.top - 30,
          child: Container(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.7),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(
              '${selectionRect.width.round()} √ó ${selectionRect.height.round()}',
              style: TextStyle(
                color: Colors.white,
                fontSize: 12,
              ),
            ),
          ),
        ),
    ],
  );
}



Widget _buildControls() {
  final screenSize = MediaQuery.of(context).size;
  final region = _selectedRegion!;

  double left = region.left;
  double top = region.bottom + 10;
  double width = region.width.clamp(300.0, screenSize.width - left - 20);

  if (top + 180 > screenSize.height) {
    top = region.top - 180;
    top = top.clamp(20.0, screenSize.height - 180);
  }

  double maxHeight = 120.0;

  return Positioned(
    left: left,
    top: top,
    width: width,
    child: Material(
      color: Colors.transparent,
      child: Container(
        padding: EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.9),
          borderRadius: BorderRadius.circular(8),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.5),
              blurRadius: 10,
              offset: Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              children: [
                Icon(Icons.edit, color: Colors.white70, size: 14),
                SizedBox(width: 6),
                Text(
                  '–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º—ã–π —Ç–µ–∫—Å—Ç:',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Spacer(),
                // –ö–Ω–æ–ø–∫–∞ –æ—Ç–º–µ–Ω—ã
                IconButton(
                  icon: Icon(Icons.close, size: 16, color: Colors.white70),
                  onPressed: _cancelScreenshot,
                  tooltip: '–û—Ç–º–µ–Ω–∏—Ç—å (Esc)',
                ),
              ],
            ),
            SizedBox(height: 8),

            // –ü–æ–ª–µ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞
            ConstrainedBox(
              constraints: BoxConstraints(
                minHeight: 40,
                maxHeight: maxHeight,
              ),
              child: TextField(
                focusNode: _focusNode,
                controller: _textController,
                autofocus: true,
                decoration: InputDecoration(
                  hintText: '–í–≤–µ–¥–∏—Ç–µ –∏–ª–∏ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ —Ç–µ–∫—Å—Ç...',
                  hintStyle: TextStyle(color: Colors.white60, fontSize: 12),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(6),
                    borderSide: BorderSide(color: Colors.blue.withOpacity(0.5), width: 1),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(6),
                    borderSide: BorderSide(color: Colors.blue.withOpacity(0.5), width: 1),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(6),
                    borderSide: BorderSide(color: Colors.blue, width: 1.5),
                  ),
                  filled: true,
                  fillColor: Colors.grey[900],
                  contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                ),
                style: TextStyle(color: Colors.white, fontSize: 13),
                maxLines: null,
                keyboardType: TextInputType.multiline,
                textInputAction: TextInputAction.newline,
              ),
            ),

            SizedBox(height: 12),

            Row(
              children: [
                // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å—Ç—Ä–µ–ª–∫–∞—Ö
                if (_arrows.isNotEmpty)
                  Text(
                    '–°—Ç—Ä–µ–ª–æ–∫: ${_arrows.length}',
                    style: TextStyle(color: Colors.white70, fontSize: 10),
                  ),
                SizedBox(width: 8),
                
                // –ö–Ω–æ–ø–∫–∞ –æ—Ç–º–µ–Ω—ã —Å—Ç—Ä–µ–ª–∫–∏
                if (_arrowHistory.isNotEmpty)
                  ElevatedButton.icon(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.grey[700],
                      foregroundColor: Colors.white,
                      padding: EdgeInsets.symmetric(horizontal: 10, vertical: 8),
                      minimumSize: Size(0, 30),
                    ),
                    icon: Icon(Icons.undo, size: 12),
                    label: Text('Ctrl+Z', style: TextStyle(fontSize: 10)),
                    onPressed: _undoArrow,
                  ),

                Spacer(),

                // –ö–Ω–æ–ø–∫–∞ "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å"
                ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.grey[800],
                    foregroundColor: Colors.white,
                    padding: EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                    minimumSize: Size(0, 36),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(6),
                    ),
                  ),
                  icon: Icon(Icons.copy, size: 14),
                  label: Text('Ctrl+C', style: TextStyle(fontSize: 12)),
                  onPressed: _copyScreenshotToClipboard,
                ),
                SizedBox(width: 8),

                // –ö–Ω–æ–ø–∫–∞ "–î–µ–º–æ—Ç–∏–≤–∞—Ç–æ—Ä"
                ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.orange[700],
                    foregroundColor: Colors.white,
                    padding: EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                    minimumSize: Size(0, 36),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(6),
                    ),
                  ),
                  icon: Icon(Icons.photo_size_select_large, size: 14),
                  label: Text('Ctrl+X', style: TextStyle(fontSize: 12)),
                  onPressed: _createMemeScreenshot,
                ),
                SizedBox(width: 8),

                // –ö–Ω–æ–ø–∫–∞ "Send to AI"
                ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue[700],
                    foregroundColor: Colors.white,
                    padding: EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                    minimumSize: Size(0, 36),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(6),
                    ),
                  ),
                  icon: _isProcessing
                      ? SizedBox(
                          width: 16,
                          height: 16,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          ),
                        )
                      : Icon(Icons.send, size: 14),
                  label: Text('Send to AI', style: TextStyle(fontSize: 12)),
                  onPressed: _isProcessing ? null : _onSend,
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

  Widget _buildCancelButton() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.7),
        shape: BoxShape.circle,
      ),
      child: IconButton(
        icon: Icon(Icons.close, color: Colors.white),
        onPressed: _cancelScreenshot,
        tooltip: '–ó–∞–∫—Ä—ã—Ç—å (Esc)',
      ),
    );
  }

  Widget _buildInstructions() {
    return Container(
      padding: EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.7),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            '–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:',
            style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 14),
          ),
          SizedBox(height: 6),
          Text(
            '1. –í—ã–¥–µ–ª–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å —Å —Ç–µ–∫—Å—Ç–æ–º –∏–ª–∏ QR-–∫–æ–¥–æ–º\n'
            '2. –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n'
            '3. –ù–∞–∂–º–∏—Ç–µ "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ AI"\n'
            '4. Esc - –∑–∞–∫—Ä—ã—Ç—å',
            style: TextStyle(color: Colors.white70, fontSize: 12),
          ),
        ],
      ),
    );
  }

  @override
  void onWindowClose() {
    super.onWindowClose();
  }
}
class KeyboardLogger {
  static final KeyboardLogger _instance = KeyboardLogger._internal();
  factory KeyboardLogger() => _instance;
  KeyboardLogger._internal();

  Timer? _inactivityTimer;
  String _currentBuffer = '';
  DateTime _lastKeyTime = DateTime.now();
  final Duration _inactivityThreshold = Duration(seconds: 35);
  bool _isEnabled = false;

  // –§–∏–ª—å—Ç—Ä –¥–ª—è –∏—Å–∫–ª—é—á–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –∫–ª–∞–≤–∏—à
  final Set<LogicalKeyboardKey> _ignoredKeys = {
    LogicalKeyboardKey.shift,
    LogicalKeyboardKey.shiftLeft,
    LogicalKeyboardKey.shiftRight,
    LogicalKeyboardKey.control,
    LogicalKeyboardKey.controlLeft,
    LogicalKeyboardKey.controlRight,
    LogicalKeyboardKey.alt,
    LogicalKeyboardKey.altLeft,
    LogicalKeyboardKey.altRight,
    LogicalKeyboardKey.meta,
    LogicalKeyboardKey.metaLeft,
    LogicalKeyboardKey.metaRight,
    LogicalKeyboardKey.capsLock,
    LogicalKeyboardKey.numLock,
    LogicalKeyboardKey.scrollLock,
    LogicalKeyboardKey.f1,
    LogicalKeyboardKey.f2,
    LogicalKeyboardKey.f3,
    LogicalKeyboardKey.f4,
    LogicalKeyboardKey.f5,
    LogicalKeyboardKey.f6,
    LogicalKeyboardKey.f7,
    LogicalKeyboardKey.f8,
    LogicalKeyboardKey.f9,
    LogicalKeyboardKey.f10,
    LogicalKeyboardKey.f11,
    LogicalKeyboardKey.f12,
    LogicalKeyboardKey.escape,
    LogicalKeyboardKey.printScreen,
    LogicalKeyboardKey.pause,
    LogicalKeyboardKey.insert,
    LogicalKeyboardKey.home,
    LogicalKeyboardKey.pageUp,
    LogicalKeyboardKey.delete,
    LogicalKeyboardKey.end,
    LogicalKeyboardKey.pageDown,
    LogicalKeyboardKey.arrowLeft,
    LogicalKeyboardKey.arrowRight,
    LogicalKeyboardKey.arrowUp,
    LogicalKeyboardKey.arrowDown,
  };

  Future<void> initialize() async {
    if (_isEnabled) return;
    
    _isEnabled = true;
    _currentBuffer = '';
    _lastKeyTime = DateTime.now();
    
    await _writeTextLog('Keyboard logger initialized');
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    _startInactivityTimer();
  }

  void _startInactivityTimer() {
    return;
    _inactivityTimer = Timer.periodic(Duration(seconds: 1), (timer) {
      final now = DateTime.now();
      final timeDiff = now.difference(_lastKeyTime);
      
      if (timeDiff >= _inactivityThreshold && _currentBuffer.isNotEmpty) {
        _writeTextLog('Inactivity timeout reached, saving buffer');
        _saveKeyboardInput();
      }
    });
  }

  void handleKeyEvent(RawKeyEvent event) {
    if (!_isEnabled) return;
    
    final now = DateTime.now();
    _lastKeyTime = now;

    if (event is RawKeyDownEvent) {
      final logicalKey = event.logicalKey;
      
      // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∫–ª–∞–≤–∏—à–∏
      if (_ignoredKeys.contains(logicalKey)) return;

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –∫–ª–∞–≤–∏—à
      if (logicalKey == LogicalKeyboardKey.backspace) {
        _handleBackspace();
      } else if (logicalKey == LogicalKeyboardKey.enter) {
        _handleEnter();
      } else if (logicalKey == LogicalKeyboardKey.space) {
        _handleSpace();
      } else if (logicalKey == LogicalKeyboardKey.tab) {
        _handleTab();
      } else {
        // –û–±—ã—á–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
        _handleCharacter(logicalKey);
      }
    }
  }

  void _handleBackspace() {
    if (_currentBuffer.isNotEmpty) {
      _currentBuffer = _currentBuffer.substring(0, _currentBuffer.length - 1);
      _writeTextLog('Backspace pressed, buffer length: ${_currentBuffer.length}');
    }
  }

  void _handleEnter() {
    _writeTextLog('Enter pressed, saving buffer with ${_currentBuffer.length} characters');
    _currentBuffer += '\n';
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ Enter
    _saveKeyboardInput();
  }

  void _handleSpace() {
    _currentBuffer += ' ';
    _writeTextLog('Space pressed, buffer: "${_getBufferPreview()}"');
  }

  void _handleTab() {
    _currentBuffer += '\t';
    _writeTextLog('Tab pressed, buffer: "${_getBufferPreview()}"');
  }

  void _handleCharacter(LogicalKeyboardKey key) {
    final keyLabel = key.keyLabel;
    
    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ —Ç–µ–∫—Å—Ç–µ
    if (keyLabel.length == 1 && _isValidCharacter(keyLabel)) {
      _currentBuffer += keyLabel;
      _writeTextLog('Character pressed: "$keyLabel", buffer: "${_getBufferPreview()}"');
    } else {
      _writeTextLog('Invalid character filtered: "$keyLabel" (key: ${key.keyId})');
    }
  }

  String _getBufferPreview() {
    if (_currentBuffer.isEmpty) return 'empty';
    final preview = _currentBuffer.length > 30 
        ? '${_currentBuffer.substring(0, 30)}...' 
        : _currentBuffer;
    return preview.replaceAll('\n', '\\n').replaceAll('\t', '\\t');
  }

  bool _isValidCharacter(String char) {
    // –ë–∞–∑–æ–≤—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ —Å–∏–º–≤–æ–ª–∞
    if (char.isEmpty) return false;
    
    final codeUnit = char.codeUnitAt(0);
    
    // –†–∞–∑—Ä–µ—à–∞–µ–º –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã, –æ—Å–Ω–æ–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
    // –ö–∏—Ä–∏–ª–ª–∏—Ü–∞: 1040-1103 (–ê-–Ø–∞-—è) + –Å—ë (1025, 1105)
    // –õ–∞—Ç–∏–Ω–Ω–∏—Ü–∞: 65-90 (A-Z), 97-122 (a-z)
    // –¶–∏—Ñ—Ä—ã: 48-57 (0-9)
    // –û—Å–Ω–æ–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã: 32 (–ø—Ä–æ–±–µ–ª), 33-47, 58-64, 91-96, 123-126
    return (codeUnit >= 1040 && codeUnit <= 1103) || // –ö–∏—Ä–∏–ª–ª–∏—Ü–∞
           (codeUnit == 1025 || codeUnit == 1105) || // –Å—ë
           (codeUnit >= 65 && codeUnit <= 90) ||     // A-Z
           (codeUnit >= 97 && codeUnit <= 122) ||    // a-z
           (codeUnit >= 48 && codeUnit <= 57) ||     // 0-9
           (codeUnit >= 32 && codeUnit <= 126);      // –û—Å–Ω–æ–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
  }

  bool _isValidContent(String content) {
    if (content.isEmpty) return false;
    
    final trimmed = content.trim();
    
    // –°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    if (trimmed.length < 3) {
      _writeTextLog('Content too short: $trimmed');
      return false;
    }
    
    // –¢–æ–ª—å–∫–æ –ø—Ä–æ–±–µ–ª—ã/–ø–µ—Ä–µ–Ω–æ—Å—ã
    if (trimmed.isEmpty) {
      _writeTextLog('Content only whitespace');
      return false;
    }
    
    // –ü–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è —Å–∏–º–≤–æ–ª—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, "aaaaaaa")
    final repeatingRegex = RegExp(r'^(.)\1{4,}$'); // 5+ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
    if (repeatingRegex.hasMatch(trimmed)) {
      _writeTextLog('Content repeating characters: $trimmed');
      return false;
    }
    
    // –¢–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã (–∫–æ—Ä–æ—Ç–∫–∏–µ —á–∏—Å–ª–æ–≤—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏)
    final onlyDigits = RegExp(r'^\d+$');
    if (onlyDigits.hasMatch(trimmed) && trimmed.length < 5) {
      _writeTextLog('Content only digits: $trimmed');
      return false;
    }
    
    // –°–ª—É—á–∞–π–Ω—ã–µ –Ω–∞–∂–∞—Ç–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, "asdfghjk")
    if (_isRandomTyping(trimmed)) {
      _writeTextLog('Content random typing: $trimmed');
      return false;
    }
    
    return true;
  }

  bool _isRandomTyping(String text) {
    if (text.length < 6) return false;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Ç–∏–ø–∞ "asdfgh" –∏–ª–∏ "qwerty"
    final commonRandomPatterns = [
      'asdfgh', 'qwerty', 'zxcvbn', '–π—Ü—É–∫–µ–Ω', '—Ñ—ã–≤–∞–ø—Ä', '—è—á—Å–º–∏—Ç'
    ];
    
    final lowerText = text.toLowerCase();
    for (final pattern in commonRandomPatterns) {
      if (lowerText.contains(pattern)) {
        return true;
      }
    }
    
    return false;
  }

  Future<void> _saveKeyboardInput() async {
    if (_currentBuffer.isEmpty) {
      _writeTextLog('Save attempted but buffer is empty');
      return;
    }

    if (!_isValidContent(_currentBuffer)) {
      _writeTextLog('Invalid content, skipping save: "${_currentBuffer.substring(0, min(_currentBuffer.length, 20))}..."');
      _currentBuffer = '';
      return;
    }

    try {
      final directory = await getApplicationDocumentsDirectory();
      final copypasteDir = Directory('${directory.path}/copypasted');
      
      if (!copypasteDir.existsSync()) {
        copypasteDir.createSync(recursive: true);
        _writeTextLog('Created directory: ${copypasteDir.path}');
      }

      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'keyboard_$timestamp.cnp';
      final file = File('${copypasteDir.path}/$fileName');
      
      final entry = {
        'content': _currentBuffer,
        'timestamp': timestamp,
        'source': 'keyboard',
        'starred': false,
        'length': _currentBuffer.length,
      };

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π UTF-8
      final jsonString = jsonEncode(entry);
      final bytes = utf8.encode(jsonString);
      await file.writeAsBytes(bytes);
      
      _writeTextLog('Keyboard input saved: ${_currentBuffer.length} characters to $fileName');
      
      // –û—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
      _currentBuffer = '';
      
    } catch (e) {
      await _writeTextLog('Error saving keyboard input: $e');
    }
  }

  Future<void> _writeTextLog(String message) async {
    try {
      final documentsDir = await getApplicationDocumentsDirectory();
      final logFile = File('${documentsDir.path}/log_keylogger_text.log');
      
      final timestamp = DateTime.now().toString();
      final logMessage = '[$timestamp] $message\n';
      
      // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω–µ—Ü —Ñ–∞–π–ª–∞
      await logFile.writeAsString(logMessage, mode: FileMode.append);
      
      // –¢–∞–∫–∂–µ –≤—ã–≤–æ–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª—å –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
      print(message);
    } catch (e) {
      print('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –ª–æ–≥–∞: $e');
    }
  }

  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â–∏–π –±—É—Ñ–µ—Ä
  Future<void> forceSave() async {
    if (_currentBuffer.isNotEmpty) {
      await _writeTextLog('Force save triggered');
      await _saveKeyboardInput();
    } else {
      await _writeTextLog('Force save attempted but buffer is empty');
    }
  }

  // –û—á–∏—Å—Ç–∏—Ç—å —Ç–µ–∫—É—â–∏–π –±—É—Ñ–µ—Ä –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
  void clearBuffer() {
    _writeTextLog('Buffer cleared manually, was ${_currentBuffer.length} characters');
    _currentBuffer = '';
    _lastKeyTime = DateTime.now();
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
  Map<String, dynamic> getStatus() {
    return {
      'isEnabled': _isEnabled,
      'bufferLength': _currentBuffer.length,
      'lastActivity': _lastKeyTime,
      'timeSinceLastActivity': DateTime.now().difference(_lastKeyTime).inSeconds,
      'bufferPreview': _currentBuffer.length > 50 
          ? '${_currentBuffer.substring(0, 50)}...' 
          : _currentBuffer,
    };
  }

  void dispose() {
    _writeTextLog('Keyboard logger disposed');
    _isEnabled = false;
    _inactivityTimer?.cancel();
    _inactivityTimer = null;
    
    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Å—Ç–∞–≤—à–∏–π—Å—è –±—É—Ñ–µ—Ä –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏
    if (_currentBuffer.isNotEmpty) {
      _writeTextLog('Auto-saving remaining buffer on dispose');
      _saveKeyboardInput();
    }
  }

  int min(int a, int b) => a < b ? a : b;
}
class ProcessManager {
  static final ProcessManager _instance = ProcessManager._internal();
  final Map<String, Process> _processes = {};

  factory ProcessManager() => _instance;

  ProcessManager._internal();

  void registerProcess(String id, Process process) {
    _processes[id] = process;
  }

  void killProcess(String id) {
    if (_processes.containsKey(id)) {
      _processes[id]?.kill();
      _processes.remove(id);
    }
  }

  void killAllProcesses() {
    _processes.forEach((id, process) {
      process.kill();
    });
    _processes.clear();
  }

  bool hasProcess(String id) => _processes.containsKey(id);

  // ======================
  // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–æ–¥ getProcess
  // ======================
  Process? getProcess(String id) {
    return _processes[id];
  }
}

  void _writeToDebugLog(String message) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final debugFile = File('${directory.path}/chat_debug.log');
      await debugFile.writeAsString('${DateTime.now()}: $message\n', mode: FileMode.append);
      print('DEBUG: $message'); // –¢–∞–∫–∂–µ –≤—ã–≤–æ–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª—å
    } catch (e) {
      print('Error writing to debug log: $e');
    }
  }

Future<String> _getSharedFilePath() async {
  final directory = await getApplicationDocumentsDirectory();
  return '${directory.path}/shared_eaten_files.json';
}

void _handleFileFeed(String filePath) {
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é
  print('Feeding file to AI: $filePath');
  // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª –≤ –æ—Å–Ω–æ–≤–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
}

void _handleTextFeed(String text) {
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é –±—Ä–∞—É–∑–µ—Ä–∞
  print('Feeding text to AI: $text');
  // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –≤ –æ—Å–Ω–æ–≤–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
  
}


void main(List<String> args) async {
  _writeToDebugLog1("0");
  WidgetsFlutterBinding.ensureInitialized();
  _writeToDebugLog1("1");
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
  if (args.isNotEmpty) {
      if (args.contains('--feed-file')) {
    final fileIndex = args.indexOf('--feed-file') + 1;
    if (fileIndex < args.length) {
      final filePath = args[fileIndex];
      _handleFileFeed(filePath);
      return;
    }
  }
  
  if (args.contains('--feed-text')) {
    final textIndex = args.indexOf('--feed-text') + 1;
    if (textIndex < args.length) {
      final text = args[textIndex];
      _handleTextFeed(text);
      return;
    }
  }
    if (args[0]=='ai_open'){
      
      await _initAIWindow();
       runApp(MaterialApp(
        title: 'Advanced Neural Network System',
        theme: ThemeData.dark(),
        home: NeuralNetworkApp(),
      ));
        return;
    }else if (args[0]=='essentials'){
      
      await _initEssentialsWindow();
        runApp(EssentialsApp(
        ));
        return;
    }else if (args[0]=='macro_keyboard'){
      
      await _initMacroKeyboardWindow();
         runApp( VirtualKeyboardApp());
        return;
    }else

    if (args[0] == 'chat') {
        final debugFile = File('chat_debug.log');
        await debugFile.writeAsString('Chat window args: $args\n', mode: FileMode.append);
        
        // –ü–∞—Ä—Å–∏–º –∏—Å—Ç–æ—Ä–∏—é —á–∞—Ç–∞
        List<Map<String, String>> chatHistory = [];
        if (args.length > 1 && args[1].isNotEmpty && args[1] != '[]') {
          try {
            final parsed = json.decode(args[1]) as List;
            chatHistory = parsed.map((item) => Map<String, String>.from(item)).toList();
          } catch (e) {
            debugFile.writeAsString('Error parsing chat history: $e\n', mode: FileMode.append);
          }
        }
        
        await _initChatWindow(args);
        runApp(ChatWindowApp(initialChatHistory: chatHistory));
        return;
      }else if (args[0] == 'files') {
  await _initFilesWindow();
  runApp(EatenFilesWindowApp(
    
  ));
} else if(args[0] == 'screenshoter') {
    await _initScreenshotWindow();
    runApp(const ScreenshotApp());
  }else if(args[0] == 'clipboard-history') {
    await _initClipboardHistoryWindow();
    runApp(const ClipboardHistoryWindow());
  } else if (args[0] == 'settings') {
      await _initSettingsWindow();
         String apiKey = args.length > 1 ? args[1] : '';
    bool useDeepSeek = args.length > 2 ? args[2].toLowerCase() == 'true' : false;
    String petName = args.length > 3 ? args[3] : '–ü–∏—Ç–æ–º–µ—Ü';
    bool useVision = args.length > 4 ? args[4].toLowerCase() == 'true' : false;

    runApp(SettingsWindowApp(
      apiKey: apiKey,
      petName: petName,
      useDeepSeek: useDeepSeek,
      useVision: useVision,
    ));

    } else  if (args.contains('--feed-file') && args.length > 1) {
    final fileIndex = args.indexOf('--feed-file') + 1;
    if (fileIndex < args.length) {
      final filePath = args[fileIndex];
      print('Feeding file: $filePath');
    }
  }
  else {
      // –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
      await _initMainWindow();
      
    }   
  } else {
    // –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    await _initMainWindow();
    
  }
}


Future<void> _initClipboardHistoryWindow() async {
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = WindowOptions(
    size: Size(400, 800), // –í—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä, –ø–æ—Ç–æ–º —É—Å—Ç–∞–Ω–æ–≤–∏–º —Ç–æ—á–Ω—ã–π
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    alwaysOnTop: true,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã —ç–∫—Ä–∞–Ω–∞ —á–µ—Ä–µ–∑ screen_retriever
    final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    final windowHeight = screenSize.height * 0.8;

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä
    await windowManager.setSize(Size(400, windowHeight));

    // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (–∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —ç–∫—Ä–∞–Ω–∞ —Å–ø—Ä–∞–≤–∞)
    final startPosition = Offset(
      screenSize.width, // –ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞ –ø—Ä–∞–≤—ã–º –∫—Ä–∞–µ–º
      (screenSize.height - windowHeight) / 2,
    );

    // –ö–æ–Ω–µ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
    final endPosition = Offset(
      screenSize.width - 405, // –ü—Ä–∞–≤—ã–π –∫—Ä–∞–π
      (screenSize.height - windowHeight) / 2,
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é (–Ω–µ–≤–∏–¥–∏–º–æ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º)
    await windowManager.setPosition(startPosition);
    await windowManager.setOpacity(0.0); // –ù–∞—á–∞–ª—å–Ω–∞—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ (–Ω–æ –ø–æ–∫–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–µ –∏ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º)
    await windowManager.show();

    // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è
    await _animateWindowAppearance(startPosition, endPosition);

    await windowManager.focus();

    print('Clipboard window initialized with animation');
  });
}


Future<void> _initAIWindow() async {
  await windowManager.ensureInitialized();
  await windowManager.setSize(ui.Size(1820, 940));
  await windowManager.center();
  //await windowManager.setAlwaysOnTop(true);
  await windowManager.setTitle('–ö–≤–∞–Ω—Ç–æ–≤—ã–π –º–æ–∑–≥');
  await windowManager.show();
}



Future<void> _initMacroKeyboardWindow() async {
  await windowManager.ensureInitialized();
  await windowManager.setOpacity(0.0);
  WindowOptions windowOptions = WindowOptions(
    size: Size(420, 800), // –í—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä, –ø–æ—Ç–æ–º —É—Å—Ç–∞–Ω–æ–≤–∏–º —Ç–æ—á–Ω—ã–π
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    alwaysOnTop: true,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã —ç–∫—Ä–∞–Ω–∞ —á–µ—Ä–µ–∑ screen_retriever
    final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    final windowHeight = screenSize.height * 0.35;
    final windowWidth = screenSize.width * 0.55;
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä
    await windowManager.setSize(Size(windowWidth, windowHeight));

    // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (–∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —ç–∫—Ä–∞–Ω–∞ —Å–ø—Ä–∞–≤–∞)
    final startPosition = Offset(
      (screenSize.width - windowWidth)/2, // –ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞ –ø—Ä–∞–≤—ã–º –∫—Ä–∞–µ–º
      (screenSize.height ) ,
    );

    // –ö–æ–Ω–µ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
    final endPosition = Offset(
  (screenSize.width - windowWidth )/2, // –ü—Ä–∞–≤—ã–π –∫—Ä–∞–π
      (screenSize.height - windowHeight) - 50,
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é (–Ω–µ–≤–∏–¥–∏–º–æ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º)
    await windowManager.setPosition(startPosition);
    await windowManager.setOpacity(0.0); // –ù–∞—á–∞–ª—å–Ω–∞—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ (–Ω–æ –ø–æ–∫–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–µ –∏ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º)
    await windowManager.show();

    // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è
    await _animateWindowAppearanceFromBottom(startPosition, endPosition);

    await windowManager.focus();

    print('Clipboard window initialized with animation');
  });
}
Future<void> _initEssentialsWindow() async {
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = WindowOptions(
    size: Size(420, 800), // –í—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä, –ø–æ—Ç–æ–º —É—Å—Ç–∞–Ω–æ–≤–∏–º —Ç–æ—á–Ω—ã–π
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    alwaysOnTop: true,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã —ç–∫—Ä–∞–Ω–∞ —á–µ—Ä–µ–∑ screen_retriever
    final primaryDisplay = await screenRetriever.getPrimaryDisplay();
    final screenSize = primaryDisplay.size;
    final windowHeight = screenSize.height * 0.8;

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä
    await windowManager.setSize(Size(420, windowHeight));

    // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (–∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —ç–∫—Ä–∞–Ω–∞ —Å–ø—Ä–∞–≤–∞)
    final startPosition = Offset(
      screenSize.width, // –ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞ –ø—Ä–∞–≤—ã–º –∫—Ä–∞–µ–º
      (screenSize.height - windowHeight) / 2,
    );

    // –ö–æ–Ω–µ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
    final endPosition = Offset(
      screenSize.width - 405, // –ü—Ä–∞–≤—ã–π –∫—Ä–∞–π
      (screenSize.height - windowHeight) / 2,
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é (–Ω–µ–≤–∏–¥–∏–º–æ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º)
    await windowManager.setPosition(startPosition);
    await windowManager.setOpacity(0.0); // –ù–∞—á–∞–ª—å–Ω–∞—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ (–Ω–æ –ø–æ–∫–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–µ –∏ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º)
    await windowManager.show();

    // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è
    await _animateWindowAppearance(startPosition, endPosition);

    await windowManager.focus();

    print('Clipboard window initialized with animation');
  });
}





Future<void> _animateWindowAppearanceFromBottom(Offset startPos, Offset endPos) async {
  const duration = Duration(milliseconds: 390);
  const steps = 60;
  final stepDuration = duration ~/ steps;

  for (int i = 0; i <= steps; i++) {
    final progress = i / steps;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—Ä–∏–≤—É—é –¥–ª—è –±–æ–ª–µ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
    final curvedProgress = Curves.easeOutCubic.transform(progress);
    
    final currentY = startPos.dy + (endPos.dy - startPos.dy) * curvedProgress;
    final currentPosition = Offset(startPos.dx,currentY);
    
    // –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ –∫—Ä–∏–≤—ã–µ –¥–ª—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∏ –¥–≤–∏–∂–µ–Ω–∏—è
    final fadeProgress = Curves.easeOutCubic.transform(progress);
    final currentOpacity = fadeProgress;

    await windowManager.setPosition(currentPosition);
    await windowManager.setOpacity(currentOpacity);

    await Future.delayed(stepDuration);
  }

  // –§–∏–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  await windowManager.setPosition(endPos);
  await windowManager.setOpacity(1.0);
}


Future<void> _animateWindowAppearance(Offset startPos, Offset endPos) async {
  const duration = Duration(milliseconds: 390);
  const steps = 60;
  final stepDuration = duration ~/ steps;

  for (int i = 0; i <= steps; i++) {
    final progress = i / steps;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—Ä–∏–≤—É—é –¥–ª—è –±–æ–ª–µ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
    final curvedProgress = Curves.easeOutCubic.transform(progress);
    
    final currentX = startPos.dx + (endPos.dx - startPos.dx) * curvedProgress;
    final currentPosition = Offset(currentX, startPos.dy);
    
    // –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ –∫—Ä–∏–≤—ã–µ –¥–ª—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∏ –¥–≤–∏–∂–µ–Ω–∏—è
    final fadeProgress = Curves.easeOutCubic.transform(progress);
    final currentOpacity = fadeProgress;

    await windowManager.setPosition(currentPosition);
    await windowManager.setOpacity(currentOpacity);

    await Future.delayed(stepDuration);
  }

  // –§–∏–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  await windowManager.setPosition(endPos);
  await windowManager.setOpacity(1.0);
}

Future<void> _animateFadeIn() async {
  const duration = Duration(milliseconds: 390);
  const steps = 60;
  final stepDuration = duration ~/ steps;

  for (int i = 0; i <= steps; i++) {
    final progress = i / steps;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—Ä–∏–≤—É—é –¥–ª—è –±–æ–ª–µ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
    final curvedProgress = Curves.easeOutCubic.transform(progress);
    
    
    // –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ –∫—Ä–∏–≤—ã–µ –¥–ª—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∏ –¥–≤–∏–∂–µ–Ω–∏—è
    final fadeProgress = Curves.easeOutCubic.transform(progress);
    final currentOpacity = fadeProgress;

    await windowManager.setOpacity(currentOpacity);

    await Future.delayed(stepDuration);
  }


  await windowManager.setOpacity(1.0);
}

Future<void> _initChatWindow(List<String> args) async {
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = WindowOptions(
    size: Size(360, 700),
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    alwaysOnTop: true,
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    try {
      await windowManager.setAsFrameless();
    } catch (e) {
      print('Error setting frameless: $e');
    }

    try {
      await windowManager.setHasShadow(false);
    } catch (e) {
      print('Error disabling shadow: $e');
    }

    await windowManager.setSize(Size(360, 700));

    // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è, –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–ª–∏ args
    if (args.length >= 4) {
      try {
        final parentX = double.parse(args[2]);
        final parentY = double.parse(args[3]);
        final targetX = parentX - 180;
        final targetY = parentY - 650;

        final display = await screenRetriever.getPrimaryDisplay();
        final screenSize = display.size;

        final finalX = targetX.clamp(0.0, screenSize.width - 600);
        final finalY = max(targetY, 0.0);

        await windowManager.setPosition(Offset(finalX, finalY));
      } catch (e) {
        await windowManager.center();
      }
    } else {
      await windowManager.center();
    }

    await windowManager.show();
    await windowManager.focus();
  });
_animateFadeIn();
  // ======================
  // –°–ª—É—à–∞—Ç–µ–ª—å stdin –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏
  // ======================
  
}
Future<void> _initFilesWindow() async {
  await windowManager.ensureInitialized();
  await windowManager.setSize(ui.Size(800, 600));
  await windowManager.center();
  await windowManager.setAlwaysOnTop(true);
  await windowManager.setTitle('üìÅ –°—ä–µ–¥–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã');
  await windowManager.show();
}

Future<void> _initScreenshotWindow() async {
  await windowManager.ensureInitialized();
  final display = await screenRetriever.getPrimaryDisplay();
        final screenSize = display.size;

  await windowManager.setSize(ui.Size(screenSize.width,screenSize.height));
  await windowManager.center();
  await windowManager.setAlwaysOnTop(true);
  await windowManager.setTitle('üìÅ –°—ä–µ–¥–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã');
  await windowManager.show();
}
Future<void> _initSettingsWindow() async {
  await windowManager.ensureInitialized();
  await windowManager.setSize(ui.Size(500, 400));
  await windowManager.center();
  await windowManager.setAlwaysOnTop(true);
  await windowManager.setTitle('–ù–∞—Å—Ç—Ä–æ–π–∫–∏');
}


Future<void> _initMainWindow() async {

  
  await windowManager.ensureInitialized();

  final prefs = await SharedPreferences.getInstance();
  final firstRun = prefs.getBool('first_run') ?? true;
  
  // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä —ç–∫—Ä–∞–Ω–∞
  final display = await screenRetriever.getPrimaryDisplay();
  final screenSize = display.size;
  
  final windowWidth = firstRun ? 400.0 : 260.0;
  final windowHeight = firstRun ? 500.0 : 270.0;

  WindowOptions windowOptions = WindowOptions(
    size: ui.Size(windowWidth, windowHeight),
    backgroundColor: Colors.transparent,
    skipTaskbar: firstRun ? false : true, // –î–ª—è –ø–µ—Ä–≤–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤ —Ç–∞—Å–∫–±–∞—Ä–µ
    titleBarStyle: firstRun ? TitleBarStyle.normal : TitleBarStyle.hidden,
    windowButtonVisibility: firstRun, // –ö–Ω–æ–ø–∫–∏ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
    alwaysOnTop: !firstRun, // –í—Å–µ–≥–¥–∞ –ø–æ–≤–µ—Ä—Ö –¥—Ä—É–≥–∏—Ö —Ç–æ–ª—å–∫–æ –Ω–µ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    if (firstRun) {
      // –î–ª—è –ø–µ—Ä–≤–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ - –æ–±—ã—á–Ω–æ–µ –æ–∫–Ω–æ –ø–æ —Ü–µ–Ω—Ç—Ä—É
      // –ù–µ frameless
      await windowManager.setAsFrameless();
      await windowManager.center(); // ‚úÖ –ü–û –¶–ï–ù–¢–†–£ –≠–ö–†–ê–ù–ê
    
    } else {
      // –î–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –∑–∞–ø—É—Å–∫–æ–≤ - frameless –æ–∫–Ω–æ –≤ –ø—Ä–∞–≤–æ–º –Ω–∏–∂–Ω–µ–º —É–≥–ª—É
      await windowManager.setAsFrameless();
      await windowManager.setAlwaysOnTop(true);
      await windowManager.setSkipTaskbar(true);
      await windowManager.setPosition(Offset(
        screenSize.width - windowWidth - 15, // right: 15
        screenSize.height - windowHeight - 150, // bottom: 150
      ));
    }
    if (Platform.isWindows) {
  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∏ –∫–ª–∏–∫–æ–≤
  windowManager.setIgnoreMouseEvents(false); // –†–∞–∑—Ä–µ—à–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –º—ã—à–∏
  // –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–æ–Ω –æ–∫–Ω–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
}
    await windowManager.setTitle('ImeYou Tamagochi');
    await windowManager.setSize(ui.Size(windowWidth, windowHeight));
    await windowManager.show();
  });
  final clipboardMonitor = ClipboardMonitor();
  await clipboardMonitor.initialize();


  runApp(MaterialApp(
    home: firstRun ? NameInputScreen() : TamagochiOverlay(),
    debugShowCheckedModeBanner: false,
  ));
}


class ChatWindowApp extends StatelessWidget {
  final List<Map<String, String>> initialChatHistory;
  final String chatName;

  const ChatWindowApp({Key? key, required this.initialChatHistory, this.chatName = 'Small talk'}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        backgroundColor: Colors.transparent,
        body: ChatWindowContent(
          initialChatHistory: initialChatHistory,
          initialChatName: chatName,
        ),
      ),
    );
  }
}

class ChatWindowContent extends StatefulWidget {
  final List<Map<String, String>> initialChatHistory;
  final String initialChatName;

  const ChatWindowContent({Key? key, required this.initialChatHistory, required this.initialChatName}) : super(key: key);

  @override
  _ChatWindowContentState createState() => _ChatWindowContentState();
}

class _ChatWindowContentState extends State<ChatWindowContent> {
  final List<ChatMessage> _chatHistory = [];
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  String _apiKey = '';
  bool _useDeepSeek = true;
  FocusNode _textFieldFocusNode = FocusNode();
  bool _isSearchMode = false;
  String _searchQuery = '';
  List<ChatMessage> _filteredChatHistory = [];
  bool _showFavorites = false;
  String _currentChatName = 'Small talk';
  List<String> _availableChats = ['Small talk'];
  Map<String, List<ChatMessage>> _chatHistories = {};
  Map<String, String> _chatFiles = {};
  bool _isRecording = false;
  stt.SpeechToText _speechToText = stt.SpeechToText();
  String _recognizedText = '';
  bool _searchWeb = true;
  bool _searchImages = false;
  bool _searchWiki = false;
  String _replyingTo = '';
  File? _backgroundImage;
  final Map<String, List<String>> _searchResults = {};
  final Map<String, List<Map<String, String>>> _imageResults = {};
  final Map<String, String> _wikiResults = {};
  bool _chatLocked = false;
  Timer? _directoryCheckTimer;
  int _hoveredMessageIndex = -1;
  String _defaultLanguage='ru';
  final _httpClient = http.Client();

Future<void> _translateTextToDefaultLanguage() async {
  await _translateText(_defaultLanguage);
}

Future<void> _translateTextToEnglishLanguage() async {
  await _translateText('en');
}

Future<void> _translateText(String targetLanguage) async {
  final text = _messageController.text.trim();
  if (text.isEmpty) {
    //_showMessage('–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞');
    return;
  }

  try {
   

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —è–∑—ã–∫
    final sourceLanguage = await _detectLanguage(text);
    
    // –ï—Å–ª–∏ –∏—Å—Ö–æ–¥–Ω—ã–π —è–∑—ã–∫ —É–∂–µ —Ü–µ–ª–µ–≤–æ–π - –Ω–µ –ø–µ—Ä–µ–≤–æ–¥–∏–º
    if (sourceLanguage == targetLanguage) {
      //_showMessage('–¢–µ–∫—Å—Ç —É–∂–µ –Ω–∞ —Ü–µ–ª–µ–≤–æ–º —è–∑—ã–∫–µ');
      return;
    }

    // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ API –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–æ–≤
    String translatedText = await _translateWithLibreTranslate(text, sourceLanguage, targetLanguage);
    
    if (translatedText.isEmpty) {
      translatedText = await _translateWithMyMemory(text, sourceLanguage, targetLanguage);
    }

    if (translatedText.isNotEmpty) {
      setState(() {
        _messageController.text = translatedText;
      });
      //_showMessage('–¢–µ–∫—Å—Ç –ø–µ—Ä–µ–≤–µ–¥–µ–Ω');
    } else {
      //_showMessage('–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥');
    }
    
  } catch (e) {
    //_showMessage('–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: $e');
  } finally {
    setState(() {
      //_isProcessing = false;
    });
  }
}

void _setupKeyboardListener() {
  RawKeyboard.instance.addListener((RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      final isControlPressed = event.isControlPressed;
      
      if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyQ) {
        _translateTextToDefaultLanguage(); // –û–±–Ω–æ–≤–ª–µ–Ω–æ
      } else if (isControlPressed && event.logicalKey == LogicalKeyboardKey.keyW) {
        _translateTextToEnglishLanguage(); // –û–±–Ω–æ–≤–ª–µ–Ω–æ
      }
    }
  });
}
// –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π API LibreTranslate
Future<String> _translateWithLibreTranslate(String text, String from, String to) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/translate'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'q': text,
        'source': from,
        'target': to,
        'format': 'text'
      }),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['translatedText'] ?? '';
    }
  } catch (e) {
    print('LibreTranslate error: $e');
  }
  return '';
}

// –†–µ–∑–µ—Ä–≤–Ω—ã–π API MyMemory
Future<String> _translateWithMyMemory(String text, String from, String to) async {
  try {
    final response = await _httpClient.get(
      Uri.parse('https://api.mymemory.translated.net/get?'
          'q=${Uri.encodeComponent(text)}&'
          'langpair=$from|$to'),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['responseData']['translatedText'] ?? '';
    }
  } catch (e) {
    print('MyMemory error: $e');
  }
  return '';
}

Future<String> _detectLanguage(String text) async {
  try {
    // –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —è–∑—ã–∫–∞
    return _detectLanguageBasic(text);
    
    // –î–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å API (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
    // return await _detectLanguageWithAPI(text);
  } catch (e) {
    return _detectLanguageBasic(text);
  }
}

// API –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞ (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
/*
Future<String> _detectLanguageWithAPI(String text) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/detect'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'q': text}),
    ).timeout(Duration(seconds: 5));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      if (data is List && data.isNotEmpty) {
        return data[0]['language'] ?? 'en';
      }
    }
  } catch (e) {
    print('Language detection API error: $e');
  }
  return _detectLanguageBasic(text);
}
*/

String _detectLanguageBasic(String text) {
  // –£–ª—É—á—à–µ–Ω–Ω–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —è–∑—ã–∫–∞
  final russianRegex = RegExp(r'[–∞-—è–ê-–Ø—ë–Å]');
  final englishRegex = RegExp(r'[a-zA-Z]');
  final koreanRegex = RegExp(r'[„Ñ±-„Öé„Öè-„Ö£Í∞Ä-Ìû£]');
  final chineseRegex = RegExp(r'[\u4e00-\u9fff]');
  final japaneseRegex = RegExp(r'[\u3040-\u309F\u30A0-\u30FF]');
  
  // –ü–æ–¥—Å—á–µ—Ç —Å–∏–º–≤–æ–ª–æ–≤ —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–æ–≤
  int russianCount = russianRegex.allMatches(text).length;
  int englishCount = englishRegex.allMatches(text).length;
  int koreanCount = koreanRegex.allMatches(text).length;
  int chineseCount = chineseRegex.allMatches(text).length;
  int japaneseCount = japaneseRegex.allMatches(text).length;
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫ –ø–æ –ø—Ä–µ–æ–±–ª–∞–¥–∞—é—â–∏–º —Å–∏–º–≤–æ–ª–∞–º
  if (russianCount > 0 && russianCount > englishCount) return 'ru';
  if (koreanCount > 0) return 'ko';
  if (chineseCount > 0) return 'zh';
  if (japaneseCount > 0) return 'ja';
  if (englishCount > 0) return 'en';
  
  return 'en'; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
}


  @override
  void initState() {
    super.initState();
    _loadAllChats().then((_) {
      setState(() {
        _currentChatName = widget.initialChatName;
        if (_chatHistories.containsKey(_currentChatName)) {
          _chatHistory.addAll(_chatHistories[_currentChatName]!);
        } else {
          _chatHistory.addAll(widget.initialChatHistory.map((msg) => ChatMessage.fromMap(msg)));
        }
        
        if (_chatHistory.isEmpty && _currentChatName == 'Small talk') {
          _chatHistory.add(ChatMessage(
            type: 'ai',
            message: '–ü—Ä–∏–≤–µ—Ç! –ö–∞–∫ –¥–µ–ª–∞? –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?',
            timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
            starred: false,
            chatName: 'Small talk'
          ));
        }
      });
      _scrollToBottom();
    });
    
    
    _loadSavedData();
    _initSpeechToText();
    _loadBackgroundImage();
    _startDirectoryWatcher();
    _initListenerStd();
    _startServer();
     _setupKeyboardListener();
  }
 Future<void> _imReady() async {
  try {
    // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É 1500 –º—Å
    await Future.delayed(const Duration(milliseconds: 300));
    await windowManager.focus();
      if (!_textFieldFocusNode.hasFocus) {
    _textFieldFocusNode.requestFocus();
  }
    final socket = await Socket.connect('localhost', 8082);
    // –Ø–≤–Ω–æ –∫–æ–¥–∏—Ä—É–µ–º –≤ UTF-8
    final encodedData = utf8.encode("chat is ready");
    socket.add(encodedData);
    await socket.flush();
    socket.destroy();
  } catch (e) {
    print('Error sending data: $e');
  }
}
  void _initListenerStd(){
  // –¢–µ–∫—É—â–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–∫–Ω–∞
  double currentX = 0;
  double currentY = 0;
  
  stdin.transform(utf8.decoder).transform(const LineSplitter()).listen((line) async {
    try {
      final parts = line.trim().split(',');
      if (parts.length == 2) {
        final targetX = double.tryParse(parts[0]) ?? 0;
        final targetY = double.tryParse(parts[1]) ?? 0;
        
        final dx = targetX - 45;
        final dy = targetY - 625;
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–≤–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é
        await _smoothMove(currentX, currentY, dx, dy, 50);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        currentX = dx;
        currentY = dy;
      }
    } catch (e) {
      print('Error parsing position from stdin: $e');
    }
  });
}

Future<void> _smoothMove(double startX, double startY, double targetX, double targetY, int durationMs) async {
  const int frames = 8; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–¥—Ä–æ–≤ –∞–Ω–∏–º–∞—Ü–∏–∏
  const double frameDuration = 50 / 8; // ~6.25ms –Ω–∞ –∫–∞–¥—Ä
  
  for (int i = 1; i <= frames; i++) {
    // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∞–Ω–∏–º–∞—Ü–∏–∏ (0.0 - 1.0)
    double progress = i / frames;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–∏–Ω–µ–π–Ω—É—é –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—é
    double currentX = startX + (targetX - startX) * progress;
    double currentY = startY + (targetY - startY) * progress;
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –æ–∫–Ω–∞
    await windowManager.setBounds(Rect.fromLTWH(currentX, currentY, 360, 700));
    
    // –ñ–¥–µ–º –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∫–∞–¥—Ä–æ–º
    await Future.delayed(Duration(milliseconds: frameDuration.round()));
  }
  
  // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏
  await windowManager.setBounds(Rect.fromLTWH(targetX, targetY, 360, 700));
}

Future<void> _startServer() async {
  final server = await ServerSocket.bind('localhost', 8080);
  print('Server listening on port 8080');

  server.listen((Socket socket) {
    final List<int> dataBuffer = [];
    
    socket.listen(
      (List<int> data) {
        dataBuffer.addAll(data);
      },
      onDone: () {
        // –î–µ–∫–æ–¥–∏—Ä—É–µ–º –≤—Å–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ UTF-8
        final String receivedString = utf8.decode(dataBuffer);
        _putIntoInput(receivedString);
      },
      onError: (error) {
        print('Socket error: $error');
      }
    );
  });

  await _imReady();
}
void _putIntoInput(String clipboardtext) {

  
  // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ –ø–æ–ª—É—á–∞–µ—Ç —Ñ–æ–∫—É—Å
  if (!_textFieldFocusNode.hasFocus) {
    _textFieldFocusNode.requestFocus();
  }
  
  final currentText = _messageController.text;
  
  String newText;
  int newPosition;
  
  // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ –Ω–µ –≤ —Ñ–æ–∫—É—Å–µ –∏–ª–∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è,
  // –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –≤ –∫–æ–Ω–µ—Ü
  if (!_textFieldFocusNode.hasFocus || _messageController.selection.baseOffset == -1) {
    newText = currentText + clipboardtext;
    newPosition = newText.length;
  } else {
    final selection = _messageController.selection;
    
    if (selection.start == selection.end) {
      // –ö—É—Ä—Å–æ—Ä –±–µ–∑ –≤—ã–¥–µ–ª–µ–Ω–∏—è - –≤—Å—Ç–∞–≤–ª—è–µ–º –≤ –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞
      final before = currentText.substring(0, selection.start);
      final after = currentText.substring(selection.end);
      newText = '$before$clipboardtext$after';
      newPosition = selection.start + clipboardtext.length;
    } else {
      // –ï—Å—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç - –∑–∞–º–µ–Ω—è–µ–º –µ–≥–æ
      final before = currentText.substring(0, selection.start);
      final after = currentText.substring(selection.end);
      newText = '$before$clipboardtext$after';
      newPosition = selection.start + clipboardtext.length;
    }
  }
  
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º setValue –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
  _messageController.value = TextEditingValue(
    text: newText,
    selection: TextSelection.collapsed(offset: newPosition),
  );
  
  // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —Ñ–æ–∫—É—Å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
  _textFieldFocusNode.requestFocus();
  setState(() {}); // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã—Å–æ—Ç—É
}
  void _startDirectoryWatcher() {
    _directoryCheckTimer = Timer.periodic(Duration(seconds: 5), (timer) async {
      await _checkForNewFiles();
    });
  }

  Future<void> _checkForNewFiles() async {
    await _loadAllChats();
  }

  Future<void> _loadAllChats() async {
    final directory = await getApplicationDocumentsDirectory();
    final chatsDir = Directory('${directory.path}/imeyou_pet/chats');
    
    if (!chatsDir.existsSync()) {
      chatsDir.createSync(recursive: true);
      return;
    }

    var chatFolders = chatsDir.listSync();
    List<String> chats = ['–ù–æ–≤—ã–π —á–∞—Ç'];
    Map<String, List<ChatMessage>> allChats = {};

    for (var folder in chatFolders) {
      if (folder is Directory) {
        String chatName = path.basename(folder.path);
        if (chatName != '–ù–æ–≤—ã–π —á–∞—Ç') {
          chats.add(chatName);
          allChats[chatName] = await _loadChatHistory(chatName);
        }
      }
    }

    setState(() {
      _availableChats = chats;
      _chatHistories = allChats;
    });
  }

  Future<List<ChatMessage>> _loadChatHistory(String chatName) async {
    final directory = await getApplicationDocumentsDirectory();
    final chatDir = Directory('${directory.path}/imeyou_pet/chats/$chatName');
    List<ChatMessage> history = [];

    if (chatDir.existsSync()) {
      var messageFiles = chatDir.listSync();
      
      // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ–∞–π–ª—ã –ø–æ timestamp
      messageFiles.sort((a, b) {
        String nameA = path.basename(a.path);
        String nameB = path.basename(b.path);
        return nameA.compareTo(nameB);
      });

      for (var file in messageFiles) {
        if (file is File && file.path.endsWith('.json')) {
          try {
            String content = await file.readAsString();
            Map<String, dynamic> messageData = json.decode(content);
            history.add(ChatMessage(
              type: messageData['source'] ?? messageData['type'] ?? 'user',
              message: messageData['text'] ?? messageData['message'] ?? '',
              timestamp: messageData['timestamp'] ?? DateTime.now().millisecondsSinceEpoch.toString(),
              starred: messageData['starred'] == true || messageData['starred'] == 'true',
              chatName: chatName,
              searchResults: List<String>.from(messageData['searchResults'] ?? []),
              imageResults: List<Map<String, String>>.from(messageData['imageResults'] ?? []),
              wikiResult: messageData['wikiResult'] ?? ''
            ));
          } catch (e) {
            print('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ ${file.path}: $e');
          }
        }
      }
    }
    return history;
  }

  Future<void> _saveMessageToChat(ChatMessage message) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final chatDir = Directory('${directory.path}/imeyou_pet/chats/${message.chatName}');
      
      if (!chatDir.existsSync()) {
        chatDir.createSync(recursive: true);
      }
      
      String timestamp = message.timestamp;
      String sourcePrefix = message.type.toLowerCase() == 'ai' ? 'ai' : 'user';
      String fileName = '${timestamp}_$sourcePrefix.json';
      
      final messageFile = File('${chatDir.path}/$fileName');
      await messageFile.writeAsString(json.encode(message.toMap()));
      
    } catch (e) {
      print('Error saving message: $e');
    }
  }

  void _initSpeechToText() async {
    bool available = await _speechToText.initialize();
    if (!available) {
      print("Speech to text not available");
    }
  }

  void _loadBackgroundImage() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final bgDir = Directory('${directory.path}/imeyou_pet/widget_backgrounds');
      
      if (bgDir.existsSync()) {
        final configFile = File('${bgDir.path}/current_chat_bg.json');
        if (configFile.existsSync()) {
          final jsonString = await configFile.readAsString();
          final configData = json.decode(jsonString);
          final bgPath = configData['current_bg'];
          
          if (bgPath != null && File(bgPath).existsSync()) {
            setState(() {
              _backgroundImage = File(bgPath);
            });
            return;
          }
        }
        
        final files = bgDir.listSync();
        for (var file in files) {
          if (file.path.endsWith('chat_skin.png') || file.path.endsWith('chat_skin.jpg')) {
            setState(() {
              _backgroundImage = File(file.path);
            });
            break;
          }
        }
      }
    } catch (e) {
      print('Error loading background: $e');
    }
  }

  void _loadSavedData() async {
    final prefs = await SharedPreferences.getInstance();
    if (mounted) {
      setState(() {
        _apiKey = prefs.getString('api_key') ?? '';
        _useDeepSeek = prefs.getBool('use_deepseek') ?? true;
      });
    }
  }

  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  void _sendMessage() async {
    if (_chatLocked) return;
    
    final message = _messageController.text.trim();
    if (message.isEmpty) return;

    final userMessage = ChatMessage(
      type: 'user',
      message: message,
      timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
      starred: false,
      chatName: _currentChatName
    );
    
    setState(() {
      _chatHistory.add(userMessage);
      _messageController.clear();
      _replyingTo = '';
    });
    
    await _saveMessageToChat(userMessage);
    _scrollToBottom();

    if (_apiKey.isNotEmpty) {
      await _callAIAPI(message);
    }

    if (_searchWeb || _searchImages || _searchWiki) {
      await _performSearches(message);
    }
  }

  Future<void> _callAIAPI(String prompt) async {
    try {
      List<Map<String, dynamic>> messages = [];
      int startIndex = max(0, _chatHistory.length - 100);
      
      for (int i = startIndex; i < _chatHistory.length; i++) {
        var msg = _chatHistory[i];
        messages.add({
          "role": msg.type == 'user' ? "user" : "assistant",
          "content": msg.message
        });
      }

      messages.add({"role": "user", "content": prompt});

      var response = await http.post(
        Uri.parse('https://api.deepseek.com/v1/chat/completions'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $_apiKey',
        },
        body: json.encode({
          'model': 'deepseek-chat',
          'messages': messages,
          'max_tokens': 1000,
        }),
      );

      if (response.statusCode == 200) {
        var data = json.decode(response.body);
        String aiResponse = data['choices'][0]['message']['content'];
        
        if (_currentChatName == '–ù–æ–≤—ã–π —á–∞—Ç' && aiResponse.contains('<chatname>')) {
          RegExp exp = RegExp(r'<chatname>(.*?)</chatname>');
          Match? match = exp.firstMatch(aiResponse);
          if (match != null) {
            String newChatName = match.group(1)!;
            setState(() {
              _currentChatName = newChatName;
              _availableChats = [_availableChats[0], 'Small talk', newChatName];
            });
            aiResponse = aiResponse.replaceAll(exp, '').trim();
          }
        }

        if (aiResponse.toLowerCase().contains('–∑–∞–∫—Ä—ã—Ç–∏–µ —á–∞—Ç–∞') || 
            aiResponse.toLowerCase().contains('chat closed')) {
          setState(() {
            _chatLocked = true;
          });
        }

        final aiMessage = ChatMessage(
          type: 'ai',
          message: aiResponse,
          timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
          starred: false,
          chatName: _currentChatName
        );
        
        setState(() {
          _chatHistory.add(aiMessage);
        });
        
        await _saveMessageToChat(aiMessage);
        _scrollToBottom();
      }
    } catch (e) {
      print('Error calling AI API: $e');
      // Fallback —Å–æ–æ–±—â–µ–Ω–∏–µ
      final fallbackMessage = ChatMessage(
        type: 'ai',
        message: '–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ AI —Å–µ—Ä–≤–∏—Å—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ API –∫–ª—é—á–∞.',
        timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
        starred: false,
        chatName: _currentChatName
      );
      
      setState(() {
        _chatHistory.add(fallbackMessage);
      });
      await _saveMessageToChat(fallbackMessage);
      _scrollToBottom();
    }
  }

  Future<void> _performSearches(String query) async {
    if (_searchWeb) {
      await _searchWebResults(query);
    }
    if (_searchImages) {
      await _searchImagesResults(query);
    }
    if (_searchWiki && query.split(' ').length < 10) {
      await _searchWikiResults(query);
    }
  }

  Future<void> _searchWebResults(String query) async {
    // Mock web search results
    final results = [
      'https://example.com/result1',
      'https://example.com/result2',
      'https://example.com/result3',
    ];
    
    if (_chatHistory.isNotEmpty) {
      final lastMessage = _chatHistory.last;
      lastMessage.searchResults = results;
      await _saveMessageToChat(lastMessage);
    }
  }

  Future<void> _searchImagesResults(String query) async {
    // Mock image results
    final results = [];
    for (int i = 0; i < 9; i++) {
      results.add({
        'url': 'https://example.com/image$i.jpg',
        'thumbnail': 'https://example.com/thumb$i.jpg',
        'title': 'Result ${i + 1}'
      });
    }
    
    if (_chatHistory.isNotEmpty) {
      final lastMessage = _chatHistory.last;
      lastMessage.imageResults = List<Map<String, String>>.from(results);
      await _saveMessageToChat(lastMessage);
    }
  }

  Future<void> _searchWikiResults(String query) async {
    // Mock wiki result
    final result = 'Wikipedia article about $query - This is a summary of the first 50 words from the Wikipedia article...';
    
    if (_chatHistory.isNotEmpty) {
      final lastMessage = _chatHistory.last;
      lastMessage.wikiResult = result;
      await _saveMessageToChat(lastMessage);
    }
  }

  void _removeMessage(int index) async {
    if (index >= 0 && index < _chatHistory.length) {
      final message = _chatHistory[index];
      setState(() {
        _chatHistory.removeAt(index);
      });
      // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª —Å–æ–æ–±—â–µ–Ω–∏—è
      final directory = await getApplicationDocumentsDirectory();
      final chatDir = Directory('${directory.path}/imeyou_pet/chats/${message.chatName}');
      if (chatDir.existsSync()) {
        final files = chatDir.listSync();
        for (var file in files) {
          if (file is File && file.path.endsWith('.json')) {
            try {
              String content = await file.readAsString();
              Map<String, dynamic> messageData = json.decode(content);
              if (messageData['timestamp'] == message.timestamp) {
                file.deleteSync();
                break;
              }
            } catch (e) {
              print('Error deleting message file: $e');
            }
          }
        }
      }
    }
  }

  void _toggleStar(int index) async {
    if (index >= 0 && index < _chatHistory.length) {
      setState(() {
        _chatHistory[index].starred = !_chatHistory[index].starred;
      });
      await _saveMessageToChat(_chatHistory[index]);
    }
  }

  void _copyToClipboard(String text) {
    Clipboard.setData(ClipboardData(text: text));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞')),
    );
  }

  void _setReply(String message) {
    setState(() {
      _replyingTo = message;
    });
  }

  void _clearChat() {
    setState(() {
      _chatHistory.removeWhere((msg) => !msg.starred);
    });
  }

 void _startRecording() async {
  if (_isRecording) return;
  
  if (await _speechToText.initialize()) {
    setState(() {
      _isRecording = true;
      _recognizedText = '';
    });
    
    _speechToText.listen(
      onResult: (result) {
        setState(() {
          _recognizedText = result.recognizedWords;
          _messageController.text = _recognizedText;
        });
      },
    );
  }
}

void _stopRecording() {
  _speechToText.stop();
  setState(() {
    _isRecording = false;
  });
}

  void _handleFileDrop(List<File> files) {
    if (files.isNotEmpty) {
      _analyzeFile(files.first.path);
    }
  }

  void _handleBackgroundImageDrop(List<File> files) async {
    if (files.isNotEmpty && (files.first.path.endsWith('.png') || files.first.path.endsWith('.jpg'))) {
      try {
        final directory = await getApplicationDocumentsDirectory();
        final bgDir = Directory('${directory.path}/imeyou_pet/widget_backgrounds');
        if (!bgDir.existsSync()) {
          bgDir.createSync(recursive: true);
        }
        
        final newFile = File('${bgDir.path}/chat_skin${path.extension(files.first.path)}');
        await newFile.writeAsBytes(await files.first.readAsBytes());
        
        final configFile = File('${bgDir.path}/current_chat_bg.json');
        final configData = {
          'current_bg': newFile.path
        };
        await configFile.writeAsString(json.encode(configData));
        
        print('Background saved: ${newFile.path}');
        _loadBackgroundImage();
        
      } catch (e) {
        print('Error setting background: $e');
      }
    }
  }

  void _analyzeFile(String filePath) async {
    final fileName = path.basename(filePath);
    final fileExtension = path.extension(filePath).toLowerCase();
    final fileSize = File(filePath).lengthSync();

    String fileMetadata = await _extractFileMetadata(filePath);

    String analysisPrompt = '''
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ñ–∞–π–ª: $fileName
–ü—É—Ç—å: $filePath
–†–∞–∑–º–µ—Ä: ${fileSize ~/ 1024} KB
–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ: $fileExtension
$fileMetadata

–ï—Å–ª–∏ —Ç–µ–±–µ –∑–Ω–∞–∫–æ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–ª–∏ —Ç—ã –º–æ–∂–µ—à—å –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç—å —á—Ç–æ —ç—Ç–æ –∑–∞ —Ñ–∞–π–ª - –¥–∞–π –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, –º—É–∑—ã–∫–∞–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è, –∫–Ω–∏–≥–∞, –ø—Ä–æ–≥—Ä–∞–º–º–∞). –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ–∑–Ω–∞–∫–æ–º —Ç–∞–∫ –∏ –Ω–∞–ø–∏—à–∏ "—Ñ–∞–π–ª –Ω–µ–æ–ø–æ–∑–Ω–∞–Ω". –ë—É–¥—å –∫—Ä–∞—Ç–æ–∫ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–µ–Ω.
''';

    setState(() {
      _chatHistory.add(ChatMessage(
        type: 'ai',
        message: 'üìÅ –ê–Ω–∞–ª–∏–∑ —Ñ–∞–π–ª–∞: $fileName\n–≠—Ç–æ —Ñ–∞–π–ª —Ç–∏–ø–∞ $fileExtension. –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ: ${_guessFileType(fileExtension)}',
        timestamp: DateTime.now().millisecondsSinceEpoch.toString(),
        starred: false,
        chatName: _currentChatName
      ));
    });
    _saveFileResponse(filePath, "Mock analysis response");
  }

  String _guessFileType(String extension) {
    switch (extension) {
      case '.txt': return '–¢–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª';
      case '.pdf': return 'PDF –¥–æ–∫—É–º–µ–Ω—Ç';
      case '.jpg': case '.png': return '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ';
      case '.mp3': return '–ê—É–¥–∏–æ —Ñ–∞–π–ª';
      case '.mp4': return '–í–∏–¥–µ–æ —Ñ–∞–π–ª';
      default: return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Ñ–∞–π–ª–∞';
    }
  }

  Future<String> _extractFileMetadata(String filePath) async {
    final file = File(filePath);
    final stat = await file.stat();
    return '–°–æ–∑–¥–∞–Ω: ${stat.modified}\n–†–∞–∑–º–µ—Ä: ${stat.size} –±–∞–π—Ç';
  }

  Future<void> _saveFileResponse(String filePath, String response) async {
    final directory = await getApplicationDocumentsDirectory();
    final responsesDir = Directory('${directory.path}/imeyou_pet/file_responses');
    if (!responsesDir.existsSync()) {
      responsesDir.createSync(recursive: true);
    }
    
    final responseFile = File('${responsesDir.path}/${path.basename(filePath)}.response.txt');
    await responseFile.writeAsString(response);
  }

  void _createNewChat() {
    setState(() {
      _currentChatName = '–ù–æ–≤—ã–π —á–∞—Ç';
      _chatHistory.clear();
      _chatLocked = false;
    });
  }

  void _switchChat(String chatName) {
    if (chatName == '–ù–æ–≤—ã–π —á–∞—Ç') {
      _createNewChat();
      return;
    }
    
    setState(() {
      _currentChatName = chatName;
      _chatHistory.clear();
      if (_chatHistories.containsKey(chatName)) {
        _chatHistory.addAll(_chatHistories[chatName]!);
      }
      _chatLocked = false;
    });
  }

  void _filterMessages() {
    if (_isSearchMode && _searchQuery.isNotEmpty) {
      _filteredChatHistory = _searchAcrossAllChats(_searchQuery);
    } else if (_showFavorites) {
      _filteredChatHistory = _getAllStarredMessages();
    } else {
      _filteredChatHistory = List.from(_chatHistory);
    }
  }

  List<ChatMessage> _getAllStarredMessages() {
    List<ChatMessage> allStarred = [];
    for (var chat in _chatHistories.values) {
      allStarred.addAll(chat.where((msg) => msg.starred));
    }
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (–Ω–æ–≤—ã–µ —Å–≤–µ—Ä—Ö—É)
    allStarred.sort((a, b) => b.timestamp.compareTo(a.timestamp));
    return allStarred;
  }

  List<ChatMessage> _searchAcrossAllChats(String query) {
    List<ChatMessage> allMessages = [];
    for (var chat in _chatHistories.values) {
      allMessages.addAll(chat);
    }
    allMessages.addAll(_chatHistory); // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è

    return _filterSearchResults(allMessages, query);
  }

  List<ChatMessage> _filterSearchResults(List<ChatMessage> messages, String query) {
    final queryLower = query.toLowerCase().trim();
    
    if (queryLower.isEmpty) {
      return messages;
    }

    final queryWords = queryLower.split(RegExp(r'\s+')).where((word) => word.length > 1).toList();
    
    if (queryWords.length <= 1) {
      return messages.where((msg) {
        final content = msg.message.toLowerCase();
        return content.contains(queryLower);
      }).toList();
    } else {
      final List<Map<String, dynamic>> resultsWithScore = [];
      
      for (final message in messages) {
        final content = message.message.toLowerCase();
        
        double score = 0.0;
        int foundWords = 0;
        
        for (final word in queryWords) {
          bool wordFound = false;
          
          final wordVariations = _getWordVariations(word);
          for (final variation in wordVariations) {
            if (content.contains(variation)) {
              score += variation == word ? 3.0 : 2.5;
              wordFound = true;
              break;
            }
          }
          
          if (!wordFound) {
            final wordPattern = RegExp(r'\b' + word);
            if (wordPattern.hasMatch(content)) {
              score += 2.0;
              wordFound = true;
            }
          }
          
          if (wordFound) foundWords++;
        }
        
        if (foundWords == queryWords.length) {
          score += 5.0;
        }
        
        if (message.starred) {
          score += 2.0;
        }
        
        final lengthPenalty = content.length > 200 ? content.length / 1000.0 : 0.0;
        score -= lengthPenalty;
        
        if (content.contains(queryLower)) {
          score += 4.0;
        }
        
        if (content.startsWith(queryLower)) {
          score += 3.0;
        }
        
        // –ë–æ–Ω—É—Å –∑–∞ –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        final ageBonus = _calculateAgeBonus(message.timestamp);
        score += ageBonus;
        
        if (foundWords > 0) {
          resultsWithScore.add({
            'message': message,
            'score': score,
            'foundWords': foundWords,
            'contentLength': content.length,
          });
        }
      }
      
      resultsWithScore.sort((a, b) {
        final double scoreA = a['score'] as double;
        final double scoreB = b['score'] as double;
        
        if (scoreB > scoreA) return 1;
        if (scoreB < scoreA) return -1;
        
        final int wordsA = a['foundWords'] as int;
        final int wordsB = b['foundWords'] as int;
        if (wordsB > wordsA) return 1;
        if (wordsB < wordsA) return -1;
        
        final int lengthA = a['contentLength'] as int;
        final int lengthB = b['contentLength'] as int;
        return lengthA.compareTo(lengthB);
      });
      
      return resultsWithScore.map((e) => e['message'] as ChatMessage).toList();
    }
  }

  double _calculateAgeBonus(String timestamp) {
    try {
      final messageTime = DateTime.fromMillisecondsSinceEpoch(int.parse(timestamp));
      final now = DateTime.now();
      final difference = now.difference(messageTime);
      
      if (difference.inDays == 0) return 3.0; // –°–µ–≥–æ–¥–Ω—è
      if (difference.inDays <= 7) return 2.0; // –ù–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ
      if (difference.inDays <= 30) return 1.0; // –í —ç—Ç–æ–º –º–µ—Å—è—Ü–µ
      return 0.0;
    } catch (e) {
      return 0.0;
    }
  }

  List<String> _getWordVariations(String word) {
    final variations = <String>[];
    variations.add(word);
    
    if (word.length > 3) {
      if (word.endsWith('–∞')) {
        variations.add(word.substring(0, word.length - 1));
      }
      if (word.endsWith('—è')) {
        variations.add(word.substring(0, word.length - 1));
      }
      if (word.endsWith('–æ')) {
        variations.add(word.substring(0, word.length - 1));
      }
      if (word.endsWith('—ã')) {
        variations.add(word.substring(0, word.length - 1));
      }
      if (word.endsWith('–∏')) {
        variations.add(word.substring(0, word.length - 1));
      }
    }
    
    return variations;
  }

  Widget _buildMessageBubble(ChatMessage chat, int index) {
    final isAI = chat.type == 'ai';
    
    return MouseRegion(
      onEnter: (_) => setState(() => _hoveredMessageIndex = index),
      onExit: (_) => setState(() => _hoveredMessageIndex = -1),
      child: Container(
        margin: EdgeInsets.only(bottom: 12),
        child: Column(
          crossAxisAlignment: isAI ? CrossAxisAlignment.start : CrossAxisAlignment.end,
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: isAI ? MainAxisAlignment.start : MainAxisAlignment.end,
              children: [
                if (isAI) ...[
                  Container(
                    padding: EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: Color(0xFF2B2B2B).withOpacity(0.8),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(Icons.android, size: 16, color: Colors.white),
                  ),
                  SizedBox(width: 8),
                ],
                Flexible(
                  child: Container(
                    padding: EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: isAI 
                        ? Color(0xFF2B2B2B).withOpacity(0.8)
                        : Color(0xFF2B2B2B).withOpacity(0.7),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          chat.message,
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 14,
                          ),
                        ),
                        ..._buildConditionalWidgets(chat),
                      ],
                    ),
                  ),
                ),
                if (!isAI) ...[
                  SizedBox(width: 8),
                  Container(
                    padding: EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: Color(0xFF2B2B2B).withOpacity(0.8),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(Icons.person, size: 16, color: Colors.white),
                  ),
                ],
              ],
            ),
            
            // –ö–Ω–æ–ø–∫–∏ –ø–æ—è–≤–ª—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Ö–æ–≤–µ—Ä–µ
            if (_hoveredMessageIndex == index)
              Container(
                margin: EdgeInsets.only(top: 4),
                child: Row(
                  mainAxisAlignment: isAI ? MainAxisAlignment.start : MainAxisAlignment.end,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (isAI) SizedBox(width: 32),
                    Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        GestureDetector(
                          onTap: () => _toggleStar(index),
                          child: Container(
                            width: 25,
                            height: 25,
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(
                              chat.starred ? Icons.star : Icons.star_border,
                              size: 16,
                              color: chat.starred ? Colors.yellow : Colors.white,
                            ),
                          ),
                        ),
                        SizedBox(width: 4),
                        GestureDetector(
                          onTap: () => _copyToClipboard(chat.message),
                          child: Container(
                            width: 25,
                            height: 25,
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.content_copy, size: 16, color: Colors.white),
                          ),
                        ),
                        SizedBox(width: 4),
                        GestureDetector(
                          onTap: () => _setReply(chat.message),
                          child: Container(
                            width: 25,
                            height: 25,
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.reply, size: 16, color: Colors.white),
                          ),
                        ),
                        SizedBox(width: 4),
                        GestureDetector(
                          onTap: () => _removeMessage(index),
                          child: Container(
                            width: 25,
                            height: 25,
                            decoration: BoxDecoration(
                              color: Colors.black.withOpacity(0.5),
                              shape: BoxShape.circle,
                            ),
                            child: Icon(Icons.delete, size: 16, color: Colors.white),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildConditionalWidgets(ChatMessage chat) {
    final List<Widget> widgets = [];
    
    if (chat.type == 'ai' && chat.searchResults.isNotEmpty) {
      widgets.addAll([
        SizedBox(height: 8),
        _buildSearchResults(chat.searchResults),
      ]);
    }
    
    if (chat.type == 'ai' && chat.imageResults.isNotEmpty) {
      widgets.addAll([
        SizedBox(height: 8),
        _buildImageGrid(chat.imageResults),
      ]);
    }
    
    if (chat.type == 'ai' && chat.wikiResult.isNotEmpty) {
      widgets.addAll([
        SizedBox(height: 8),
        _buildWikiWidget(chat.wikiResult),
      ]);
    }
    
    return widgets;
  }

  Widget _buildSearchResults(List<String> results) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞:', style: TextStyle(color: Colors.white70, fontSize: 12)),
        ...results.map((url) => GestureDetector(
          onTap: () => launch(url),
          child: Row(
            children: [
              Container(
                width: 16,
                height: 16,
                margin: EdgeInsets.only(right: 4),
                decoration: BoxDecoration(
                  color: Colors.blue,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              Expanded(
                child: Text(
                  url,
                  style: TextStyle(color: Colors.blue, fontSize: 12),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        )).toList(),
      ],
    );
  }

  Widget _buildImageGrid(List<Map<String, String>> images) {
    return GridView.builder(
      shrinkWrap: true,
      physics: NeverScrollableScrollPhysics(),
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        crossAxisSpacing: 4,
        mainAxisSpacing: 4,
      ),
      itemCount: min(images.length, 9),
      itemBuilder: (context, index) {
        return Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            color: Colors.grey[800],
          ),
          child: Center(
            child: Text(
              'Image ${index + 1}',
              style: TextStyle(color: Colors.white, fontSize: 10),
            ),
          ),
        );
      },
    );
  }

  Widget _buildWikiWidget(String wikiText) {
    return Container(
      padding: EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.2),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.article, size: 16, color: Colors.white),
              SizedBox(width: 4),
              Text('Wikipedia', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
            ],
          ),
          SizedBox(height: 4),
          Text(
            wikiText,
            style: TextStyle(color: Colors.white, fontSize: 12),
            maxLines: 3,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

 @override
Widget build(BuildContext context) {
  _filterMessages();
  
  return Material(
    color: Colors.transparent,
    child: Stack(
      children: [
        if (_backgroundImage != null)
          Positioned.fill(
            child: Container(
              decoration: BoxDecoration(
                image: DecorationImage(
                  image: FileImage(_backgroundImage!),
                  fit: BoxFit.cover,
                  alignment: Alignment.center,
                ),
              ),
            ),
          ),
        
        Container(
          color: Colors.transparent,
          child: Column(
            children: [
              // Header (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞)
              Container(
                height: 40,
                padding: EdgeInsets.symmetric(horizontal: 12),
                color: Colors.transparent,
                child: Row(
                  children: [
                    Expanded(
                      child: DropdownButton<String>(
                        value: _currentChatName,
                        dropdownColor: Color(0xFF2B2B2B),
                        style: TextStyle(color: Colors.white, fontSize: 14),
                        underline: Container(),
                        onChanged: (String? newValue) {
                          if (newValue != null) _switchChat(newValue);
                        },
                        items: _availableChats.map<DropdownMenuItem<String>>((String value) {
                          return DropdownMenuItem<String>(
                            value: value,
                            child: Container(
                              constraints: BoxConstraints(maxWidth: 600),
                              child: Text(
                                value,
                                style: TextStyle(color: Colors.white),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          );
                        }).toList(),
                      ),
                    ),
                    if (_chatLocked)
                      Padding(
                        padding: EdgeInsets.only(right: 8),
                        child: Text(
                          '–ß–∞—Ç –∑–∞–∫—Ä—ã—Ç',
                          style: TextStyle(color: Colors.red, fontSize: 12),
                        ),
                      ),
                    MouseRegion(
                      cursor: SystemMouseCursors.click,
                      child: GestureDetector(
                        onTap: _clearChat,
                        child: Container(
                          padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: Colors.red.withOpacity(0.7),
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            '–û—á–∏—Å—Ç–∏—Ç—å —á–∞—Ç',
                            style: TextStyle(color: Colors.white, fontSize: 12),
                          ),
                        ),
                      ),
                    ),
                    SizedBox(width: 8),
                    MouseRegion(
                      cursor: SystemMouseCursors.click,
                      child: GestureDetector(
                        onTap: () => windowManager.close(),
                        child: Icon(Icons.close, size: 20, color: Colors.white),
                      ),
                    ),
                  ],
                ),
              ),

              // Tabs (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞)
              Container(
                height: 30,
                child: Row(
                  children: [
                    Expanded(
                      child: GestureDetector(
                        onTap: () => setState(() {
                          _showFavorites = false;
                          _isSearchMode = false;
                        }),
                        child: Container(
                          decoration: BoxDecoration(
                            color: !_showFavorites && !_isSearchMode 
                              ? Colors.blue.withOpacity(0.3) 
                              : Colors.transparent,
                          ),
                          child: Center(
                            child: Text(
                              '–í—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                    Expanded(
                      child: GestureDetector(
                        onTap: () => setState(() {
                          _showFavorites = true;
                          _isSearchMode = false;
                        }),
                        child: Container(
                          decoration: BoxDecoration(
                            color: _showFavorites 
                              ? Colors.blue.withOpacity(0.3) 
                              : Colors.transparent,
                          ),
                          child: Center(
                            child: Text(
                              '–ò–∑–±—Ä–∞–Ω–Ω—ã–µ',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),

              // Reply widget (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏)
              if (_replyingTo.isNotEmpty)
                Container(
                  height: 40, // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞
                  margin: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  padding: EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.green.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.reply, size: 16, color: Colors.white),
                      SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _replyingTo,
                          style: TextStyle(color: Colors.white, fontSize: 12),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      GestureDetector(
                        onTap: () => setState(() => _replyingTo = ''),
                        child: Icon(Icons.close, size: 16, color: Colors.white),
                      ),
                    ],
                  ),
                ),

              // –ì–∏–±–∫–∞—è –æ–±–ª–∞—Å—Ç—å –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –∏ –ø–æ–ª—è –≤–≤–æ–¥–∞
              Expanded(
                child: LayoutBuilder(
                  builder: (context, constraints) {
                    // –í—ã—á–∏—Å–ª—è–µ–º –≤—ã—Å–æ—Ç—É –ø–æ–ª—è –≤–≤–æ–¥–∞
                    final double inputHeight = _calculateInputHeight();
                    // –í—ã—Å–æ—Ç–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π = –æ–±—â–∞—è –≤—ã—Å–æ—Ç–∞ - –≤—ã—Å–æ—Ç–∞ –ø–æ–ª—è –≤–≤–æ–¥–∞
                    final double chatHistoryHeight = constraints.maxHeight - inputHeight;
                    
                    return Column(
                      children: [
                        // –ò—Å—Ç–æ—Ä–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π (—Ä–∞—Å—Ç–µ—Ç/—É–º–µ–Ω—å—à–∞–µ—Ç—Å—è —Å–≤–µ—Ä—Ö—É)
                        Container(
                          height: chatHistoryHeight,
                          child: _filteredChatHistory.isEmpty
                              ? Center(
                                  child: Container(
                                    padding: EdgeInsets.all(16),
                                    decoration: BoxDecoration(
                                      color: Color(0xFF2B2B2B).withOpacity(0.8),
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    child: Text(
                                      '–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π',
                                      style: TextStyle(color: Colors.white54),
                                    ),
                                  ),
                                )
                              : ListView.builder(
                                  controller: _scrollController,
                                  padding: EdgeInsets.all(16),
                                  itemCount: _filteredChatHistory.length,
                                  itemBuilder: (context, index) {
                                    return _buildMessageBubble(_filteredChatHistory[index], index);
                                  },
                                ),
                        ),
                        
                        // –ü–æ–ª–µ –≤–≤–æ–¥–∞ (—Ä–∞—Å—Ç–µ—Ç –≤–≤–µ—Ä—Ö)
                        Container(
                          height: inputHeight,
                          child: Column(
                            children: [
                              // Checkboxes (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞)
                              Container(
                                height: 30,
                                padding: EdgeInsets.symmetric(horizontal: 16),
                                child: Row(
                                  children: [
                                    Row(
                                      children: [
                                        Checkbox(
                                          value: _searchWeb,
                                          onChanged: (value) => setState(() => _searchWeb = value ?? false),
                                          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                        ),
                                        Text('search web', style: TextStyle(color: Colors.white, fontSize: 11)),
                                      ],
                                    ),
                                    Row(
                                      children: [
                                        Checkbox(
                                          value: _searchImages,
                                          onChanged: (value) => setState(() => _searchImages = value ?? false),
                                          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                        ),
                                        Text('search images', style: TextStyle(color: Colors.white, fontSize: 11)),
                                      ],
                                    ),
                                    Row(
                                      children: [
                                        Checkbox(
                                          value: _searchWiki,
                                          onChanged: (value) => setState(() => _searchWiki = value ?? false),
                                          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                        ),
                                        Text('search wiki', style: TextStyle(color: Colors.white, fontSize: 11)),
                                      ],
                                    ),
                                  ],
                                ),
                              ),

                              // –ü–æ–ª–µ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ (—Ä–∞—Å—Ç–µ—Ç –≤–≤–µ—Ä—Ö)
                              Expanded(
                                child: Container(
                                  margin: EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    color: Color(0xFF2B2B2B).withOpacity(0.9),
                                    borderRadius: BorderRadius.circular(20),
                                  ),
                                  child: Row(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      if (_isSearchMode)
                                        Padding(
                                          padding: EdgeInsets.only(left: 16, top: 12),
                                          child: Text('?:', style: TextStyle(color: Colors.yellow)),
                                        ),
                                      
                                      Expanded(
                                        child: TextField(
                                          controller: _messageController,
                                          focusNode: _textFieldFocusNode,
                                          style: TextStyle(color: Colors.white),
                                          maxLines: null,
                                          decoration: InputDecoration(
                                            contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                                            border: InputBorder.none,
                                            hintText: _isSearchMode ? '–ü–æ–∏—Å–∫ –≤ —á–∞—Ç–µ...' : '–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...',
                                            hintStyle: TextStyle(color: Colors.white70),
                                          ),
                                          onChanged: (value) {
                                            if (value.startsWith('?:')) {
                                              setState(() {
                                                _isSearchMode = true;
                                                _searchQuery = value.substring(2).trim();
                                              });
                                            } else if (_isSearchMode && !value.startsWith('?:')) {
                                              setState(() {
                                                _isSearchMode = false;
                                                _searchQuery = '';
                                              });
                                            }
                                            setState(() {}); // –ü–µ—Ä–µ—Å—á–µ—Ç –≤—ã—Å–æ—Ç—ã
                                          },
                                          onSubmitted: (value) {
                                            if (_isSearchMode) {
                                              setState(() {
                                                _isSearchMode = false;
                                                _searchQuery = '';
                                                _messageController.clear();
                                              });
                                            } else {
                                              _sendMessage();
                                            }
                                          },
                                          enabled: !_chatLocked,
                                        ),
                                      ),
                                      if (_isRecording)
                                        Padding(
                                          padding: EdgeInsets.only(right: 8, top: 12),
                                          child: Icon(Icons.mic, color: Colors.red),
                                        ),
                                      IconButton(
                                        icon: Icon(Icons.send, color: Colors.white),
                                        onPressed: _chatLocked ? null : _sendMessage,
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    );
                  },
                ),
              ),
            ],
          ),
        ),
      ],
    ),
  );
}

double _calculateInputHeight() {
  final text = _messageController.text;
  final double baseHeight = 110.0; // –ë–∞–∑–æ–≤–∞—è –≤—ã—Å–æ—Ç–∞ (—á–µ–∫–±–æ–∫—Å—ã + –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –ø–æ–ª—è)
  
  if (text.isEmpty) {
    return baseHeight;
  }
  
  // –†–∞—Å—á–µ—Ç –≤—ã—Å–æ—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å—Ç—Ä–æ–∫
  final lineCount = '\n'.allMatches(text).length ;
  final double lineHeight = 50.0; // –í—ã—Å–æ—Ç–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
  final double minTextFieldHeight = 110.0; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—è
  final double maxInputHeight = 420.0; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –≤—Å–µ–≥–æ –ø–æ–ª—è –≤–≤–æ–¥–∞
  
  // –í—ã—Å–æ—Ç–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—è = –º–∏–Ω–∏–º—É–º 40px + (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ - 1) * –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏
  final double textFieldHeight = minTextFieldHeight + (lineCount - 1) * lineHeight;
  
  // –û–±—â–∞—è –≤—ã—Å–æ—Ç–∞ = —á–µ–∫–±–æ–∫—Å—ã (30px) + —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ + –æ—Ç—Å—Ç—É–ø—ã
  final double totalHeight = textFieldHeight ; // 32px = margin (16+16)
  
  return totalHeight.clamp(baseHeight, maxInputHeight);
}

  @override
  void dispose() {
    _directoryCheckTimer?.cancel();
    _speechToText.stop();
    super.dispose();
  }
}

class ChatMessage {
  final String type;
  final String message;
  final String timestamp;
  bool starred;
  final String chatName;
  List<String> searchResults;
  List<Map<String, String>> imageResults;
  String wikiResult;

  ChatMessage({
    required this.type,
    required this.message,
    required this.timestamp,
    required this.starred,
    required this.chatName,
    this.searchResults = const [],
    this.imageResults = const [],
    this.wikiResult = '',
  });

  factory ChatMessage.fromMap(Map<String, String> map) {
    return ChatMessage(
      type: map['type'] ?? map['source'] ?? 'user',
      message: map['message'] ?? map['text'] ?? '',
      timestamp: map['timestamp'] ?? DateTime.now().millisecondsSinceEpoch.toString(),
      starred: map['starred'] == 'true',
      chatName: map['chatName'] ?? 'Small talk',
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'type': type,
      'message': message,
      'timestamp': timestamp,
      'starred': starred,
      'chatName': chatName,
      'searchResults': searchResults,
      'imageResults': imageResults,
      'wikiResult': wikiResult,
    };
  }
}

class EatenFilesWindowApp extends StatefulWidget {
  const EatenFilesWindowApp({Key? key}) : super(key: key);

  @override
  State<EatenFilesWindowApp> createState() => _EatenFilesWindowAppState();
}

class _EatenFilesWindowAppState extends State<EatenFilesWindowApp> {
  final TextEditingController _addController = TextEditingController();
  final TextEditingController _searchController = TextEditingController();
  final TextEditingController _folderNameController = TextEditingController();
  final FocusNode _addFocusNode = FocusNode();
  final FocusNode _folderNameFocusNode = FocusNode();
  
  bool _isAdding = false;
  bool _isCreatingFolder = false;
  Set<String> _selectedFilters = {};
  Map<String, List<EatenFile>> _filteredFiles = {
    'recent': [],
    'this_month': [],
    'older': []
  };
  int _currentTab = 0;
  List<EatenFile> _files = [];
  List<EatenFile> _recentlyOpened = [];
  List<CustomFolder> _customFolders = [];
  
  final String _storageDir = path.join(Directory.current.path, 'imeyou_pet', 'eaten_files');
  final String _foldersDataPath = path.join(Directory.current.path, 'imeyou_pet', 'custom_folders.json');
  
  Offset? _contextMenuPosition;
  EatenFile? _contextMenuFile;
  int? _contextMenuIndex;
  StreamSubscription<FileSystemEvent>? _fileWatcher;
  bool _isInitialized = false;
  bool _isLoading = true;

  // –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
  bool _isEditing = false;
  EatenFile? _editingFile;
  final TextEditingController _editNameController = TextEditingController();
  final TextEditingController _editCommentController = TextEditingController();
  
  // –î–µ–±–∞—É–Ω—Å –¥–ª—è –ø–æ–∏—Å–∫–∞
  Timer? _searchDebounce;
  
  @override
  void initState() {
    super.initState();
    _initializeApp();
  }

  void _initializeApp() async {
    try {
      await windowManager.ensureInitialized();
      
      final storageDir = Directory(_storageDir);
      if (!await storageDir.exists()) {
        await storageDir.create(recursive: true);
      }
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ UI
      await _loadFilesFromStorage();
      await _loadCustomFolders();
      
      _startFileWatcher();
      _setupListeners();
      
      if (mounted) {
        setState(() {
          _isInitialized = true;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Error in initializeApp: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  void _setupListeners() {
    _searchController.addListener(() {
      // –î–µ–±–∞—É–Ω—Å –ø–æ–∏—Å–∫–∞ - –∂–¥–µ–º 300ms –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤–≤–æ–¥–∞
      _searchDebounce?.cancel();
      _searchDebounce = Timer(const Duration(milliseconds: 300), () {
        if (_isInitialized && mounted) {
          _updateFilteredFiles();
        }
      });
    });
    
    _addFocusNode.addListener(() {
      if (!_addFocusNode.hasFocus && mounted && _isAdding && _addController.text.isEmpty) {
        Future.delayed(const Duration(milliseconds: 100), () {
          if (mounted && !_addFocusNode.hasFocus) {
            setState(() {
              _isAdding = false;
            });
          }
        });
      }
    });
  }

  void _startFileWatcher() {
    try {
      final dir = Directory(_storageDir);
      _fileWatcher = dir.watch(recursive: false).listen((event) {
        if (event.type == FileSystemEvent.create || event.type == FileSystemEvent.delete) {
          Future.delayed(const Duration(milliseconds: 500), () {
            if (mounted) {
              _loadFilesFromStorage();
            }
          });
        }
      });
    } catch (e) {
      debugPrint('Error starting file watcher: $e');
    }
  }
  
  Future<void> _loadFilesFromStorage() async {
    try {
      final dir = Directory(_storageDir);
      if (!await dir.exists()) {
        if (mounted) {
          setState(() {
            _files = [];
            _filteredFiles = _filterFilesSync();
          });
        }
        return;
      }
      
      final List<EatenFile> loadedFiles = [];
      final entities = await dir.list().toList();
      
      for (var entity in entities) {
        if (entity is File && entity.path.endsWith('.json')) {
          try {
            final content = await entity.readAsString();
            final jsonData = json.decode(content);
            final file = EatenFile.fromJson(jsonData);
            loadedFiles.add(file);
          } catch (e) {
            debugPrint('Error loading file ${entity.path}: $e');
          }
        }
      }
      
      if (mounted) {
        setState(() {
          _files = loadedFiles;
          _filteredFiles = _filterFilesSync();
        });
      }
    } catch (e) {
      debugPrint('Error loading files from storage: $e');
    }
  }

  Future<void> _loadCustomFolders() async {
    try {
      final file = File(_foldersDataPath);
      if (await file.exists()) {
        final content = await file.readAsString();
        final List<dynamic> jsonList = json.decode(content);
        if (mounted) {
          setState(() {
            _customFolders = jsonList.map((e) => CustomFolder.fromJson(e)).toList();
          });
        }
      }
    } catch (e) {
      debugPrint('Error loading custom folders: $e');
    }
  }

  void _saveCustomFolders() async {
    try {
      final file = File(_foldersDataPath);
      final dir = file.parent;
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }
      await file.writeAsString(json.encode(_customFolders.map((e) => e.toJson()).toList()));
    } catch (e) {
      debugPrint('Error saving custom folders: $e');
    }
  }

  Future<void> _saveFileWithDuplicateCheck(EatenFile newFile) async {
    final existingFileIndex = _files.indexWhere((file) => file.path == newFile.path);
    
    if (existingFileIndex != -1) {
      final existingFile = _files[existingFileIndex];
      newFile.isStarred = existingFile.isStarred;
      newFile.openCount = existingFile.openCount;
      newFile.lastOpened = existingFile.lastOpened;
      newFile.comment = existingFile.comment;
      if (newFile.iconBytes == null && existingFile.iconBytes != null) {
        newFile.iconBytes = existingFile.iconBytes;
      }
      _files.removeAt(existingFileIndex);
    }
    
    _files.insert(0, newFile);
    
    await _saveFile(newFile);
    if (mounted) {
      setState(() {
        _filteredFiles = _filterFilesSync();
      });
    }
  }

  Future<void> _saveFile(EatenFile file) async {
    try {
      final fileName = '${file.id}.json';
      final filePath = path.join(_storageDir, fileName);
      final outputFile = File(filePath);
      final dir = outputFile.parent;
      
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }
      
      await outputFile.writeAsString(json.encode(file.toJson()));
    } catch (e) {
      debugPrint('Error saving file: $e');
    }
  }

  Future<void> _deleteFile(EatenFile file) async {
    try {
      final fileName = '${file.id}.json';
      final filePath = path.join(_storageDir, fileName);
      final outputFile = File(filePath);
      if (await outputFile.exists()) {
        await outputFile.delete();
      }
      if (mounted) {
        setState(() {
          _files.remove(file);
          _filteredFiles = _filterFilesSync();
        });
      }
    } catch (e) {
      debugPrint('Error deleting file: $e');
    }
  }

  void _addItem(String itemPath) async {
    final trimmedPath = itemPath.trim();
    if (trimmedPath.isEmpty) return;

    final isWeb = _isWebUrl(trimmedPath);
    final isSystemPath = _isSystemPath(trimmedPath);
    
    if (!isWeb && !isSystemPath) {
      _showErrorSnackbar('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø—É—Ç—å –∏–ª–∏ URL');
      return;
    }

    try {
      Uint8List? iconBytes;
      String title = 'none';
      
      if (isWeb) {
        // –î–ª—è –≤–µ–±-—Å–∞–π—Ç–æ–≤ –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∫–æ–Ω–∫—É –∏ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
        iconBytes = await _getFavicon(trimmedPath);
        title = await _getPageTitle(trimmedPath);
        if (title == 'none') {
          title = _getDomainName(trimmedPath);
        }
      } else if (isSystemPath) {
        // –î–ª—è —Ñ–∞–π–ª–æ–≤ –ø–æ–ª—É—á–∞–µ–º –∏–∫–æ–Ω–∫—É
        if (trimmedPath.toLowerCase().endsWith('.lnk')) {
          iconBytes = await _getLnkFileIcon(trimmedPath);
        } else {
          iconBytes = await _getFileIcon(trimmedPath);
        }
      }

      final newFile = EatenFile(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        path: trimmedPath,
        isWeb: isWeb,
        isStarred: false,
        openCount: 0,
        lastOpened: null,
        iconBytes: iconBytes,
        fileName: isWeb ? _getDomainName(trimmedPath) : path.basename(trimmedPath),
        pageTitle: title,
        comment: '',
      );

      await _saveFileWithDuplicateCheck(newFile);
      
      _addController.clear();
      if (mounted) {
        setState(() {
          _isAdding = false;
        });
      }
    } catch (e) {
      debugPrint('Error adding item: $e');
      _showErrorSnackbar('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞');
    }
  }

  void _showErrorSnackbar(String message) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(message),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 2),
        )
      );
    }
  }

  Future<void> _handlePasteFromClipboard() async {
    try {
      if (Platform.isWindows || Platform.isMacOS || Platform.isLinux) {
        final result = await FilePicker.platform.pickFiles(
          allowMultiple: true,
          type: FileType.any,
        );

        if (result != null && result.files.isNotEmpty) {
          for (var platformFile in result.files) {
            if (platformFile.path != null) {
              _addItem(platformFile.path!);
            }
          }
        }
      }
    } catch (e) {
      debugPrint('Error handling paste: $e');
    }
  }

  bool _isWebUrl(String text) {
    final trimmed = text.trim();
    return trimmed.startsWith('http://') || 
           trimmed.startsWith('https://') ||
           trimmed.startsWith('www.');
  }

  bool _isSystemPath(String text) {
    final trimmed = text.trim();
    if (Platform.isWindows) {
      return trimmed.contains(':\\') || trimmed.startsWith('\\\\');
    } else {
      return trimmed.startsWith('/');
    }
  }

  Future<Uint8List?> _getFavicon(String url) async {
    try {
      final domain = _getDomainName(url);
      final faviconUrl = 'https://www.google.com/s2/favicons?domain=$domain&sz=32';
      final response = await http.get(Uri.parse(faviconUrl));
      if (response.statusCode == 200) {
        return response.bodyBytes;
      }
    } catch (e) {
      debugPrint('Error getting favicon: $e');
    }
    return null;
  }

  Future<String> _getPageTitle(String url) async {
    try {
      final formattedUrl = url.startsWith('http') ? url : 'https://$url';
      final response = await http.get(Uri.parse(formattedUrl));
      if (response.statusCode == 200) {
        final titleMatch = RegExp(r'<title>(.*?)</title>', caseSensitive: false).firstMatch(response.body);
        if (titleMatch != null && titleMatch.group(1)!.isNotEmpty) {
          return titleMatch.group(1)!;
        }
      }
    } catch (e) {
      debugPrint('Error getting page title: $e');
    }
    return _getDomainName(url);
  }

  Future<Uint8List?> _getLnkFileIcon(String lnkPath) async {
    try {
      const MethodChannel _channel = MethodChannel('screenshot_channel');
      final result = await _channel.invokeMethod('getLnkFileIcon', lnkPath);
      if (result != null) {
        return result as Uint8List;
      }
    } catch (e) {
      debugPrint('Error getting lnk file icon: $e');
    }
    
    return await _getFileIcon(lnkPath);
  }

  Future<Uint8List?> _getFileIcon(String filePath) async {
    try {
      const MethodChannel _channel = MethodChannel('screenshot_channel');
      final result = await _channel.invokeMethod('getFileIcon', filePath);
      return result as Uint8List?;
    } catch (e) {
      debugPrint('Error getting file icon: $e');
      return null;
    }
  }

  void _toggleStar(EatenFile file) async {
    if (mounted) {
      setState(() {
        file.isStarred = !file.isStarred;
        _filteredFiles = _filterFilesSync();
      });
    }
    await _saveFile(file);
  }

  void _incrementOpenCount(EatenFile file) async {
    if (mounted) {
      setState(() {
        file.openCount++;
        file.lastOpened = DateTime.now();
        _filteredFiles = _filterFilesSync();
      });
    }
    await _saveFile(file);
  }

  void _updateFilteredFiles() {
    if (!_isInitialized || !mounted) return;
    
    setState(() {
      _filteredFiles = _filterFilesSync();
    });
  }

  Map<String, List<EatenFile>> _filterFilesSync() {
    List<EatenFile> currentList = _currentTab == 0 ? List.from(_files) : List.from(_recentlyOpened);

    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–∏—Å–∫
    final searchQuery = _searchController.text.toLowerCase().trim();
    if (searchQuery.isNotEmpty) {
      final searchTerms = searchQuery.split(' ');
      currentList = currentList.where((file) {
        final fileName = file.fileName.toLowerCase();
        final filePath = file.path.toLowerCase();
        final comment = file.comment?.toLowerCase() ?? '';
        
        return searchTerms.every((term) =>
          fileName.contains(term) ||
          filePath.contains(term) ||
          comment.contains(term)
        );
      }).toList();
    }

    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
    if (_selectedFilters.isNotEmpty) {
      currentList = currentList.where((file) {
        if (file.isWeb) {
          final domain = _getDomainName(file.path);
          return _selectedFilters.contains('url') || 
                 _selectedFilters.contains('domain:$domain');
        } else {
          final ext = path.extension(file.path).toLowerCase();
          if (ext.isNotEmpty) {
            return _selectedFilters.contains(ext);
          } else {
            return _selectedFilters.contains('no_ext');
          }
        }
      }).toList();
    }

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏
    return _groupFilesByTimeOptimized(currentList, _currentTab);
  }

  String _getDomainName(String url) {
    try {
      final uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');
      return uri.host;
    } catch (e) {
      return url.length > 15 ? '${url.substring(0, 12)}...' : url;
    }
  }

  Map<String, List<EatenFile>> _groupFilesByTimeOptimized(List<EatenFile> files, int currentTab) {
    if (currentTab != 0) {
      return {'recent': files, 'this_month': [], 'older': []};
    }

    final recent = <EatenFile>[];
    final thisMonthList = <EatenFile>[];
    final older = <EatenFile>[];

    for (var file in files) {
      if (file.isWeb) {
        recent.add(file);
        continue;
      }

      try {
        final fileEntity = File(file.path);
        if (fileEntity.existsSync()) {
          recent.add(file); // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        } else {
          recent.add(file);
        }
      } catch (e) {
        recent.add(file);
      }
    }

    return {
      'recent': recent,
      'this_month': thisMonthList,
      'older': older,
    };
  }

  void _createFolder() {
    final folderName = _folderNameController.text.trim();
    if (folderName.isEmpty) return;

    final newFolder = CustomFolder(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: folderName,
      fileIds: [],
    );

    if (mounted) {
      setState(() {
        _customFolders.add(newFolder);
        _isCreatingFolder = false;
        _folderNameController.clear();
      });
    }
    _saveCustomFolders();
  }

  Widget _buildFileGridItem(EatenFile file, int index) {
    return FileGridItem1(
      file: file,
      index: index,
      onTap: () {
        _hideContextMenu();
        if (file.isWeb || _isWebUrl(file.path)) {
          _openWebUrl(file);
        } else {
          _openFile(file);
        }
        _incrementOpenCount(file);
      },
      onLongPress: () {
        _hideContextMenu();
        if (file.isWeb || _isWebUrl(file.path)) {
          _searchWebTitle(file.path);
        } else {
          _revealInExplorer(file.path);
        }
      },
      onSecondaryTap: (details) {
        _showContextMenu(details.globalPosition, file, index);
      },
      onStarToggled: () => _toggleStar(file),
    );
  }

  void _showContextMenu(Offset position, EatenFile file, int index) {
    if (mounted) {
      setState(() {
        _contextMenuPosition = position;
        _contextMenuFile = file;
        _contextMenuIndex = index;
      });
    }
  }

  void _hideContextMenu() {
    if (mounted) {
      setState(() {
        _contextMenuPosition = null;
        _contextMenuFile = null;
        _contextMenuIndex = null;
      });
    }
  }

  void _handleMenuAction(String action) {
    if (_contextMenuFile == null || _contextMenuIndex == null) return;

    final file = _contextMenuFile!;
    final fileExists = file.isWeb ? true : File(file.path).existsSync();

    switch (action) {
      case 'open':
        if (file.isWeb) {
          _openWebUrl(file);
        } else if (fileExists) {
          _openFile(file);
        }
        _incrementOpenCount(file);
        break;
      case 'reveal':
        if (!file.isWeb && fileExists) {
          _revealInExplorer(file.path);
        }
        break;
      case 'search':
        if (file.isWeb) {
          _searchWebTitle(file.path);
        }
        break;
      case 'delete':
        _deleteFile(file);
        break;
      case 'toggle_star':
        _toggleStar(file);
        break;
      case 'edit':
        _startEditing(file);
        break;
    }

    _hideContextMenu();
  }

  void _startEditing(EatenFile file) {
    if (mounted) {
      setState(() {
        _isEditing = true;
        _editingFile = file;
        _editNameController.text = file.fileName;
        _editCommentController.text = file.comment ?? '';
      });
    }
  }

  void _stopEditing() {
    if (mounted) {
      setState(() {
        _isEditing = false;
        _editingFile = null;
        _editNameController.clear();
        _editCommentController.clear();
      });
    }
  }

  void _saveEditing() async {
    if (_editingFile == null) return;

    if (mounted) {
      setState(() {
        _editingFile!.fileName = _editNameController.text;
        _editingFile!.comment = _editCommentController.text;
        _filteredFiles = _filterFilesSync();
      });
    }

    await _saveFile(_editingFile!);
    _stopEditing();
  }

  Widget _buildContextMenu() {
    if (_contextMenuPosition == null || _contextMenuFile == null) return const SizedBox.shrink();

    final file = _contextMenuFile!;
    final isWeb = file.isWeb;
    final fileExists = isWeb ? true : File(file.path).existsSync();

    return Positioned(
      left: _contextMenuPosition!.dx,
      top: _contextMenuPosition!.dy,
      child: Container(
        width: 200,
        decoration: BoxDecoration(
          color: const Color(0xFF2D2D2D),
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.4),
              blurRadius: 15,
              spreadRadius: 2,
            )
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildContextMenuItem(
              Icons.open_in_new,
              '–û—Ç–∫—Ä—ã—Ç—å',
              Colors.blue,
              () => _handleMenuAction('open'),
            ),
            if (!isWeb && fileExists)
              _buildContextMenuItem(
                Icons.folder_open,
                '–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ',
                Colors.green,
                () => _handleMenuAction('reveal'),
              )
            else
              _buildContextMenuItem(
                Icons.search,
                '–ù–∞–π—Ç–∏',
                Colors.green,
                () => _handleMenuAction('search'),
              ),
            _buildContextMenuItem(
              file.isStarred ? Icons.star : Icons.star_border,
              file.isStarred ? '–°–Ω—è—Ç—å –∑–≤–µ–∑–¥—É' : '–í –∑–≤–µ–∑–¥—ã',
              Colors.orange,
              () => _handleMenuAction('toggle_star'),
            ),
            _buildContextMenuItem(
              Icons.edit,
              '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å',
              Colors.blue,
              () => _handleMenuAction('edit'),
            ),
            _buildContextMenuItem(
              Icons.delete,
              '–£–¥–∞–ª–∏—Ç—å',
              Colors.red,
              () => _handleMenuAction('delete'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContextMenuItem(IconData icon, String text, Color color, VoidCallback onTap) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Icon(icon, size: 20, color: color),
              const SizedBox(width: 12),
              Text(
                text,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 14,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildExtensionFilter() {
    final extensions = _getAllExtensions();
    final domains = _getAllDomains();

    return Container(
      width: 200,
      color: Colors.black.withOpacity(0.3),
      child: ListView(
        children: [
          const Padding(
            padding: EdgeInsets.all(8),
            child: Text(
              '–§–∏–ª—å—Ç—Ä—ã',
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Divider(color: Colors.white54),
          if (domains.isNotEmpty) ...[
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 8),
              child: Text('–î–æ–º–µ–Ω—ã:', style: TextStyle(color: Colors.white70)),
            ),
            ...domains.map((domain) => _buildFilterItem('üåê $domain', 'domain:$domain')),
            Divider(color: Colors.white54),
          ],
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 8),
            child: Text('–†–∞—Å—à–∏—Ä–µ–Ω–∏—è:', style: TextStyle(color: Colors.white70)),
          ),
          ...extensions.map((ext) => _buildFilterItem(
            ext == 'url' ? 'üåê URL' : 
            ext == 'no_ext' ? 'üìÑ –ë–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è' : 
            'üìÑ ${ext.toUpperCase()}',
            ext
          )),
          Divider(color: Colors.white54),
          ListTile(
            title: const Text(
              '–û—á–∏—Å—Ç–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã',
              style: TextStyle(
                color: Colors.white70,
                fontSize: 12,
              ),
            ),
            trailing: const Icon(Icons.clear_all, size: 16, color: Colors.white70),
            onTap: () {
              if (mounted) {
                setState(() {
                  _selectedFilters.clear();
                  _filteredFiles = _filterFilesSync();
                });
              }
            },
          ),
        ],
      ),
    );
  }

  Widget _buildFilterItem(String label, String value) {
    final isSelected = _selectedFilters.contains(value);
    
    return ListTile(
      title: Text(
        label,
        style: TextStyle(
          color: isSelected ? Colors.blue : Colors.white,
          fontSize: 12,
        ),
      ),
      trailing: isSelected ? const Icon(Icons.check, size: 16, color: Colors.blue) : null,
      onTap: () {
        if (mounted) {
          setState(() {
            if (isSelected) {
              _selectedFilters.remove(value);
            } else {
              _selectedFilters.add(value);
            }
            _filteredFiles = _filterFilesSync();
          });
        }
      },
    );
  }

  Set<String> _getAllExtensions() {
    final extensions = <String>{};
    final currentList = _currentTab == 0 ? _files : _recentlyOpened;
    
    for (var file in currentList) {
      if (file.isWeb) {
        extensions.add('url');
      } else {
        final ext = path.extension(file.path).toLowerCase();
        if (ext.isNotEmpty) {
          extensions.add(ext);
        } else {
          extensions.add('no_ext');
        }
      }
    }
    
    return extensions;
  }

  Set<String> _getAllDomains() {
    final domains = <String>{};
    final currentList = _currentTab == 0 ? _files : _recentlyOpened;
    
    for (var file in currentList) {
      if (file.isWeb) {
        domains.add(_getDomainName(file.path));
      }
    }
    
    return domains;
  }

  void _pickFile() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        allowMultiple: false,
        type: FileType.any,
      );

      if (result != null && result.files.single.path != null) {
        _addController.text = result.files.single.path!;
      }
    } catch (e) {
      debugPrint('Error picking file: $e');
    }
  }

  void _searchWebTitle(String url) async {
    final searchUrl = 'https://www.google.com/search?q=${Uri.encodeComponent(url)}';
    if (await canLaunch(searchUrl)) {
      await launch(searchUrl);
    }
  }

  Widget _buildEditPanel() {
    if (!_isEditing || _editingFile == null) return const SizedBox.shrink();

    return Positioned(
      right: 0,
      top: 0,
      bottom: 0,
      width: 200,
      child: Container(
        color: const Color(0xFF2B2B2B).withOpacity(0.95),
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ',
              style: TextStyle(
                color: Colors.white,
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            
            Container(
              width: double.infinity,
              height: 120,
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.3),
                borderRadius: BorderRadius.circular(8),
              ),
              child: _editingFile!.iconBytes != null
                  ? Image.memory(
                      _editingFile!.iconBytes!,
                      fit: BoxFit.contain,
                    )
                  : Icon(
                      _editingFile!.isWeb ? Icons.language : Icons.insert_drive_file,
                      color: Colors.white,
                      size: 48,
                    ),
            ),
            const SizedBox(height: 16),
            
            const Text(
              '–ù–∞–∑–≤–∞–Ω–∏–µ:',
              style: TextStyle(color: Colors.white70, fontSize: 12),
            ),
            const SizedBox(height: 4),
            TextField(
              controller: _editNameController,
              style: const TextStyle(color: Colors.white, fontSize: 12),
              decoration: InputDecoration(
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                  borderSide: BorderSide.none,
                ),
                filled: true,
                fillColor: Colors.black.withOpacity(0.3),
                contentPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
              ),
            ),
            const SizedBox(height: 16),
            
            if (!_editingFile!.isWeb) ...[
              const Text(
                '–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ:',
                style: TextStyle(color: Colors.white70, fontSize: 12),
              ),
              const SizedBox(height: 4),
              Row(
                children: [
                  Expanded(
                    child: Text(
                      _editingFile!.path,
                      style: const TextStyle(color: Colors.white54, fontSize: 10),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(width: 8),
                  MouseRegion(
                    cursor: SystemMouseCursors.click,
                    child: GestureDetector(
                      onTap: () => _revealInExplorer(_editingFile!.path),
                      child: Container(
                        padding: const EdgeInsets.all(4),
                        decoration: BoxDecoration(
                          color: Colors.blue.withOpacity(0.3),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: const Icon(Icons.folder_open, size: 16, color: Colors.white),
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
            ],
            
            const Text(
              '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:',
              style: TextStyle(color: Colors.white70, fontSize: 12),
            ),
            const SizedBox(height: 4),
            Expanded(
              child: TextField(
                controller: _editCommentController,
                style: const TextStyle(color: Colors.white, fontSize: 12),
                maxLines: null,
                expands: true,
                textAlignVertical: TextAlignVertical.top,
                decoration: InputDecoration(
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide.none,
                  ),
                  filled: true,
                  fillColor: Colors.black.withOpacity(0.3),
                  contentPadding: const EdgeInsets.all(8),
                ),
              ),
            ),
            const SizedBox(height: 16),
            
            Row(
              children: [
                Expanded(
                  child: MouseRegion(
                    cursor: SystemMouseCursors.click,
                    child: GestureDetector(
                      onTap: _saveEditing,
                      child: Container(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        decoration: BoxDecoration(
                          color: Colors.blue.withOpacity(0.8),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Center(
                          child: Text(
                            '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å',
                            style: TextStyle(color: Colors.white, fontSize: 12),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: MouseRegion(
                    cursor: SystemMouseCursors.click,
                    child: GestureDetector(
                      onTap: () {
                        _deleteFile(_editingFile!);
                        _stopEditing();
                      },
                      child: Container(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        decoration: BoxDecoration(
                          color: Colors.red.withOpacity(0.8),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Center(
                          child: Text(
                            '–£–¥–∞–ª–∏—Ç—å',
                            style: TextStyle(color: Colors.white, fontSize: 12),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: _stopEditing,
                child: Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(vertical: 8),
                  decoration: BoxDecoration(
                    color: Colors.grey.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Center(
                    child: Text(
                      '–û—Ç–º–µ–Ω–∞',
                      style: TextStyle(color: Colors.white, fontSize: 12),
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            Row(
              children: [
                _buildExtensionFilter(),
                Expanded(
                  child: Stack(
                    children: [
                      Container(
                        margin: EdgeInsets.only(right: _isEditing ? 200 : 0),
                        decoration: BoxDecoration(
                          color: const Color(0xFF2B2B2B).withOpacity(0.95),
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(12),
                            bottomLeft: Radius.circular(12),
                          ),
                        ),
                        child: Column(
                          children: [
                            // Header
                            Container(
                              height: 40,
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              decoration: BoxDecoration(
                                color: const Color(0xFF1A1A1A).withOpacity(0.9),
                                borderRadius: const BorderRadius.only(
                                  topLeft: Radius.circular(12),
                                ),
                              ),
                              child: Row(
                                children: [
                                  const Text(
                                    '–§–∞–π–ª—ã',
                                    style: TextStyle(
                                      color: Colors.white,
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  const Spacer(),
                                  MouseRegion(
                                    cursor: SystemMouseCursors.click,
                                    child: GestureDetector(
                                      onTap: () => windowManager.close(),
                                      child: const Icon(Icons.close, size: 20, color: Colors.white),
                                    ),
                                  ),
                                ],
                              ),
                            ),

                            // –í–∫–ª–∞–¥–∫–∏ –∏ –ø–æ–∏—Å–∫
                            Container(
                              padding: const EdgeInsets.all(12),
                              color: const Color(0xFF1A1A1A).withOpacity(0.7),
                              child: Column(
                                children: [
                                  Row(
                                    children: [
                                      _buildTab('üìÅ –°—ä–µ–¥–µ–Ω–Ω—ã–µ', 0),
                                      _buildTab('üïê –ù–µ–¥–∞–≤–Ω–∏–µ', 1),
                                      Expanded(
                                        child: Padding(
                                          padding: const EdgeInsets.symmetric(horizontal: 8),
                                          child: TextField(
                                            controller: _searchController,
                                            style: const TextStyle(color: Colors.white),
                                            decoration: InputDecoration(
                                              hintText: '–ü–æ–∏—Å–∫...',
                                              hintStyle: const TextStyle(color: Colors.white54),
                                              border: OutlineInputBorder(
                                                borderRadius: BorderRadius.circular(20),
                                                borderSide: BorderSide.none,
                                              ),
                                              filled: true,
                                              fillColor: const Color(0xFF2B2B2B).withOpacity(0.8),
                                              contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                            ),
                                          ),
                                        ),
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.paste, color: Colors.white),
                                        onPressed: _handlePasteFromClipboard,
                                        tooltip: '–í—Å—Ç–∞–≤–∏—Ç—å –∏–∑ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞',
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),

                            // –°—Ç—Ä–æ–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ –¥–ª—è —Å—ä–µ–¥–µ–Ω–Ω—ã—Ö)
                            if (_currentTab == 0) _buildAddRow(),

                            // –°–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤
                            Expanded(
                              child: _isLoading 
                                  ? const Center(child: CircularProgressIndicator())
                                  : _buildFileList(),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            
            // –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
            _buildContextMenu(),

            // –ü–∞–Ω–µ–ª—å —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            _buildEditPanel(),
          ],
        ),
      ),
    );
  }

  Widget _buildAddRow() {
    return Container(
      padding: const EdgeInsets.all(12),
      color: const Color(0xFF1A1A1A).withOpacity(0.7),
      child: Row(
        children: [
          if (_isAdding) ...[
            Expanded(
              child: TextField(
                controller: _addController,
                focusNode: _addFocusNode,
                style: const TextStyle(color: Colors.white),
                decoration: InputDecoration(
                  hintText: '–í–≤–µ–¥–∏—Ç–µ URL –∏–ª–∏ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É...',
                  hintStyle: const TextStyle(color: Colors.white54),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide.none,
                  ),
                  filled: true,
                  fillColor: const Color(0xFF2B2B2B).withOpacity(0.8),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                ),
                onSubmitted: (_) => _addItem(_addController.text),
              ),
            ),
            const SizedBox(width: 8),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: _pickFile,
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: const Color(0xFF2B2B2B).withOpacity(0.8),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Icon(Icons.folder_open, color: Colors.white),
                ),
              ),
            ),
            const SizedBox(width: 4),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: () => _addItem(_addController.text),
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Icon(Icons.add, color: Colors.white),
                ),
              ),
            ),
            const SizedBox(width: 4),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: () {
                  if (mounted) {
                    setState(() {
                      _isAdding = false;
                      _addController.clear();
                    });
                  }
                },
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: const Color(0xFF2B2B2B).withOpacity(0.8),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Icon(Icons.close, color: Colors.white),
                ),
              ),
            ),
          ] else ...[
            Expanded(
              child: Text(
                'üìÅ –°—ä–µ–¥–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã (${_files.length})',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            MouseRegion(
              cursor: SystemMouseCursors.click,
              child: GestureDetector(
                onTap: () {
                  if (mounted) {
                    setState(() {
                      _isAdding = true;
                    });
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      _addFocusNode.requestFocus();
                    });
                  }
                },
                child: Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Row(
                    children: [
                      Icon(Icons.add, color: Colors.white, size: 16),
                      SizedBox(width: 8),
                      Text(
                        '–î–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª',
                        style: TextStyle(color: Colors.white),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildFileList() {
    final isEmpty = _currentTab == 0 ? _files.isEmpty : _recentlyOpened.isEmpty;

    if (isEmpty) {
      return Center(
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: const Color(0xFF2B2B2B).withOpacity(0.8),
            borderRadius: BorderRadius.circular(12),
          ),
          child: const Text(
            '–ù–µ—Ç —Ñ–∞–π–ª–æ–≤',
            style: TextStyle(color: Colors.white54),
          ),
        ),
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤–æ–æ–±—â–µ —Ñ–∞–π–ª—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    final hasRecent = _filteredFiles['recent']?.isNotEmpty ?? false;
    final hasThisMonth = _filteredFiles['this_month']?.isNotEmpty ?? false;
    final hasOlder = _filteredFiles['older']?.isNotEmpty ?? false;

    if (!hasRecent && !hasThisMonth && !hasOlder) {
      return Center(
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: const Color(0xFF2B2B2B).withOpacity(0.8),
            borderRadius: BorderRadius.circular(12),
          ),
          child: const Text(
            '–ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–º —Ñ–∏–ª—å—Ç—Ä–∞–º',
            style: TextStyle(color: Colors.white54),
          ),
        ),
      );
    }

    return Container(
      color: const Color(0xFF2B2B2B).withOpacity(0.8),
      child: ListView(
        padding: const EdgeInsets.all(12),
        children: [
          if (hasRecent) ...[
            _buildSectionHeader('–ù–µ–¥–∞–≤–Ω–∏–µ'),
            _buildFileGrid(_filteredFiles['recent']!),
            const SizedBox(height: 16),
          ],
          if (hasThisMonth) ...[
            _buildSectionHeader('–í —ç—Ç–æ–º –º–µ—Å—è—Ü–µ'),
            _buildFileGrid(_filteredFiles['this_month']!),
            const SizedBox(height: 16),
          ],
          if (hasOlder) ...[
            _buildSectionHeader('–†–∞–Ω–µ–µ'),
            _buildFileGrid(_filteredFiles['older']!),
          ],
        ],
      ),
    );
  }

  Widget _buildFileGrid(List<EatenFile> files) {
    return GridView.builder(
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 8,
        mainAxisSpacing: 8,
        crossAxisSpacing: 8,
        childAspectRatio: 0.85,
      ),
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: files.length,
      itemBuilder: (context, index) {
        final file = files[index];
        return _buildFileGridItem(file, index);
      },
    );
  }

  void _openWebUrl(EatenFile file) async {
    String formattedUrl = file.path.trim();
    if (!formattedUrl.startsWith('http')) {
      formattedUrl = 'https://$formattedUrl';
    }
    
    if (await canLaunch(formattedUrl)) {
      await launch(formattedUrl);
      _incrementOpenCount(file);
      _addToRecentlyOpened(file);
    }
  }

  void _openFile(EatenFile file) async {
    try {
      if (Platform.isWindows) {
        await Process.run('start', ['""', file.path], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', [file.path]);
      } else if (Platform.isLinux) {
        await Process.run('xdg-open', [file.path]);
      }
      _addToRecentlyOpened(file);
    } catch (e) {
      debugPrint('Error opening file: $e');
    }
  }

  void _addToRecentlyOpened(EatenFile file) {
    if (mounted) {
      setState(() {
        _recentlyOpened.removeWhere((f) => f.id == file.id);
        _recentlyOpened.insert(0, file);
        if (_recentlyOpened.length > 100) {
          _recentlyOpened.removeRange(100, _recentlyOpened.length);
        }
      });
    }
  }

  Widget _buildTab(String title, int tabIndex) {
    final isSelected = _currentTab == tabIndex;
    return GestureDetector(
      onTap: () {
        if (mounted) {
          setState(() {
            _currentTab = tabIndex;
            _filteredFiles = _filterFilesSync();
          });
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isSelected ? Colors.blue.withOpacity(0.3) : Colors.transparent,
          border: Border(
            bottom: BorderSide(
              color: isSelected ? Colors.blue : Colors.transparent,
              width: 2,
            ),
          ),
        ),
        child: Text(
          title,
          style: TextStyle(
            color: isSelected ? Colors.white : Colors.white70,
            fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
          ),
        ),
      ),
    );
  }
  
  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Text(
        title,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 14,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  void _revealInExplorer(String filePath) async {
    try {
      if (Platform.isWindows) {
        await Process.run('explorer', ['/select,', filePath]);
      } else if (Platform.isMacOS) {
        await Process.run('open', ['-R', filePath]);
      } else if (Platform.isLinux) {
        final dir = path.dirname(filePath);
        await Process.run('xdg-open', [dir]);
      }
    } catch (e) {
      debugPrint('Error revealing file: $e');
    }
  }

  @override
  void dispose() {
    _searchDebounce?.cancel();
    _fileWatcher?.cancel();
    _addFocusNode.dispose();
    _addController.dispose();
    _searchController.dispose();
    _folderNameController.dispose();
    _folderNameFocusNode.dispose();
    _editNameController.dispose();
    _editCommentController.dispose();
    super.dispose();
  }
}

class EatenFile {
  final String id;
  final String path;
  final bool isWeb;
  bool isStarred;
  int openCount;
  DateTime? lastOpened;
  Uint8List? iconBytes;
  String fileName;
  final String pageTitle;
  String? comment;

  EatenFile({
    required this.id,
    required this.path,
    required this.isWeb,
    required this.isStarred,
    required this.openCount,
    this.lastOpened,
    this.iconBytes,
    required this.fileName,
    required this.pageTitle,
    this.comment,
  });

  factory EatenFile.fromJson(Map<String, dynamic> json) {
    return EatenFile(
      id: json['id'],
      path: json['path'],
      isWeb: json['isWeb'],
      isStarred: json['isStarred'],
      openCount: json['openCount'],
      lastOpened: json['lastOpened'] != null ? DateTime.parse(json['lastOpened']) : null,
      fileName: json['fileName'] ?? (json['isWeb'] ? _getDomainName(json['path']) : _getFileName(json['path'])),
      pageTitle: json['pageTitle'] != null ? json['pageTitle'] : 'none',
      comment: json['comment'],
    );
  }

  static String _getFileName(String filePath) {
    final parts = filePath.split(RegExp(r'[\\/]'));
    return parts.isNotEmpty ? parts.last : filePath;
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'path': path,
      'isWeb': isWeb,
      'isStarred': isStarred,
      'openCount': openCount,
      'lastOpened': lastOpened?.toIso8601String(),
      'fileName': fileName,
      'pageTitle': pageTitle,
      'comment': comment,
    };
  }

  static String _getDomainName(String url) {
    try {
      final uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');
      return uri.host;
    } catch (e) {
      return url.length > 15 ? '${url.substring(0, 12)}...' : url;
    }
  }
}

class CustomFolder {
  final String id;
  final String name;
  final List<String> fileIds;

  CustomFolder({
    required this.id,
    required this.name,
    required this.fileIds,
  });

  factory CustomFolder.fromJson(Map<String, dynamic> json) {
    return CustomFolder(
      id: json['id'],
      name: json['name'],
      fileIds: List<String>.from(json['fileIds'] ?? []),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'fileIds': fileIds,
    };
  }
}

class FileGridItem1 extends StatefulWidget {
  final EatenFile file;
  final int index;
  final VoidCallback onTap;
  final VoidCallback onLongPress;
  final void Function(TapDownDetails) onSecondaryTap;
  final VoidCallback onStarToggled;

  const FileGridItem1({
    Key? key,
    required this.file,
    required this.index,
    required this.onTap,
    required this.onLongPress,
    required this.onSecondaryTap,
    required this.onStarToggled,
  }) : super(key: key);

  @override
  State<FileGridItem1> createState() => _FileGridItemState1();
}

class _FileGridItemState1 extends State<FileGridItem1> {
  @override
  Widget build(BuildContext context) {
    String displayName = widget.file.fileName;
    
    if (widget.file.isWeb) {
      displayName = widget.file.pageTitle != 'none' ? widget.file.pageTitle : widget.file.fileName;
    }
    
    if (displayName.length > 12) {
      displayName = '${displayName.substring(0, 9)}...';
    }
    
    return GestureDetector(
      onTap: widget.onTap,
      onLongPress: widget.onLongPress,
      onSecondaryTapDown: widget.onSecondaryTap,
      child: Container(
        width: 85,
        height: 85,
        margin: const EdgeInsets.all(4),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.4),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Stack(
          children: [
            Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Container(
                  height: 40,
                  width: double.infinity,
                  child: _buildContentPreview(widget.file),
                ),
                const SizedBox(height: 4),
                Text(
                  displayName,
                  style: const TextStyle(
                    fontSize: 10,
                    color: Colors.white,
                  ),
                  textAlign: TextAlign.center,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
            Positioned(
              top: 4,
              right: 4,
              child: GestureDetector(
                onTap: widget.onStarToggled,
                child: Icon(
                  widget.file.isStarred ? Icons.star : Icons.star_border,
                  color: widget.file.isStarred ? Colors.yellow : Colors.white54,
                  size: 16,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContentPreview(EatenFile file) {
    final isUrl = file.isWeb || _isWebUrl(file.path);
    final isImageFile = _isImageFile(file);
    
    if (isUrl) {
      return _buildUrlIcon(file);
    } else if (isImageFile) {
      return _buildImagePreview(file);
    } else {
      return _buildFileIcon(file);
    }
  }

  bool _isImageFile(EatenFile file) {
    final imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];
    final ext = file.fileName.toLowerCase();
    return imageExtensions.any((imageExt) => ext.endsWith(imageExt));
  }

  bool _isWebUrl(String path) {
    return path.startsWith('http://') || 
           path.startsWith('https://') ||
           path.startsWith('www.');
  }

  Future<Uint8List?> _getFileIcon(String filePath) async {
    const MethodChannel _fileIconChannel = MethodChannel('screenshot_channel');
    try {
      final result = await _fileIconChannel.invokeMethod('getFileIcon', filePath);
      return result as Uint8List?;
    } catch (e) {
      debugPrint('Error getting file icon: $e');
      return null;
    }
  }

  String _getDomainName(String url) {
    try {
      final uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');
      return uri.host;
    } catch (e) {
      return url.length > 15 ? '${url.substring(0, 12)}...' : url;
    }
  }

  Future<Uint8List?> _getFavicon(String url) async {
    try {
      final domain = _getDomainName(url);
      final faviconUrl = 'https://www.google.com/s2/favicons?domain=$domain&sz=32';
      final response = await http.get(Uri.parse(faviconUrl));
      if (response.statusCode == 200) {
        return response.bodyBytes;
      }
    } catch (e) {
      debugPrint('Error getting favicon: $e');
    }
    return null;
  }   
  
  Widget _buildUrlIcon(EatenFile file) {
    if (file.iconBytes != null) {
      return Center(
        child: Image.memory(
          file.iconBytes!,
          width: 36,
          height: 36,
          fit: BoxFit.contain,
        ),
      );
    } else {
      return FutureBuilder<Uint8List?>(
        future: _getFavicon(file.path),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Container(
              width: 36,
              height: 36,
              child: const CircularProgressIndicator(strokeWidth: 2),
            );
          } else if (snapshot.hasData) {
            return Image.memory(
              snapshot.data!,
              width: 36,
              height: 36,
              fit: BoxFit.contain,
            );
          } else {
            return const Icon(
              Icons.language,
              color: Colors.blue,
              size: 36,
            );
          }
        },
      );
    }
  }

  Widget _buildImagePreview(EatenFile file) {
    return Center(
      child: Container(
        width: 36,
        height: 36,
        child: Image.file(
          File(file.path),
          width: 36,
          height: 36,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            return _buildFallbackIcon(file);
          },
        ),
      ),
    );
  }

  Widget _buildFileIcon(EatenFile file) {
    if (file.iconBytes != null) {
      return Center(
        child: Image.memory(
          file.iconBytes!,
          width: 36,
          height: 36,
          fit: BoxFit.contain,
        ),
      );
    } else {
      return FutureBuilder<Uint8List?>(
        future: _getFileIcon(file.path),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Container(
              width: 36,
              height: 36,
              child: const CircularProgressIndicator(strokeWidth: 2),
            );
          } else if (snapshot.hasData) {
            return Image.memory(
              snapshot.data!,
              width: 36,
              height: 36,
              fit: BoxFit.contain,
            );
          } else {
            return _buildFallbackIcon(file);
          }
        },
      );
    }
  }

  Widget _buildFallbackIcon(EatenFile file) {
    return Icon(
      file.isWeb ? Icons.language : Icons.insert_drive_file,
      color: file.isWeb ? Colors.blue : Colors.white,
      size: 36,
    );
  }
}
class SettingsWindowApp extends StatefulWidget {
  final String apiKey;
  final String petName;
  final bool useDeepSeek;
  final bool useVision;

  const SettingsWindowApp({
    Key? key,
    required this.apiKey,
    required this.petName,
    required this.useDeepSeek,
    required this.useVision,
  }) : super(key: key);

  @override
  State<SettingsWindowApp> createState() => _SettingsWindowAppState();
}
class _SettingsWindowAppState extends State<SettingsWindowApp> {
  late TextEditingController _apiKeyController;
  late TextEditingController _petNameController;
  late bool _useDeepSeek;
  late bool _useVision;

  @override
  void initState() {
    super.initState();
    _apiKeyController = TextEditingController(text: widget.apiKey);
    _petNameController = TextEditingController(text: widget.petName);
    _useDeepSeek = widget.useDeepSeek;
    _useVision = widget.useVision;
  }

  void _saveSettings() async {
    final prefs = await SharedPreferences.getInstance();
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º API –∫–ª—é—á
    await prefs.setString('api_key', _apiKeyController.text);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–º—è –ø–∏—Ç–æ–º—Ü–∞
    await prefs.setString('pet_name', _petNameController.text);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É DeepSeek
    await prefs.setBool('use_deepseek', _useDeepSeek);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–≥–æ –∑—Ä–µ–Ω–∏—è
    await prefs.setBool('vision', _useVision);

    windowManager.close();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text('‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏'),
          actions: [
            IconButton(
              icon: Icon(Icons.close),
              onPressed: () => windowManager.close(),
            ),
          ],
        ),
        body: Padding(
          padding: EdgeInsets.all(20),
          child: Column(
            children: [
              TextField(
                controller: _petNameController,
                decoration: InputDecoration(labelText: '–ò–º—è –ø–∏—Ç–æ–º—Ü–∞'),
              ),
              SizedBox(height: 16),
              TextField(
                controller: _apiKeyController,
                decoration: InputDecoration(labelText: 'API –∫–ª—é—á'),
                obscureText: true,
              ),
              SizedBox(height: 16),
              Row(
                children: [
                  Checkbox(
                    value: _useDeepSeek,
                    onChanged: (value) => setState(() => _useDeepSeek = value!),
                  ),
                  Text('–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å DeepSeek API'),
                ],
              ),
              SizedBox(height: 8),
              Row(
                children: [
                  Checkbox(
                    value: _useVision,
                    onChanged: (value) => setState(() => _useVision = value!),
                  ),
                  Text('–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–µ –∑—Ä–µ–Ω–∏–µ'),
                ],
              ),
              Spacer(),
              ElevatedButton(
                onPressed: _saveSettings,
                child: Text('–°–æ—Ö—Ä–∞–Ω–∏—Ç—å'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
class NameInputScreen extends StatefulWidget {
  @override
  _NameInputScreenState createState() => _NameInputScreenState();
}

class _NameInputScreenState extends State<NameInputScreen> {
  final _nameController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('ImeYou Tamagochi - –ù–∞—Å—Ç—Ä–æ–π–∫–∞'),
        actions: [
          IconButton(
            icon: Icon(Icons.close),
            onPressed: () => windowManager.close(),
          ),
        ],
      ),
      body: Padding(
        padding: EdgeInsets.all(20),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!',
              style: TextStyle(fontSize: 11, fontWeight: FontWeight.bold, color: Colors.deepPurple),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 20),
            Text(
              '–î–∞–π—Ç–µ –∏–º—è –≤–∞—à–µ–º—É —Ç–∞–º–∞–≥–æ—á–∏:',
              style: TextStyle(fontSize: 11),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 20),
            TextField(
              controller: _nameController,
              decoration: InputDecoration(
                hintText: '–í–≤–µ–¥–∏—Ç–µ –∏–º—è',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                filled: true,
                fillColor: Colors.grey[100],
              ),
            ),
            SizedBox(height: 30),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                ElevatedButton(
                  onPressed: () => windowManager.close(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.grey,
                    padding: EdgeInsets.symmetric(horizontal: 30, vertical: 15),
                  ),
                  child: Text('–ó–∞–∫—Ä—ã—Ç—å', style: TextStyle(color: Colors.white)),
                ),
                ElevatedButton(
                  onPressed: () async {
                    if (_nameController.text.isNotEmpty) {
                      final prefs = await SharedPreferences.getInstance();
                      await prefs.setString('pet_name', _nameController.text);
                      await prefs.setBool('first_run', false);
                      
                      // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≤ —Ä–µ–∂–∏–º–µ —Ç–∞–º–∞–≥–æ—á–∏
                      await windowManager.destroy();
                      await _initMainWindow();
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurple,
                    padding: EdgeInsets.symmetric(horizontal: 30, vertical: 15),
                  ),
                  child: Text('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', style: TextStyle(color: Colors.white)),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



  // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –∫–∞–¥—Ä–æ–≤ –∞–Ω–∏–º–∞—Ü–∏–∏
  class AnimationFrame {
    final String imagePath;
    final int durationMs;

    AnimationFrame(this.imagePath, this.durationMs);
  }

class TamagochiOverlay extends StatefulWidget {
  @override
  _TamagochiOverlayState createState() => _TamagochiOverlayState();
}

class _TamagochiOverlayState extends State<TamagochiOverlay>
    with WindowListener, TickerProviderStateMixin {
  // –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–∏—Ç–æ–º—Ü–∞
  
  final NativeSMTC _smtc = NativeSMTC();
  String _title = '–ù–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è';
  String _artist = '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
  String _album = '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
  String _playbackState = '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
  String _lastUpdate = '';
  final GlobalKey _screenshotKey = GlobalKey();
  bool _screenshotAnalyzeActive = false;
  String _analysisResult = '';
    double _happiness = 50.0;
  double _hunger = 50.0;
  int _level = 1;
  int _daysAlive = 0;
  bool _isAlive = true;
  bool _isSleeping = false;
  String _petName = '–¢–∞–º–∞–≥–æ—á–∏';
  bool _mouseOverWidgetOrChat = false;
  Timer? _longPressTimer;
  bool _isLongPressing = false;
  double _scale = 1.0;
  double _opacity = 0.0;
  bool _showStatus = false;
  bool _showRecentFiles = false;
  bool _isHoveringRecentFiles = false;
  final GlobalKey _petKey = GlobalKey();
  // –§–∞–π–ª—ã –∏ —á–∞—Ç
  late List<String> _eatenFiles = [];
  final List<Map<String, String>> _chatHistory = [];
  String _apiKey = '';
  bool _useDeepSeek = true;
  final TextEditingController _promptController = TextEditingController();
  Process? _chatProcess;
  bool _isChatOpen = false;
  // –¢–∞–π–º–µ—Ä—ã
  Timer? _dayTimer;
  Timer? _stateTimer;
  Timer? _movementTimer;
  Timer? _hoverTimer;
  Timer? _idleTimer;
 final String _storageDir = path.join(Directory.current.path, 'imeyou_pet', 'eaten_files');
  // –î–≤–∏–∂–µ–Ω–∏–µ –∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
  bool _isFollowingCursor = false;
  bool _isDragging = false;
  bool _isMovingWindow = false;
  bool _isAnimatingDrop = false;
  bool _contextMenuOpen = false;
  double _screenWidth = 1920;
  double _screenHeight = 1080;
  double _windowWidth = 260;
  double _windowHeight = 270;
  Offset _dragStartOffset = Offset.zero;
  Offset _windowStartOffset = Offset.zero;
  double _idleOffset = 0;
  double _idleDirection = 1;
  DateTime _lastCursorMove = DateTime.now();
  Offset _userSetPosition = Offset.zero;
  bool _userHasSetPosition = false;

  // –§–∏–∑–∏–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è
  Offset _velocity = Offset.zero;
  Offset _position = Offset.zero;
  bool _isThrown = false;
  double _gravity = 0.5;
  double _friction = 0.95;
  double _bounceFactor = 0.7;
  Timer? _physicsTimer;

  // –ê–Ω–∏–º–∞—Ü–∏–∏
  Map<String, List<AnimationFrame>> _animations = {};
  String _currentAnimation = 'idle';
  int _currentFrameIndex = 0;
  Timer? _animationTimer;
  DateTime _lastFrameChange = DateTime.now();

  // –û–≤–µ—Ä–ª–µ–∏
  OverlayEntry? _chatOverlay;
  OverlayEntry? _contextMenuOverlay;
  OverlayEntry? _submenuOverlay;
  OverlayEntry? _fileViewerOverlay;
  bool _chatOverlayVisible = false;
  bool _isMusicPlaying = false;
  Timer? _musicCheckTimer;
  bool _chatIsReadyToReceiveMessages=false;
late final KeyboardLogger _keyboardLogger = KeyboardLogger();
late final HotkeyService _hotkeyService = HotkeyService();
late final http.Client _httpClient = http.Client();
String _defaultLanguage = 'ru';

  // –§—Ä–∞–∑—ã
  List<String> _randomPhrases = [
    "–ü—Ä–∏–≤–µ—Ç! –ö–∞–∫ –¥–µ–ª–∞?",
    "–Ø –≥–æ–ª–æ–¥–µ–Ω!",
    "–ü–æ–∏–≥—Ä–∞–π —Å–æ –º–Ω–æ–π!",
    "–û—Ç–ª–∏—á–Ω—ã–π –¥–µ–Ω—å!",
    "–ú–Ω–µ —Å–∫—É—á–Ω–æ...",
    "–£—Ä–∞! –ù–æ–≤—ã–π —Ñ–∞–π–ª!",
    "–Ø —Ç–µ–±—è –ª—é–±–ª—é!",
    "–í—Ä–µ–º—è –ø–æ–∫—É—à–∞—Ç—å!",
  ];

  String _currentPhrase = "";

  late List<EatenFile> _files;
  late List<EatenFile> _filteredFiles;
  List<String> _recentlyOpened = [];
  final String _sharedFilesPath = 'eaten_files.json';
  final String _recentFilesPath = 'recent_files.json';
   final Map<String, Uint8List> _iconCache = {};
Timer? _clipboardTimer;
  Set<String> _lastFiles = {};

  static Process? _powerShellProcess;
  static Timer? _checkTimer;
  static final _script = '''
Add-Type -AssemblyName System.Windows.Forms
if ([System.Windows.Forms.Clipboard]::ContainsFileDropList()) {
    \$files = [System.Windows.Forms.Clipboard]::GetFileDropList()
    return (\$files | ConvertTo-Json -Compress)
}
return "[]"
''';


void _tabKeyPressed(String key){
    int index=-1;
    if (key=="Q"){
      index=0;
    } else
    if (key=="W"){
      index=1;
    } else
    if (key=="E"){
      index=2;
    } else
    if (key=="A"){
      index=3;
    } else
    if (key=="S"){
      index=4;
    } else
    if (key=="D"){
      index=5;
    } else
    if (key=="Z"){
      index=6;
    } else
    if (key=="X"){
      index=7;
    } else
    if (key=="C"){
      index=8;
    }
      if (index==-1) return;
      
// –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ–∞–π–ª—ã: —Å–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–æ–π, –∑–∞—Ç–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –æ—Ç–∫—Ä—ã—Ç–∏–π, –∑–∞—Ç–µ–º –ø–æ –¥–∞–≤–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è
    final sortedFiles = _files.toList()
      ..sort((a, b) {
        // 1. –°–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–æ–π
        if (a.isStarred && !b.isStarred) return -1;
        if (!a.isStarred && b.isStarred) return 1;
        
        // 2. –ó–∞—Ç–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –æ—Ç–∫—Ä—ã—Ç–∏–π (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)
        final openCountComparison = b.openCount.compareTo(a.openCount);
        if (openCountComparison != 0) return openCountComparison;
        
        // 3. –ó–∞—Ç–µ–º –ø–æ –¥–∞–≤–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è (—Å–Ω–∞—á–∞–ª–∞ –Ω–µ–¥–∞–≤–Ω–æ –æ—Ç–∫—Ä—ã—Ç—ã–µ)
        if (a.lastOpened != null && b.lastOpened != null) {
          return b.lastOpened!.compareTo(a.lastOpened!);
        }
        if (a.lastOpened != null) return -1;
        if (b.lastOpened != null) return 1;
        
        return 0;
      });
      
                  final file=sortedFiles[index];
                   final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
    


}
  Future<void> _registerHotkeys() async {

    /*
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'q',
      onPressed: () {_tabKeyPressed("Q");
     }
    );
    
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'w',
      onPressed: () {_tabKeyPressed("W");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'e',
      onPressed: () {_tabKeyPressed("E");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'a',
      onPressed: () {_tabKeyPressed("A");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 's',
      onPressed: () {_tabKeyPressed("S");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'd',
      onPressed: () {_tabKeyPressed("D");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'z',
      onPressed: () {_tabKeyPressed("Z");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'x',
      onPressed: () {_tabKeyPressed("X");
     }
    );
    await _hotkeyService.registerHotkey(
      modifier: 'tab',
      key: 'c',
      onPressed: () {_tabKeyPressed("C");
     }
    );
    */
    
    // Alt+Z
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'z',
      onPressed: () => _openFullChatWindow(),
    );

    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'e',
      onPressed: () => _showMacroKeyboardWindow(),
    );

    // Alt+X
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'x',
      onPressed: () => _showEssentialsViewer(),
    );

    // Alt+C
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'c',
      onPressed: () => _showCNPWindow(),
    );

    // Alt+V
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'v',
      onPressed: () => _copyVisibleAndOpenChatCopyCliplboardAsEntry(),
    );

    // Alt+S
    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 's',
      onPressed: () => _showScreenshotViewer(),
    );

   await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'q',
      onPressed: () => _translateCurrentSelectionToDefaultLanguage(),
    );

    await _hotkeyService.registerHotkey(
      modifier: 'alt',
      key: 'w',
      onPressed: () => _translateCurrentSelectionToEnglish(),
    );

  }

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–æ–∫—É—Å–µ –≤ Windows
Future<WindowsFocusInfo?> _getWindowsFocusInfo() async {
  try {
    const MethodChannel channel = MethodChannel('screenshot_channel');
    final String result = await channel.invokeMethod('getFocusInfo');
    return WindowsFocusInfo.fromJson(result);
  } catch (e) {
    print('Error getting Windows focus info: $e');
    return null;
  }
}
 

  
Future<void> _translateCurrentSelectionToDefaultLanguage() async {
  await _translateAndReplaceSelection(_defaultLanguage);
}

Future<void> _translateCurrentSelectionToEnglish() async {
  await _translateAndReplaceSelection('en');
}

Future<void> _translateAndReplaceSelection(String targetLanguage) async {
  try {
    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–æ–∫—É—Å–µ –∏ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–º —Ç–µ–∫—Å—Ç–µ
    final focusInfo = await _getWindowsFocusInfo();
    
    if (focusInfo == null ||focusInfo.selectedText==null || focusInfo.selectedText!.isEmpty) {
      //_showMessage('–ù–µ—Ç –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞');
      return;
    }

    final selectedText = focusInfo.selectedText!.trim();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–µ–∫—Å—Ç –Ω–µ —è–≤–ª—è–µ—Ç—Å—è URL –∏–ª–∏ email
    if (_isUrlOrEmail(selectedText)) {
      //_showMessage('–í—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç —è–≤–ª—è–µ—Ç—Å—è URL –∏–ª–∏ email, –ø–µ—Ä–µ–≤–æ–¥ –ø—Ä–æ–ø—É—â–µ–Ω');
      return;
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —è–∑—ã–∫
    final sourceLanguage = await _detectLanguage(selectedText);
    
    // –ï—Å–ª–∏ –∏—Å—Ö–æ–¥–Ω—ã–π —è–∑—ã–∫ —É–∂–µ —Ü–µ–ª–µ–≤–æ–π - –Ω–µ –ø–µ—Ä–µ–≤–æ–¥–∏–º
    if (sourceLanguage == targetLanguage) {
      //_showMessage('–¢–µ–∫—Å—Ç —É–∂–µ –Ω–∞ —Ü–µ–ª–µ–≤–æ–º —è–∑—ã–∫–µ');
      return;
    }

    // –í—ã–ø–æ–ª–Ω—è–µ–º –ø–µ—Ä–µ–≤–æ–¥
    String translatedText = await _translateWithLibreTranslate(selectedText, sourceLanguage, targetLanguage);
    
    if (translatedText.isEmpty) {
      translatedText = await _translateWithMyMemory(selectedText, sourceLanguage, targetLanguage);
    }

    if (translatedText.isNotEmpty) {
      // –ö–æ–ø–∏—Ä—É–µ–º –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
      await Clipboard.setData(ClipboardData(text: translatedText));
        AppLogger.writeLog('should be: $selectedText --> $translatedText');
      // –ò–º–∏—Ç–∏—Ä—É–µ–º –≤—Å—Ç–∞–≤–∫—É (Ctrl+V) –≤ —Ç–µ–∫—É—â–µ–µ –æ–∫–Ω–æ
      await _simulatePaste();
      
      //_showMessage('–¢–µ–∫—Å—Ç –ø–µ—Ä–µ–≤–µ–¥–µ–Ω –∏ –≤—Å—Ç–∞–≤–ª–µ–Ω');
    } else {
      //_showMessage('–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥');
    }
    
  } catch (e) {
    //_showMessage('–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: $e');
  }
}

bool _isUrlOrEmail(String text) {
  final urlRegex = RegExp(
    r'^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$',
    caseSensitive: false,
  );
  
  final emailRegex = RegExp(
    r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
  );
  
  return urlRegex.hasMatch(text) || emailRegex.hasMatch(text);
}

Future<void> _simulatePaste() async {
  try {
    const MethodChannel channel = MethodChannel('screenshot_channel');
    await channel.invokeMethod('simulatePaste');
  } catch (e) {
    print('Error simulating paste: $e');
    // Fallback: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π
    //_showMessage('–ü–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä. –ù–∞–∂–º–∏—Ç–µ Ctrl+V –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏');
  }
}


// –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π API LibreTranslate
Future<String> _translateWithLibreTranslate(String text, String from, String to) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/translate'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'q': text,
        'source': from,
        'target': to,
        'format': 'text'
      }),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['translatedText'] ?? '';
    }
  } catch (e) {
    print('LibreTranslate error: $e');
  }
  return '';
}

// –†–µ–∑–µ—Ä–≤–Ω—ã–π API MyMemory
Future<String> _translateWithMyMemory(String text, String from, String to) async {
  try {
    final response = await _httpClient.get(
      Uri.parse('https://api.mymemory.translated.net/get?'
          'q=${Uri.encodeComponent(text)}&'
          'langpair=$from|$to'),
    ).timeout(Duration(seconds: 10));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['responseData']['translatedText'] ?? '';
    }
  } catch (e) {
    print('MyMemory error: $e');
  }
  return '';
}

Future<String> _detectLanguage(String text) async {
  try {
    // –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —è–∑—ã–∫–∞
    return _detectLanguageBasic(text);
    
    // –î–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å API (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
    // return await _detectLanguageWithAPI(text);
  } catch (e) {
    return _detectLanguageBasic(text);
  }
}

// API –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞ (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
/*
Future<String> _detectLanguageWithAPI(String text) async {
  try {
    final response = await _httpClient.post(
      Uri.parse('https://libretranslate.de/detect'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'q': text}),
    ).timeout(Duration(seconds: 5));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      if (data is List && data.isNotEmpty) {
        return data[0]['language'] ?? 'en';
      }
    }
  } catch (e) {
    print('Language detection API error: $e');
  }
  return _detectLanguageBasic(text);
}
*/

String _detectLanguageBasic(String text) {
  // –£–ª—É—á—à–µ–Ω–Ω–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —è–∑—ã–∫–∞
  final russianRegex = RegExp(r'[–∞-—è–ê-–Ø—ë–Å]');
  final englishRegex = RegExp(r'[a-zA-Z]');
  final koreanRegex = RegExp(r'[„Ñ±-„Öé„Öè-„Ö£Í∞Ä-Ìû£]');
  final chineseRegex = RegExp(r'[\u4e00-\u9fff]');
  final japaneseRegex = RegExp(r'[\u3040-\u309F\u30A0-\u30FF]');
  
  // –ü–æ–¥—Å—á–µ—Ç —Å–∏–º–≤–æ–ª–æ–≤ —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–æ–≤
  int russianCount = russianRegex.allMatches(text).length;
  int englishCount = englishRegex.allMatches(text).length;
  int koreanCount = koreanRegex.allMatches(text).length;
  int chineseCount = chineseRegex.allMatches(text).length;
  int japaneseCount = japaneseRegex.allMatches(text).length;
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫ –ø–æ –ø—Ä–µ–æ–±–ª–∞–¥–∞—é—â–∏–º —Å–∏–º–≤–æ–ª–∞–º
  if (russianCount > 0 && russianCount > englishCount) return 'ru';
  if (koreanCount > 0) return 'ko';
  if (chineseCount > 0) return 'zh';
  if (japaneseCount > 0) return 'ja';
  if (englishCount > 0) return 'en';
  
  return 'en'; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
}


  void startMonitoring({int intervalMs = 1000}) {
    stopMonitoring(); // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä
    
    _checkTimer = Timer.periodic(
      Duration(milliseconds: intervalMs),
      (Timer t) => _checkWindowsClipboard()
    );
  }

  void _handleNewFiles(List<String> files) {
    return;
    final newFiles = files.toSet().difference(_lastFiles);
    if (newFiles.isNotEmpty) {
      // –§–∞–π–ª—ã –ø–æ—è–≤–∏–ª–∏—Å—å –≤ –±—É—Ñ–µ—Ä–µ –æ–±–º–µ–Ω–∞ - –≤–æ–∑–º–æ–∂–Ω–æ –Ω–∞—á–∞–ª–æ—Å—å –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
      print('Potential file drag detected: $newFiles');
      // –í—ã–∑—ã–≤–∞–µ–º –≤–∞—à—É —Ñ—É–Ω–∫—Ü–∏—é
      _handleFileDrag();
    }
    _lastFiles = files.toSet();
  }
  Future<void> _ensurePowerShell() async {
    if (_powerShellProcess != null) return;

    _powerShellProcess = await Process.start('powershell', [
      '-NoProfile',
      '-Command',
      '-'
    ], runInShell: false);
  }
   Future<void> _checkWindowsClipboard() async {
    try {
      await _ensurePowerShell();
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø—Ä–æ—Ü–µ—Å—Å
      _powerShellProcess!.stdin.writeln(_script);
      
      // –ß–∏—Ç–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å —Ç–∞–π–º–∞—É—Ç–æ–º
      final output = await _powerShellProcess!.stdout
          .transform(utf8.decoder)
          .transform(LineSplitter())
          .first
          .timeout(const Duration(seconds: 5));

      final filesJson = output.trim();
      if (filesJson != "[]") {
        try {
          final files = List<String>.from(json.decode(filesJson));
          _handleNewFiles(files);
        } catch (e) {
          print('Error parsing files: $e');
        }
      }
    } catch (e) {
      print('Clipboard check error: $e');
      // –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –ø—Ä–∏ –æ—à–∏–±–∫–µ
      _powerShellProcess?.kill();
      _powerShellProcess = null;
    }
  }




 Future<Uint8List?> _getFavicon(String url) async {
    try {
      final domain = _getDomainName(url);
      final faviconUrl = 'https://www.google.com/s2/favicons?domain=$domain&sz=32';
      final response = await http.get(Uri.parse(faviconUrl));
      if (response.statusCode == 200) {
        return response.bodyBytes;
      }
    } catch (e) {
      debugPrint('Error getting favicon: $e');
    }
    return null;
  }   
void _incrementOpenCount(EatenFile file) async {
    setState(() {
      file.openCount++;
      file.lastOpened = DateTime.now();
    });
    await _saveFile(file);
    _updateFilteredFiles();
  }



  void _updateFilteredFiles() {
  List<EatenFile> currentList = [];
  final Map<String, Uint8List> _iconCache = {};
  
    // –°–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–æ–π, –∑–∞—Ç–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –æ—Ç–∫—Ä—ã—Ç–∏–π
    final starredFiles = _files.where((file) => file.isStarred).toList();
    final otherFiles = _files.where((file) => !file.isStarred).toList()
      ..sort((a, b) => b.openCount.compareTo(a.openCount));
    
    currentList = [...starredFiles, ...otherFiles];
  



    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏
    setState(() {
      _filteredFiles = currentList;
    });
  }

  

Future<Uint8List?> _getCachedIcon(EatenFile file) async {
  final cacheKey = file.isWeb ? 'web_${_getDomainName(file.path)}' : 'file_${file.path}';
  
  if (_iconCache.containsKey(cacheKey)) {
    return _iconCache[cacheKey];
  }
  
  Uint8List? iconBytes;
  if (file.isWeb) {
    iconBytes = await _getFavicon(file.path);
  } else {

    iconBytes =  await _getFileIcon(file);
  }
  
  if (iconBytes != null) {
    _iconCache[cacheKey] = iconBytes;
  }
  
  return iconBytes;
}

  void _onAnalysisResult(String result) {
    setState(() {
      _analysisResult = result;
    });
    print('Received analysis result: $result');
  }
  
  void _startAnalysis() async {
    bool success = await ScreenAnalysis.startAnalysis();
    if (success) {
      print('Screen analysis started');
    }
  }
  
  void _stopAnalysis() async {
    bool success = await ScreenAnalysis.stopAnalysis();
    if (success) {
      print('Screen analysis stopped');
    }
  }
  

  void _closeChatWindow() {
    _chatProcess?.kill();
    _chatProcess = null;
    _isChatOpen = false;
    // –ù–µ –Ω—É–∂–Ω–æ —É–¥–∞–ª—è—Ç—å listener, —Ç–∞–∫ –∫–∞–∫ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–∫—Å–∏–Ω
  }
void _toggleChatWindow() async {
  const chatProcessId = 'chat_window';

  if (ProcessManager().hasProcess(chatProcessId)) {
    ProcessManager().killProcess(chatProcessId);
    _isChatOpen = false;
    return;
  }


  try {
    final pos = await windowManager.getPosition();
    final fullChatHistory = await _loadFullChatHistory();

    // JSON –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞
    String chatHistoryJson;
    try {
      chatHistoryJson = json.encode(fullChatHistory);
      
    } catch (e) {
      
      chatHistoryJson = '[]';
    }

    // –õ–æ–≥–∏—Ä—É–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã
    

    // –ó–∞–ø—É—Å–∫ –¥–æ—á–µ—Ä–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ —á–∞—Ç–∞
    final process = await Process.start(
      Platform.resolvedExecutable,
      [
        'chat',
        chatHistoryJson,
        pos.dx.toString(),
        pos.dy.toString(),
      ],
    );

    

    ProcessManager().registerProcess(chatProcessId, process);
    _isChatOpen = true;

    // –°–ª—É—à–∞–µ–º stderr –ø—Ä–æ—Ü–µ—Å—Å–∞
    process.stderr.transform(utf8.decoder).listen((data) async {
      
    });

    // –¢–∞–π–º–µ—Ä –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∫–∞–∂–¥—ã–µ 80 –º—Å
    Timer.periodic(Duration(milliseconds: 155), (timer) async {
      if (!ProcessManager().hasProcess(chatProcessId)) {
        timer.cancel();
        return;
      }
      if (!mounted) { // ‚Üê –î–æ–±–∞–≤—å—Ç–µ —ç—Ç—É –ø—Ä–æ–≤–µ—Ä–∫—É
        timer.cancel();
        return;
      }
      final currentPos = await windowManager.getPosition();
      final proc = ProcessManager().getProcess(chatProcessId);
      proc?.stdin.writeln('${currentPos.dx},${currentPos.dy}');
    });

    process.exitCode.then((code) async {
      
      if (mounted) {
        setState(() {
          _isChatOpen = false;
        });
      }
      ProcessManager().killProcess(chatProcessId);
    });
  } catch (e) {
    
    print('Error opening chat window: $e');
    _isChatOpen = false;
  }
}


void _windowListener() async {
  if (_isChatOpen) {
    final pos = await windowManager.getPosition();
    final size = await windowManager.getSize();
    
    // TODO: –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –ø—Ä–æ—Ü–µ—Å—Å—É —á–∞—Ç–∞ —á–µ—Ä–µ–∑ IPC
  }
}



Future<void> _loadSharedFiles() async {
  try {
    final dir = Directory(_storageDir);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
      return;
    }
    
    final List<EatenFile> loadedFiles = [];
    final entities = await dir.list().toList();
    
    for (var entity in entities) {
      if (entity is File && entity.path.endsWith('.json')) {
        try {
          final content = await entity.readAsString();
          if (content.trim().isNotEmpty) {
            final jsonData = json.decode(content);
            final file = EatenFile.fromJson(jsonData);
            loadedFiles.add(file);
          }
        } catch (e) {
          debugPrint('Error loading file ${entity.path}: $e');
        }
      }
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º: —Å–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–æ–π, –∑–∞—Ç–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –æ—Ç–∫—Ä—ã—Ç–∏–π
    loadedFiles.sort((a, b) {
      if (a.isStarred && !b.isStarred) return -1;
      if (!a.isStarred && b.isStarred) return 1;
      return b.openCount.compareTo(a.openCount);
    });
    
    setState(() {
      _files = loadedFiles;
      _updateFilteredFiles();
    });
    
    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∫–æ–Ω–∫–∏ –¥–ª—è —Ñ–∞–π–ª–æ–≤
    _loadIconsForFiles();
  } catch (e) {
    debugPrint('Error loading files from storage: $e');
  }
}

void _loadIconsForFiles() async {
  for (var file in _files) {
    if (file.iconBytes == null) {
      final iconBytes = await _getCachedIcon(file);
      if (iconBytes != null && mounted) {
        setState(() {
          file.iconBytes = iconBytes;
        });
      }
    }
  }
}

Future<void> _saveFile(EatenFile file) async {
  try {
    final fileName = '${file.id}.json';
    final filePath = path.join(_storageDir, fileName);
    final outputFile = File(filePath);
    final dir = outputFile.parent;
    
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    
    await outputFile.writeAsString(json.encode(file.toJson()));
  } catch (e) {
    debugPrint('Error saving file: $e');
  }
}

Future<void> _deleteFile(EatenFile file) async {
  try {
    // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –¥–∞–Ω–Ω—ã—Ö
    final fileName = '${file.id}.json';
    final filePath = path.join(_storageDir, fileName);
    final outputFile = File(filePath);
    
    if (await outputFile.exists()) {
      await outputFile.delete();
    }
    
    // –£–¥–∞–ª—è–µ–º –∏–∑ –∫—ç—à–∞ –∏–∫–æ–Ω–æ–∫
    final cacheKey = file.isWeb ? 'web_${_getDomainName(file.path)}' : 'file_${file.path}';
    _iconCache.remove(cacheKey);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º UI
    setState(() {
      _files.remove(file);
      _updateFilteredFiles();
    });
  } catch (e) {
    debugPrint('Error deleting file: $e');
  }
}
Future<void> _saveSharedFiles() async {
  try {
    final dir = Directory(_storageDir);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∂–¥—ã–π —Ñ–∞–π–ª –æ—Ç–¥–µ–ª—å–Ω–æ
    for (var file in _files) {
      await _saveFile(file);
    }
    
    debugPrint('Saved ${_files.length} files to storage');
  } catch (e) {
    debugPrint('Error saving files to storage: $e');
  }
}

// –ò–ª–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ñ–∞–π–ª:
Future<void> _saveSingleFile(EatenFile file) async {
  try {
    await _saveFile(file);
  } catch (e) {
    debugPrint('Error saving single file: $e');
  }
}

// –ú–µ—Ç–æ–¥ –¥–ª—è –º–∞—Å—Å–æ–≤–æ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
Future<void> _saveAllFiles(List<EatenFile> files) async {
  try {
    final dir = Directory(_storageDir);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    
    for (var file in files) {
      await _saveFile(file);
    }
    
    debugPrint('Saved ${files.length} files to storage');
  } catch (e) {
    debugPrint('Error saving all files: $e');
  }
}

Future<void> _keyLoggerActivate() async {
    //await _keyboardLogger.initialize();
}
  static void stopMonitoring() {
    _checkTimer?.cancel();
    _checkTimer = null;
    _powerShellProcess?.kill();
    _powerShellProcess = null;
  }


void _setupKeyboardListener() {
  RawKeyboard.instance.addListener((RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      //peekay
    if (_showRecentFiles==false) return;
// –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ–∞–π–ª—ã: —Å–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–æ–π, –∑–∞—Ç–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –æ—Ç–∫—Ä—ã—Ç–∏–π, –∑–∞—Ç–µ–º –ø–æ –¥–∞–≤–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è
    final sortedFiles = _files.toList()
      ..sort((a, b) {
        // 1. –°–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–æ–π
        if (a.isStarred && !b.isStarred) return -1;
        if (!a.isStarred && b.isStarred) return 1;
        
        // 2. –ó–∞—Ç–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –æ—Ç–∫—Ä—ã—Ç–∏–π (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)
        final openCountComparison = b.openCount.compareTo(a.openCount);
        if (openCountComparison != 0) return openCountComparison;
        
        // 3. –ó–∞—Ç–µ–º –ø–æ –¥–∞–≤–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è (—Å–Ω–∞—á–∞–ª–∞ –Ω–µ–¥–∞–≤–Ω–æ –æ—Ç–∫—Ä—ã—Ç—ã–µ)
        if (a.lastOpened != null && b.lastOpened != null) {
          return b.lastOpened!.compareTo(a.lastOpened!);
        }
        if (a.lastOpened != null) return -1;
        if (b.lastOpened != null) return 1;
        
        return 0;
      });
      if (event.logicalKey == LogicalKeyboardKey.escape) {
        setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
      } else if ( event.logicalKey == LogicalKeyboardKey.keyQ) {
                  final file=sortedFiles[0];
                   final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
                  

      } else if (event.logicalKey == LogicalKeyboardKey.keyW) {
        final file=sortedFiles[1];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      } else if (event.logicalKey == LogicalKeyboardKey.keyE) {
        final file=sortedFiles[2];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      } else if (event.logicalKey == LogicalKeyboardKey.keyA) {
        final file=sortedFiles[3];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      } else if (event.logicalKey == LogicalKeyboardKey.keyS) {
        final file=sortedFiles[4];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      } else if (event.logicalKey == LogicalKeyboardKey.keyD) {
       final file=sortedFiles[5];
        final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      }else if (event.logicalKey == LogicalKeyboardKey.keyZ) {
        final file=sortedFiles[6];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      }else if (event.logicalKey == LogicalKeyboardKey.keyX) {
        final file=sortedFiles[7];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      }else if (event.logicalKey == LogicalKeyboardKey.keyC) {
        final file=sortedFiles[8];
         final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
      }
    }
  });
}

  void _setupDragDropListener() {
    FileDragDropService.onDragStart = () {
      setState(() {
        _isDragging = true;
      });
      print('Drag started!');
      _handleFileDrag();
    };

    FileDragDropService.onDragEnd = () {
      setState(() {
        _isDragging = false;
      });
      _returnToUserPosition();
    };

    FileDragDropService.initialize();
  }


  bool _isYouTubeContent(String title, String artist) {
  final lowerTitle = title.toLowerCase();
  final lowerArtist = artist.toLowerCase();
  
  return lowerTitle.contains('youtube') ||
         lowerArtist.contains('chrome') ||
         lowerArtist.contains('edge') ||
         lowerArtist.contains('microsoft') ||
         lowerArtist.contains('google') ||
         lowerTitle.contains(' - youtube') ||
         lowerArtist == 'youtube';
}

bool _isMusicContent(String title, String artist) {
  // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ YouTube –∏ –µ—Å—Ç—å –∞—Ä—Ç–∏—Å—Ç/–Ω–∞–∑–≤–∞–Ω–∏–µ - —Å—á–∏—Ç–∞–µ–º –º—É–∑—ã–∫–æ–π
  return !_isYouTubeContent(title, artist) &&
         artist != '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å' &&
         title != '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç—Ä–µ–∫' &&
         artist.isNotEmpty;
}

Future<void> _youtubeVideoIsPlaying(String title, String channel) async {
  print('–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ YouTube –≤–∏–¥–µ–æ: "$title" –æ—Ç "$channel"');
  
  // –û—á–∏—â–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –æ—Ç YouTube-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤
  final cleanTitle = _cleanYouTubeTitle(title);
  final cleanChannel = _cleanYouTubeArtist(channel);
  
  // –ü—ã—Ç–∞–µ–º—Å—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (—ç—Ç–æ –±—É–¥–µ—Ç —ç–º—É–ª—è—Ü–∏—è)
  final videoType = await _determineYouTubeVideoType(cleanTitle, cleanChannel);
  
  switch (videoType) {
    case 'live':
      _startAnimation("watching_stream");
      _showPhrase(cleanTitle, cleanChannel, isMusic: false);
      break;
    case 'movie':
      final genre = await _getMovieGenre(cleanTitle);
      _startAnimation("watching_movie");
      _showPhrase(cleanTitle, cleanChannel, isMusic: false, movieGenre: genre);
      break;
    default:
      _startAnimation("watching_video");
      _showPhrase(cleanTitle, cleanChannel, isMusic: false);
  }
}

String _cleanYouTubeTitle(String title) {
  return title
      .replaceAll('YouTube', '')
      .replaceAll(' - YouTube', '')
      .replaceAll('| YouTube', '')
      .trim();
}

String _cleanYouTubeArtist(String artist) {
  if (artist.toLowerCase().contains('chrome') || 
      artist.toLowerCase().contains('edge')) {
    return 'YouTube';
  }
  return artist;
}

Future<String> _determineYouTubeVideoType(String title, String channel) async {
  // –≠–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –Ω–∞–∑–≤–∞–Ω–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –≤–∏–¥–µ–æ
  final lowerTitle = title.toLowerCase();
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é
  if (lowerTitle.contains('–ø—Ä—è–º–æ–π —ç—Ñ–∏—Ä') ||
      lowerTitle.contains('—Å—Ç—Ä–∏–º') ||
      lowerTitle.contains('live') ||
      lowerTitle.contains('—Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è')) {
    return 'live';
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ñ–∏–ª—å–º (–ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º)
  if (lowerTitle.contains('—Ñ–∏–ª—å–º') ||
      lowerTitle.contains('–∫–∏–Ω–æ') ||
      lowerTitle.contains('movie') ||
      lowerTitle.contains('full movie') ||
      lowerTitle.contains('–ø–æ–ª–Ω–æ–º–µ—Ç—Ä–∞–∂–Ω—ã–π')) {
    return 'movie';
  }
  
  // –î–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å YouTube API
  // –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω–æ–π –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤–∏–¥–µ–æ
  
  return 'video'; // –æ–±—ã—á–Ω–æ–µ –≤–∏–¥–µ–æ
}

Future<void> _musicIsPlaying(String artist, String title, String album, String? cover) async {
  print('–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –º—É–∑—ã–∫–∞: "$title" - "$artist"');
  
  // –ü–æ–ª—É—á–∞–µ–º –∂–∞–Ω—Ä —Ç—Ä–µ–∫–∞
  final genre = await _getMusicGenre(artist, title);
  final basicGenre = _simplifyGenre(genre);
  
  _startAnimation("music_interact_$basicGenre");
  _showPhrase(title, artist, isMusic: true, musicGenre: basicGenre);
}
String  _previusGenreMusic="unknown";
     
Future<String> _getMusicGenre(String artist, String title) async {
  try {

   

    if (_previusArtist==artist && _previusTitle==title){
      return "";
    }
    final musicBrainzService = MusicBrainzService();
    
    // –ü—Ä–æ–±—É–µ–º MusicBrainz API
    final genre = await musicBrainzService.getCombinedGenre(artist, title);
    if (genre != 'unknown') {
      _previusGenreMusic=genre;
      return genre;
    }
    
    // Fallback: –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ –∞—Ä—Ç–∏—Å—Ç—É (–ª–æ–∫–∞–ª—å–Ω–∞—è –±–∞–∑–∞)
    return await _getArtistGenre(artist);
  } catch (e) {
    print('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∂–∞–Ω—Ä–∞: $e');
    return 'unknown';
  }
}

Future<String> _getArtistGenre(String artist) async {
  // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –±–∞–∑–∞ –∂–∞–Ω—Ä–æ–≤ –ø–æ –∞—Ä—Ç–∏—Å—Ç–∞–º
  final genreMap = {
    'rock': ['nirvana', 'linkin park', 'queen', 'ac/dc', 'metallica'],
    'pop': ['taylor swift', 'justin bieber', 'ariana grande', 'katy perry'],
    'hiphop': ['eminem', 'kanye west', 'drake', 'snoop dogg'],
    'electronic': ['daft punk', 'deadmau5', 'skrillex', 'tiesto'],
    'classical': ['mozart', 'beethoven', 'bach', 'chopin'],
    'jazz': ['miles davis', 'louis armstrong', 'ella fitzgerald'],
  };
  
  final lowerArtist = artist.toLowerCase();
  for (final entry in genreMap.entries) {
    if (entry.value.any((artistName) => lowerArtist.contains(artistName))) {
      return entry.key;
    }
  }
  
  return 'unknown';
}

String _simplifyGenre(String genre) {
  final lowerGenre = genre.toLowerCase();
  
  if (lowerGenre.contains('rock')) return 'rock';
  if (lowerGenre.contains('pop')) return 'pop';
  if (lowerGenre.contains('hip') || lowerGenre.contains('rap')) return 'hiphop';
  if (lowerGenre.contains('electronic') || lowerGenre.contains('dance') || lowerGenre.contains('house')) return 'electronic';
  if (lowerGenre.contains('classical')) return 'classical';
  if (lowerGenre.contains('jazz')) return 'jazz';
  if (lowerGenre.contains('metal')) return 'metal';
  if (lowerGenre.contains('country')) return 'country';
  if (lowerGenre.contains('reggae')) return 'reggae';
  
  return 'unknown';
}


final List<String> randomPhrasesImpression = ["–£—Ö —Ç—ã", "–û", "–í–æ—É", "–ü—Ä–∏–∫–æ–ª—å–Ω–æ", "–í–∞—É", "–ó–¥–æ—Ä–æ–≤–æ"];
final List<String> randomPhrasesEnd = ["–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ!", "–©–∞ –∑–∞—Ü–µ–Ω–∏–º", "–ì–æ–¥–Ω–æ—Ç–∞", "–ö—Ä—É—Ç—è–∫", "–û–±–æ–∂–∞—é —ç—Ç–æ"];


Timer? _phraseTimer;


String _previusTitle="–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç—Ä–µ–∫";
String _previusArtist="–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å";
DateTime _lastMessageAppeared=DateTime.now();
void _showPhrase(String title, String artist, {bool isMusic = true, String? movieGenre, String? musicGenre}) {
  final random = Random();

  final now = DateTime.now();
    final timeDiff = now.difference(_lastMessageAppeared).inSeconds;
  // –®–∞–Ω—Å 69% –Ω–∞ –≤–æ–∑–≤—Ä–∞—Ç –±–µ–∑ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
  if (random.nextDouble() < 0.69 || timeDiff<600 || (_previusTitle==title && _previusArtist==artist)) {
    return;
  }
  _previusTitle=title;
  _previusArtist=artist;
  _lastMessageAppeared = now;
  final impression = randomPhrasesImpression[random.nextInt(randomPhrasesImpression.length)];
  final end = randomPhrasesEnd[random.nextInt(randomPhrasesEnd.length)];
  
  String middle;
  if (isMusic) {
    middle = "$artist - $title";
  } else {
    middle = movieGenre != null ? "$title ($movieGenre)" : title;
  }
  
  setState(() {
    _currentPhrase = "$impression, $middle, $end";
  });
  
  // –û—á–∏—â–∞–µ–º —Ñ—Ä–∞–∑—É —á–µ—Ä–µ–∑ 4 —Å–µ–∫—É–Ω–¥—ã
  _phraseTimer?.cancel();
  _phraseTimer = Timer(const Duration(seconds: 4), () {
    setState(() {
      _currentPhrase = "";
    });
  });
}

Future<String> _getMovieGenre(String title) async {
  // –≠–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∂–∞–Ω—Ä–∞ —Ñ–∏–ª—å–º–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
  final lowerTitle = title.toLowerCase();
  
  if (lowerTitle.contains('—É–∂–∞—Å') || lowerTitle.contains('—Ö–æ—Ä—Ä–æ—Ä') || lowerTitle.contains('—Å—Ç—Ä–∞—à')) return 'horror';
  if (lowerTitle.contains('–∫–æ–º–µ–¥–∏—è') || lowerTitle.contains('—Å–º–µ—à')) return 'comedy';
  if (lowerTitle.contains('–¥—Ä–∞–º–∞')) return 'drama';
  if (lowerTitle.contains('—Ñ–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞') || lowerTitle.contains('—Ñ—ç–Ω—Ç–µ–∑–∏')) return 'fantasy';
  if (lowerTitle.contains('–±–æ–µ–≤–∏–∫') || lowerTitle.contains('—ç–∫—à–Ω')) return 'action';
  if (lowerTitle.contains('—Ä–æ–º–∞–Ω') || lowerTitle.contains('–ª—é–±–æ–≤')) return 'romance';
  if (lowerTitle.contains('–¥–µ—Ç–µ–∫—Ç–∏–≤') || lowerTitle.contains('–º–∏—Å—Ç–∏–∫')) return 'mystery';
  
  return 'movie';
}

    
  // –§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
  Future<void> _play() async {
    final success = _smtc.play();
    print('Play –∫–æ–º–∞–Ω–¥–∞: $success');
  }

  Future<void> _pause() async {
    final success = _smtc.pause();
    print('Pause –∫–æ–º–∞–Ω–¥–∞: $success');
  }

  Future<void> _next() async {
    final success = _smtc.next();
    print('Next –∫–æ–º–∞–Ω–¥–∞: $success');
  }

  Future<void> _previous() async {
    final success = _smtc.previous();
    print('Previous –∫–æ–º–∞–Ω–¥–∞: $success');
  }

  Timer? _updateTimer;
  Future<void> _initializeMediaControls() async {

    return;
    _updateTimer = Timer.periodic(const Duration(seconds: 25), (timer) {
      try{
      _updateMediaInfo();
      }
      catch (e){
        AppLogger.writeLog("update media info broken, try again");
      }
    });
  }

  void _updateMediaInfo() {
    try {
      final mediaInfo = _smtc.getCurrentMediaInfo();
      final playbackState = _smtc.getPlaybackState();
      if (_playbackState=="–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ"){
      setState(() {
        _title = mediaInfo.title.isNotEmpty ? mediaInfo.title : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç—Ä–µ–∫';
        _artist = mediaInfo.artist.isNotEmpty ? mediaInfo.artist : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å';
        _album = mediaInfo.album.isNotEmpty ? mediaInfo.album : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–ª—å–±–æ–º';
        _playbackState = _parsePlaybackState(playbackState);
        _lastUpdate = '–û–±–Ω–æ–≤–ª–µ–Ω–æ: ${DateTime.now().toString().substring(11, 19)}';
      });
      
      print('–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ: "$_title" - "$_artist" ($_playbackState)');
      AppLogger.writeLog('–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ: "$_title" - "$_artist" ($_playbackState)');
      // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞

    
      if (_isYouTubeContent(_title, _artist)) {
        _youtubeVideoIsPlaying(_title, _artist);
      } else if (_isMusicContent(_title, _artist)) {
        _musicIsPlaying(_artist, _title, _album, null);
      }}

    } catch (e) {
      print('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö: $e');
    }
  }



  String _parsePlaybackState(PlaybackState state) {
    switch (state) {
      case PlaybackState.playing:
        return '–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ';
      case PlaybackState.paused:
        return '–ü–∞—É–∑–∞';
      case PlaybackState.stopped:
        return '–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ';
      default:
        return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    }
  }



 @override
void initState() {
  super.initState();

  
  WidgetsBinding.instance.addPostFrameCallback((_) async {
    try {

      startMonitoring(intervalMs: 1000);
      _setupDragDropListener();
      windowManager.addListener(this);
      _startServer();
      _startServer2();
      _initializeMediaControls();
      await _keyLoggerActivate();
      

      await _loadSavedData();
      _registerHotkeys();
      _setupKeyboardListener();
      

      await _initializeScreenSizeAndWindow();
      

      _startTimers();
      

      _startIdleDetection();

      await _ensureShortcutsFolderExists();
      

      await _loadChatHistory();
      

      _startMusicChecker();
      

      _setupWindowsContextMenu();
      

      await _loadAnimations();
      

      await windowManager.setAlwaysOnTop(true);
      

      _startPhysicsEngine();
      

      
    } catch (e, stack) {

      
      // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–∫–∞–∑–∞—Ç—å –æ–∫–Ω–æ –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
      try {
        await windowManager.show();

      } catch (e2) {

      }
    }
  });
}

  // –ó–∞–≥—Ä—É–∑–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–π
  Future<void> _loadAnimations() async {
    try {
      final animations = {
        'idle': await _loadAnimationFrames('idle'),
        'walk': await _loadAnimationFrames('walk'),
        'catch': await _loadAnimationFrames('catch'),
        'sleep': await _loadAnimationFrames('sleep'),
        'happy': await _loadAnimationFrames('happy'),
      };
      
      setState(() {
        _animations = animations;
      });
      
      _startAnimation('idle');
    } catch (e) {
      print('Error loading animations: $e');
    }
  }

  Future<List<AnimationFrame>> _loadAnimationFrames(String animationName) async {
    final List<AnimationFrame> frames = [];
    final petName="test";
    try {
      final directory = await getApplicationDocumentsDirectory();
      final animationDir = Directory('${directory.path}/$petName/animations/$animationName');
      
      if (animationDir.existsSync()) {
        final files = animationDir.listSync()
          .where((file) => file.path.endsWith('.png'))
          .toList();
        
        files.sort((a, b) {
          final aName = path.basenameWithoutExtension(a.path);
          final bName = path.basenameWithoutExtension(b.path);
          return int.parse(aName).compareTo(int.parse(bName));
        });
        
        for (final file in files) {
          final fileName = path.basenameWithoutExtension(file.path);
          final durationMs = int.parse(fileName);
          frames.add(AnimationFrame(file.path, durationMs));
        }
      }
    } catch (e) {
      print('Error loading animation $animationName: $e');
    }
    
    return frames;
  }

  void _startAnimation(String animationName) {
    if (_animations[animationName] == null || _animations[animationName]!.isEmpty) {
      return;
    }
    
    _animationTimer?.cancel();
    _currentAnimation = animationName;
    _currentFrameIndex = 0;
    _lastFrameChange = DateTime.now();
    
    _animationTimer = Timer.periodic(Duration(milliseconds: 16), (timer) {
          if (!mounted) { // ‚Üê –î–æ–±–∞–≤—å—Ç–µ —ç—Ç—É –ø—Ä–æ–≤–µ—Ä–∫—É
        timer.cancel();
        return;
      }
      final now = DateTime.now();
      final currentFrame = _animations[_currentAnimation]![_currentFrameIndex];
      final elapsed = now.difference(_lastFrameChange).inMilliseconds;
      
      if (elapsed >= currentFrame.durationMs) {
        setState(() {
          _currentFrameIndex = (_currentFrameIndex + 1) % _animations[_currentAnimation]!.length;
          _lastFrameChange = now;
        });
      }
    });
  }

  void _startPhysicsEngine() {
    _physicsTimer = Timer.periodic(Duration(milliseconds: 16), (timer) {
      if (!mounted) { // ‚Üê –î–æ–±–∞–≤—å—Ç–µ —ç—Ç—É –ø—Ä–æ–≤–µ—Ä–∫—É
        timer.cancel();
        return;
      }
      if (!_isThrown) return;
      
      _updatePhysics();
    });
  }

void _updatePhysics() {
  // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é
  _velocity = Offset(_velocity.dx, _velocity.dy + _gravity);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
  _position = Offset(
    _position.dx + _velocity.dx,
    _position.dy + _velocity.dy
  );
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—ã—Å–æ—Ç—É –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ (150 –ø–∏–∫—Å–µ–ª–µ–π –æ—Ç –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü—ã —ç–∫—Ä–∞–Ω–∞)
  final surfaceLevel = _screenHeight - 50;
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –∫—Ä–∞—è–º–∏ —ç–∫—Ä–∞–Ω–∞
  bool hitBoundary = false;
  
  if (_position.dx < -30) {
    _position = Offset(-30, _position.dy);
    _velocity = Offset(-_velocity.dx * _bounceFactor, _velocity.dy);
    hitBoundary = true;
  } else if (_position.dx > _screenWidth - _windowWidth+30) {
    _position = Offset(_screenWidth - _windowWidth, _position.dy);
    _velocity = Offset(-_velocity.dx * _bounceFactor, _velocity.dy);
    hitBoundary = true;
  }
  
  if (_position.dy < 0) {
    _position = Offset(_position.dx, 0);
    _velocity = Offset(_velocity.dx, -_velocity.dy * _bounceFactor);
    hitBoundary = true;
  } else if (_position.dy > surfaceLevel - _windowHeight) {
    // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ (150px –æ—Ç –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü—ã)
    _position = Offset(_position.dx, surfaceLevel - _windowHeight);
    _velocity = Offset(_velocity.dx, -_velocity.dy * _bounceFactor);
    hitBoundary = true;
    
    // –ï—Å–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å –æ—á–µ–Ω—å –º–∞–ª–∞ –ø–æ—Å–ª–µ –æ—Ç—Å–∫–æ–∫–∞ –æ—Ç –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º
    if (_velocity.dy.abs() < 1.0) {
      _isThrown = false;
      _velocity = Offset.zero;
      _userSetPosition = _position;
      _userHasSetPosition = true;
      _saveData();
      _startAnimation('idle');
    }
  }
  
  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–µ–Ω–∏–µ
  _velocity = Offset(_velocity.dx * _friction, _velocity.dy * _friction);
  
  // –ï—Å–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å –æ—á–µ–Ω—å –º–∞–ª–∞, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º
  if (_velocity.distance < 0.5 && !hitBoundary) {
    _isThrown = false;
    _velocity = Offset.zero;
    _userSetPosition = _position;
    
    _userHasSetPosition = true;
    _saveData();
    _startAnimation('idle');
  }
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –æ–∫–Ω–∞

  if (!_isDragging){
windowManager.setPosition(_position);
  }
  
}

  void _startMusicChecker() {
    _musicCheckTimer = Timer.periodic(Duration(seconds: 3), (timer) async {
      try {
        final isPlaying = await AudioChecker.isAudioPlaying();
        if (mounted && isPlaying != _isMusicPlaying) {
          setState(() {
            _isMusicPlaying = isPlaying;
          });
        }
      } catch (e) {
        print('Music check failed: $e');
      }
    });
  }

  void _setupWindowsContextMenu() async {
    if (Platform.isWindows) {
      try {
        final exePath = Platform.resolvedExecutable;
        final regCommand = '''
          \$keyPath = "Registry::HKEY_CLASSES_ROOT\\\\*\\\\shell\\\\FeedTo${_petName.replaceAll(' ', '')}"
          New-Item -Path \$keyPath -Force
          Set-ItemProperty -Path \$keyPath -Name "MUIVerb" -Value "–°–∫–æ—Ä–º–∏—Ç—å —Ñ–∞–π–ª $_petName"
          Set-ItemProperty -Path \$keyPath -Name "Icon" -Value "$exePath"
          
          \$commandPath = "\$keyPath\\\\command"
          New-Item -Path \$commandPath -Force
          Set-ItemProperty -Path \$commandPath -Name "(Default)" -Value "'$exePath' --feed-file '%1'"
        ''';

        await Process.run('powershell', ['-Command', regCommand]);
      } catch (e) {
        print('Error setting up Windows context menu: $e');
      }
    }
  }

  void _showRandomPhrase() {
    setState(() {
      _currentPhrase = _randomPhrases[Random().nextInt(_randomPhrases.length)];
    });
    
    Timer(Duration(seconds: 3), () {
      setState(() {
        _currentPhrase = "";
      });
    });
  }

Future<List<Map<String, String>>> _loadFullChatHistory() async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final chatDir = Directory('${directory.path}/ai_chat');
    final file = File('${chatDir.path}/chat_history.json');

    if (file.existsSync()) {
      final content = await file.readAsString();
      await File('chat_debug.log').writeAsString(
        '${DateTime.now()}: File content: $content\n',
        mode: FileMode.append,
      );

      if (content.trim().isEmpty) {
        return [];
      }

      final List<dynamic> data = json.decode(content);
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ Map<String, String>
      return data.map((item) {
        final map = item as Map<String, dynamic>;
        return map.map((key, value) => MapEntry(key, value.toString()));
      }).toList();
    }
  } catch (e) {
    await File('chat_debug.log').writeAsString(
      '${DateTime.now()}: Error loading chat history: $e\n',
      mode: FileMode.append,
    );
    print('Error loading chat history: $e');
  }

  return [];
}



  void _openFullChatWindow() async {
    const chatProcessId = 'chat_window';

  if (ProcessManager().hasProcess(chatProcessId)) {
    ProcessManager().killProcess(chatProcessId);
    _isChatOpen = false;
    return;
  }

  final debugFile = File('chat_debug.log');
  await debugFile.writeAsString(
    '${DateTime.now()}: _toggleChatWindow started\n',
    mode: FileMode.append,
  );

  try {
    final pos = await windowManager.getPosition();
    final fullChatHistory = await _loadFullChatHistory();

    // JSON –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞
    String chatHistoryJson;
    try {
      chatHistoryJson = json.encode(fullChatHistory);
      await debugFile.writeAsString(
        '${DateTime.now()}: JSON encoded successfully: ${chatHistoryJson.length} chars\n',
        mode: FileMode.append,
      );
    } catch (e) {
      await debugFile.writeAsString(
        '${DateTime.now()}: JSON encode error: $e\n',
        mode: FileMode.append,
      );
      chatHistoryJson = '[]';
    }

    // –õ–æ–≥–∏—Ä—É–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã
    await debugFile.writeAsString(
      '${DateTime.now()}: Starting process with args: chat, $chatHistoryJson, ${pos.dx}, ${pos.dy}\n',
      mode: FileMode.append,
    );

    // –ó–∞–ø—É—Å–∫ –¥–æ—á–µ—Ä–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ —á–∞—Ç–∞
    final process = await Process.start(
      Platform.resolvedExecutable,
      [
        'chat',
        chatHistoryJson,
        pos.dx.toString(),
        pos.dy.toString(),
      ],
    );

    await debugFile.writeAsString(
      '${DateTime.now()}: Process started with PID: ${process.pid}\n',
      mode: FileMode.append,
    );

    ProcessManager().registerProcess(chatProcessId, process);
    _isChatOpen = true;

    // –°–ª—É—à–∞–µ–º stderr –ø—Ä–æ—Ü–µ—Å—Å–∞
    process.stderr.transform(utf8.decoder).listen((data) async {
      await debugFile.writeAsString(
        '${DateTime.now()}: Process stderr: $data\n',
        mode: FileMode.append,
      );
    });

    // –¢–∞–π–º–µ—Ä –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∫–∞–∂–¥—ã–µ 80 –º—Å
    Timer.periodic(Duration(milliseconds: 25), (timer) async {
      if (!ProcessManager().hasProcess(chatProcessId)) {
        timer.cancel();
        return;
      }
      if (!mounted) { // ‚Üê –î–æ–±–∞–≤—å—Ç–µ —ç—Ç—É –ø—Ä–æ–≤–µ—Ä–∫—É
        timer.cancel();
        return;
      }
      final currentPos = await windowManager.getPosition();
      final proc = ProcessManager().getProcess(chatProcessId);
      proc?.stdin.writeln('${currentPos.dx},${currentPos.dy}');
    });

    process.exitCode.then((code) async {
      await debugFile.writeAsString(
        '${DateTime.now()}: Process exited with code: $code\n',
        mode: FileMode.append,
      );
      if (mounted) {
        setState(() {
          _isChatOpen = false;
          _chatIsReadyToReceiveMessages=false;
        });
      }
      ProcessManager().killProcess(chatProcessId);
    });
  } catch (e) {
    await debugFile.writeAsString(
      '${DateTime.now()}: Error opening chat window: $e\n',
      mode: FileMode.append,
    );
    print('Error opening chat window: $e');
    _isChatOpen = false;
  }
}


void _showContextMenuAtPosition() async {
  if (_contextMenuOverlay != null) {
    _removeContextMenu();
    return;
  }

  // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∏ —Ä–∞–∑–º–µ—Ä –≤–∏–¥–∂–µ—Ç–∞ —Ç–∞–º–∞–≥–æ—á–∏
  final RenderBox petRenderBox = _petKey.currentContext!.findRenderObject() as RenderBox;
  final Offset petPosition = petRenderBox.localToGlobal(Offset.zero);
  final ui.Size petSize = petRenderBox.size;

  final display = await screenRetriever.getPrimaryDisplay();
  final screenSize = display.size;

  final menuWidth = 200.0;
  final menuHeight = 200.0;

  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –º–µ–Ω—é –ø–æ —Ü–µ–Ω—Ç—Ä—É –≤–∏–¥–∂–µ—Ç–∞ —Ç–∞–º–∞–≥–æ—á–∏
  double menuX = petPosition.dx + (petSize.width - menuWidth) / 2;
  double menuY = petPosition.dy + (petSize.height - menuHeight) / 2 + 15;

  // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏—é, –µ—Å–ª–∏ –º–µ–Ω—é –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã —ç–∫—Ä–∞–Ω–∞
  if (menuX + menuWidth > screenSize.width) {
    menuX = screenSize.width - menuWidth - 10;
  }
  if (menuY + menuHeight > screenSize.height) {
    menuY = screenSize.height - menuHeight - 10;
  }
  if (menuX < 10) menuX = 10;
  if (menuY < 10) menuY = 10;

  _contextMenuOpen = true;

  _contextMenuOverlay = OverlayEntry(
    builder: (context) => Stack(
      children: [
        // –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ —Ñ–æ–Ω–∞
        Positioned.fill(
          child: GestureDetector(
            onTap: _removeContextMenu,
            child: Container(color: Colors.transparent),
          ),
        ),
        // –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é —Å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º –≤—ã—Ö–æ–¥–∞ –∫—É—Ä—Å–æ—Ä–∞
        Positioned(
          left: menuX,
          top: menuY,
          child: MouseRegion(
            // –£–∫–∞–∑—ã–≤–∞–µ–º –æ–±–ª–∞—Å—Ç—å, –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∑–∞ –∫–æ—Ç–æ—Ä—É—é –º–µ–Ω—é –∑–∞–∫—Ä–æ–µ—Ç—Å—è
            onExit: (event) {
              _removeContextMenu();
            },
            child: Container(
              width: menuWidth,
              height: menuHeight,
              decoration: BoxDecoration(
                color: Color(0xFF2D2D2D),
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.4),
                    blurRadius: 15,
                    spreadRadius: 2,
                  )
                ],
              ),
              child: GridView.count(
                crossAxisCount: 3,
                padding: EdgeInsets.all(11),
                mainAxisSpacing: 4,
                crossAxisSpacing: 4,
                children: [
                  _buildGridMenuItem(
                    Icons.camera_alt,
                    '–°–∫—Ä–∏–Ω—à–æ—Ç',
                    Colors.blue,
                    () {
                      _removeContextMenu();
                      _showScreenshotViewer();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.star,
                    'Essentials',
                    Colors.orange,
                    () {
                      _removeContextMenu();
                      _showEssentialsViewer();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.folder,
                    '–§–∞–π–ª—ã',
                    Colors.blue,
                    () {
                      _removeContextMenu();
                      _showFileViewer();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.chat,
                    '–ß–∞—Ç',
                    Colors.green,
                    () {
                      _removeContextMenu();
                      _openFullChatWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.chat,
                    '–ö–æ–ø–∏–ø–∞—Å—Ç–∞',
                    Colors.green,
                    () {
                      _removeContextMenu();
                      _showCNPWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.settings,
                    '–ù–∞—Å—Ç—Ä–æ–π–∫–∏',
                    Colors.orange,
                    () {
                      _removeContextMenu();
                      _showSettingsWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.settings,
                    'AI Test',
                    Colors.orange,
                    () {
                      _removeContextMenu();
                      _showAIWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.keyboard,
                    '–í–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞',
                    Colors.orange,
                    () {
                      _removeContextMenu();
                      _showMacroKeyboardWindow();
                    },
                  ),
                  _buildGridMenuItem(
                    Icons.close,
                    '–ó–∞–∫—Ä—ã—Ç—å',
                    Colors.red,
                    () {
                      _removeContextMenu();
                      ProcessManager().killAllProcesses();
                      windowManager.close();
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ],
    ),
  );

  Overlay.of(context)!.insert(_contextMenuOverlay!);
}
Widget _buildGridMenuItem(IconData icon, String text, Color color, VoidCallback onTap) {
  return Material(
    color: Colors.transparent,
    child: InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        width: 55, // –º–∞–∫—Å–∏–º—É–º 55 –ø–∏–∫—Å–µ–ª–µ–π
        height: 55,
        decoration: BoxDecoration(
          color: Color(0xFF3D3D3D),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: Colors.white.withOpacity(0.1), width: 1),
        ),
        padding: EdgeInsets.symmetric(horizontal: 4, vertical: 4),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, size: 20, color: color), // —á—É—Ç—å –±–æ–ª—å—à–µ –∏–∫–æ–Ω–∫–∞
            SizedBox(height: 2),
            Flexible(
              child: Text(
                text,
                style: TextStyle(
                  fontSize: 10, // —á–∏—Ç–∞–µ–º—ã–π —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞
                  color: Colors.white,
                  fontWeight: FontWeight.w500,
                ),
                textAlign: TextAlign.center,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    ),
  );
}
bool _isHoveringPet=false;
void _removeContextMenu() {
  if (_contextMenuOverlay != null) {
    _contextMenuOverlay!.remove();
    _contextMenuOverlay = null;
    _contextMenuOpen = false;
  }
     if (Platform.isWindows && !_isHoveringPet && !_isHoveringRecentFiles && !_contextMenuOpen) {
        windowManager.setIgnoreMouseEvents(false);
      }
}
  void _showEatenFilesOnClick() async {
    final pos = await windowManager.getPosition();
    //_showEatenFilesSubmenu(Offset(pos.dx, pos.dy - 100));
  }

  void _startLongPressTimer(Offset position) {
    _longPressTimer?.cancel();
    _isLongPressing = true;
    _longPressTimer = Timer(Duration(milliseconds: 450), () {
      if (_isLongPressing && mounted) {
        //_showEatenFilesSubmenu(position);
      }
    });
  }

  void _cancelLongPressTimer() {
    _longPressTimer?.cancel();
    _isLongPressing = false;
  }

  Future<void> _loadChatHistory() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final chatDir = Directory('${directory.path}/ai_chat');
      final file = File('${chatDir.path}/chat_history.json');
      
      if (file.existsSync()) {
        final content = await file.readAsString();
        final List<dynamic> data = json.decode(content);
        setState(() {
          _chatHistory.clear();
          _chatHistory.addAll(data.cast<Map<String, String>>());
        });
      }
    } catch (e) {
      print('Error loading chat history: $e');
    }
  }

  Future<void> _ensureShortcutsFolderExists() async {
    try {
      final exeDir = _getExeDirectory();
      final shortcuts = Directory(path.join(exeDir, 'Shortcuts'));
      if (!shortcuts.existsSync()) shortcuts.createSync(recursive: true);
    } catch (_) {}
  }

  String _getExeDirectory() {
    try {
      final exe = Platform.resolvedExecutable;
      final exeDir = path.dirname(exe);
      return exeDir;
    } catch (e) {
      return Directory.current.path;
    }
  }

  Future<void> _initializeScreenSizeAndWindow() async {
    final display = await screenRetriever.getPrimaryDisplay();
    final screenSize = display.size;
    final pos = await windowManager.getPosition();

    final prefs = await SharedPreferences.getInstance();
    final firstRun = prefs.getBool('first_run') ?? true;

    setState(() {
      _screenWidth = screenSize.width;
      _screenHeight = screenSize.height;
      _position = pos;
    });

    if (!firstRun) {
      _userSetPosition = Offset(
        _screenWidth - _windowWidth - 15,
        _screenHeight - _windowHeight-150,
      );
      _userHasSetPosition = true;
      await windowManager.setPosition(_userSetPosition);
      _position = _userSetPosition;
    } else {
      _userSetPosition = Offset(
        _screenWidth - 500,
        _screenHeight - 600,
      );
      _userHasSetPosition = true;
      await windowManager.setPosition(_userSetPosition);
      _position = _userSetPosition;
    }
  }

  void _startIdleDetection() {
    _idleTimer = Timer.periodic(Duration(milliseconds: 100), (timer) async {
      if (_isDragging || _isAnimatingDrop || _contextMenuOpen || _chatOverlayVisible || _isThrown) return;

      final now = DateTime.now();
      final idleTime = now.difference(_lastCursorMove).inSeconds;

      if (idleTime >= 20 && _userHasSetPosition && !_isThrown) {
        _startAnimation('idle');
        
        setState(() {
          _idleOffset += 2 * _idleDirection;
          if (_idleOffset.abs() >= 20) {
            _idleDirection *= -1;
          }
        });

        final currentPos = await windowManager.getPosition();
        await windowManager.setPosition(Offset(
          _userSetPosition.dx + _idleOffset,
          _userSetPosition.dy
        ));
      }
    });
  }

  Future<void> _loadSavedData() async {
    final prefs = await SharedPreferences.getInstance();
    if (mounted) {
      setState(() {
        _happiness = prefs.getDouble('happiness') ?? 50.0;
        _hunger = prefs.getDouble('hunger') ?? 50.0;
        _level = prefs.getInt('level') ?? 1;
        _daysAlive = prefs.getInt('days_alive') ?? 0;
        _apiKey = prefs.getString('api_key') ?? '';
        _useDeepSeek = prefs.getBool('use_deepseek') ?? true;
        _petName = prefs.getString('pet_name') ?? '–¢–∞–º–∞–≥–æ—á–∏';
        
        _screenshotAnalyzeActive=prefs.getBool('vision') ?? false;
        final savedX = prefs.getDouble('user_position_x');
        final savedY = prefs.getDouble('user_position_y');
        if (savedX != null && savedY != null) {
          _userSetPosition = Offset(savedX, savedY);
          _position = _userSetPosition;
          _userHasSetPosition = true;
          windowManager.setPosition(_userSetPosition);
        }
      });
      _loadSharedFiles();
    }

    if (_screenshotAnalyzeActive==true){
      _startAnalysis();

    }else{
      _stopAnalysis();
    }
  }


  void _startTimers() {
    _dayTimer = Timer.periodic(Duration(minutes: 1), (timer) {
      if (!_isAlive || !mounted) return;
      setState(() {
        _daysAlive++;
        if (_daysAlive % 1440 == 0) _level++;
        _saveData();
      });
    });

    _stateTimer = Timer.periodic(Duration(seconds: 1100), (timer) {
      if (!_isAlive || _isSleeping || !mounted) return;
      setState(() {
        _happiness = max(0, _happiness - 2);
        _hunger = min(100, _hunger + 1);
        if (_hunger >= 100) _isAlive = false;
        _saveData();
      });
    });
  }

  void _onTap() {
    if (!_isAlive) return;
    
    setState(() {
      _happiness = min(100, _happiness + 5);
      _showRandomPhrase();
    });
    
    _saveData();
  }

void _onDoubleTap() {
  if (!_isAlive) return;
  
  // –û—Ç–º–µ–Ω—è–µ–º –ª—é–±—ã–µ pending —Ç–∞–π–º–µ—Ä—ã
  _cancelLongPressTimer();
  
  // –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ —Å –¥—Ä—É–≥–∏–º–∏ –∂–µ—Å—Ç–∞–º–∏
  Future.delayed(Duration(milliseconds: 100), () {
    if (mounted) {
      _toggleChatWindow();
    }
  });
}

  void _showChatWindow() async {
    if (_chatOverlayVisible) {
      _removeChatOverlay();
      return;
    }

    final pos = await windowManager.getPosition();
    final display = await screenRetriever.getPrimaryDisplay();
    final screenSize = display.size;

    double chatX = pos.dx - 600;
    double chatY = pos.dy - 900;

    chatX = chatX.clamp(0.0, screenSize.width - 600);
    chatY = chatY.clamp(0.0, screenSize.height - 900);

    _isFollowingCursor = false;
    _chatOverlayVisible = true;

    _chatOverlay = OverlayEntry(
      builder: (context) => MouseRegion(
        onEnter: (_) {
          _mouseOverWidgetOrChat = true;
          _isFollowingCursor = false;
        },
        onExit: (_) {
          _mouseOverWidgetOrChat = false;
          if (!_mouseOverWidgetOrChat && _chatOverlayVisible) {
            _removeChatOverlay();
          }
        },
        
      ),
    );

    Overlay.of(context)!.insert(_chatOverlay!);
    await windowManager.setAlwaysOnTop(false);
  }

  void _sendChatMessage(String message) async {
    _chatHistory.add({
      'type': 'user',
      'message': message,
      'timestamp': DateTime.now().toString(),
    });

    setState(() {});

    if (message.startsWith('http')) {
      await launchUrl(Uri.parse(message));
    } else {
      final response = await _callAIAPI(message);
      _chatHistory.add({
        'type': 'ai',
        'message': response,
        'timestamp': DateTime.now().toString(),
      });
    }

    setState(() {});
  //  _saveChatHistory();
  }

  void _removeChatOverlay() async {
    _chatOverlay?.remove();
    _chatOverlay = null;
    _chatOverlayVisible = false;
    _isFollowingCursor = false;
    await windowManager.setAlwaysOnTop(true);
  }

  bool _isSystemPath(String text) {
    final trimmed = text.trim();
    if (Platform.isWindows) {
      return trimmed.contains(':\\') || trimmed.startsWith('\\\\');
    } else {
      return trimmed.startsWith('/');
    }
  }
  Future<Uint8List?> _getFileIcon1(String filePath) async {
    const MethodChannel _fileIconChannel = MethodChannel('screenshot_channel');
    try {
    final result = await _fileIconChannel.invokeMethod('getFileIcon', filePath);
    return result as Uint8List?;
  } catch (e) {
    print('Error getting file icon: $e');
    return null;
  }
  }
void _onFileDropped(List<String> files) async {
  if (!_isAlive || files.isEmpty) return;

  // –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–ª—è –Ω–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤
  final List<EatenFile> newFiles = [];
 
  for (final filePath in files) {
    final trimmedPath = filePath.trim();
    if (trimmedPath.isEmpty) continue;
    
    final isWeb = _isWebUrl(trimmedPath);
    final isSystemPath = _isSystemPath(trimmedPath);
    
    if (!isWeb && !isSystemPath) continue;
    
    Uint8List? iconBytes;
    String title="none";
    if (isWeb) {
      iconBytes = await _getFavicon(trimmedPath);
      title = await _getPageTitle(trimmedPath);
    } else if (isSystemPath) {
      iconBytes = await _getFileIcon1(trimmedPath);
      title = "none";
    }

    final newFile = EatenFile(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      path: trimmedPath,
      isWeb: isWeb,
      isStarred: false,
      openCount: 0,
      lastOpened: null,
      iconBytes: iconBytes,
      fileName: isWeb ? _getDomainName(trimmedPath) : path.basename(trimmedPath),
      pageTitle: title,
    );
  _openFile(newFile);
    newFiles.add(newFile);
  }

  setState(() {
    for (final newFile in newFiles) {
      // –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ñ–∞–π–ª —Å —Ç–∞–∫–∏–º –∂–µ path
      final existingFileIndex = _files.indexWhere((file) => file.path == newFile.path);
      
      if (existingFileIndex != -1) {
        // –ï—Å–ª–∏ —Ñ–∞–π–ª —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —É–¥–∞–ª—è–µ–º –µ–≥–æ
        final existingFile = _files.removeAt(existingFileIndex);
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–∞–π–ª–∞ (–∑–≤–µ–∑–¥–æ—á–∫—É, —Å—á–µ—Ç—á–∏–∫ –æ—Ç–∫—Ä—ã—Ç–∏–π –∏ —Ç.–¥.)
        newFile.isStarred = existingFile.isStarred;
        newFile.openCount = existingFile.openCount;
        newFile.lastOpened = existingFile.lastOpened;
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∫–æ–Ω–∫—É –µ—Å–ª–∏ –Ω–æ–≤–∞—è –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å
        if (newFile.iconBytes == null && existingFile.iconBytes != null) {
          newFile.iconBytes = existingFile.iconBytes;
        }
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —Ñ–∞–π–ª –≤ –Ω–∞—á–∞–ª–æ —Å–ø–∏—Å–∫–∞
      _files.insert(0, newFile);
      _saveFile(newFile);
    }
    
    _hunger = max(0, _hunger - 100);
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∞–π–ª–æ–≤
    if (_files.length > 1000) {
      final filesToRemove = _files.sublist(1000);
      for (final file in filesToRemove) {
        _deleteFile(file); // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã –∏–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞
      }
      _files.removeRange(1000, _files.length);
    }
  });

  _saveData();
  // _saveSharedFiles(); // –≠–¢–£ –°–¢–†–û–ß–ö–£ –£–î–ê–õ–Ø–ï–ú, —Ç.–∫. –º–µ—Ç–æ–¥ –±–æ–ª—å—à–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
  _analyzeFile(files.last);

  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text('–§–∞–π–ª –ø—Ä–∏–Ω—è—Ç: ${path.basename(files.last)}'), 
      duration: Duration(seconds: 2)
    ),
  );
}
void _onUrlDropped(String url) async {
  if (!_isAlive || url.isEmpty) return;

  final trimmedUrl = url.trim();
  if (trimmedUrl.isEmpty) return;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –≤–∞–ª–∏–¥–Ω—ã–π URL
  if (!_isWebUrl(trimmedUrl)) return;
  String title = await _getPageTitle(trimmedUrl);
  // –ü–æ–ª—É—á–∞–µ–º favicon –¥–ª—è URL
  final iconBytes = await _getFavicon(trimmedUrl);

  final newFile = EatenFile(
    id: DateTime.now().millisecondsSinceEpoch.toString(),
    path: trimmedUrl,
    isWeb: true,
    isStarred: false,
    openCount: 0,
    lastOpened: null,
    iconBytes: iconBytes,
    fileName: _getDomainName(trimmedUrl),
    pageTitle: title,
  );

  setState(() {
    // –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ñ–∞–π–ª —Å —Ç–∞–∫–∏–º –∂–µ URL
    final existingFileIndex = _files.indexWhere((file) => file.path == newFile.path);
    
    if (existingFileIndex != -1) {
      // –ï—Å–ª–∏ URL —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —É–¥–∞–ª—è–µ–º –µ–≥–æ
      final existingFile = _files.removeAt(existingFileIndex);
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–∞–π–ª–∞
      newFile.isStarred = existingFile.isStarred;
      newFile.openCount = existingFile.openCount;
      newFile.lastOpened = existingFile.lastOpened;
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∫–æ–Ω–∫—É –µ—Å–ª–∏ –Ω–æ–≤–∞—è –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å
      if (newFile.iconBytes == null && existingFile.iconBytes != null) {
        newFile.iconBytes = existingFile.iconBytes;
      }
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —Ñ–∞–π–ª –≤ –Ω–∞—á–∞–ª–æ —Å–ø–∏—Å–∫–∞
    _files.insert(0, newFile);
    _saveFile(newFile);
    
    _hunger = max(0, _hunger - 100);
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∞–π–ª–æ–≤
    if (_files.length > 1000) {
      final filesToRemove = _files.sublist(1000);
      for (final file in filesToRemove) {
        _deleteFile(file); // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã –∏–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞
      }
      _files.removeRange(1000, _files.length);
    }
  });

  _saveData();


  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text('URL –ø—Ä–∏–Ω—è—Ç: ${_getDomainName(trimmedUrl)}'), 
      duration: Duration(seconds: 2)
    ),
  );
}


// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–º–µ–Ω–Ω–æ–≥–æ –∏–º–µ–Ω–∏
String _getDomainName(String url) {
  try {
    final uri = Uri.parse(url);
    return uri.host;
  } catch (e) {
    // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å URL, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é —Å—Ç—Ä–æ–∫—É
    return url;
  }
}

// –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ URL
bool _isWebUrl(String text) {
  final trimmed = text.trim();
  return trimmed.startsWith('http://') || 
         trimmed.startsWith('https://') ||
         trimmed.startsWith('www.') ||
         (trimmed.contains('.') && 
         (trimmed.contains('/') || 
          trimmed.endsWith('.com') || 
          trimmed.endsWith('.ru') || 
          trimmed.endsWith('.org')));
}

// –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —è—Ä–ª—ã–∫–æ–≤ URL
void _createShortcutForUrl(String url) async {
  try {
    final directory = await getApplicationDocumentsDirectory();
    final shortcutsDir = Directory('${directory.path}/url_shortcuts');
    if (!shortcutsDir.existsSync()) {
      shortcutsDir.createSync(recursive: true);
    }

    final domain = _getDomainName(url);
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final shortcutFile = File('${shortcutsDir.path}/$domain-$timestamp.url');
    
    await shortcutFile.writeAsString('[InternetShortcut]\nURL=$url');
  } catch (e) {
    debugPrint('Error creating URL shortcut: $e');
  }
}



void _saveData() async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.setDouble('happiness', _happiness);
  await prefs.setDouble('hunger', _hunger);
  await prefs.setInt('level', _level);
  await prefs.setInt('days_alive', _daysAlive);
  await prefs.setString('api_key', _apiKey);
  await prefs.setBool('use_deepseek', _useDeepSeek);
  await _loadSharedFiles();
  await prefs.setDouble('user_position_x', _userSetPosition.dx);
  await prefs.setDouble('user_position_y', _userSetPosition.dy);
  await prefs.setBool('vision',_screenshotAnalyzeActive);
  await _saveSharedFiles(); // ‚Üê –î–û–ë–ê–í–¨–¢–ï –≠–¢–£ –°–¢–†–û–ß–ö–£
}


  void _analyzeFile(String filePath) async {
    final fileName = path.basename(filePath);
    final fileExtension = path.extension(filePath).toLowerCase();
    final fileSize = File(filePath).lengthSync();

    String fileMetadata = await _extractFileMetadata(filePath);

    String analysisPrompt = '''
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ñ–∞–π–ª: $fileName
–ü—É—Ç—å: $filePath
–†–∞–∑–º–µ—Ä: ${fileSize ~/ 1024} KB
–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ: $fileExtension
$fileMetadata

–ï—Å–ª–∏ —Ç–µ–±–µ –∑–Ω–∞–∫–æ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–ª–∏ —Ç—ã –º–æ–∂–µ—à—å –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç—å —á—Ç–æ —ç—Ç–æ –∑–∞ —Ñ–∞–π–ª - –¥–∞–π –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, –º—É–∑—ã–∫–∞–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è, –∫–Ω–∏–≥–∞, –ø—Ä–æ–≥—Ä–∞–º–º–∞). –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ–∑–Ω–∞–∫–æ–º —Ç–∞–∫ –∏ –Ω–∞–ø–∏—à–∏ "—Ñ–∞–π–ª –Ω–µ–æ–ø–æ–∑–Ω–∞–Ω". –ë—É–¥—å –∫—Ä–∞—Ç–æ–∫ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–µ–Ω.
''';

    final response = await _callAIAPI(analysisPrompt);
    _chatHistory.add({
      'type': 'ai',
      'message': 'üìÅ –ê–Ω–∞–ª–∏–∑ —Ñ–∞–π–ª–∞: $fileName\n$response',
      'timestamp': DateTime.now().toString(),
    });
    //_saveChatHistory();
    _saveFileResponse(filePath, response);
  }

  Future<void> _saveFileResponse(String filePath, String response) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/file_responses.json');
      
      Map<String, dynamic> responses = {};
      if (file.existsSync()) {
        final content = await file.readAsString();
        responses = json.decode(content);
      }
      
      responses[filePath] = response;
      await file.writeAsString(json.encode(responses));
    } catch (e) {
      print('Error saving file response: $e');
    }
  }

  Future<String> _extractFileMetadata(String filePath) async {
    try {
      final file = File(filePath);
      final stat = await file.stat();
      String metadata = '–ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è: ${stat.modified}\n';

      if (file.existsSync()) {
        try {
          final bytes = await file.readAsBytes();
          if (bytes.length > 10) {
            final header = bytes.take(10).toList();
            if (header[0] == 0xFF && header[1] == 0xD8) {
              metadata += '–¢–∏–ø: JPEG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n';
            } else if (header[0] == 0x89 && header[1] == 0x50) {
              metadata += '–¢–∏–ø: PNG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n';
            } else if (header[0] == 0x50 && header[1] == 0x4B) {
              metadata += '–¢–∏–ø: ZIP –∞—Ä—Ö–∏–≤ –∏–ª–∏ Office –¥–æ–∫—É–º–µ–Ω—Ç\n';
            } else if (header[0] == 0x49 && header[1] == 0x44 && header[2] == 0x33) {
              metadata += '–¢–∏–ø: MP3 —Ñ–∞–π–ª —Å ID3 —Ç–µ–≥–æ–º\n';
            }
          }
        } catch (e) {}
      }

      if (filePath.toLowerCase().endsWith('.mp3') || 
          filePath.toLowerCase().endsWith('.wav') ||
          filePath.toLowerCase().endsWith('.flac') ||
          filePath.toLowerCase().endsWith('.m4a')) {
        metadata += '–ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ê—É–¥–∏–æ —Ñ–∞–π–ª\n';
      } else if (filePath.toLowerCase().endsWith('.txt') || 
                filePath.toLowerCase().endsWith('.doc') ||
                filePath.toLowerCase().endsWith('.docx') ||
                filePath.toLowerCase().endsWith('.pdf')) {
        metadata += '–ö–∞—Ç–µ–≥–æ—Ä–∏—è: –¢–µ–∫—Å—Ç–æ–≤—ã–π –¥–æ–∫—É–º–µ–Ω—Ç\n';
      } else if (filePath.toLowerCase().endsWith('.jpg') || 
                filePath.toLowerCase().endsWith('.png') ||
                filePath.toLowerCase().endsWith('.gif') ||
                filePath.toLowerCase().endsWith('.bmp')) {
        metadata += '–ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n';
      } else if (filePath.toLowerCase().endsWith('.exe') ||
                filePath.toLowerCase().endsWith('.msi') ||
                filePath.toLowerCase().endsWith('.app')) {
        metadata += '–ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ò—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª\n';
      }

      return metadata;
    } catch (e) {
      return '–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ: –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã\n';
    }
  }

  Future<String> _callAIAPI(String prompt) async {
    if (_apiKey.isEmpty) return 'API –∫–ª—é—á –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –µ–≥–æ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–º –º–µ–Ω—é.';

    try {
      final url = _useDeepSeek
          ? 'https://api.deepseek.com/v1/chat/completions'
          : 'https://api.openai.com/v1/chat/completions';

      final response = await http.post(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $_apiKey',
        },
        body: json.encode({
          'model': _useDeepSeek ? 'deepseek-chat' : 'gpt-4',
          'messages': [{'role': 'user', 'content': prompt}],
          'max_tokens': 500,
          'temperature': 0.7,
        }),
      );

      if (response.statusCode == 200) {
        final jsonResponse = json.decode(response.body);
        return jsonResponse['choices'][0]['message']['content']?.trim() ?? '–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç API';
      } else {
        return '–û—à–∏–±–∫–∞ API: ${response.statusCode} - ${response.body}';
      }
    } catch (e) {
      return '–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: $e';
    }
  }

  void _saveChatHistory() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final chatDir = Directory('${directory.path}/ai_chat');
      if (!chatDir.existsSync()) chatDir.createSync(recursive: true);

      final file = File('${chatDir.path}/chat_history.json');
      await file.writeAsString(json.encode(_chatHistory));
    } catch (e) {
      print('Error saving chat history: $e');
    }
  }

  Future<void> _createShortcutForFile(String targetPath) async {
    try {
      final exeDir = _getExeDirectory();
      final shortcutsDir = Directory(path.join(exeDir, 'Shortcuts'));
      if (!shortcutsDir.existsSync()) shortcutsDir.createSync(recursive: true);

      final fileName = path.basename(targetPath);
      final safeName = fileName.replaceAll(RegExp(r'[<>:"/\\|?*]'), '_');
      final shortcutPath = path.join(shortcutsDir.path, '$safeName.lnk');

      final ps = r'''
$target = "%TARGET%"
$shortcutPath = "%SHORTCUT%"
$w = New-Object -ComObject WScript.Shell
$sc = $w.CreateShortcut($shortcutPath)
$sc.TargetPath = $target
$sc.WorkingDirectory = (Split-Path $target)
$sc.Save()
''';

      final command = ps
          .replaceAll('%TARGET%', targetPath.replaceAll(r'%', '%%'))
          .replaceAll('%SHORTCUT%', shortcutPath.replaceAll(r'%', '%%'));

      final result = await Process.run('powershell',
          ['-NoProfile', '-NonInteractive', '-Command', command],
          runInShell: true);

      if (result.exitCode != 0) {
        final fallback = File(path.join(shortcutsDir.path, '$safeName.shortcut.txt'));
        await fallback.writeAsString(targetPath);
      }
    } catch (e) {
      try {
        final exeDir = _getExeDirectory();
        final shortcutsDir = Directory(path.join(exeDir, 'Shortcuts'));
        if (!shortcutsDir.existsSync()) shortcutsDir.createSync(recursive: true);
        final safeName = path.basename(targetPath).replaceAll(RegExp(r'[<>:"/\\|?*]'), '_');
        final fallback = File(path.join(shortcutsDir.path, '$safeName.shortcut.txt'));
        await fallback.writeAsString(targetPath);
      } catch (_) {}
    }
  }

  Widget _buildStatusBar(String label, double value, Color color) {
    return SizedBox(
      width: 120,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '$label: ${value.toInt()}%',
            style: TextStyle(color: Colors.white, fontSize: 10),
          ),
          SizedBox(height: 2),
          Container(
            height: 8,
            decoration: BoxDecoration(
              color: Colors.grey[700],
              borderRadius: BorderRadius.circular(4),
            ),
            child: FractionallySizedBox(
              alignment: Alignment.centerLeft,
              widthFactor: (value / 100).clamp(0.0, 1.0),
              child: Container(
                decoration: BoxDecoration(
                  color: color,
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _showFileViewer() async {

    const processId="eaten_files_all";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }

   final process =   await Process.start(
      Platform.resolvedExecutable,
      [
        'files',
        json.encode(_eatenFiles),
      ],
      runInShell: true,
    );

      ProcessManager().registerProcess(processId, process);
  }
 void _showScreenshotViewer() async {

       const processId="screenshoter";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process =  
    await Process.start(
      Platform.resolvedExecutable,
      [
        'screenshoter',
      ],
      runInShell: true,
    );

    ProcessManager().registerProcess(processId, process);
    
    


  }

  

  void _openFile(EatenFile filePath) async {
    try {
      if (Platform.isWindows) {
        await Process.run('start', ['""', filePath.path], runInShell: true);
      } else if (Platform.isMacOS) {
        await Process.run('open', [filePath.path]);
      } else {
        await Process.run('xdg-open', [filePath.path]);
      }
    } catch (e) {
      print('Error opening file: $e');
    }
  }

  void _openFileFolder(String filePath) {
    final directory = File(filePath).parent;
    try {
      if (Platform.isWindows) {
        Process.run('explorer', ['/select,', filePath], runInShell: true);
      } else if (Platform.isMacOS) {
        Process.run('open', ['-R', filePath]);
      } else {
        Process.run('xdg-open', [directory.path]);
      }
    } catch (e) {
      print('Error opening file folder: $e');
    }
  }

  void _clearEatenFiles() {
    setState(() {
      _eatenFiles.clear();
      _saveData();
    });
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('–°–ø–∏—Å–æ–∫ —Å—ä–µ–¥–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –æ—á–∏—â–µ–Ω'),
        duration: Duration(seconds: 2),
      ),
    );
  }

  void _showSettingsWindow() async {


         const processId="settings_window";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process = await Process.start(
      Platform.resolvedExecutable,
      [
            'settings',
      _apiKey,
      _useDeepSeek.toString(),
      _petName,
      _screenshotAnalyzeActive.toString(),
      ],
    );

    ProcessManager().registerProcess(processId, process);
    
    


  // –ü–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –æ–∫–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ SharedPreferences
  if (process.exitCode == 0) {
    _loadSavedData(); // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞
  }
}



 void _showMacroKeyboardWindow() async {


         const processId="macro_keyboard";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process = await Process.start(
      Platform.resolvedExecutable,
      [
            'macro_keyboard',
      ],
    );

    ProcessManager().registerProcess(processId, process);
    
    


  // –ü–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –æ–∫–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ SharedPreferences
  if (process.exitCode == 0) {
    _loadSavedData(); // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞
  }
}


  void _showAIWindow() async {


         const processId="ai_process";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process = await Process.start(
      Platform.resolvedExecutable,
      [
            'ai_open',
      ],
    );

    ProcessManager().registerProcess(processId, process);
    
    


  // –ü–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –æ–∫–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ SharedPreferences
  if (process.exitCode == 0) {
    _loadSavedData(); // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞
  }
}

  void _showCNPWindow() async {
     const processId="cnp_window";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process = await Process.start(
      Platform.resolvedExecutable,
      [
        'clipboard-history',
       
      ],
    );

    ProcessManager().registerProcess(processId, process);
    
    
   
  }


void _copyVisibleAndOpenChatCopyCliplboardAsEntry() async {
  const chatProcessId = 'chat_window';
  
  try {
    // 1. –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º —Ñ–æ–∫—É—Å–µ –≤ Windows
    final focusInfo = await _getWindowsFocusInfo();
    
    if (focusInfo == null) {
      print('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–æ–∫—É—Å–µ');
      return;
    }
    
    // 2. –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–æ–≤
    if (focusInfo.isFileSelection) {
      final filePath = focusInfo.selectedPath;
      if (filePath != null && filePath.isNotEmpty) {
        // 2.1 –ö–æ–ø–∏—Ä—É–µ–º –ø—É—Ç—å —Ñ–∞–π–ª–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
        await _copyToClipboard(filePath);
        
        // 2.2 –í—ã–∑—ã–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É —Ñ–∞–π–ª–∞ –≤ —Ç–µ–∫—É—â–µ–º –∫–ª–∞—Å—Å–µ
        _onFileDropped([filePath]);
        return; // –ù–µ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–æ —á–∞—Ç–∞ –¥–ª—è —Ñ–∞–π–ª–æ–≤
      }
    }
    
    // 3. –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞
    if (focusInfo.isTextSelection && focusInfo.selectedText != null) {
      final selectedText = focusInfo.selectedText!.trim();
      
      if (selectedText.isEmpty) {
        print('–í—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –ø—É—Å—Ç');
        return;
      }
      
      // 2. –ö–æ–ø–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
      await _copyToClipboard(selectedText);
      
      // 3.1 –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç —Å—Å—ã–ª–∫–æ–π
      if (_isWebUrl(selectedText)) {
        // 3.2 –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É –≤ —Ç–µ–∫—É—â–µ–º –∫–ª–∞—Å—Å–µ
        _onUrlDropped(selectedText);
        return; // –ù–µ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–æ —á–∞—Ç–∞ –¥–ª—è —Å—Å—ã–ª–æ–∫
      }
      
      // 3.1 –û—Ç–∫—Ä—ã–≤–∞–µ–º –æ–∫–Ω–æ —á–∞—Ç–∞ –¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
      String clipboardText = selectedText;
      
      // –ï—Å–ª–∏ –æ–∫–Ω–æ —á–∞—Ç–∞ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç
      if (ProcessManager().hasProcess(chatProcessId)) {
        await _sendToServer(clipboardText);
        return;
      }
      
      // –û—Ç–∫—Ä—ã–≤–∞–µ–º –Ω–æ–≤–æ–µ –æ–∫–Ω–æ —á–∞—Ç–∞
      await _openChatWindowWithText(clipboardText, chatProcessId);
    }
    
  } catch (e) {
    print('Error in _copyVisibleAndOpenChatCopyCliplboardAsEntry: $e');
  }
}
static Future<void> _sendToServer(String data) async {
  try {
    final socket = await Socket.connect('localhost', 8080);
    // –Ø–≤–Ω–æ –∫–æ–¥–∏—Ä—É–µ–º –≤ UTF-8
    final encodedData = utf8.encode(data);
    socket.add(encodedData);
    await socket.flush();
    socket.destroy();
  } catch (e) {
    print('Error sending data: $e');
  }
}



// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –æ–∫–Ω–∞ —á–∞—Ç–∞ —Å —Ç–µ–∫—Å—Ç–æ–º
// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –æ–∫–Ω–∞ —á–∞—Ç–∞ —Å —Ç–µ–∫—Å—Ç–æ–º
Future<void> _openChatWindowWithText(String clipboardText, String chatProcessId) async {
  try {
    final pos = await windowManager.getPosition();
    final emptyChatHistory = '[]'; // –ü—É—Å—Ç–æ–π JSON

    // –ó–∞–ø—É—Å–∫ –¥–æ—á–µ—Ä–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ —á–∞—Ç–∞
    final process = await Process.start(
      Platform.resolvedExecutable,
      [
        'chat',
        emptyChatHistory,
        pos.dx.toString(),
        pos.dy.toString(),
      ],
    );

    ProcessManager().registerProcess(chatProcessId, process);
    _isChatOpen = true;

    // –°–ª—É—à–∞–µ–º stderr –ø—Ä–æ—Ü–µ—Å—Å–∞
    process.stderr.transform(utf8.decoder).listen((data) {
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –¥–æ—á–µ—Ä–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
    });

    // –ñ–¥–µ–º –ø–æ–∫–∞ —á–∞—Ç –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤ –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è (—Å —Ç–∞–π–º–∞—É—Ç–æ–º 5 —Å–µ–∫—É–Ω–¥)
    bool isReady = await _waitForChatReady(
      timeout: const Duration(seconds: 5),
      checkInterval: const Duration(milliseconds: 150),
    );

    

    if (isReady) {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –≤ –æ—Ç–∫—Ä—ã—Ç–æ–µ –æ–∫–Ω–æ
      _sendToServer(clipboardText);
    } else {
      print('Chat window failed to become ready within timeout');
      return;
    }

    // –¢–∞–π–º–µ—Ä –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
    Timer.periodic(const Duration(milliseconds: 25), (timer) async {
      if (!ProcessManager().hasProcess(chatProcessId)) {
        timer.cancel();
        return;
      }
      final currentPos = await windowManager.getPosition();
      final currentProc = ProcessManager().getProcess(chatProcessId);
      currentProc?.stdin.writeln('${currentPos.dx},${currentPos.dy}');
      await currentProc?.stdin.flush();
    });

    process.exitCode.then((code) {
      if (mounted) {
        setState(() {
          _isChatOpen = false;
        });
      }
      ProcessManager().killProcess(chatProcessId);
    });
    
  } catch (e) {
    print('Error opening chat window: $e');
    _isChatOpen = false;
  }
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ —á–∞—Ç–∞
Future<bool> _waitForChatReady({
  Duration timeout = const Duration(seconds: 5),
  Duration checkInterval = const Duration(milliseconds: 100),
}) async {
  final startTime = DateTime.now();
  
  while (DateTime.now().difference(startTime) < timeout) {
    if (_chatIsReadyToReceiveMessages) {
      return true;
    }
    await Future.delayed(checkInterval);
  }
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑ –ø–µ—Ä–µ–¥ –≤–æ–∑–≤—Ä–∞—Ç–æ–º false
  return _chatIsReadyToReceiveMessages;
}


// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
Future<void> _copyToClipboard(String text) async {
  try {
    await Clipboard.setData(ClipboardData(text: text));
  } catch (e) {
    print('Error copying to clipboard: $e');
  }
}


   void _showEssentialsViewer() async {


      const processId="essentials";

    if (ProcessManager().hasProcess(processId)) {
    ProcessManager().killProcess(processId);
    
    return;
  }


    final process =  
    await Process.start(
      Platform.resolvedExecutable,
      [
         'essentials',
      ],
      
    );

    ProcessManager().registerProcess(processId, process);
    


   
  }


    final List<Offset> _cursorHistory = [];
  Timer? _cursorHistoryTimer;
  DateTime _dragStartTime = DateTime.now();


   Offset _calculateRecentCursorVelocity() {
    if (_cursorHistory.length < 2) {
      // –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –∏–∑ details
      return Offset.zero;
    }

    // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 400 –º—Å)
    final recentPoints = _cursorHistory;
    
    if (recentPoints.length < 2) {
      return Offset.zero;
    }

    // –ü–µ—Ä–≤–∞—è –∏ –ø–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞ –≤ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º–æ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ (400 –º—Å)
    final firstPoint = recentPoints.first;
    final lastPoint = recentPoints.last;

    // –°–º–µ—â–µ–Ω–∏–µ –∑–∞ 400 –º—Å
    final dx = lastPoint.dx - firstPoint.dx;
    final dy = lastPoint.dy - firstPoint.dy;

    // –°–∫–æ—Ä–æ—Å—Ç—å = —Å–º–µ—â–µ–Ω–∏–µ / –≤—Ä–µ–º—è (–ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ø–∏–∫—Å–µ–ª–∏ –≤ —Å–µ–∫—É–Ω–¥—É)
    return Offset(dx / 0.4, dy / 0.4);
  }

  // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ç–æ—á–µ–∫ –¥–ª—è –±–æ–ª—å—à–µ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
  Offset _calculateSmoothCursorVelocity() {
    if (_cursorHistory.length < 5) {
      return Offset.zero;
    }

    // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 —Ç–æ—á–µ–∫ (–ø—Ä–∏–º–µ—Ä–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 80 –º—Å)
    final recentPoints = _cursorHistory.length >= 5 
        ? _cursorHistory.sublist(_cursorHistory.length - 5)
        : _cursorHistory;

    double totalDx = 0;
    double totalDy = 0;
    int count = 0;

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –º–µ–∂–¥—É —Å–æ—Å–µ–¥–Ω–∏–º–∏ —Ç–æ—á–∫–∞–º–∏
    for (int i = 1; i < recentPoints.length; i++) {
      final dx = recentPoints[i].dx - recentPoints[i-1].dx;
      final dy = recentPoints[i].dy - recentPoints[i-1].dy;
      totalDx += dx;
      totalDy += dy;
      count++;
    }

    if (count == 0) return Offset.zero;

    // –°—Ä–µ–¥–Ω—è—è —Å–∫–æ—Ä–æ—Å—Ç—å –∑–∞ –∫–∞–¥—Ä (16 –º—Å), –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Å–µ–∫—É–Ω–¥—É
    final avgDxPerFrame = totalDx / count;
    final avgDyPerFrame = totalDy / count;

    return Offset(avgDxPerFrame * 60, avgDyPerFrame * 60); // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ø–∏–∫—Å–µ–ª–∏/—Å–µ–∫—É–Ω–¥—É
  }


  void _cleanOldCursorHistory() {
    final now = DateTime.now();
    final cutoffTime = now.subtract(Duration(milliseconds: 400));
    
    // –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å–∏ —Å—Ç–∞—Ä—à–µ 400 –º—Å
    _cursorHistory.removeWhere((position) {
      // –ü–æ—Å–∫–æ–ª—å–∫—É –º—ã –Ω–µ —Ö—Ä–∞–Ω–∏–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–æ–∑–∏—Ü–∏–∏,
      // —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏, –æ—Å—Ç–∞–≤–ª—è—è —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—è 60 FPS)
      return _cursorHistory.indexOf(position) < _cursorHistory.length - 25; // ~400ms –ø—Ä–∏ 60 FPS
    });
  }

  
  void _onPanStart(DragStartDetails details) async {
    if (!_isAlive) return;
    
    _physicsTimer?.cancel();
    _isThrown = false;
    _velocity = Offset.zero;
    
    setState(() {
      _isDragging = true;
      _isFollowingCursor = false;
      _dragStartOffset = details.globalPosition;
      _mouseOverWidgetOrChat = true;
    });
    
    _animationTimer1?.cancel();
    _animationTimer1 = null;
    
    // –û—á–∏—â–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –∫—É—Ä—Å–æ—Ä–∞ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –∂–µ—Å—Ç–∞
    _cursorHistory.clear();
    _dragStartTime = DateTime.now();
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è —Å–±–æ—Ä–∞ –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ–∑–∏—Ü–∏–π –∫—É—Ä—Å–æ—Ä–∞
    _cursorHistoryTimer = Timer.periodic(Duration(milliseconds: 16), (timer) {
      if (!_isDragging) {
        timer.cancel();
        return;
      }
      _cleanOldCursorHistory();
    });

    Offset? last_cursor_pos = await _getCursorPosition();

    _animationTimer1 = Timer.periodic(Duration(milliseconds: 16), (timer) async {
      Offset? cursorPos = await _getCursorPosition();
      if (cursorPos == null && last_cursor_pos != null) {
        cursorPos = last_cursor_pos;
      }
      if (last_cursor_pos == null) {
        return;
      }
      last_cursor_pos = cursorPos;
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é
      _cursorHistory.add(cursorPos!);
      _cleanOldCursorHistory();
      
      final targetPos = Offset(
        cursorPos.dx - 110, // –°–º–µ—â–µ–Ω–∏–µ –ø–æ X
        cursorPos.dy - 160, // –°–º–µ—â–µ–Ω–∏–µ –ø–æ Y
      );
      
      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é –æ–∫–Ω–∞
      final currentPos = await windowManager.getPosition();

      // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é —Å –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π
      final newX = currentPos.dx + (targetPos.dx - currentPos.dx) * 0.1;
      final newY = currentPos.dy + (targetPos.dy - currentPos.dy) * 0.1;
      
      final newPos = Offset(newX, newY);
      
      setState(() {
        _position = newPos;
      });
      
      windowManager.setPosition(newPos);
    });
  }
  Timer? _animationTimer1;

void _onPanUpdate(DragUpdateDetails details) async {
  // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä, –µ—Å–ª–∏ –æ–Ω –∞–∫—Ç–∏–≤–µ–Ω
 return;
}
void _onPanEnd(DragEndDetails details) async {
    if (!_isDragging) return;

    _animationTimer1?.cancel();
    _animationTimer1 = null;
    _cursorHistoryTimer?.cancel();
    _cursorHistoryTimer = null;

    Offset? cursorPos = await _getCursorPosition();
    if (cursorPos == null) {
      cursorPos = await windowManager.getPosition();
    }
    final startPosition = _dragStartOffset;
    double distance = (cursorPos! - startPosition).distance;
    
    // –†–ê–°–ß–ï–¢ –°–ö–û–†–û–°–¢–ò –ù–ê –û–°–ù–û–í–ï –ü–û–°–õ–ï–î–ù–ò–• 400 –ú–° –ö–£–†–°–û–†–ê
    final velocity = _calculateRecentCursorVelocity();
    
    setState(() {
      _isDragging = false;
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
      final scaledVelocity = Offset(
        velocity.dx / 30, 
        velocity.dy / 30
      );
      _velocity = Offset(
        scaledVelocity.dx.clamp(-21.0, 21.0),
        scaledVelocity.dy.clamp(-17.0, 17.0)
      );
      
      _isThrown = _velocity.distance > 2.0;
      
      // –ò—Å–ø—Ä–∞–≤–ª—è–µ–º —Ñ–æ—Ä–º—É–ª—ã —Å—á–∞—Å—Ç—å—è –∏ –≥–æ–ª–æ–¥–∞
      _happiness = (_happiness + (_velocity.distance / 10)).clamp(0, 100).toDouble();
      _hunger = (_hunger + (_velocity.distance / 14)).clamp(0, 100).toDouble();
      
      _idleOffset = 0;
    });

    if (_isThrown) {
      _startAnimation('walk');
      _startPhysicsEngine();
    } else {
      windowManager.getPosition().then((position) {
        setState(() {
          _userSetPosition = position;
          _userHasSetPosition = true;
        });
        _saveData();
        
        // –§–∏–∫—Å–∏—Ä—É–µ–º –≤–∏–¥–∂–µ—Ç –Ω–∞ –≤—ã—Å–æ—Ç–µ 150px –æ—Ç –Ω–∏–∂–Ω–µ–≥–æ –∫—Ä–∞—è —ç–∫—Ä–∞–Ω–∞
        final targetY = _screenHeight - _windowHeight;
        _returnToUserPosition();
      });
    }
    
    // –û—á–∏—â–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    _cursorHistory.clear();
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥—Ä–∞–≥-–Ω-–¥—Ä–æ–ø–∞ —Ñ–∞–π–ª–æ–≤
  void _handleFileDrag() {
    if (!_isAlive || _isChatOpen)  return;
    
    _startAnimation('catch');
    
    // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∫ –∫—É—Ä—Å–æ—Ä—É
    _moveToCursor();
  }

  void _moveToCursor() async {
  final initialPos = await windowManager.getPosition();
  Timer? timer;
  DateTime? startTime;
  
  timer = Timer.periodic(Duration(milliseconds: 16), (timer) async {
    final cursorPos = await _getCursorPosition();
    if (cursorPos == null) {
      timer.cancel();
      return;
    }
    
    startTime ??= DateTime.now();
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –∫—É—Ä—Å–æ—Ä—É –æ—Ç –Ω–∞—á–∞–ª—å–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
    final directionX = cursorPos.dx - _windowWidth / 2 - initialPos.dx;
    final directionY = max(cursorPos.dy - 150, 0.0) - initialPos.dy;
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –∫—É—Ä—Å–æ—Ä–∞
    final distance = sqrt(directionX * directionX + directionY * directionY);
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ 100 –ø–∏–∫—Å–µ–ª—è–º–∏
    final limitedDistance = min(distance, 45.0);
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–µ—Å–ª–∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –Ω–µ –Ω—É–ª–µ–≤–æ–µ)
    final normalizedX = distance > 0 ? directionX / distance : 0.0;
    final normalizedY = distance > 0 ? directionY / distance : 0.0;
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–ª–µ–≤—É—é –ø–æ–∑–∏—Ü–∏—é (–Ω–µ –¥–∞–ª—å—à–µ 100 –ø–∏–∫—Å–µ–ª–µ–π –æ—Ç –Ω–∞—á–∞–ª—å–Ω–æ–π)
    final targetX = initialPos.dx + normalizedX * limitedDistance;
    final targetY = initialPos.dy + normalizedY * limitedDistance;
    
    // –ê–Ω–∏–º–∞—Ü–∏—è —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é ~100px –∑–∞ 750ms
    final elapsed = DateTime.now().difference(startTime!).inMilliseconds;
    final progress = min(elapsed / 750.0, 1.0);
    final eased = Curves.easeInOut.transform(progress);
    
    // –¢–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –æ–∫–Ω–∞
    final currentPos = await windowManager.getPosition();
    
    // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–ª–µ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
    final newX = currentPos.dx + (targetX - currentPos.dx) * 0.015; // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
    final newY = currentPos.dy + (targetY - currentPos.dy) * 0.015;
    
    windowManager.setPosition(Offset(newX, newY));
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã –±–µ–∑–¥–µ–π—Å—Ç–≤–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    if ((elapsed > 7000 && progress >= 1.0)||_isDragging==false) {
      timer.cancel();
    }
  });
  
  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ (–º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –∏–∑–≤–Ω–µ)
  // _stopAnimation() => timer?.cancel();
}

void _returnToUserPosition() async {
  final currentPos = await windowManager.getPosition();
  Timer? timer;
  DateTime? startTime;
  
  timer = Timer.periodic(Duration(milliseconds: 16), (timer) async {
    startTime ??= DateTime.now();
    

    // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–ª–µ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –¥–ª—è —ç—Ç–æ–≥–æ –∫–∞–¥—Ä–∞ (–Ω–µ –¥–∞–ª—å—à–µ 100 –ø–∏–∫—Å–µ–ª–µ–π)
    final targetX = _userSetPosition.dx;
    final targetY = _userSetPosition.dy;
    
    // –ê–Ω–∏–º–∞—Ü–∏—è —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é ~100px –∑–∞ 750ms
    final elapsed = DateTime.now().difference(startTime!).inMilliseconds;
    final progress = min(elapsed / 750.0, 1.0);
    final eased = Curves.easeInOut.transform(progress);
    
    // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–ª–µ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
    final newX = currentPos.dx + (targetX - currentPos.dx) * 0.2 +3; // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
    final newY = currentPos.dy + (targetY - currentPos.dy) * 0.2 +3;
    
    windowManager.setPosition(Offset(newX, newY));
   
    
 // Then in your code:
    if (((targetX-newX).abs() < 30 && (targetY-newY).abs() < 30)||elapsed>1200||_isDragging) {
      windowManager.setPosition(_userSetPosition); // –¢–æ—á–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ–∑–∏—Ü–∏–∏
      timer.cancel();
      return;
    }
    
  });
}

Future<Offset?> _getCursorPosition() async {
  try {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º screen_retriever –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
    final cursorInfo = await screenRetriever.getCursorScreenPoint();
    return Offset(cursorInfo.dx, cursorInfo.dy);
  } catch (e) {
    print('Error getting cursor position: $e');
    return null;
  }
}

  Widget _buildStatusBars() {

    bool should_show = (!_currentPhrase.isEmpty && _currentPhrase!="");
    return AnimatedOpacity(
      opacity: (_showStatus||should_show) ? 1.0 : 0.0,
      duration: Duration(milliseconds: 300),
      child: Container(
        padding: EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.8),
          borderRadius: BorderRadius.circular(10),
        ),
        child: Column(
          children: [
            if (_currentPhrase.isNotEmpty && _currentPhrase!="")
              Text(
                _currentPhrase,
                style: TextStyle(color: Colors.white, fontSize: 12),
              )
            else
              Column(
                children: [
                  Text('Lv.$_level $_petName', style: TextStyle(color: Colors.white)),
                  _buildStatusBar('–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ', _happiness, Colors.green),
                  _buildStatusBar('–°—ã—Ç–æ—Å—Ç—å', 100 - _hunger, Colors.orange),
                ],
              ),
          ],
        ),
      ),
    );
  }
  Future<void> getFocus() async {
      await windowManager.focus();
      const channel = MethodChannel('screenshot_channel');
      //final result = await channel.invokeMethod('getFocus');
      
  }

  void _test_to_build(){
    return;
  }


  
Widget _buildInteractiveWidget() {
  return Positioned.fill(

      child: Stack(
        children: [
          // –û—Å–Ω–æ–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å - –ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –¥–ª—è –∫–ª–∏–∫–æ–≤ –û–°
             Positioned.fill(
            child: IgnorePointer(
              child: Container(
                color: Colors.transparent,
              ),
            ),
          ),
          
          // –û–±–ª–∞—Å—Ç—å –ø–∏—Ç–æ–º—Ü–∞ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π —Å–æ–±—ã—Ç–∏–π
          Positioned(
            left: 0,
            top: 0,
            width: _windowWidth,
            height: _windowHeight,
            child: Container(
              width: _windowWidth,
              height: _windowHeight,
              key: _petKey, 
              child: Stack(
                children: [
                  Positioned(
                    bottom: 0, 
                    left: (_windowWidth - 80) / 2, 
                    child: _buildPet(),
                  ),
                  Positioned(
                    bottom: 120,
                    left: 0,
                    right: 0,
                    child: Center(child: _buildStatusBars()),
                  ),
                ],
              ),
            ),
          ),

          if (_showRecentFiles)
            Positioned(
              left: 0,
              top: 15,
              child: _buildRecentFilesOverlay(),
            ),
        ],
      ),
    
  );
}
Widget _buildPet() {
  // –°–æ–∑–¥–∞–µ–º –æ–±—â–∏–π GestureDetector –¥–ª—è –≤—Å–µ—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π
  final gestureDetector = GestureDetector(
    behavior: HitTestBehavior.opaque,
    onTap: _onTap,
    onDoubleTap: _onDoubleTap,
    onLongPressStart: (details) {
      _startLongPressTimer(details.globalPosition);
    },
    onLongPressEnd: (details) {
      _cancelLongPressTimer();
    },
    onLongPressCancel: _cancelLongPressTimer,
    onPanStart: (DragStartDetails details) => _onPanStart(details),
    onPanUpdate: (DragUpdateDetails details) => _onPanUpdate(details),
    onPanEnd: (DragEndDetails details) => _onPanEnd(details),
    child: _buildPetContent(),
  );

  return     Listener(
      onPointerDown: (PointerDownEvent evt) {
        if (evt.kind == PointerDeviceKind.mouse && evt.buttons == kSecondaryMouseButton) {
          _showContextMenuAtPosition();
        }
      },child: MouseRegion(
    onEnter: (event) async {
      if (Platform.isWindows) {
        await windowManager.setIgnoreMouseEvents(false);
      }
      await getFocus();
      if (!_isMovingWindow && !_isAnimatingDrop) {
        setState(() {
          _showStatus = true;
          _opacity = 1.0;
          _isHoveringPet=true;
        });
      }
      _startHoverTimer();
      _mouseOverWidgetOrChat = true;
      _lastCursorMove = DateTime.now();
      
      // –ü—Ä–µ—Ä—ã–≤–∞–µ–º idle –∞–Ω–∏–º–∞—Ü–∏—é –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
      if (_currentAnimation == 'idle') {
        _startAnimation('idle'); // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
      }
    },
    onExit: (event) {

         if (Platform.isWindows && !_isHoveringRecentFiles && !_contextMenuOpen) {
        windowManager.setIgnoreMouseEvents(false);
      }

      if (!_isMovingWindow && !_isAnimatingDrop) {
        setState(() {
          _showStatus = false;
          _opacity = 0.0;
          _isHoveringPet=false;
        });
      }
      _cancelHoverTimer();
      _mouseOverWidgetOrChat = false;
    },
    onHover: (event) {
      _lastCursorMove = DateTime.now();
    },
    child: gestureDetector,
  ),);
}

Widget _buildPetContent() {
  if (!_isAlive) {
    return Icon(Icons.cancel, size: 60, color: Colors.red);
  }

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∏—Å—Ç–µ–º—É –∞–Ω–∏–º–∞—Ü–∏–π
  if (_animations[_currentAnimation] != null && _animations[_currentAnimation]!.isNotEmpty) {
    final currentFrame = _animations[_currentAnimation]![_currentFrameIndex];
    return Image.file(
      File(currentFrame.imagePath),
      width: 110,
      height: 100,
      fit: BoxFit.contain,
    );
  }

  // Fallback –Ω–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
  return Image.asset(
    _isMusicPlaying ? 'assets/images/2.png' : 'assets/images/main_template.png',
    width: 80,
    height: 80,
    fit: BoxFit.contain,
  );
}


  void _animateWindowToPosition(Offset targetPosition) {
    _setMovingState(true);
    _isAnimatingDrop = true;
    
    windowManager.getPosition().then((startPos) {
      final startX = startPos.dx;
      final startY = startPos.dy;
      final duration = Duration(milliseconds: 500);
      final startTime = DateTime.now();

      Timer.periodic(Duration(milliseconds: 16), (timer) async {
        final t = DateTime.now().difference(startTime).inMilliseconds / duration.inMilliseconds;
        final eased = Curves.easeOut.transform(min(1.0, t));
        
        double curX = startX + (targetPosition.dx - startX) * eased;
        double curY = startY + (targetPosition.dy - startY) * eased;
        
        curX = curX.clamp(0.0, _screenWidth - _windowWidth);
        curY = curY.clamp(0.0, _screenHeight - _windowHeight);
        
        await windowManager.setPosition(Offset(curX, curY));
        
        if (t >= 1.0) {
          timer.cancel();
          _isAnimatingDrop = false;
          _setMovingState(false);
          setState(() {
            _userSetPosition = Offset(curX, curY);
            _userHasSetPosition = true;
          });
          _saveData();
        }
      });
    });
  }
  void _revealInExplorer(EatenFile filePath) async {
    try {
      if (Platform.isWindows) {
        await Process.run('explorer', ['/select,', filePath.path]);
      } else if (Platform.isMacOS) {
        await Process.run('open', ['-R', filePath.path]);
      } else if (Platform.isLinux) {
        final dir = path.dirname(filePath.path);
        await Process.run('xdg-open', [dir]);
      }
    } catch (e) {
      debugPrint('Error revealing file: $e');
    }
  }

  void _setMovingState(bool val) {
    if (_isMovingWindow == val) return;
    setState(() => _isMovingWindow = val);
  }

  void _startHoverTimer() {
    _hoverTimer?.cancel();
    _hoverTimer = Timer(Duration(milliseconds: 1500), () {
      if (mounted && !_isHoveringRecentFiles && !_contextMenuOpen && !_chatOverlayVisible) {
        setState(() => _showRecentFiles = true);
        _isFollowingCursor = false;
      }
    });
  }

  void _cancelHoverTimer() {
    _hoverTimer?.cancel();
    if (mounted && !_isHoveringRecentFiles) {
      setState(() => _showRecentFiles = false);
      if (!_contextMenuOpen && !_chatOverlayVisible) {
        _isFollowingCursor = false;
      }
    }
  }

  
Future<void> _startServer() async {
  final server = await ServerSocket.bind('localhost', 8081);
  print('Server listening on port 8080');

  server.listen((Socket socket) {
    final List<int> dataBuffer = [];
    
    socket.listen(
      (List<int> data) {
        dataBuffer.addAll(data);
      },
      onDone: () {
        // –î–µ–∫–æ–¥–∏—Ä—É–µ–º –≤—Å–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ UTF-8
        final String receivedString = utf8.decode(dataBuffer);
         // –ï—Å–ª–∏ –æ–∫–Ω–æ —á–∞—Ç–∞ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç

         
      if (ProcessManager().hasProcess("chat_window")) {
         _sendToServer(receivedString);
        return;
      }
      
      // –û—Ç–∫—Ä—ã–≤–∞–µ–º –Ω–æ–≤–æ–µ –æ–∫–Ω–æ —á–∞—Ç–∞
       
        _openChatWindowWithText(receivedString,"chat_window");
      },
      onError: (error) {
        print('Socket error: $error');
      }
    );
  });
}


Future<void> _startServer2() async {
  final server = await ServerSocket.bind('localhost', 8082);
  print('Server listening on port 8080');

  server.listen((Socket socket) {
    final List<int> dataBuffer = [];
    
    socket.listen(
      (List<int> data) {
        dataBuffer.addAll(data);
      },
      onDone: () {
        // –î–µ–∫–æ–¥–∏—Ä—É–µ–º –≤—Å–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ UTF-8
        final String receivedString = utf8.decode(dataBuffer);
         // –ï—Å–ª–∏ –æ–∫–Ω–æ —á–∞—Ç–∞ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç
        if (receivedString=="chat is ready"){
        setState(() {
          _chatIsReadyToReceiveMessages = true;
        });

        }
         
      },
      onError: (error) {
        print('Socket error: $error');
      }
    );
  });
}



Widget _buildRecentFilesOverlay() {
  if (!_showRecentFiles) return SizedBox.shrink();

// –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ–∞–π–ª—ã: —Å–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–æ–π, –∑–∞—Ç–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –æ—Ç–∫—Ä—ã—Ç–∏–π, –∑–∞—Ç–µ–º –ø–æ –¥–∞–≤–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è
final sortedFiles = _files.toList()
  ..sort((a, b) {
    // 1. –°–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–æ–π
    if (a.isStarred && !b.isStarred) return -1;
    if (!a.isStarred && b.isStarred) return 1;
    
    // 2. –ó–∞—Ç–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –æ—Ç–∫—Ä—ã—Ç–∏–π (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)
    final openCountComparison = b.openCount.compareTo(a.openCount);
    if (openCountComparison != 0) return openCountComparison;
    
    // 3. –ó–∞—Ç–µ–º –ø–æ –¥–∞–≤–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è (—Å–Ω–∞—á–∞–ª–∞ –Ω–µ–¥–∞–≤–Ω–æ –æ—Ç–∫—Ä—ã—Ç—ã–µ)
    if (a.lastOpened != null && b.lastOpened != null) {
      return b.lastOpened!.compareTo(a.lastOpened!);
    }
    if (a.lastOpened != null) return -1;
    if (b.lastOpened != null) return 1;
    
    return 0;
  });
  return MouseRegion(
    onEnter: (_) {
      setState(() => _isHoveringRecentFiles = true);
    

    },
    onExit: (_) {
      setState(() => _isHoveringRecentFiles = false);
      if (!_contextMenuOpen && !_chatOverlayVisible) {
        _isFollowingCursor = false;
      }
       if (Platform.isWindows && !_isHoveringRecentFiles && !_contextMenuOpen) {
        windowManager.setIgnoreMouseEvents(false);
      }
    },
    child: Container(
      width: _windowWidth - 15,
      height: _windowHeight - 15,
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.9),
        borderRadius: BorderRadius.circular(12),
      ),
      child: ScrollConfiguration(
        behavior: ScrollConfiguration.of(context).copyWith(
          scrollbars: true,
          dragDevices: {
            PointerDeviceKind.touch,
            PointerDeviceKind.mouse,
          },
        ),
        child: GridView.builder(
          padding: EdgeInsets.all(6),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3,
            crossAxisSpacing: 4,
            mainAxisSpacing: 4,
            childAspectRatio: 1,
          ),
          itemCount: sortedFiles.isEmpty ? 1 : sortedFiles.length,
          itemBuilder: (context, index) {
            if (sortedFiles.isEmpty) {
              return Container(
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(6),
                ),
                child: Icon(Icons.folder_open, color: Colors.white54, size: 24),
              );
            }

            final file = sortedFiles[index];
            final displayName = file.isWeb? file.pageTitle : _getDisplayFileName(file);
            
            // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞–ø–∫—É
            bool isDirectory = false;
            if (!file.isWeb) {
              try {
                final dir = Directory(file.path);
                isDirectory = dir.existsSync();
              } catch (e) {
                isDirectory = false;
              }
            }
            
            return MouseRegion(
              onEnter: (_) => _showFileTooltip(displayName),
              child: GestureDetector(
                onTap: () {
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _openWebUrl(file);
                  } else if (isDirectory) {
                    _openFile(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _openFile(file);
                  }
                  _incrementOpenCount(file);
                  _isFollowingCursor = false;
                },
                onLongPress: () {
                  setState(() {
                    _showRecentFiles = false;
                    _isHoveringRecentFiles = false;
                  });
                  if (file.isWeb) {
                    _searchWebTitle(file);
                  } else if (isDirectory) {
                    _revealInExplorer(file); // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
                  } else {
                    _revealInExplorer(file);
                  }
                  _isFollowingCursor = false;
                },
                
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(6),
                    border: Border.all(
                      color: file.isStarred ? Colors.yellow.withOpacity(0.5) : Colors.white.withOpacity(0.2), 
                      width: file.isStarred ? 2 : 1
                    ),
                  ),
                  child: Stack(
                    children: [
                      // –î–ª—è –ø–∞–ø–æ–∫
                      if (isDirectory)
                        Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(
                                Icons.folder,
                                size: 40,
                                color: Colors.green.shade300,
                              ),
                              SizedBox(height: 4),
                              Text(
                                displayName.length > 15 ? '${displayName.substring(0, 15)}...' : displayName,
                                style: TextStyle(
                                  color: Colors.green.shade300,
                                  fontSize: 9,
                                  fontWeight: file.isStarred ? FontWeight.bold : FontWeight.normal,
                                ),
                                textAlign: TextAlign.center,
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ],
                          ),
                        )
                      // –î–ª—è web-—Ñ–∞–π–ª–æ–≤
                      else if (file.isWeb)
                        Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              if (file.iconBytes != null)
                                Image.memory(
                                  file.iconBytes!,
                                  width: 40,
                                  height: 40,
                                  fit: BoxFit.contain,
                                )
                              else
                                Icon(
                                  Icons.language,
                                  size: 40,
                                  color: Colors.blue,
                                ),
                              SizedBox(height: 4),
                              Text(
                                displayName.length > 15 ? '${displayName.substring(0, 15)}...' : displayName,
                                style: TextStyle(
                                  color: Colors.blue,
                                  fontSize: 9,
                                  fontWeight: file.isStarred ? FontWeight.bold : FontWeight.normal,
                                ),
                                textAlign: TextAlign.center,
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ],
                          ),
                        )
                      // –î–ª—è –æ–±—ã—á–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                      else
                        Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
                            if (_isImageFile(displayName))
                              ClipRRect(
                                borderRadius: BorderRadius.circular(4),
                                child: Image.file(
                                  File(file.path),
                                  width: 40,
                                  height: 40,
                                  fit: BoxFit.cover,
                                  errorBuilder: (context, error, stackTrace) {
                                    return Icon(
                                      Icons.insert_drive_file,
                                      size: 40,
                                      color: Colors.white,
                                    );
                                  },
                                ),
                              )
                            else if (file.iconBytes != null)
                              Image.memory(
                                file.iconBytes!,
                                width: 40,
                                height: 40,
                                fit: BoxFit.contain,
                              )
                            else
                              Icon(
                                Icons.insert_drive_file,
                                size: 40,
                                color: Colors.white,
                              ),
                            SizedBox(height: 4),
                            Text(
                              displayName.length > 15 ? '${displayName.substring(0, 15)}...' : displayName,
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 9,
                                fontWeight: file.isStarred ? FontWeight.bold : FontWeight.normal,
                              ),
                              textAlign: TextAlign.center,
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ],
                        ),
                      if (file.isStarred)
                        Positioned(
                          top: 2,
                          right: 2,
                          child: Icon(
                            Icons.star,
                            color: Colors.yellow,
                            size: 12,
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            );
          },
        ),
      ),
    ),
  );
}
// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
bool _isImageFile(String fileName) {

  return fileName.endsWith('.jpg') || 
         fileName.endsWith('.jpeg') ||
         fileName.endsWith('.png') ||
         fileName.endsWith('.gif') ||
         fileName.endsWith('.bmp') ||
         fileName.endsWith('.webp') ||
         fileName.endsWith('.svg');
}

// –í–∏–¥–∂–µ—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–µ–≤—å—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
Widget _buildImagePreview(String filePath) {
  try {
    return Container(
      width: 40,
      height: 40,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(4),
        child: Image.file(
          File(filePath),
          fit: BoxFit.cover,
          width: 40,
          height: 40,
          errorBuilder: (context, error, stackTrace) {
            // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –∏–∫–æ–Ω–∫—É
            return Icon(
              Icons.insert_drive_file, 
              size: 40, 
              color: Colors.white
            );
          },
        ),
      ),
    );
  } catch (e) {
    // –ü—Ä–∏ –æ—à–∏–±–∫–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –∏–∫–æ–Ω–∫—É —Ñ–∞–π–ª–∞
    return Icon(
      Icons.insert_drive_file, 
      size: 40, 
      color: Colors.white
    );
  }
}

// –ú–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–≥–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
String _getDisplayFileName(dynamic file) {
  return file.isWeb ? _getDomainName(file.path) : path.basename(file.path);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è File –æ–±—ä–µ–∫—Ç–∞
Future<File> _getImageFile(String filePath) async {
  return File(filePath);
}


// –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –≤ –∫–ª–∞—Å—Å:




Future<void> _openWebUrl(EatenFile url) async {
  String formattedUrl = url.path.trim();
  if (!formattedUrl.startsWith('http')) {
    formattedUrl = 'https://$formattedUrl';
  }
  
  if (await canLaunch(formattedUrl)) {
    await launch(formattedUrl);
  } else {
    debugPrint('Cannot launch URL: $formattedUrl');
  }
}

Future<void> _searchWebTitle(EatenFile url) async {
  final searchUrl = 'https://www.google.com/search?q=${Uri.encodeComponent(url.path)}';
  if (await canLaunch(searchUrl)) {
    await launch(searchUrl);
  }
}

// –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —É –≤–∞—Å –µ—Å—Ç—å –∏–º–ø–æ—Ä—Ç –¥–ª—è url_launcher:
// import 'package:url_launcher/url_launcher.dart';

  Future<Uint8List?> _getFileIcon (EatenFile fileName) async {
    const MethodChannel _fileIconChannel = MethodChannel('screenshot_channel');
    try {
    final result = await _fileIconChannel.invokeMethod('getFileIcon', fileName.path);
    return result as Uint8List?;
  } catch (e) {
    print('Error getting file icon: $e');
    return null;
  }
  }

  void _showFileTooltip(String fileName) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(fileName),
        duration: Duration(seconds: 2),
        backgroundColor: Colors.black.withOpacity(0.8),
        behavior: SnackBarBehavior.floating,
        margin: EdgeInsets.only(bottom: 100, left: 20, right: 20),
      ),
    );
  }



@override
Widget build(BuildContext context) {
  return RepaintBoundary(
    key: _screenshotKey,
    child: RawKeyboardListener(
      focusNode: FocusNode(),
      autofocus: true,
      onKey: (event) {
        // –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏—è –∫–µ–π–ª–æ–≥–≥–µ—Ä—É
        _keyboardLogger.handleKeyEvent(event);
      },
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            Positioned.fill(
              child: DropTarget(
                onDragEntered: (detail) {
                  setState(() {
                    _isFollowingCursor = true;
                  });
                },
                onDragExited: (detail) {
                  setState(() {
                    _isFollowingCursor = false;
                    if (_userHasSetPosition) {
                     // _animateWindowToPosition(_userSetPosition);
                    }
                  });
                },
                onDragDone: (detail) {
                  final paths = <String>[];
                  try {
                    for (final f in detail.files) {
                      if (f.path != null && f.path.isNotEmpty) paths.add(f.path);
                    }
                  } catch (e) {}
                  if (paths.isNotEmpty) _onFileDropped(paths);
                  
                  setState(() {
                    _isFollowingCursor = false;
                    if (_userHasSetPosition) {
                     // _animateWindowToPosition(_userSetPosition);
                    }
                  });
                },
                child: Stack(
                  children: [
                    // –û—Å–Ω–æ–≤–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç —Å–æ–±—ã—Ç–∏—è, –∫—Ä–æ–º–µ —Å–ª—É—á–∞–µ–≤ –∫–æ–≥–¥–∞ –æ—Ç–∫—Ä—ã—Ç–æ –º–µ–Ω—é
                    Positioned.fill(
                      child: IgnorePointer(
                        ignoring: true, // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–±—ã—Ç–∏—è —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –º–µ–Ω—é –æ—Ç–∫—Ä—ã—Ç–æ –∏–ª–∏ —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞
                        child: Container(color: Colors.transparent),
                      ),
                    ),
                    // InteractiveWidget - –≤—Å–µ–≥–¥–∞ –∫–ª–∏–∫–∞–±–µ–ª–µ–Ω
                    _buildInteractiveWidget(),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    ),
  );
}



// –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ –º–µ—Ç–æ–¥—ã –≤ –≤–∞—à –æ—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å
void _handleFileTap(dynamic file, bool isDirectory) {
  setState(() {
    _showRecentFiles = false;
    _isHoveringRecentFiles = false;
  });
  if (file.isWeb) {
    _openWebUrl(file);
  } else if (isDirectory) {
    _openFile(file);
  } else {
    _openFile(file);
  }
  _incrementOpenCount(file);
  _isFollowingCursor = false;
}

void _handleFileLongPress(dynamic file, bool isDirectory) {
  setState(() {
    _showRecentFiles = false;
    _isHoveringRecentFiles = false;
  });
  if (file.isWeb) {
    _searchWebTitle(file);
  } else if (isDirectory) {
    _revealInExplorer(file);
  } else {
    _revealInExplorer(file);
  }
  _isFollowingCursor = false;
}
@override
void dispose() {
  // –û—Ç–º–µ–Ω–∞ –≤—Å–µ—Ö —Ç–∞–π–º–µ—Ä–æ–≤3
   _phraseTimer?.cancel();
    _smtc.dispose();
  _clipboardTimer?.cancel();
  _longPressTimer?.cancel();
  _dayTimer?.cancel();
  _musicCheckTimer?.cancel();
  _stateTimer?.cancel();
  _movementTimer?.cancel();
  _hoverTimer?.cancel();
  _idleTimer?.cancel();
  _physicsTimer?.cancel();
  _animationTimer?.cancel();
  FileDragDropService.dispose(); // –í–∞–∂–Ω–æ: –æ—Ç–∫–ª—é—á–∞–µ–º –ª–∏—Å—Ç–µ–Ω–µ—Ä
  // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
  stopMonitoring();
  
  // –ó–∞–∫—Ä—ã—Ç–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
  ProcessManager().killAllProcesses();
  _chatProcess?.kill();
  
  // –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–µ—Ç–µ–≤—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
  _httpClient.close();
  
  // –£–¥–∞–ª–µ–Ω–∏–µ –æ–≤–µ—Ä–ª–µ–µ–≤
  _removeContextMenu();
  _removeChatOverlay();
  _submenuOverlay?.remove();
  _fileViewerOverlay?.remove();
  
  // –û—Ç–ø–∏—Å–∫–∞ –æ—Ç —Å–ª—É—à–∞—Ç–µ–ª–µ–π
  windowManager.removeListener(this);
  _keyboardLogger.dispose();
  
  // –û—á–∏—Å—Ç–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤
  _promptController.dispose();
  _hotkeyService.dispose();
  
  super.dispose();
}
 // –£–¥–∞–ª–∏—Ç–µ –º–µ—Ç–æ–¥ _windowListener –∏ –¥–æ–±–∞–≤—å—Ç–µ –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ:
  @override
  void onWindowMove() async {
    if (_isChatOpen) {
      final pos = await windowManager.getPosition();
      final size = await windowManager.getSize();
      
      // TODO: –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –ø—Ä–æ—Ü–µ—Å—Å—É —á–∞—Ç–∞ —á–µ—Ä–µ–∑ IPC
      // –ù–∞–ø—Ä–∏–º–µ—Ä, —á–µ—Ä–µ–∑ named pipe, socket –∏–ª–∏ platform channel
      _sendPositionToChat(pos, size);
    }
  }

  void _sendPositionToChat(Offset position, ui.Size size) async {
    try {
      // –ó–¥–µ—Å—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–∑–∏—Ü–∏–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å —á–∞—Ç–∞
      // –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —á–µ—Ä–µ–∑ platform channels, sockets –∏–ª–∏ –¥—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã IPC
      print('New position: $position, size: $size');
    } catch (e) {
      print('Error sending position to chat: $e');
    }
  }

  @override
  void onWindowClose() async => await windowManager.hide();
  @override
  void onWindowFocus() {}
  @override
  void onWindowBlur() {}
}



class _FileGridItem extends StatefulWidget {
  final dynamic file;
  final String displayName;
  final bool isDirectory;
  final VoidCallback onTap;
  final VoidCallback onLongPress;

  const _FileGridItem({
    required this.file,
    required this.displayName,
    required this.isDirectory,
    required this.onTap,
    required this.onLongPress,
  });

  @override
  State<_FileGridItem> createState() => _FileGridItemState();
}

class _FileGridItemState extends State<_FileGridItem> {
  Timer? _autoOpenTimer;

  @override
  void dispose() {
    _autoOpenTimer?.cancel();
    super.dispose();
  }

  void _startAutoOpenTimer() {
    _autoOpenTimer?.cancel();
    _autoOpenTimer = Timer(Duration(seconds: 4), () {
      widget.onTap();
    });
  }

  void _cancelAutoOpenTimer() {
    _autoOpenTimer?.cancel();
  }

 //—Å—é–¥–∞_–∫–æ–ø–∏–ø–∞—Å—Ç–∞

 // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
bool _isImageFile(String fileName) {

  return fileName.endsWith('.jpg') || 
         fileName.endsWith('.jpeg') ||
         fileName.endsWith('.png') ||
         fileName.endsWith('.gif') ||
         fileName.endsWith('.bmp') ||
         fileName.endsWith('.webp') ||
         fileName.endsWith('.svg');
}


  void _showFileTooltip(String fileName) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(fileName),
        duration: Duration(seconds: 2),
        backgroundColor: Colors.black.withOpacity(0.8),
        behavior: SnackBarBehavior.floating,
        margin: EdgeInsets.only(bottom: 100, left: 20, right: 20),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) {
        _showFileTooltip(widget.displayName);
        _startAutoOpenTimer();
      },
      onExit: (_) => _cancelAutoOpenTimer(),
      child: GestureDetector(
        onTap: () {
          _cancelAutoOpenTimer();
          widget.onTap();
        },
        onLongPress: () {
          _cancelAutoOpenTimer();
          widget.onLongPress();
        },
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.1),
            borderRadius: BorderRadius.circular(6),
            border: Border.all(
              color: widget.file.isStarred ? Colors.yellow.withOpacity(0.5) : Colors.white.withOpacity(0.2), 
              width: widget.file.isStarred ? 2 : 1
            ),
          ),
          child: Stack(
            children: [
              // –î–ª—è –ø–∞–ø–æ–∫
              if (widget.isDirectory)
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.folder,
                        size: 40,
                        color: Colors.green.shade300,
                      ),
                      SizedBox(height: 4),
                      Text(
                        widget.displayName.length > 15 ? '${widget.displayName.substring(0, 15)}...' : widget.displayName,
                        style: TextStyle(
                          color: Colors.green.shade300,
                          fontSize: 9,
                          fontWeight: widget.file.isStarred ? FontWeight.bold : FontWeight.normal,
                        ),
                        textAlign: TextAlign.center,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                )
              // –î–ª—è web-—Ñ–∞–π–ª–æ–≤
              else if (widget.file.isWeb)
                Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      if (widget.file.iconBytes != null)
                        Image.memory(
                          widget.file.iconBytes!,
                          width: 40,
                          height: 40,
                          fit: BoxFit.contain,
                        )
                      else
                        Icon(
                          Icons.language,
                          size: 40,
                          color: Colors.blue,
                        ),
                      SizedBox(height: 4),
                      Text(
                        widget.displayName.length > 15 ? '${widget.displayName.substring(0, 15)}...' : widget.displayName,
                        style: TextStyle(
                          color: Colors.blue,
                          fontSize: 9,
                          fontWeight: widget.file.isStarred ? FontWeight.bold : FontWeight.normal,
                        ),
                        textAlign: TextAlign.center,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                )
              // –î–ª—è –æ–±—ã—á–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
              else
                Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
                    if (_isImageFile(widget.displayName))
                      ClipRRect(
                        borderRadius: BorderRadius.circular(4),
                        child: Image.file(
                          File(widget.file.path),
                          width: 40,
                          height: 40,
                          fit: BoxFit.cover,
                          errorBuilder: (context, error, stackTrace) {
                            return Icon(
                              Icons.insert_drive_file,
                              size: 40,
                              color: Colors.white,
                            );
                          },
                        ),
                      )
                    else if (widget.file.iconBytes != null)
                      Image.memory(
                        widget.file.iconBytes!,
                        width: 40,
                        height: 40,
                        fit: BoxFit.contain,
                      )
                    else
                      Icon(
                        Icons.insert_drive_file,
                        size: 40,
                        color: Colors.white,
                      ),
                    SizedBox(height: 4),
                    Text(
                      widget.displayName.length > 15 ? '${widget.displayName.substring(0, 15)}...' : widget.displayName,
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 9,
                        fontWeight: widget.file.isStarred ? FontWeight.bold : FontWeight.normal,
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              if (widget.file.isStarred)
                Positioned(
                  top: 2,
                  right: 2,
                  child: Icon(
                    Icons.star,
                    color: Colors.yellow,
                    size: 12,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}



class WindowsFocusInfo {
  final bool isFileSelection;
  final bool isTextSelection;
  final String? selectedText;
  final String? selectedPath;
  final String? error;
  
  WindowsFocusInfo({
    required this.isFileSelection,
    required this.isTextSelection,
    this.selectedText,
    this.selectedPath,
    this.error,
  });
  
  factory WindowsFocusInfo.fromJson(String jsonString) {
    try {
      final Map<String, dynamic> map = json.decode(jsonString);
      return WindowsFocusInfo(
        isFileSelection: map['isFileSelection'] ?? false,
        isTextSelection: map['isTextSelection'] ?? false,
        selectedText: map['selectedText'],
        selectedPath: map['selectedPath'],
        error: map['error'],
      );
    } catch (e) {
      return WindowsFocusInfo(
        isFileSelection: false,
        isTextSelection: false,
        error: 'JSON parsing error: $e',
      );
    }
  }
  
  factory WindowsFocusInfo.fromMap(Map<String, dynamic> map) {
    return WindowsFocusInfo(
      isFileSelection: map['isFileSelection'] ?? false,
      isTextSelection: map['isTextSelection'] ?? false,
      selectedText: map['selectedText'],
      selectedPath: map['selectedPath'],
      error: map['error'],
    );
  }
  
  bool get hasError => error != null;
  bool get hasSelection => isFileSelection || isTextSelection;
}


// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∫–ª–∞—Å—Å—ã –∏ –º–µ—Ç–æ–¥—ã
class ImageInfo {
  final img.Image image;
  final int width;
  final int height;
  final bool isLandscape;
  final bool isPortrait;
  final double aspectRatio;

  ImageInfo({
    required this.image,
    required this.width,
    required this.height,
    required this.isLandscape,
    required this.isPortrait,
    required this.aspectRatio,
  });
}

class ImagePlacement {
  final img.Image image;
  final int x;
  final int y;
  final int width;
  final int height;

  ImagePlacement({
    required this.image,
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });
}

class CollageStrategy {
  final int canvasWidth;
  final int canvasHeight;
  final List<ImagePlacement> placements;

  CollageStrategy({
    required this.canvasWidth,
    required this.canvasHeight,
    required this.placements,
  });
}

CollageStrategy _createHorizontalRowStrategy(List<img.Image> images, int maxWidth, int maxHeight) {
  final placements = <ImagePlacement>[];
  int currentX = 0;
  int rowHeight = 0;
  
  // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –¥–ª—è —Ä—è–¥–∞
  for (final image in images) {
    rowHeight = rowHeight > image.height ? rowHeight : image.height;
  }
  
  // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –≤—ã—Å–æ—Ç—É –ø–æ–¥ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
  if (rowHeight > maxHeight) {
    rowHeight = maxHeight;
  }
  
  // –†–∞–∑–º–µ—â–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
  for (final image in images) {
    final scaleFactor = rowHeight / image.height;
    final scaledWidth = (image.width * scaleFactor).round();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–µ–≤—ã—Å–∏–ª–∏ –ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É
    if (currentX + scaledWidth > maxWidth) {
      // –ï—Å–ª–∏ –ø—Ä–µ–≤—ã—Å–∏–ª–∏, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ä—è–¥
      break;
    }
    
    placements.add(ImagePlacement(
      image: image,
      x: currentX,
      y: 0,
      width: scaledWidth,
      height: rowHeight,
    ));
    
    currentX += scaledWidth;
  }
  
  return CollageStrategy(
    canvasWidth: currentX,
    canvasHeight: rowHeight,
    placements: placements,
  );
}

CollageStrategy _createVerticalColumnStrategy(List<img.Image> images, int maxWidth, int maxHeight) {
  final placements = <ImagePlacement>[];
  int currentY = 0;
  int columnWidth = 0;
  
  // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É –¥–ª—è –∫–æ–ª–æ–Ω–∫–∏
  for (final image in images) {
    columnWidth = columnWidth > image.width ? columnWidth : image.width;
  }
  
  // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º —à–∏—Ä–∏–Ω—É –ø–æ–¥ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
  if (columnWidth > maxWidth) {
    columnWidth = maxWidth;
  }
  
  // –†–∞–∑–º–µ—â–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
  for (final image in images) {
    final scaleFactor = columnWidth / image.width;
    final scaledHeight = (image.height * scaleFactor).round();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–µ–≤—ã—Å–∏–ª–∏ –ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É
    if (currentY + scaledHeight > maxHeight) {
      break;
    }
    
    placements.add(ImagePlacement(
      image: image,
      x: 0,
      y: currentY,
      width: columnWidth,
      height: scaledHeight,
    ));
    
    currentY += scaledHeight;
  }
  
  return CollageStrategy(
    canvasWidth: columnWidth,
    canvasHeight: currentY,
    placements: placements,
  );
}

CollageStrategy _createAdaptiveGridStrategy(List<img.Image> images, int maxWidth, int maxHeight, bool isLandscape) {
  final placements = <ImagePlacement>[];
  
  if (images.length <= 3) {
    // –î–ª—è –º–∞–ª–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π - –ø—Ä–æ—Å—Ç–æ–π —Ä—è–¥ –∏–ª–∏ –∫–æ–ª–æ–Ω–∫–∞
    if (isLandscape) {
      return _createHorizontalRowStrategy(images, maxWidth, maxHeight);
    } else {
      return _createVerticalColumnStrategy(images, maxHeight, maxWidth);
    }
  }
  
  // –î–ª—è –±–æ–ª—å—à–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ - —Å–µ—Ç–∫–∞ 2xN
  int cols = 2;
  int rows = (images.length / cols).ceil();
  
  int cellWidth = (maxWidth / cols).round();
  int cellHeight = (maxHeight / rows).round();
  
  for (int i = 0; i < images.length; i++) {
    final image = images[i];
    final row = i ~/ cols;
    final col = i % cols;
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–π
    final double widthRatio = cellWidth / image.width;
    final double heightRatio = cellHeight / image.height;
    final double scale = widthRatio < heightRatio ? widthRatio : heightRatio;
    
    final scaledWidth = (image.width * scale).round();
    final scaledHeight = (image.height * scale).round();
    
    // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —è—á–µ–π–∫–µ
    final x = col * cellWidth + (cellWidth - scaledWidth) ~/ 2;
    final y = row * cellHeight + (cellHeight - scaledHeight) ~/ 2;
    
    placements.add(ImagePlacement(
      image: image,
      x: x,
      y: y,
      width: scaledWidth,
      height: scaledHeight,
    ));
  }
  
  return CollageStrategy(
    canvasWidth: maxWidth,
    canvasHeight: rows * cellHeight,
    placements: placements,
  );
}

CollageStrategy _createMixedOrientationStrategy(List<img.Image> images, int maxWidth, int maxHeight) {
  final placements = <ImagePlacement>[];
  
  // –†–∞–∑–¥–µ–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
  final landscapeImages = images.where((img) => img.width >= img.height).toList();
  final portraitImages = images.where((img) => img.height > img.width).toList();
  
  // –ü—Ä–æ–±—É–µ–º —Å–æ–∑–¥–∞—Ç—å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Ä—è–¥ –∏–∑ –∞–ª—å–±–æ–º–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
  if (landscapeImages.isNotEmpty) {
    final landscapeStrategy = _createHorizontalRowStrategy(landscapeImages, maxWidth, maxHeight ~/ 2);
    for (final placement in landscapeStrategy.placements) {
      placements.add(placement);
    }
  }
  
  // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Ä—Ç—Ä–µ—Ç–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∏–∂–µ
  if (portraitImages.isNotEmpty) {
    final portraitStrategy = _createHorizontalRowStrategy(portraitImages, maxWidth, maxHeight ~/ 2);
    for (final placement in portraitStrategy.placements) {
      placements.add(ImagePlacement(
        image: placement.image,
        x: placement.x,
        y: maxHeight ~/ 2,
        width: placement.width,
        height: placement.height,
      ));
    }
  }
  
  return CollageStrategy(
    canvasWidth: maxWidth,
    canvasHeight: maxHeight,
    placements: placements,
  );
}

class CosineLSH {
  final int _numHyperplanes;
  final int _numBands;
  final int _rowsPerBand;
  final int _dimensions;
  final List<List<double>> _hyperplanes;
  final Map<String, Map<String, Set<String>>> _buckets;
  
  CosineLSH({
    required int dimensions,
    int numHyperplanes = 100,
    int numBands = 20,
  })  : _numHyperplanes = numHyperplanes,
        _numBands = numBands,
        _rowsPerBand = numHyperplanes ~/ numBands,
        _dimensions = dimensions,
        _hyperplanes = [],
        _buckets = {} {
    _initializeHyperplanes(dimensions);
    _initializeBuckets();
  }

  void _initializeHyperplanes(int dimensions) {
    final random = Random();
    for (int i = 0; i < _numHyperplanes; i++) {
      final hyperplane = List<double>.generate(dimensions, 
          (_) => random.nextGaussian());
      final norm = _computeNorm(hyperplane);
      for (int j = 0; j < dimensions; j++) {
        hyperplane[j] /= norm;
      }
      _hyperplanes.add(hyperplane);
    }
  }

  void _initializeBuckets() {
    for (int band = 0; band < _numBands; band++) {
      _buckets['band_$band'] = {};
    }
  }

  double _computeNorm(List<double> vector) {
    double sum = 0.0;
    for (final value in vector) {
      sum += value * value;
    }
    return sqrt(sum);
  }

  /// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ Map<int, double> –≤ –ø–ª–æ—Ç–Ω—ã–π –≤–µ–∫—Ç–æ—Ä
  List<double> _mapToDenseVector(Map<int, double> sparseVector) {
    final dense = List<double>.filled(_dimensions, 0.0);
    sparseVector.forEach((index, value) {
      if (index < _dimensions) {
        dense[index] = value;
      }
    });
    return dense;
  }

  /// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞
  List<double> _normalizeVector(Map<int, double> sparseVector) {
    final dense = _mapToDenseVector(sparseVector);
    final norm = _computeNorm(dense);
    if (norm > 0) {
      for (int i = 0; i < _dimensions; i++) {
        dense[i] /= norm;
      }
    }
    return dense;
  }

  /// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–π —Å–∏–≥–Ω–∞—Ç—É—Ä—ã
  List<int> _computeCosineSignature(Map<int, double> vector) {
    final normalized = _normalizeVector(vector);
    final signature = List<int>.filled(_numHyperplanes, 0);
    
    for (int i = 0; i < _numHyperplanes; i++) {
      double dotProduct = 0.0;
      for (int j = 0; j < _dimensions; j++) {
        dotProduct += normalized[j] * _hyperplanes[i][j];
      }
      signature[i] = dotProduct >= 0 ? 1 : 0;
    }
    
    return signature;
  }

  /// –•—ç—à –¥–ª—è –ø–æ–ª–æ—Å—ã
  String _hashBand(List<int> band) {
    return band.join('');
  }

  /// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ –≤ –∏–Ω–¥–µ–∫—Å
  void addVector(String vectorId, Map<int, double> vector) {
    final signature = _computeCosineSignature(vector);
    
    for (int band = 0; band < _numBands; band++) {
      final start = band * _rowsPerBand;
      final end = (band + 1) * _rowsPerBand;
      final bandSignature = signature.sublist(start, end);
      final bandHash = _hashBand(bandSignature);
      
      final bandKey = 'band_$band';
      if (!_buckets[bandKey]!.containsKey(bandHash)) {
        _buckets[bandKey]![bandHash] = <String>{};
      }
      _buckets[bandKey]![bandHash]!.add(vectorId);
    }
  }

  /// –ü–æ–∏—Å–∫ –ø–æ—Ö–æ–∂–∏—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤
  Set<String> findSimilarVectors(Map<int, double> queryVector, {double threshold = 0.7}) {
    final querySignature = _computeCosineSignature(queryVector);
    final candidates = <String>{};
    
    // –°–æ–±–∏—Ä–∞–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –∏–∑ –≤—Å–µ—Ö –ø–æ–ª–æ—Å
    for (int band = 0; band < _numBands; band++) {
      final start = band * _rowsPerBand;
      final end = (band + 1) * _rowsPerBand;
      final bandSignature = querySignature.sublist(start, end);
      final bandHash = _hashBand(bandSignature);
      
      final bandKey = 'band_$band';
      final bucketVectors = _buckets[bandKey]![bandHash];
      
      if (bucketVectors != null) {
        candidates.addAll(bucketVectors);
      }
    }
    
    // –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –ø–æ—Ä–æ–≥—É —Å—Ö–æ–∂–µ—Å—Ç–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    final similarVectors = <String>{};
    for (final candidateId in candidates) {
      // –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
      // –∏ –≤—ã—á–∏—Å–ª–∏—Ç—å —Ç–æ—á–Ω–æ–µ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–µ —Å—Ö–æ–¥—Å—Ç–≤–æ
      similarVectors.add(candidateId);
    }
    
    return similarVectors;
  }

  /// –û—Ü–µ–Ω–∫–∞ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Å—Ö–æ–¥—Å—Ç–≤–∞
  double estimateCosineSimilarity(
      Map<int, double> vector1, 
      Map<int, double> vector2) {
    
    final signature1 = _computeCosineSignature(vector1);
    final signature2 = _computeCosineSignature(vector2);
    
    int matchingBits = 0;
    for (int i = 0; i < _numHyperplanes; i++) {
      if (signature1[i] == signature2[i]) {
        matchingBits++;
      }
    }
    
    return cos((1 - matchingBits / _numHyperplanes) * pi);
  }

  /// –¢–æ—á–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Å—Ö–æ–¥—Å—Ç–≤–∞
  double exactCosineSimilarity(Map<int, double> vector1, Map<int, double> vector2) {
    final dense1 = _mapToDenseVector(vector1);
    final dense2 = _mapToDenseVector(vector2);
    
    double dotProduct = 0.0;
    double norm1 = 0.0;
    double norm2 = 0.0;
    
    for (int i = 0; i < _dimensions; i++) {
      dotProduct += dense1[i] * dense2[i];
      norm1 += dense1[i] * dense1[i];
      norm2 += dense2[i] * dense2[i];
    }
    
    if (norm1 == 0 || norm2 == 0) return 0.0;
    
    return dotProduct / (sqrt(norm1) * sqrt(norm2));
  }

  /// –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  Map<String, dynamic> getStats() {
    int totalBuckets = 0;
    int totalVectors = 0;
    
    for (final band in _buckets.values) {
      totalBuckets += band.length;
      for (final bucket in band.values) {
        totalVectors += bucket.length;
      }
    }
    
    return {
      'dimensions': _dimensions,
      'numHyperplanes': _numHyperplanes,
      'numBands': _numBands,
      'rowsPerBand': _rowsPerBand,
      'totalBuckets': totalBuckets,
      'totalVectors': totalVectors,
    };
  }

  /// –û—á–∏—Å—Ç–∫–∞ –∏–Ω–¥–µ–∫—Å–∞
  void clear() {
    for (final bandKey in _buckets.keys) {
      _buckets[bandKey]!.clear();
    }
  }
}

class RecommendationSystem {
  final CosineLSH _lsh;
  final Map<String, Map<int, double>> _userVectors;
  
  RecommendationSystem({required int dimensions})
      : _lsh = CosineLSH(dimensions: dimensions),
        _userVectors = {};
  
  void addUserPreferences(String userId, Map<int, double> preferences) {
    _userVectors[userId] = preferences;
    _lsh.addVector(userId, preferences);
  }
  
  Set<String> findSimilarUsers(String userId) {
    final userVector = _userVectors[userId];
    if (userVector == null) return {};
    
    return _lsh.findSimilarVectors(userVector);
  }
  
  double userSimilarity(String user1, String user2) {
    final vector1 = _userVectors[user1];
    final vector2 = _userVectors[user2];
    
    if (vector1 == null || vector2 == null) return 0.0;
    
    return _lsh.exactCosineSimilarity(vector1, vector2);
  }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
void example() {
  final recommender = RecommendationSystem(dimensions: 100);
  
  // –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, –æ—Ü–µ–Ω–∫–∏ —Ç–æ–≤–∞—Ä–æ–≤)
  recommender.addUserPreferences('user1', {0: 5.0, 1: 3.0, 2: 4.5});
  recommender.addUserPreferences('user2', {0: 4.8, 1: 3.2, 2: 4.6}); // –ü–æ—Ö–æ–∂ –Ω–∞ user1
  recommender.addUserPreferences('user3', {10: 5.0, 11: 2.0}); // –î—Ä—É–≥–æ–π –ø—Ä–æ—Ñ–∏–ª—å
  
  final similarUsers = recommender.findSimilarUsers('user1');
  print('–ü–æ—Ö–æ–∂–∏–µ –Ω–∞ user1: $similarUsers'); // –ù–∞–π–¥–µ—Ç user2
}

class SemanticEmbedding {
  final List<double> vector;
  final DateTime createdAt;
  final String version;
  
  SemanticEmbedding({
    required this.vector,
    DateTime? createdAt,
    this.version = '1.0',
  }) : createdAt = createdAt ?? DateTime.now();
  
  // –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è JSON
  Map<String, dynamic> toJson() => {
    'vector': vector,
    'createdAt': createdAt.toIso8601String(),
    'version': version,
  };
  
  factory SemanticEmbedding.fromJson(Map<String, dynamic> json) {
    return SemanticEmbedding(
      vector: List<double>.from(json['vector']),
      createdAt: DateTime.parse(json['createdAt']),
      version: json['version'] ?? '1.0',
    );
  }
  
  // –ö–æ—Å–∏–Ω—É—Å–Ω–∞—è —Å—Ö–æ–∂–µ—Å—Ç—å —Å –¥—Ä—É–≥–∏–º —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–º
  double similarityTo(SemanticEmbedding other) {
    double dot = 0.0, norm1 = 0.0, norm2 = 0.0;
    for (int i = 0; i < vector.length; i++) {
      dot += vector[i] * other.vector[i];
      norm1 += vector[i] * vector[i];
      norm2 += other.vector[i] * other.vector[i];
    }
    return dot / (sqrt(norm1) * sqrt(norm2));
  }
}
class EmbeddingService {
  final int embeddingDimensions;
  final bool useCompression;
  final Map<int, dynamic> _wordEmbeddings; // –ú–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –æ–±–∞ —Ç–∏–ø–∞
  final Map<int, dynamic> _neuronEmbeddings;
  final Map<int, dynamic> _fragmentEmbeddings;
  
  EmbeddingService({
    this.embeddingDimensions = 100,
    this.useCompression = true, // –í–∫–ª—é—á–∞–µ–º —Å–∂–∞—Ç–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  }) : _wordEmbeddings = {},
        _neuronEmbeddings = {},
        _fragmentEmbeddings = {};
  
  /// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–∞ (—Å–∂–∞—Ç–æ–≥–æ –∏–ª–∏ –æ–±—ã—á–Ω–æ–≥–æ)
  dynamic _generateEmbeddingVector(List<double> vector) {
    if (useCompression) {
      return CompressedEmbedding(quantizedVector: CompressedEmbedding.quantize(vector));
    } else {
      return SemanticEmbedding(vector: vector);
    }
  }
   SemanticEmbedding generateWordEmbedding(Word word, Map<int, Word> allWords) {
    final vector = List<double>.filled(embeddingDimensions, 0.0);
    final random = Random(word.id);
    
    // –ë–∞–∑–æ–≤—ã–π –≤–µ–∫—Ç–æ—Ä
    for (int i = 0; i < embeddingDimensions; i++) {
      vector[i] = (word.id * (i + 1)) % 1.0;
    }
    
    // –£—á–∏—Ç—ã–≤–∞–µ–º —Å–≤—è–∑–∏ —Å –¥—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏
    double totalWeight = 0.0;
    word.ratings.forEach((otherWordId, rating) {
      final otherWord = allWords[otherWordId];
      if (otherWord != null && _wordEmbeddings.containsKey(otherWordId)) {
        final otherEmbedding = _wordEmbeddings[otherWordId]!;
        final weight = rating / word.allRating.toDouble();
        
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += otherEmbedding.vector[i] * weight;
        }
        totalWeight += weight;
      }
    });
    
    // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
    if (totalWeight > 0) {
      for (int i = 0; i < embeddingDimensions; i++) {
        vector[i] /= totalWeight;
      }
    }
    
    return SemanticEmbedding(vector: vector);
  }
  
  void _applySemanticTypeWeight(List<double> vector, String semanticType) {
    final weights = {
      'question': 1.2,
      'statement': 1.0,
      'command': 1.1,
      'exclamation': 1.15,
    };
    
    final weight = weights[semanticType] ?? 1.0;
    for (int i = 0; i < vector.length; i++) {
      vector[i] *= weight;
    }
  }
  
  void _applyNeuronRelations(Neuron neuron, List<double> vector, Map<int, Word> allWords) {
    // –£—á–∏—Ç—ã–≤–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥—Ä—É–≥–∏—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤
    neuron.neuronRatings.forEach((otherNeuronId, rating) {
      if (_neuronEmbeddings.containsKey(otherNeuronId)) {
        final otherEmbedding = _neuronEmbeddings[otherNeuronId]!;
        final influence = rating / 100.0; // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
        
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] = vector[i] * (1 - influence) + otherEmbedding.vector[i] * influence;
        }
      }
    });
  }

  SemanticEmbedding updateNeuronEmbedding(
    Neuron neuron, 
    Map<int, Word> allWords,
    Map<int, Fragment> allFragments,
  ) {
    final embedding = generateNeuronEmbedding(neuron, allWords, allFragments);
    _neuronEmbeddings[neuron.id] = embedding;
    return embedding;
  }

    SemanticEmbedding updateFragmentEmbedding(Fragment fragment, Map<int, Word> allWords) {
    final embedding = generateFragmentEmbedding(fragment, allWords);
    _fragmentEmbeddings[fragment.id] = embedding;
    return embedding;
  }

  SemanticEmbedding generateFragmentEmbedding(Fragment fragment, Map<int, Word> allWords) {
    final vector = List<double>.filled(embeddingDimensions, 0.0);
    int validWords = 0;
    
    for (final wordId in fragment.wordIds) {
      if (_wordEmbeddings.containsKey(wordId)) {
        final wordEmbedding = _wordEmbeddings[wordId]!;
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += wordEmbedding.vector[i];
        }
        validWords++;
      }
    }
    
    if (validWords > 0) {
      for (int i = 0; i < embeddingDimensions; i++) {
        vector[i] /= validWords;
      }
    }
    
    _applySemanticTypeWeight(vector, fragment.semanticType.semanticType.displayName);
    return SemanticEmbedding(vector: vector);
  }

  SemanticEmbedding generateNeuronEmbedding(
    Neuron neuron, 
    Map<int, Word> allWords,
    Map<int, Fragment> allFragments,
  ) {
    final vector = List<double>.filled(embeddingDimensions, 0.0);
    int validComponents = 0;
    
    // –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
    for (final wordId in neuron.keywords) {
      if (_wordEmbeddings.containsKey(wordId)) {
        final wordEmbedding = _wordEmbeddings[wordId]!;
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += wordEmbedding.vector[i];
        }
        validComponents++;
      }
    }
    
    // –°–≤—è–∑–∞–Ω–Ω—ã–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã
    for (final fragmentId in neuron.fragmentLinks) {
      if (_fragmentEmbeddings.containsKey(fragmentId)) {
        final fragmentEmbedding = _fragmentEmbeddings[fragmentId]!;
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += fragmentEmbedding.vector[i];
        }
        validComponents++;
      }
    }
    
    if (validComponents > 0) {
      for (int i = 0; i < embeddingDimensions; i++) {
        vector[i] /= validComponents;
      }
    }
    
    _applyNeuronRelations(neuron, vector, allWords);
    return SemanticEmbedding(vector: vector);
  }
  /// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞ —Å–ª–æ–≤–∞
  dynamic updateWordEmbedding(Word word, Map<int, Word> allWords) {
    final rawVector = _computeRawWordEmbedding(word, allWords);
    final embedding = _generateEmbeddingVector(rawVector);
    _wordEmbeddings[word.id] = embedding;
    return embedding;
  }
  
  /// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ—Ç –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
  List<double> getVector(dynamic embedding) {
    if (embedding is CompressedEmbedding) {
      return embedding.dequantize();
    } else if (embedding is SemanticEmbedding) {
      return embedding.vector;
    }
    return List<double>.filled(embeddingDimensions, 0.0);
  }
  
  /// –°—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É –ª—é–±—ã–º–∏ —Ç–∏–ø–∞–º–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤
  double computeSimilarity(dynamic emb1, dynamic emb2) {
    if (emb1 is CompressedEmbedding && emb2 is CompressedEmbedding) {
      return emb1.fastSimilarityTo(emb2); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥
    }
    
    // –î–ª—è —Å–º–µ—à–∞–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∏–ª–∏ –æ–±—ã—á–Ω—ã—Ö —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤
    final vec1 = getVector(emb1);
    final vec2 = getVector(emb2);
    
    double dot = 0.0, norm1 = 0.0, norm2 = 0.0;
    for (int i = 0; i < vec1.length; i++) {
      dot += vec1[i] * vec2[i];
      norm1 += vec1[i] * vec1[i];
      norm2 += vec2[i] * vec2[i];
    }
    return dot / (sqrt(norm1) * sqrt(norm2));
  }
  
  /// –ü–æ–∏—Å–∫ –ø–æ—Ö–æ–∂–∏—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤ (—Ä–∞–±–æ—Ç–∞–µ—Ç —Å –ª—é–±—ã–º —Ç–∏–ø–æ–º —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤)
  List<SimilarityResult> findSimilarNeurons(int neuronId, int topK, double minSimilarity) {
    final sourceEmbedding = _neuronEmbeddings[neuronId];
    if (sourceEmbedding == null) return [];
    
    final results = <SimilarityResult>[];
    
    _neuronEmbeddings.forEach((id, embedding) {
      if (id != neuronId) {
        final similarity = computeSimilarity(sourceEmbedding, embedding);
        if (similarity >= minSimilarity) {
          results.add(SimilarityResult(id: id, similarity: similarity));
        }
      }
    });
    
    results.sort((a, b) => b.similarity.compareTo(a.similarity));
    return results.take(topK).toList();
  }

   /// ‚úÖ –ü–û–õ–£–ß–ò–¢–¨ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —ç–º–±–µ–¥–¥–∏–Ω–≥ (–±–µ–∑ –ø–µ—Ä–µ—Å—á–µ—Ç–∞)
  SemanticEmbedding? getWordEmbedding(int wordId) => _wordEmbeddings[wordId];
  SemanticEmbedding? getFragmentEmbedding(int fragmentId) => _fragmentEmbeddings[fragmentId];
  SemanticEmbedding? getNeuronEmbedding(int neuronId) => _neuronEmbeddings[neuronId];
  
  // –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –º–µ—Ç–æ–¥ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Å—ã—Ä–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞
  List<double> _computeRawWordEmbedding(Word word, Map<int, Word> allWords) {
    final vector = List<double>.filled(embeddingDimensions, 0.0);
    final random = Random(word.id);
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—à–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –¥–ª—è Gaussian
    for (int i = 0; i < embeddingDimensions; i++) {
      vector[i] = random.nextGaussian() * 0.1; // –ú–µ–Ω—å—à–∏–π —Ä–∞–∑–±—Ä–æ—Å
    }
    
    // –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ—Å—Ç–∞–µ—Ç—Å—è —Ç–∞–∫–æ–π –∂–µ...
    double totalWeight = 0.0;
    word.ratings.forEach((otherWordId, rating) {
      final otherWord = allWords[otherWordId];
      if (otherWord != null && _wordEmbeddings.containsKey(otherWordId)) {
        final otherEmbedding = _wordEmbeddings[otherWordId];
        final otherVector = getVector(otherEmbedding);
        final weight = rating / word.allRating.toDouble();
        
        for (int i = 0; i < embeddingDimensions; i++) {
          vector[i] += otherVector[i] * weight;
        }
        totalWeight += weight;
      }
    });
    
    if (totalWeight > 0) {
      for (int i = 0; i < embeddingDimensions; i++) {
        vector[i] /= totalWeight;
      }
    }
    
    return vector;
  }
}

class SimilarityResult {
  final int id;
  final double similarity;
  
  SimilarityResult({required this.id, required this.similarity});
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'similarity': similarity,
  };
}

class CompressedEmbedding {
  final List<int> quantizedVector;
  final DateTime createdAt;
  final String version;
  
  CompressedEmbedding({
    required this.quantizedVector,
    DateTime? createdAt,
    this.version = '1.0',
  }) : createdAt = createdAt ?? DateTime.now();
  
  // –ö–≤–∞–Ω—Ç–æ–≤–∞–Ω–∏–µ –∏–∑ double –≤ int8
  static List<int> quantize(List<double> vector) {
    // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏
    double maxAbs = vector.map((v) => v.abs()).reduce((a, b) => a > b ? a : b);
    if (maxAbs == 0.0) maxAbs = 1.0; // –∏–∑–±–µ–≥–∞–µ–º –¥–µ–ª–µ–Ω–∏—è –Ω–∞ 0
    
    return vector.map((v) {
      // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [-127, 127]
      double normalized = v / maxAbs;
      return (normalized * 127).round().clamp(-127, 127);
    }).toList();
  }
  
  // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏
  List<double> dequantize() {
    return quantizedVector.map((v) => v / 127.0).toList();
  }
  
  // –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è JSON (–µ—â–µ –±–æ–ª–µ–µ –∫–æ–º–ø–∞–∫—Ç–Ω–∞—è!)
  Map<String, dynamic> toJson() => {
    'q': quantizedVector, // 'q' –≤–º–µ—Å—Ç–æ 'vector' –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞
    'c': createdAt.millisecondsSinceEpoch,
    'v': version,
  };
  
  factory CompressedEmbedding.fromJson(Map<String, dynamic> json) {
    return CompressedEmbedding(
      quantizedVector: List<int>.from(json['q']),
      createdAt: DateTime.fromMillisecondsSinceEpoch(json['c']),
      version: json['v'] ?? '1.0',
    );
  }
  
  // –ö–æ—Å–∏–Ω—É—Å–Ω–∞—è —Å—Ö–æ–∂–µ—Å—Ç—å –º–µ–∂–¥—É —Å–∂–∞—Ç—ã–º–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞–º–∏
  double similarityTo(CompressedEmbedding other) {
    final vec1 = dequantize();
    final vec2 = other.dequantize();
    
    double dot = 0.0, norm1 = 0.0, norm2 = 0.0;
    for (int i = 0; i < vec1.length; i++) {
      dot += vec1[i] * vec2[i];
      norm1 += vec1[i] * vec1[i];
      norm2 += vec2[i] * vec2[i];
    }
    return dot / (sqrt(norm1) * sqrt(norm2));
  }
  
  // –ë—ã—Å—Ç—Ä–∞—è —Å—Ö–æ–∂–µ—Å—Ç—å –±–µ–∑ –¥–µ–∫–≤–∞–Ω—Ç–æ–≤–∞–Ω–∏—è (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è)
  double fastSimilarityTo(CompressedEmbedding other) {
    int dot = 0;
    int norm1 = 0;
    int norm2 = 0;
    
    for (int i = 0; i < quantizedVector.length; i++) {
      final v1 = quantizedVector[i];
      final v2 = other.quantizedVector[i];
      dot += v1 * v2;
      norm1 += v1 * v1;
      norm2 += v2 * v2;
    }
    
    return dot / (sqrt(norm1) * sqrt(norm2));
  }
}

extension NeuronEmbeddingExtension on Neuron {
  /// üîÑ –û–±–Ω–æ–≤–∏—Ç—å —ç–º–±–µ–¥–¥–∏–Ω–≥ —ç—Ç–æ–≥–æ –Ω–µ–π—Ä–æ–Ω–∞
  void updateEmbedding(EmbeddingService service, Map<int, Word> words, Map<int, Fragment> fragments) {
    embedding = service.updateNeuronEmbedding(this, words, fragments);
  }
  
  /// ‚úÖ –ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —ç–º–±–µ–¥–¥–∏–Ω–≥ (–µ—Å–ª–∏ –µ—Å—Ç—å)
  SemanticEmbedding? getEmbedding(EmbeddingService service) {
    return embedding ?? service.getNeuronEmbedding(id);
  }
}

extension WordEmbeddingExtension on Word {
  /// üîÑ –û–±–Ω–æ–≤–∏—Ç—å —ç–º–±–µ–¥–¥–∏–Ω–≥ —ç—Ç–æ–≥–æ —Å–ª–æ–≤–∞
  void updateEmbedding(EmbeddingService service, Map<int, Word> allWords) {
    embedding = service.updateWordEmbedding(this, allWords);
  }
  
  /// ‚úÖ –ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —ç–º–±–µ–¥–¥–∏–Ω–≥
  SemanticEmbedding? getEmbedding(EmbeddingService service) {
    return embedding ?? service.getWordEmbedding(id);
  }
}

extension FragmentEmbeddingExtension on Fragment {
  /// üîÑ –û–±–Ω–æ–≤–∏—Ç—å —ç–º–±–µ–¥–¥–∏–Ω–≥ —ç—Ç–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
  void updateEmbedding(EmbeddingService service, Map<int, Word> allWords) {
    embedding = service.updateFragmentEmbedding(this, allWords);
  }
  
  /// ‚úÖ –ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —ç–º–±–µ–¥–¥–∏–Ω–≥
  SemanticEmbedding? getEmbedding(EmbeddingService service) {
    return embedding ?? service.getFragmentEmbedding(id);
  }
}

// –î–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞ –∏–ª–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ö–µ–ª–ø–µ—Ä
extension GaussianRandom on Random {
  double nextGaussian() {
    // Box-Muller transform –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
    double u1 = 1.0 - nextDouble(); // (0,1] -> (0,1]
    double u2 = 1.0 - nextDouble();
    double radius = sqrt(-2.0 * log(u1));
    double theta = 2.0 * pi * u2;
    return radius * cos(theta);
  }
}

enum SemanticType {
  fact,           // –§–∞–∫—Ç
  opinion,        // –ú–Ω–µ–Ω–∏–µ  
  instruction,    // –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è
  question,       // –í–æ–ø—Ä–æ—Å
  hypothesis,     // –ì–∏–ø–æ—Ç–µ–∑–∞
  definition,     // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
  comparison,     // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ
  causal,         // –ü—Ä–∏—á–∏–Ω–Ω–æ-—Å–ª–µ–¥—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–≤—è–∑—å
  temporal,       // –í—Ä–µ–º–µ–Ω–Ω–æ–µ
  emotional,      // –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ
  unknown;        // –ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–∏–ø

  /// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä—É—Å—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–∏–ø–∞
  String get displayName {
    return switch (this) {
      SemanticType.fact => '—Ñ–∞–∫—Ç',
      SemanticType.opinion => '–º–Ω–µ–Ω–∏–µ', 
      SemanticType.instruction => '–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è',
      SemanticType.question => '–≤–æ–ø—Ä–æ—Å',
      SemanticType.hypothesis => '–≥–∏–ø–æ—Ç–µ–∑–∞',
      SemanticType.definition => '–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ',
      SemanticType.comparison => '—Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
      SemanticType.causal => '–ø—Ä–∏—á–∏–Ω–Ω–æ-—Å–ª–µ–¥—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–≤—è–∑—å',
      SemanticType.temporal => '–≤—Ä–µ–º–µ–Ω–Ω–æ–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ',
      SemanticType.emotional => '—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Å–∫–∞–∑—ã–≤–∞–Ω–∏–µ',
      SemanticType.unknown => '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø',
    };
  }

  /// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ (–¥–ª—è JSON/API)
  String get name {
    return toString().split('.').last;
  }
}
class SemanticPatternDetector {
  /// –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –µ–≥–æ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π —Ç–∏–ø
  static SemanticType analyzeStatement(String text) {
    final cleanText = _preprocessText(text);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
    if (_isQuestion(cleanText)) return SemanticType.question;
    if (_isFact(cleanText)) return SemanticType.fact;
    if (_isOpinion(cleanText)) return SemanticType.opinion;
    if (_isInstruction(cleanText)) return SemanticType.instruction;
    if (_isHypothesis(cleanText)) return SemanticType.hypothesis;
    if (_isDefinition(cleanText)) return SemanticType.definition;
    if (_isComparison(cleanText)) return SemanticType.comparison;
    if (_isCausal(cleanText)) return SemanticType.causal;
    if (_isTemporal(cleanText)) return SemanticType.temporal;
    if (_isEmotional(cleanText)) return SemanticType.emotional;
    
    return SemanticType.unknown;
  }
  
  /// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –§–ê–ö–¢–´
  static bool _isFact(String text) {
    final factPatterns = [
      // –ü–∞—Ç—Ç–µ—Ä–Ω—ã —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π —Ñ–∞–∫—Ç–æ–≤
      RegExp(r'^(—è–≤–ª—è–µ—Ç—Å—è|—ç—Ç–æ|—Å–æ—Å—Ç–∞–≤–ª—è–µ—Ç|—Ä–∞–≤–µ–Ω|–Ω–∞—Ö–æ–¥–∏—Ç—Å—è|—Å–æ–¥–µ—Ä–∂–∏—Ç)'),
      RegExp(r'\d+(\s|\-)(–ª–µ—Ç|–≥–æ–¥|–º–µ—Å—è—Ü|–¥–µ–Ω—å|—á–∞—Å|–º–∏–Ω—É—Ç|—Å–µ–∫—É–Ω–¥)'),
      RegExp(r'[0-9]+(%|–≥—Ä–∞–¥—É—Å|–º–µ—Ç—Ä|–∫–∏–ª–æ–º–µ—Ç—Ä|–∫–≥|–≥)'),
      RegExp(r'(–ø–æ –¥–∞–Ω–Ω—ã–º|—Å–æ–≥–ª–∞—Å–Ω–æ|–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç|–¥–æ–∫–∞–∑–∞–Ω–æ)'),
      RegExp(r'(–≤—Å–µ–≥–¥–∞|–Ω–∏–∫–æ–≥–¥–∞|–∫–∞–∂–¥—ã–π|–ª—é–±–æ–π)'),
      // –£—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤ –Ω–∞—Å—Ç–æ—è—â–µ–º –≤—Ä–µ–º–µ–Ω–∏
      RegExp(r'\b(–µ—Å—Ç—å|—Å—É—â–µ—Å—Ç–≤—É–µ—Ç|–∏–º–µ–µ—Ç|—Å–æ–¥–µ—Ä–∂–∏—Ç)\b'),
    ];
    
    return factPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ú–ù–ï–ù–ò–Ø
  static bool _isOpinion(String text) {
    final opinionPatterns = [
      RegExp(r'\b(—è –¥—É–º–∞—é|–ø–æ –º–æ–µ–º—É|–Ω–∞ –º–æ–π –≤–∑–≥–ª—è–¥|—Å—á–∏—Ç–∞—é|–ø–æ–ª–∞–≥–∞—é)\b'),
      RegExp(r'\b(–ª—É—á—à–∏–π|—Ö—É–¥—à–∏–π|–∫—Ä–∞—Å–∏–≤—ã–π|—É—Ä–æ–¥–ª–∏–≤—ã–π|–∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π|—Å–∫—É—á–Ω—ã–π)\b'),
      RegExp(r'\b(–Ω—Ä–∞–≤–∏—Ç—Å—è|–ª—é–±–ª—é|–Ω–µ–Ω–∞–≤–∏–∂—É|–ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—é)\b'),
      RegExp(r'\b(–≤–æ–∑–º–æ–∂–Ω–æ|–≤–µ—Ä–æ—è—Ç–Ω–æ|—Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ|–º–æ–∂–µ—Ç –±—ã—Ç—å)\b'),
      RegExp(r'\b(–∫ —Å–æ–∂–∞–ª–µ–Ω–∏—é|–∫ —Å—á–∞—Å—Ç—å—é|–∂–∞–ª—å|—Ä–∞–¥)\b'),
    ];
    
    return opinionPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ò–ù–°–¢–†–£–ö–¶–ò–ò
  static bool _isInstruction(String text) {
    final instructionPatterns = [
      RegExp(r'^(–Ω–∞–∂–º–∏|–≤–≤–µ–¥–∏—Ç–µ|–≤—ã–±–µ—Ä–∏—Ç–µ|—Å–ª–µ–¥—É–π—Ç–µ|–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ|—É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ)'),
      RegExp(r'\b(—à–∞–≥|–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è|—Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ|–∫–∞–∫ —Å–¥–µ–ª–∞—Ç—å)\b'),
      RegExp(r'\b(—Å–Ω–∞—á–∞–ª–∞|–∑–∞—Ç–µ–º|–ø–æ—Ç–æ–º|–ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ|–≤ –∫–æ–Ω—Ü–µ)\b'),
      RegExp(r'[0-9]+\.\s'), // –ù—É–º–µ—Ä–æ–≤–∞–Ω–Ω—ã–µ —à–∞–≥–∏
    ];
    
    return instructionPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –í–û–ü–†–û–°–´
  static bool _isQuestion(String text) {
    final questionPatterns = [
      RegExp(r'^\?|(\?)$'), // –ó–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –Ω–∞ ?
      RegExp(r'^(–∫–∞–∫|—á—Ç–æ|–≥–¥–µ|–∫–æ–≥–¥–∞|–ø–æ—á–µ–º—É|–∑–∞—á–µ–º|–∫—Ç–æ|—á–µ–π|—Å–∫–æ–ª—å–∫–æ)'),
      RegExp(r'\b(–ª–∏\??|–Ω–µ —Ç–∞–∫ –ª–∏\??|–ø—Ä–∞–≤–∏–ª—å–Ω–æ\??|–≤–µ—Ä–Ω–æ\??)\b'),
    ];
    
    return questionPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ì–ò–ü–û–¢–ï–ó–´
  static bool _isHypothesis(String text) {
    final hypothesisPatterns = [
      RegExp(r'\b(–µ—Å–ª–∏.*—Ç–æ|–ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º|–¥–æ–ø—É—Å—Ç–∏–º|–≥–∏–ø–æ—Ç–µ—Ç–∏—á–µ—Å–∫–∏)\b'),
      RegExp(r'\b(–≤–æ–∑–º–æ–∂–Ω–æ|–≤–µ—Ä–æ—è—Ç–Ω–æ|–º–æ–∂–µ—Ç –±—ã—Ç—å|—Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ)\b'),
      RegExp(r'\b(–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è|—Å—á–∏—Ç–∞–µ—Ç—Å—è|–ø–æ–ª–∞–≥–∞—é—Ç)\b'),
    ];
    
    return hypothesisPatterns.any((pattern) => pattern.hasMatch(text));
  }
  
  /// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
  static bool _isDefinition(String text) {
    return RegExp(r'^[–ê-–Ø–∞-—è]+\s*‚Äî\s*|^[–ê-–Ø–∞-—è]+\s*—ç—Ç–æ\s*').hasMatch(text) ||
           text.contains('–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ') ||
           text.contains('–æ–∑–Ω–∞—á–∞–µ—Ç');
  }
  
  /// –°—Ä–∞–≤–Ω–µ–Ω–∏—è
  static bool _isComparison(String text) {
    return text.contains('—á–µ–º') || 
           text.contains('–ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é') ||
           RegExp(r'\b(–±–æ–ª—å—à–µ|–º–µ–Ω—å—à–µ|–ª—É—á—à–µ|—Ö—É–∂–µ|—Å–∏–ª—å–Ω–µ–µ|—Å–ª–∞–±–µ–µ)\b').hasMatch(text);
  }
  
  /// –ü—Ä–∏—á–∏–Ω–Ω–æ-—Å–ª–µ–¥—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å–≤—è–∑–∏
  static bool _isCausal(String text) {
    return text.contains('–ø–æ—Ç–æ–º—É —á—Ç–æ') ||
           text.contains('–∏–∑-–∑–∞') ||
           text.contains('–≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ') ||
           text.contains('—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ');
  }
  
  /// –í—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
  static bool _isTemporal(String text) {
    return RegExp(r'\b(–∑–∞–≤—Ç—Ä–∞|–≤—á–µ—Ä–∞|—Å–µ–≥–æ–¥–Ω—è|–ø–æ—Ç–æ–º|–ø–æ—Å–ª–µ|–¥–æ|–∫–æ–≥–¥–∞)\b').hasMatch(text);
  }
  
  /// –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
  static bool _isEmotional(String text) {
    final emotionalWords = ['—Ä–∞–¥', '–≥—Ä—É—Å—Ç–Ω–æ', '–∑–ª–æ–π', '—Å—á–∞—Å—Ç–ª–∏–≤', '–æ—Ç–≤—Ä–∞—Ç–∏—Ç–µ–ª—å–Ω–æ', '–ø—Ä–µ–∫—Ä–∞—Å–Ω–æ'];
    return emotionalWords.any((word) => text.contains(word));
  }
  
  static String _preprocessText(String text) {
    return text.toLowerCase().trim();
  }
}

class FactConfidenceAnalyzer {
  /// –û—Ü–µ–Ω–∏–≤–∞–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ —Ç–æ–º, —á—Ç–æ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ - —Ñ–∞–∫—Ç (0.0 - 1.0)
  static double analyzeFactConfidence(String text) {
    double confidence = 0.0;
    
    // –ü—Ä–∏–∑–Ω–∞–∫–∏ –≤—ã—Å–æ–∫–æ—Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π
    if (_containsNumbers(text)) confidence += 0.3;
    if (_containsScientificTerms(text)) confidence += 0.2;
    if (_hasFactualLanguage(text)) confidence += 0.3;
    if (_isVerifiable(text)) confidence += 0.2;
    
    // –®—Ç—Ä–∞—Ñ—ã –∑–∞ —Å—É–±—ä–µ–∫—Ç–∏–≤–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã
    if (_containsOpinionMarkers(text)) confidence -= 0.3;
    if (_containsEmotionalLanguage(text)) confidence -= 0.2;
    
    return confidence.clamp(0.0, 1.0);
  }
  
  static bool _containsNumbers(String text) {
    return RegExp(r'\d+').hasMatch(text);
  }
  
  static bool _containsScientificTerms(String text) {
    final scientificWords = ['–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ', '—ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç', '–¥–æ–∫–∞–∑–∞–Ω–æ', '—Ç–µ–æ—Ä–∏—è', '–∑–∞–∫–æ–Ω'];
    return scientificWords.any((word) => text.toLowerCase().contains(word));
  }
  
  static bool _hasFactualLanguage(String text) {
    final factualMarkers = [
      '—è–≤–ª—è–µ—Ç—Å—è', '—Å–æ—Å—Ç–∞–≤–ª—è–µ—Ç', '—Ä–∞–≤–µ–Ω', '—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç', 
      '–ø–æ –¥–∞–Ω–Ω—ã–º', '—Å–æ–≥–ª–∞—Å–Ω–æ', '–Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏'
    ];
    return factualMarkers.any((marker) => text.toLowerCase().contains(marker));
  }
  
  static bool _isVerifiable(String text) {
    // –£—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
    return _containsNumbers(text) || 
           text.toLowerCase().contains('–º–æ–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å') ||
           _containsSpecificReferences(text);
  }
  
  static bool _containsSpecificReferences(String text) {
    return RegExp(r'[–ê-–Ø–∞-—è]+\s[0-9]+').hasMatch(text) || // "–ì–ª–∞–≤–∞ 5"
           text.contains('–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ') ||
           text.contains('—ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç');
  }
  
  static bool _containsOpinionMarkers(String text) {
    final opinionMarkers = ['—è –¥—É–º–∞—é', '–ø–æ –º–æ–µ–º—É', '–Ω–∞–≤–µ—Ä–Ω–æ–µ', '–≤–æ–∑–º–æ–∂–Ω–æ'];
    return opinionMarkers.any((marker) => text.toLowerCase().contains(marker));
  }
  
  static bool _containsEmotionalLanguage(String text) {
    final emotionalWords = ['–∫ —Å–æ–∂–∞–ª–µ–Ω–∏—é', '–∫ —Å—á–∞—Å—Ç—å—é', '—É–∂–∞—Å–Ω–æ', '–ø—Ä–µ–∫—Ä–∞—Å–Ω–æ'];
    return emotionalWords.any((word) => text.toLowerCase().contains(word));
  }
}

class SemanticAnalyzer1 {
  /// –ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å–µ–º–∞–Ω—Ç–∏–∫–∏ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
  static SemanticAnalysisResult analyze(String text) {
    final semanticType = SemanticPatternDetector.analyzeStatement(text);
    final factConfidence = FactConfidenceAnalyzer.analyzeFactConfidence(text);
    final entities = _extractEntities(text);
    final relations = _extractRelations(text);
    
    return SemanticAnalysisResult(
      text: text,
      semanticType: semanticType,
      factConfidence: factConfidence,
      entities: entities,
      relations: relations,
      isFactual: factConfidence > 0.7,
      isSubjective: semanticType == SemanticType.opinion || 
                   semanticType == SemanticType.emotional,
    );
  }
   static List<SemanticRelation> _extractRelations(String text) {
    return RelationExtractor.extractRelations(text);
  }
  /// –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Å—É—â–Ω–æ—Å—Ç–∏ –∏–∑ —Ç–µ–∫—Å—Ç–∞
  static List<SemanticEntity> _extractEntities(String text) {
    final entities = <SemanticEntity>[];
    
    // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è - –º–æ–∂–Ω–æ —É–ª—É—á—à–∏—Ç—å —Å –ø–æ–º–æ—â—å—é –≤–∞—à–µ–π —Å–∏—Å—Ç–µ–º—ã Word
    final words = text.split(RegExp(r'\s+'));
    
    for (final word in words) {
      if (_isPotentialEntity(word)) {
        entities.add(SemanticEntity(
          text: word,
          type: _classifyEntityType(word),
          position: text.indexOf(word),
        ));
      }
    }
    
    return entities;
  }
  
  static bool _isPotentialEntity(String word) {
    // –°–ª–æ–≤–∞ —Å –∑–∞–≥–ª–∞–≤–Ω–æ–π –±—É–∫–≤—ã –∏–ª–∏ –¥–ª–∏–Ω–Ω—ã–µ —Å–ª–æ–≤–∞
    return word.length > 3 || 
           (word.isNotEmpty && word[0] == word[0].toUpperCase());
  }
  

  static final _temporalWords = {
    // –í—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–µ—Ä–∏–æ–¥—ã
    '—Å–µ–≥–æ–¥–Ω—è', '–∑–∞–≤—Ç—Ä–∞', '–≤—á–µ—Ä–∞', '—Å–µ–π—á–∞—Å', '—Å—Ä–∞–∑—É', '–ø–æ—Ç–æ–º', '–ø–æ–∑–∂–µ',
    '—Å–∫–æ—Ä–æ', '–Ω–µ–¥–∞–≤–Ω–æ', '–¥–∞–≤–Ω–æ', '–≤—Å–∫–æ—Ä–µ', '—Å–Ω–∞—á–∞–ª–∞', '–ø–æ—Å–ª–µ',
    
    // –î–Ω–∏ –Ω–µ–¥–µ–ª–∏
    '–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–≤—Ç–æ—Ä–Ω–∏–∫', '—Å—Ä–µ–¥–∞', '—á–µ—Ç–≤–µ—Ä–≥', '–ø—è—Ç–Ω–∏—Ü–∞', '—Å—É–±–±–æ—Ç–∞', '–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ',
    
    // –ú–µ—Å—è—Ü—ã
    '—è–Ω–≤–∞—Ä—å', '—Ñ–µ–≤—Ä–∞–ª—å', '–º–∞—Ä—Ç', '–∞–ø—Ä–µ–ª—å', '–º–∞–π', '–∏—é–Ω—å',
    '–∏—é–ª—å', '–∞–≤–≥—É—Å—Ç', '—Å–µ–Ω—Ç—è–±—Ä—å', '–æ–∫—Ç—è–±—Ä—å', '–Ω–æ—è–±—Ä—å', '–¥–µ–∫–∞–±—Ä—å',
    
    // –í—Ä–µ–º–µ–Ω–∞ –≥–æ–¥–∞
    '–≤–µ—Å–Ω–∞', '–ª–µ—Ç–æ', '–æ—Å–µ–Ω—å', '–∑–∏–º–∞',
    
    // –ß–∞—Å—Ç–∏ —Å—É—Ç–æ–∫
    '—É—Ç—Ä–æ', '–¥–µ–Ω—å', '–≤–µ—á–µ—Ä', '–Ω–æ—á—å', '–ø–æ–ª–¥–µ–Ω—å', '–ø–æ–ª–Ω–æ—á—å',
    
    // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
    '–ø—Ä–æ—à–ª–æ–µ', '–±—É–¥—É—â–µ–µ', '–Ω–∞—Å—Ç–æ—è—â–µ–µ', '—Å–ª–µ–¥—É—é—â–∏–π', '–ø—Ä–µ–¥—ã–¥—É—â–∏–π',
    '–Ω–∞—á–∞–ª–æ', '–∫–æ–Ω–µ—Ü', '–ø–µ—Ä–∏–æ–¥', '–≤—Ä–µ–º—è', '–º–æ–º–µ–Ω—Ç',
    
    // –ß–∞—Å—Ç–æ—Ç–Ω—ã–µ —Å–ª–æ–≤–∞
    '–≤—Å–µ–≥–¥–∞', '–Ω–∏–∫–æ–≥–¥–∞', '–∏–Ω–æ–≥–¥–∞', '—á–∞—Å—Ç–æ', '—Ä–µ–¥–∫–æ', '–æ–±—ã—á–Ω–æ',
    '–ø–æ—Å—Ç–æ—è–Ω–Ω–æ', '—Ä–µ–≥—É–ª—è—Ä–Ω–æ', '–µ–∂–µ–¥–Ω–µ–≤–Ω–æ', '–µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ',
    
    // –í–æ–∑—Ä–∞—Å—Ç–Ω—ã–µ –ø–µ—Ä–∏–æ–¥—ã
    '–¥–µ—Ç—Å—Ç–≤–æ', '—é–Ω–æ—Å—Ç—å', '–º–æ–ª–æ–¥–æ—Å—Ç—å', '–∑—Ä–µ–ª–æ—Å—Ç—å', '—Å—Ç–∞—Ä–æ—Å—Ç—å',
  };

  static bool isTemporalWord(String word) {
    final cleanWord = word.toLowerCase().trim();
    return _temporalWords.contains(cleanWord) ||
           _matchesTemporalPattern(cleanWord);
  }

  static bool _matchesTemporalPattern(String word) {
    final temporalPatterns = [
      RegExp(r'^\d+:\d+$'), // 12:30
      RegExp(r'^\d+[—á—á]\.$'), // 12—á.
      RegExp(r'^\d+\s*(–≥–æ–¥|–º–µ—Å—è—Ü|–¥–µ–Ω—å|—á–∞—Å|–º–∏–Ω—É—Ç|—Å–µ–∫—É–Ω–¥)$'), // 5 –ª–µ—Ç
      RegExp(r'^[0-9]+[-\‚Äì][0-9]+$'), // 2020-2023
      RegExp(r'^(–≤|–Ω–∞|–¥–æ|–ø–æ—Å–ª–µ|—á–µ—Ä–µ–∑|–≤–æ|—Å|–ø–æ)$'), // –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–µ–¥–ª–æ–≥–∏
    ];

    return temporalPatterns.any((pattern) => pattern.hasMatch(word));
  }

  static final _locationWords = {
    // –û–±—â–∏–µ –ª–æ–∫–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Ä–º–∏–Ω—ã
    '–≥–æ—Ä–æ–¥', '–¥–µ—Ä–µ–≤–Ω—è', '—Å–µ–ª–æ', '–ø–æ—Å–µ–ª–æ–∫', '—Å—Ç–æ–ª–∏—Ü–∞', '—Ü–µ–Ω—Ç—Ä',
    '—É–ª–∏—Ü–∞', '–ø–ª–æ—â–∞–¥—å', '–ø—Ä–æ—Å–ø–µ–∫—Ç', '–±—É–ª—å–≤–∞—Ä', '–ø–µ—Ä–µ—É–ª–æ–∫',
    '–¥–æ–º', '–∑–¥–∞–Ω–∏–µ', '—Å–æ–æ—Ä—É–∂–µ–Ω–∏–µ', '–ø–æ–º–µ—â–µ–Ω–∏–µ', '–∫–æ–º–Ω–∞—Ç–∞',
    
    // –ì–µ–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã
    '—Å—Ç—Ä–∞–Ω–∞', '–≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–æ', '—Ä–µ—Å–ø—É–±–ª–∏–∫–∞', '–æ–±–ª–∞—Å—Ç—å', '–∫—Ä–∞–π',
    '—Ä–∞–π–æ–Ω', '–æ–∫—Ä—É–≥', '—Ä–µ–≥–∏–æ–Ω', '—Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è', '–∑–æ–Ω–∞',
    '–≥–æ—Ä–∞', '—Ä–µ–∫–∞', '–æ–∑–µ—Ä–æ', '–º–æ—Ä–µ', '–æ–∫–µ–∞–Ω', '–æ—Å—Ç—Ä–æ–≤',
    '–ª–µ—Å', '–ø–æ–ª–µ', '–ø—É—Å—Ç—ã–Ω—è', '–¥–æ–ª–∏–Ω–∞', '—Ä–∞–≤–Ω–∏–Ω–∞',
    
    // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –ø–æ–ª–æ–∂–µ–Ω–∏—è
    '—Å–µ–≤–µ—Ä', '—é–≥', '–∑–∞–ø–∞–¥', '–≤–æ—Å—Ç–æ–∫', '—Å–µ–≤–µ—Ä–æ-–∑–∞–ø–∞–¥', '—é–≥–æ-–≤–æ—Å—Ç–æ–∫',
    '–≤–µ—Ä—Ö', '–Ω–∏–∑', '–ª–µ–≤–æ', '–ø—Ä–∞–≤–æ', '—Ü–µ–Ω—Ç—Ä', '–ø–µ—Ä–∏—Ñ–µ—Ä–∏—è',
    '–≤–Ω—É—Ç—Ä–∏', '—Å–Ω–∞—Ä—É–∂–∏', '—Ä—è–¥–æ–º', '–¥–∞–ª–µ–∫–æ', '–±–ª–∏–∑–∫–æ',
    
    // –¢–∏–ø—ã –º–µ—Å—Ç
    '–º–∞–≥–∞–∑–∏–Ω', '—à–∫–æ–ª–∞', '–±–æ–ª—å–Ω–∏—Ü–∞', '–∞–ø—Ç–µ–∫–∞', '–±–∞–Ω–∫', '–æ—Ñ–∏—Å',
    '—Ä–µ—Å—Ç–æ—Ä–∞–Ω', '–∫–∞—Ñ–µ', '–ø–∞—Ä–∫', '—Å–∞–¥', '—Å—Ç–∞–¥–∏–æ–Ω', '–º—É–∑–µ–π',
    '–≤–æ–∫–∑–∞–ª', '–∞—ç—Ä–æ–ø–æ—Ä—Ç', '–ø–æ—Ä—Ç', '—Å—Ç–∞–Ω—Ü–∏—è',
    
    // –ü—Ä–µ–¥–ª–æ–≥–∏ –º–µ—Å—Ç–∞
    '–≤', '–Ω–∞', '—É', '–æ–∫–æ–ª–æ', '–≤–æ–∑–ª–µ', '–ø–æ–¥', '–Ω–∞–¥', '–ø–µ—Ä–µ–¥',
    '–∑–∞', '–º–µ–∂–¥—É', '—Å—Ä–µ–¥–∏', '—á–µ—Ä–µ–∑',
  };

  static final _locationPrefixes = {
    '—É–ª.', '–ø—Ä.', '–ø–µ—Ä.', '–±-—Ä', '–≥.', '–¥.', '–∫.', '–ø–æ—Å.', '—Å.',
  };

  static final _countryNames = {
    '—Ä–æ—Å—Å–∏—è', '—Ä—Ñ', '—Å—à–∞', '–∫–∏—Ç–∞–π', '–≥–µ—Ä–º–∞–Ω–∏—è', '—Ñ—Ä–∞–Ω—Ü–∏—è', '–∞–Ω–≥–ª–∏—è',
    '—è–ø–æ–Ω–∏—è', '–∏–Ω–¥–∏—è', '–±—Ä–∞–∑–∏–ª–∏—è', '–∫–∞–Ω–∞–¥–∞', '–∞–≤—Å—Ç—Ä–∞–ª–∏—è',
  };

  static final _cityNames = {
    '–º–æ—Å–∫–≤–∞', '—Å–∞–Ω–∫—Ç-–ø–µ—Ç–µ—Ä–±—É—Ä–≥', '—Å–ø–±', '–Ω—å—é-–π–æ—Ä–∫', '–ª–æ–Ω–¥–æ–Ω',
    '–ø–∞—Ä–∏–∂', '–±–µ—Ä–ª–∏–Ω', '—Ç–æ–∫–∏–æ', '–ø–µ–∫–∏–Ω', '—Å–∏–¥–Ω–µ–π',
  };

  static bool isLocationWord(String word) {
    final cleanWord = word.toLowerCase().trim();
    
    return _locationWords.contains(cleanWord) ||
           _locationPrefixes.any((prefix) => cleanWord.startsWith(prefix)) ||
           _countryNames.contains(cleanWord) ||
           _cityNames.contains(cleanWord) ||
           _matchesLocationPattern(cleanWord) ||
           _isCapitalizedLocation(cleanWord, word);
  }

  static bool _matchesLocationPattern(String word) {
    final locationPatterns = [
      RegExp(r'^[–ê-–Ø][–∞-—è]+\s*(–æ–±–ª–∞—Å—Ç—å|–∫—Ä–∞–π|—Ä–∞–π–æ–Ω|—Ä–µ—Å–ø—É–±–ª–∏–∫–∞)$'), // –ú–æ—Å–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å
      RegExp(r'^[–ê-–Ø][–∞-—è]+-[–ê-–Ø][–∞-—è]+$'), // –†–æ—Å—Ç–æ–≤-–Ω–∞-–î–æ–Ω—É
      RegExp(r'^[—É–ª|–ø—Ä|–ø–µ—Ä|–±-—Ä]\.\s+'), // —É–ª. –õ–µ–Ω–∏–Ω–∞
      RegExp(r'^\d+[-‚Äì]\d+$'), // 5-–π —Ä–∞–π–æ–Ω
    ];

    return locationPatterns.any((pattern) => pattern.hasMatch(word));
  }

  static bool _isCapitalizedLocation(String cleanWord, String originalWord) {
    // –°–ª–æ–≤–∞ —Å –∑–∞–≥–ª–∞–≤–Ω–æ–π –±—É–∫–≤—ã —á–∞—Å—Ç–æ —è–≤–ª—è—é—Ç—Å—è –∏–º–µ–Ω–∞–º–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ (–≥–µ–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–º–∏)
    return originalWord.isNotEmpty && 
           originalWord[0] == originalWord[0].toUpperCase() &&
           cleanWord.length > 2 && // –ò—Å–∫–ª—é—á–∞–µ–º –∫–æ—Ä–æ—Ç–∫–∏–µ —Å–ª–æ–≤–∞
           !_isCommonCapitalizedWord(cleanWord);
  }

  static bool _isCommonCapitalizedWord(String word) {
    final commonWords = {
      '—è', '—Ç—ã', '–æ–Ω', '–æ–Ω–∞', '–æ–Ω–æ', '–º—ã', '–≤—ã', '–æ–Ω–∏', // –º–µ—Å—Ç–æ–∏–º–µ–Ω–∏—è
      '—ç—Ç–æ', '—Ç–æ', '–≤–æ—Ç', '—Ç—É—Ç', '—Ç–∞–º', '–∑–¥–µ—Å—å', // —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–µ
    };
    return commonWords.contains(word);
  }
  static EntityType _classifyEntityType(String word) {
    if (RegExp(r'[0-9]').hasMatch(word)) return EntityType.numeric;
    if (isTemporalWord(word)) return EntityType.temporal;
    if (isLocationWord(word)) return EntityType.location;
    return EntityType.concept;
  }
  

}

class SemanticAnalysisResult {
  final String text;
  final SemanticType semanticType;
  final double factConfidence;
  final List<SemanticEntity> entities;
  final List<SemanticRelation> relations;
  final bool isFactual;
  final bool isSubjective;
  
  SemanticAnalysisResult({
    required this.text,
    required this.semanticType,
    required this.factConfidence,
    required this.entities,
    required this.relations,
    required this.isFactual,
    required this.isSubjective,
  });
}

class SemanticEntity {
  final String text;
  final EntityType type;
  final int position;
  
  SemanticEntity({
    required this.text,
    required this.type,
    required this.position,
  });
}

enum EntityType { person, location, concept, numeric, temporal, object }

enum RelationType {
  isA,           // –¢–∞–∫—Å–æ–Ω–æ–º–∏—è: "–∫–æ—à–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –∂–∏–≤–æ—Ç–Ω—ã–º"
  hasProperty,   // –°–≤–æ–π—Å—Ç–≤–æ: "–º–∞—à–∏–Ω–∞ –∏–º–µ–µ—Ç –∫–æ–ª–µ—Å–∞"
  partOf,        // –ß–∞—Å—Ç—å-—Ü–µ–ª–æ–µ: "—Ä—É–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é —Ç–µ–ª–∞"
  causes,        // –ü—Ä–∏—á–∏–Ω–∞: "–¥–æ–∂–¥—å –≤—ã–∑—ã–≤–∞–µ—Ç –ª—É–∂–∏"
  temporal,      // –í—Ä–µ–º–µ–Ω–Ω–æ–µ: "–∑–∞–≤—Ç—Ä–∞–∫ –ø–µ—Ä–µ–¥ —Ä–∞–±–æ—Ç–æ–π"
  locatedIn,     // –õ–æ–∫–∞—Ü–∏—è: "–ú–æ—Å–∫–≤–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –†–æ—Å—Å–∏–∏"
  comparesTo,    // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ: "—è–±–ª–æ–∫–æ –±–æ–ª—å—à–µ –≤–∏—à–Ω–∏"
  functional,    // –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ: "–º–æ–ª–æ—Ç–æ–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∑–∞–±–∏–≤–∞–Ω–∏—è"
  similarTo,     // –°—Ö–æ–∂–µ—Å—Ç—å: "—Ç–∏–≥—Ä –ø–æ—Ö–æ–∂ –Ω–∞ –ª—å–≤–∞"
  oppositeTo,    // –ü—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ—Å—Ç—å: "–¥–µ–Ω—å –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–µ–Ω –Ω–æ—á–∏"
}

class SemanticRelation {
  final RelationType type;
  final double confidence;
  final String? source;      // –ò—Å—Ç–æ—á–Ω–∏–∫ –æ—Ç–Ω–æ—à–µ–Ω–∏—è
  final String? target;      // –¶–µ–ª—å –æ—Ç–Ω–æ—à–µ–Ω–∏—è
  final String? evidence;    // –¢–µ–∫—Å—Ç, –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—é—â–∏–π –æ—Ç–Ω–æ—à–µ–Ω–∏–µ
  final List<String>? tags;  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–µ–≥–∏
  
  SemanticRelation({
    required this.type,
    required this.confidence,
    this.source,
    this.target,
    this.evidence,
    this.tags,
  });
  
  String get displayName => type.displayName;
  
  Map<String, dynamic> toJson() => {
    'type': type.name,
    'confidence': confidence,
    'source': source,
    'target': target,
    'evidence': evidence,
    'tags': tags,
  };
}

// –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –¥–ª—è RelationType
extension RelationTypeExtensions on RelationType {
  String get displayName {
    return switch (this) {
      RelationType.isA => '—è–≤–ª—è–µ—Ç—Å—è',
      RelationType.hasProperty => '–∏–º–µ–µ—Ç —Å–≤–æ–π—Å—Ç–≤–æ',
      RelationType.partOf => '—è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é',
      RelationType.causes => '–≤—ã–∑—ã–≤–∞–µ—Ç',
      RelationType.temporal => '–≤—Ä–µ–º–µ–Ω–Ω–æ–µ –æ—Ç–Ω–æ—à–µ–Ω–∏–µ',
      RelationType.locatedIn => '–Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤',
      RelationType.comparesTo => '—Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç—Å—è —Å',
      RelationType.functional => '—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –æ—Ç–Ω–æ—à–µ–Ω–∏–µ',
      RelationType.similarTo => '–ø–æ—Ö–æ–∂ –Ω–∞',
      RelationType.oppositeTo => '–ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–µ–Ω',
    };
  }
}

extension FragmentSemanticAnalysis on Fragment {
  SemanticAnalysisResult analyzeSemantics() {
    return SemanticAnalyzer1.analyze(text);
  }
  
  /// –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç —Ñ–∞–∫—Ç–æ–º
  bool get isFactual {
    final analysis = analyzeSemantics();
    return analysis.isFactual;
  }
}

extension NeuronSemanticAnalysis on Neuron {
  /// –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–µ–º–∞–Ω—Ç–∏–∫—É –Ω–µ–π—Ä–æ–Ω–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤
  List<SemanticAnalysisResult> analyzeFragmentsSemantics() {
    return fragmentLinks.map((fragmentId) {
      final fragment = network.fragments[fragmentId];
      return fragment!.analyzeSemantics();
    }).toList();
  }
  
  /// –ü—Ä–æ—Ü–µ–Ω—Ç —Ñ–∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –≤ –Ω–µ–π—Ä–æ–Ω–µ
  double get factualPercentage {
    final analyses = analyzeFragmentsSemantics();
    if (analyses.isEmpty) return 0.0;
    
    final factualCount = analyses.where((a) => a.isFactual).length;
    return factualCount / analyses.length;
  }
}

extension SemanticTypeExtensions on SemanticType {
  /// –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ UI
  String get capitalized {
    final name = displayName;
    return name[0].toUpperCase() + name.substring(1);
  }

  /// –î–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
  String get databaseValue {
    return name;
  }

  /// –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–∑ —Å—Ç—Ä–æ–∫–∏
  static SemanticType? fromString(String value) {
    try {
      return SemanticType.values.firstWhere(
        (type) => type.name == value.toLowerCase() || 
                 type.displayName == value.toLowerCase(),
      );
    } catch (e) {
      return SemanticType.unknown;
    }
  }
}

class RelationExtractor {
  static List<SemanticRelation> extractRelations(String text) {
    final relations = <SemanticRelation>[];
    final cleanText = text.toLowerCase().trim();
    
    relations.addAll(_extractIsARelations(cleanText));
    relations.addAll(_extractHasRelations(cleanText));
    relations.addAll(_extractPartOfRelations(cleanText));
    relations.addAll(_extractCausalRelations(cleanText));
    relations.addAll(_extractTemporalRelations(cleanText));
    relations.addAll(_extractSpatialRelations(cleanText));
    relations.addAll(_extractComparativeRelations(cleanText));
    relations.addAll(_extractFunctionalRelations(cleanText));
    
    return relations;
  }
  
  /// –û—Ç–Ω–æ—à–µ–Ω–∏—è "—è–≤–ª—è–µ—Ç—Å—è" (—Ç–∞–∫—Å–æ–Ω–æ–º–∏—è)
  static List<SemanticRelation> _extractIsARelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A —è–≤–ª—è–µ—Ç—Å—è B
      RegExp(r'(\w+)\s+—è–≤–ª—è–µ—Ç—Å—è\s+(\w+)'),
      // A - —ç—Ç–æ B
      RegExp(r'(\w+)\s*‚Äî\s*—ç—Ç–æ\s*(\w+)'),
      RegExp(r'(\w+)\s*-\s*—ç—Ç–æ\s*(\w+)'),
      // A –µ—Å—Ç—å B
      RegExp(r'(\w+)\s+–µ—Å—Ç—å\s+(\w+)'),
      // A –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π B
      RegExp(r'(\w+)\s+–ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç\s+—Å–æ–±–æ–π\s+(\w+)'),
      // A —Å—á–∏—Ç–∞–µ—Ç—Å—è B
      RegExp(r'(\w+)\s+—Å—á–∏—Ç–∞–µ—Ç—Å—è\s+(\w+)'),
      // A –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è B
      RegExp(r'(\w+)\s+–Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.isA,
            confidence: 0.85,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// –û—Ç–Ω–æ—à–µ–Ω–∏—è –≤–ª–∞–¥–µ–Ω–∏—è/—Å–≤–æ–π—Å—Ç–≤–∞
  static List<SemanticRelation> _extractHasRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A –∏–º–µ–µ—Ç B
      RegExp(r'(\w+)\s+–∏–º–µ–µ—Ç\s+(\w+)'),
      // A –æ–±–ª–∞–¥–∞–µ—Ç B
      RegExp(r'(\w+)\s+–æ–±–ª–∞–¥–∞–µ—Ç\s+(\w+)'),
      // A —Å–æ–¥–µ—Ä–∂–∏—Ç B
      RegExp(r'(\w+)\s+—Å–æ–¥–µ—Ä–∂–∏—Ç\s+(\w+)'),
      // —É A –µ—Å—Ç—å B
      RegExp(r'—É\s+(\w+)\s+–µ—Å—Ç—å\s+(\w+)'),
      // A —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ B
      RegExp(r'(\w+)\s+—Å–æ—Å—Ç–æ–∏—Ç\s+–∏–∑\s+(\w+)'),
      // A –≤–∫–ª—é—á–∞–µ—Ç B
      RegExp(r'(\w+)\s+–≤–∫–ª—é—á–∞–µ—Ç\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.hasProperty,
            confidence: 0.8,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// –û—Ç–Ω–æ—à–µ–Ω–∏—è "—á–∞—Å—Ç—å-—Ü–µ–ª–æ–µ"
  static List<SemanticRelation> _extractPartOfRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é B
      RegExp(r'(\w+)\s+—è–≤–ª—è–µ—Ç—Å—è\s+—á–∞—Å—Ç—å—é\s+(\w+)'),
      // A –≤—Ö–æ–¥–∏—Ç –≤ B
      RegExp(r'(\w+)\s+–≤—Ö–æ–¥–∏—Ç\s+–≤\s+(\w+)'),
      // A –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ B
      RegExp(r'(\w+)\s+–Ω–∞—Ö–æ–¥–∏—Ç—Å—è\s+–≤\s+(\w+)'),
      // A –≤–Ω—É—Ç—Ä–∏ B
      RegExp(r'(\w+)\s+–≤–Ω—É—Ç—Ä–∏\s+(\w+)'),
      // A –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ B
      RegExp(r'(\w+)\s+–æ—Ç–Ω–æ—Å–∏—Ç—Å—è\s+–∫\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.partOf,
            confidence: 0.75,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// –ü—Ä–∏—á–∏–Ω–Ω–æ-—Å–ª–µ–¥—Å—Ç–≤–µ–Ω–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è
  static List<SemanticRelation> _extractCausalRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ B
      RegExp(r'(\w+)\s+–ø—Ä–∏–≤–æ–¥–∏—Ç\s+–∫\s+(\w+)'),
      // A –≤—ã–∑—ã–≤–∞–µ—Ç B
      RegExp(r'(\w+)\s+–≤—ã–∑—ã–≤–∞–µ—Ç\s+(\w+)'),
      // –∏–∑-–∑–∞ A –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç B
      RegExp(r'–∏–∑-–∑–∞\s+(\w+)\s+–ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç\s+(\w+)'),
      // A —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏—á–∏–Ω–æ–π B
      RegExp(r'(\w+)\s+—è–≤–ª—è–µ—Ç—Å—è\s+–ø—Ä–∏—á–∏–Ω–æ–π\s+(\w+)'),
      // B –∑–∞–≤–∏—Å–∏—Ç –æ—Ç A
      RegExp(r'(\w+)\s+–∑–∞–≤–∏—Å–∏—Ç\s+–æ—Ç\s+(\w+)'),
      // –µ—Å–ª–∏ A, —Ç–æ B
      RegExp(r'–µ—Å–ª–∏\s+(\w+),\s+—Ç–æ\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.causes,
            confidence: 0.7,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// –í—Ä–µ–º–µ–Ω–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è
  static List<SemanticRelation> _extractTemporalRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –¥–æ B
      RegExp(r'(\w+)\s+–ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç\s+–¥–æ\s+(\w+)'),
      // A —Å–ª–µ–¥—É–µ—Ç –∑–∞ B
      RegExp(r'(\w+)\s+—Å–ª–µ–¥—É–µ—Ç\s+–∑–∞\s+(\w+)'),
      // A –≤–æ –≤—Ä–µ–º—è B
      RegExp(r'(\w+)\s+–≤–æ\s+–≤—Ä–µ–º—è\s+(\w+)'),
      // A –ø–æ—Å–ª–µ B
      RegExp(r'(\w+)\s+–ø–æ—Å–ª–µ\s+(\w+)'),
      // A –ø–µ—Ä–µ–¥ B
      RegExp(r'(\w+)\s+–ø–µ—Ä–µ–¥\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.temporal,
            confidence: 0.65,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è
  static List<SemanticRelation> _extractSpatialRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ B
      RegExp(r'(\w+)\s+–Ω–∞—Ö–æ–¥–∏—Ç—Å—è\s+–≤\s+(\w+)'),
      // A —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω –≤ B
      RegExp(r'(\w+)\s+—Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω\s+–≤\s+(\w+)'),
      // A –Ω–∞–¥ B
      RegExp(r'(\w+)\s+–Ω–∞–¥\s+(\w+)'),
      // A –ø–æ–¥ B
      RegExp(r'(\w+)\s+–ø–æ–¥\s+(\w+)'),
      // A —Ä—è–¥–æ–º —Å B
      RegExp(r'(\w+)\s+—Ä—è–¥–æ–º\s+—Å\s+(\w+)'),
      // A –º–µ–∂–¥—É B –∏ C
      RegExp(r'(\w+)\s+–º–µ–∂–¥—É\s+(\w+)\s+–∏\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.locatedIn,
            confidence: 0.7,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// –°—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è
  static List<SemanticRelation> _extractComparativeRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A –±–æ–ª—å—à–µ, —á–µ–º B
      RegExp(r'(\w+)\s+–±–æ–ª—å—à–µ,\s*—á–µ–º\s+(\w+)'),
      // A –ª—É—á—à–µ, —á–µ–º B
      RegExp(r'(\w+)\s+–ª—É—á—à–µ,\s*—á–µ–º\s+(\w+)'),
      // A –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç B
      RegExp(r'(\w+)\s+–æ—Ç–ª–∏—á–∞–µ—Ç—Å—è\s+–æ—Ç\s+(\w+)'),
      // A –ø–æ—Ö–æ–∂ –Ω–∞ B
      RegExp(r'(\w+)\s+–ø–æ—Ö–æ–∂\s+–Ω–∞\s+(\w+)'),
      // A —Ç–∞–∫–æ–π –∂–µ –∫–∞–∫ B
      RegExp(r'(\w+)\s+—Ç–∞–∫–æ–π\s+–∂–µ\s+–∫–∞–∫\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.comparesTo,
            confidence: 0.6,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
  
  /// –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è
  static List<SemanticRelation> _extractFunctionalRelations(String text) {
    final relations = <SemanticRelation>[];
    final patterns = [
      // A –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è B
      RegExp(r'(\w+)\s+–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è\s+–¥–ª—è\s+(\w+)'),
      // A –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è B
      RegExp(r'(\w+)\s+–ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω\s+–¥–ª—è\s+(\w+)'),
      // A —Å–ª—É–∂–∏—Ç –¥–ª—è B
      RegExp(r'(\w+)\s+—Å–ª—É–∂–∏—Ç\s+–¥–ª—è\s+(\w+)'),
      // A –ø–æ–º–æ–≥–∞–µ—Ç B
      RegExp(r'(\w+)\s+–ø–æ–º–æ–≥–∞–µ—Ç\s+(\w+)'),
      // A –≤–ª–∏—è–µ—Ç –Ω–∞ B
      RegExp(r'(\w+)\s+–≤–ª–∏—è–µ—Ç\s+–Ω–∞\s+(\w+)'),
    ];
    
    for (final pattern in patterns) {
      final matches = pattern.allMatches(text);
      for (final match in matches) {
        if (match.groupCount >= 2) {
          relations.add(SemanticRelation(
            type: RelationType.functional,
            confidence: 0.65,
            source: match.group(1),
            target: match.group(2),
            evidence: match.group(0),
          ));
        }
      }
    }
    
    return relations;
  }
}